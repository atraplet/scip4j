// Generated by jextract

package com.ustermetrics.scip4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class scip_h_5 {

    scip_h_5() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int SCIP_VERSION_MAJOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION_MAJOR 9
     * }
     */
    public static int SCIP_VERSION_MAJOR() {
        return SCIP_VERSION_MAJOR;
    }
    private static final int SCIP_VERSION_MINOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION_MINOR 1
     * }
     */
    public static int SCIP_VERSION_MINOR() {
        return SCIP_VERSION_MINOR;
    }
    private static final int SCIP_VERSION_PATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION_PATCH 0
     * }
     */
    public static int SCIP_VERSION_PATCH() {
        return SCIP_VERSION_PATCH;
    }
    private static final int SCIP_VERSION_SUB = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION_SUB 0
     * }
     */
    public static int SCIP_VERSION_SUB() {
        return SCIP_VERSION_SUB;
    }
    private static final int SCIP_VERSION_API = (int)115L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION_API 115
     * }
     */
    public static int SCIP_VERSION_API() {
        return SCIP_VERSION_API;
    }
    private static final int SCIP_HAVE_VARIADIC_MACROS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HAVE_VARIADIC_MACROS 1
     * }
     */
    public static int SCIP_HAVE_VARIADIC_MACROS() {
        return SCIP_HAVE_VARIADIC_MACROS;
    }
    private static final int TRUE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TRUE 1
     * }
     */
    public static int TRUE() {
        return TRUE;
    }
    private static final int FALSE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FALSE 0
     * }
     */
    public static int FALSE() {
        return FALSE;
    }
    private static final int SCIP_MAXSTRLEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define SCIP_MAXSTRLEN 1024
     * }
     */
    public static int SCIP_MAXSTRLEN() {
        return SCIP_MAXSTRLEN;
    }
    private static final int SCIP_HASHSIZE_PARAMS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_PARAMS 2048
     * }
     */
    public static int SCIP_HASHSIZE_PARAMS() {
        return SCIP_HASHSIZE_PARAMS;
    }
    private static final int SCIP_HASHSIZE_NAMES = (int)500L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_NAMES 500
     * }
     */
    public static int SCIP_HASHSIZE_NAMES() {
        return SCIP_HASHSIZE_NAMES;
    }
    private static final int SCIP_HASHSIZE_CUTPOOLS = (int)500L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_CUTPOOLS 500
     * }
     */
    public static int SCIP_HASHSIZE_CUTPOOLS() {
        return SCIP_HASHSIZE_CUTPOOLS;
    }
    private static final int SCIP_HASHSIZE_CLIQUES = (int)500L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_CLIQUES 500
     * }
     */
    public static int SCIP_HASHSIZE_CLIQUES() {
        return SCIP_HASHSIZE_CLIQUES;
    }
    private static final int SCIP_HASHSIZE_NAMES_SMALL = (int)100L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_NAMES_SMALL 100
     * }
     */
    public static int SCIP_HASHSIZE_NAMES_SMALL() {
        return SCIP_HASHSIZE_NAMES_SMALL;
    }
    private static final int SCIP_HASHSIZE_CUTPOOLS_SMALL = (int)100L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_CUTPOOLS_SMALL 100
     * }
     */
    public static int SCIP_HASHSIZE_CUTPOOLS_SMALL() {
        return SCIP_HASHSIZE_CUTPOOLS_SMALL;
    }
    private static final int SCIP_HASHSIZE_CLIQUES_SMALL = (int)100L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_CLIQUES_SMALL 100
     * }
     */
    public static int SCIP_HASHSIZE_CLIQUES_SMALL() {
        return SCIP_HASHSIZE_CLIQUES_SMALL;
    }
    private static final int SCIP_HASHSIZE_VBC = (int)500L;
    /**
     * {@snippet lang=c :
     * #define SCIP_HASHSIZE_VBC 500
     * }
     */
    public static int SCIP_HASHSIZE_VBC() {
        return SCIP_HASHSIZE_VBC;
    }
    private static final int SCIP_DEFAULT_MEM_ARRAYGROWINIT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_MEM_ARRAYGROWINIT 4
     * }
     */
    public static int SCIP_DEFAULT_MEM_ARRAYGROWINIT() {
        return SCIP_DEFAULT_MEM_ARRAYGROWINIT;
    }
    private static final int SCIP_MAXTREEDEPTH = (int)1073741822L;
    /**
     * {@snippet lang=c :
     * #define SCIP_MAXTREEDEPTH 1073741822
     * }
     */
    public static int SCIP_MAXTREEDEPTH() {
        return SCIP_MAXTREEDEPTH;
    }
    private static final int SCIP_PROBINGSCORE_PENALTYRATIO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PROBINGSCORE_PENALTYRATIO 2
     * }
     */
    public static int SCIP_PROBINGSCORE_PENALTYRATIO() {
        return SCIP_PROBINGSCORE_PENALTYRATIO;
    }
    private static final int NLOCKTYPES = (int)2L;
    /**
     * {@snippet lang=c :
     * #define NLOCKTYPES 2
     * }
     */
    public static int NLOCKTYPES() {
        return NLOCKTYPES;
    }
    private static final int SCIP_EXPR_MAXINITESTIMATES = (int)10L;
    /**
     * {@snippet lang=c :
     * #define SCIP_EXPR_MAXINITESTIMATES 10
     * }
     */
    public static int SCIP_EXPR_MAXINITESTIMATES() {
        return SCIP_EXPR_MAXINITESTIMATES;
    }
    private static final int SCIP_EXPRITER_MAXNACTIVE = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SCIP_EXPRITER_MAXNACTIVE 5
     * }
     */
    public static int SCIP_EXPRITER_MAXNACTIVE() {
        return SCIP_EXPRITER_MAXNACTIVE;
    }
    private static final int SCIP_NLPPARAM_DEFAULT_VERBLEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCIP_NLPPARAM_DEFAULT_VERBLEVEL 0
     * }
     */
    public static int SCIP_NLPPARAM_DEFAULT_VERBLEVEL() {
        return SCIP_NLPPARAM_DEFAULT_VERBLEVEL;
    }
    private static final int SCIP_MAXVERTEXPOLYDIM = (int)14L;
    /**
     * {@snippet lang=c :
     * #define SCIP_MAXVERTEXPOLYDIM 14
     * }
     */
    public static int SCIP_MAXVERTEXPOLYDIM() {
        return SCIP_MAXVERTEXPOLYDIM;
    }
    private static final int SYM_TIMING_BEFOREPRESOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SYM_TIMING_BEFOREPRESOL 0
     * }
     */
    public static int SYM_TIMING_BEFOREPRESOL() {
        return SYM_TIMING_BEFOREPRESOL;
    }
    private static final int SYM_TIMING_DURINGPRESOL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SYM_TIMING_DURINGPRESOL 1
     * }
     */
    public static int SYM_TIMING_DURINGPRESOL() {
        return SYM_TIMING_DURINGPRESOL;
    }
    private static final int SYM_TIMING_AFTERPRESOL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SYM_TIMING_AFTERPRESOL 2
     * }
     */
    public static int SYM_TIMING_AFTERPRESOL() {
        return SYM_TIMING_AFTERPRESOL;
    }

    private static class BMSallocClearMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocClearMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocClearMemory_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocClearMemory_call$descriptor() {
        return BMSallocClearMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocClearMemory_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocClearMemory_call$handle() {
        return BMSallocClearMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocClearMemory_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearMemory_call$address() {
        return BMSallocClearMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocClearMemory_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearMemory_call(long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocClearMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocClearMemory_call", num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocMemory_call(size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocMemory_call$descriptor() {
        return BMSallocMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocMemory_call(size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocMemory_call$handle() {
        return BMSallocMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocMemory_call(size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocMemory_call$address() {
        return BMSallocMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocMemory_call(size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocMemory_call(long size, MemorySegment filename, int line) {
        var mh$ = BMSallocMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocMemory_call", size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocMemoryArray_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocMemoryArray_call$descriptor() {
        return BMSallocMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocMemoryArray_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocMemoryArray_call$handle() {
        return BMSallocMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocMemoryArray_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocMemoryArray_call$address() {
        return BMSallocMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocMemoryArray_call(size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocMemoryArray_call(long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocMemoryArray_call", num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocMemory_call(void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocMemory_call$descriptor() {
        return BMSreallocMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocMemory_call(void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocMemory_call$handle() {
        return BMSreallocMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocMemory_call(void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocMemory_call$address() {
        return BMSreallocMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocMemory_call(void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocMemory_call(MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSreallocMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocMemory_call", ptr, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocMemoryArray_call(void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocMemoryArray_call$descriptor() {
        return BMSreallocMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocMemoryArray_call(void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocMemoryArray_call$handle() {
        return BMSreallocMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocMemoryArray_call(void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocMemoryArray_call$address() {
        return BMSreallocMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocMemoryArray_call(void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocMemoryArray_call(MemorySegment ptr, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSreallocMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocMemoryArray_call", ptr, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(ptr, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSclearMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSclearMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSclearMemory_call(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor BMSclearMemory_call$descriptor() {
        return BMSclearMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSclearMemory_call(void *ptr, size_t size)
     * }
     */
    public static MethodHandle BMSclearMemory_call$handle() {
        return BMSclearMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSclearMemory_call(void *ptr, size_t size)
     * }
     */
    public static MemorySegment BMSclearMemory_call$address() {
        return BMSclearMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSclearMemory_call(void *ptr, size_t size)
     * }
     */
    public static void BMSclearMemory_call(MemorySegment ptr, long size) {
        var mh$ = BMSclearMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSclearMemory_call", ptr, size);
            }
            mh$.invokeExact(ptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScopyMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScopyMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMScopyMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static FunctionDescriptor BMScopyMemory_call$descriptor() {
        return BMScopyMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMScopyMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static MethodHandle BMScopyMemory_call$handle() {
        return BMScopyMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMScopyMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static MemorySegment BMScopyMemory_call$address() {
        return BMScopyMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMScopyMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static void BMScopyMemory_call(MemorySegment ptr, MemorySegment source, long size) {
        var mh$ = BMScopyMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScopyMemory_call", ptr, source, size);
            }
            mh$.invokeExact(ptr, source, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSmoveMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSmoveMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSmoveMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static FunctionDescriptor BMSmoveMemory_call$descriptor() {
        return BMSmoveMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSmoveMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static MethodHandle BMSmoveMemory_call$handle() {
        return BMSmoveMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSmoveMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static MemorySegment BMSmoveMemory_call$address() {
        return BMSmoveMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSmoveMemory_call(void *ptr, const void *source, size_t size)
     * }
     */
    public static void BMSmoveMemory_call(MemorySegment ptr, MemorySegment source, long size) {
        var mh$ = BMSmoveMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSmoveMemory_call", ptr, source, size);
            }
            mh$.invokeExact(ptr, source, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateMemory_call(const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateMemory_call$descriptor() {
        return BMSduplicateMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateMemory_call(const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateMemory_call$handle() {
        return BMSduplicateMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateMemory_call(const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateMemory_call$address() {
        return BMSduplicateMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateMemory_call(const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateMemory_call(MemorySegment source, long size, MemorySegment filename, int line) {
        var mh$ = BMSduplicateMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateMemory_call", source, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(source, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateMemoryArray_call(const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateMemoryArray_call$descriptor() {
        return BMSduplicateMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateMemoryArray_call(const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateMemoryArray_call$handle() {
        return BMSduplicateMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateMemoryArray_call(const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateMemoryArray_call$address() {
        return BMSduplicateMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateMemoryArray_call(const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateMemoryArray_call(MemorySegment source, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSduplicateMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateMemoryArray_call", source, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(source, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeMemory_call(void **ptr, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeMemory_call$descriptor() {
        return BMSfreeMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeMemory_call(void **ptr, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeMemory_call$handle() {
        return BMSfreeMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeMemory_call(void **ptr, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeMemory_call$address() {
        return BMSfreeMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeMemory_call(void **ptr, const char *filename, int line)
     * }
     */
    public static void BMSfreeMemory_call(MemorySegment ptr, MemorySegment filename, int line) {
        var mh$ = BMSfreeMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeMemory_call", ptr, filename, line);
            }
            mh$.invokeExact(ptr, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeMemoryNull_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeMemoryNull_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeMemoryNull_call(void **ptr, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeMemoryNull_call$descriptor() {
        return BMSfreeMemoryNull_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeMemoryNull_call(void **ptr, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeMemoryNull_call$handle() {
        return BMSfreeMemoryNull_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeMemoryNull_call(void **ptr, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeMemoryNull_call$address() {
        return BMSfreeMemoryNull_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeMemoryNull_call(void **ptr, const char *filename, int line)
     * }
     */
    public static void BMSfreeMemoryNull_call(MemorySegment ptr, MemorySegment filename, int line) {
        var mh$ = BMSfreeMemoryNull_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeMemoryNull_call", ptr, filename, line);
            }
            mh$.invokeExact(ptr, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetPointerSize_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetPointerSize_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t BMSgetPointerSize_call(const void *ptr)
     * }
     */
    public static FunctionDescriptor BMSgetPointerSize_call$descriptor() {
        return BMSgetPointerSize_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t BMSgetPointerSize_call(const void *ptr)
     * }
     */
    public static MethodHandle BMSgetPointerSize_call$handle() {
        return BMSgetPointerSize_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t BMSgetPointerSize_call(const void *ptr)
     * }
     */
    public static MemorySegment BMSgetPointerSize_call$address() {
        return BMSgetPointerSize_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t BMSgetPointerSize_call(const void *ptr)
     * }
     */
    public static long BMSgetPointerSize_call(MemorySegment ptr) {
        var mh$ = BMSgetPointerSize_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetPointerSize_call", ptr);
            }
            return (long)mh$.invokeExact(ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSdisplayMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSdisplayMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSdisplayMemory_call()
     * }
     */
    public static FunctionDescriptor BMSdisplayMemory_call$descriptor() {
        return BMSdisplayMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSdisplayMemory_call()
     * }
     */
    public static MethodHandle BMSdisplayMemory_call$handle() {
        return BMSdisplayMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSdisplayMemory_call()
     * }
     */
    public static MemorySegment BMSdisplayMemory_call$address() {
        return BMSdisplayMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSdisplayMemory_call()
     * }
     */
    public static void BMSdisplayMemory_call() {
        var mh$ = BMSdisplayMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSdisplayMemory_call");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScheckEmptyMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScheckEmptyMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMScheckEmptyMemory_call()
     * }
     */
    public static FunctionDescriptor BMScheckEmptyMemory_call$descriptor() {
        return BMScheckEmptyMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMScheckEmptyMemory_call()
     * }
     */
    public static MethodHandle BMScheckEmptyMemory_call$handle() {
        return BMScheckEmptyMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMScheckEmptyMemory_call()
     * }
     */
    public static MemorySegment BMScheckEmptyMemory_call$address() {
        return BMScheckEmptyMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMScheckEmptyMemory_call()
     * }
     */
    public static void BMScheckEmptyMemory_call() {
        var mh$ = BMScheckEmptyMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScheckEmptyMemory_call");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetMemoryUsed_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetMemoryUsed_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetMemoryUsed_call()
     * }
     */
    public static FunctionDescriptor BMSgetMemoryUsed_call$descriptor() {
        return BMSgetMemoryUsed_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetMemoryUsed_call()
     * }
     */
    public static MethodHandle BMSgetMemoryUsed_call$handle() {
        return BMSgetMemoryUsed_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetMemoryUsed_call()
     * }
     */
    public static MemorySegment BMSgetMemoryUsed_call$address() {
        return BMSgetMemoryUsed_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetMemoryUsed_call()
     * }
     */
    public static long BMSgetMemoryUsed_call() {
        var mh$ = BMSgetMemoryUsed_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetMemoryUsed_call");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSalignMemsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSalignMemsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSalignMemsize(size_t *size)
     * }
     */
    public static FunctionDescriptor BMSalignMemsize$descriptor() {
        return BMSalignMemsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSalignMemsize(size_t *size)
     * }
     */
    public static MethodHandle BMSalignMemsize$handle() {
        return BMSalignMemsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSalignMemsize(size_t *size)
     * }
     */
    public static MemorySegment BMSalignMemsize$address() {
        return BMSalignMemsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSalignMemsize(size_t *size)
     * }
     */
    public static void BMSalignMemsize(MemorySegment size) {
        var mh$ = BMSalignMemsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSalignMemsize", size);
            }
            mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSisAligned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSisAligned");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BMSisAligned(size_t size)
     * }
     */
    public static FunctionDescriptor BMSisAligned$descriptor() {
        return BMSisAligned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BMSisAligned(size_t size)
     * }
     */
    public static MethodHandle BMSisAligned$handle() {
        return BMSisAligned.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BMSisAligned(size_t size)
     * }
     */
    public static MemorySegment BMSisAligned$address() {
        return BMSisAligned.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BMSisAligned(size_t size)
     * }
     */
    public static int BMSisAligned(long size) {
        var mh$ = BMSisAligned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSisAligned", size);
            }
            return (int)mh$.invokeExact(size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScreateChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScreateChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_CHKMEM *BMScreateChunkMemory_call(size_t size, int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMScreateChunkMemory_call$descriptor() {
        return BMScreateChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_CHKMEM *BMScreateChunkMemory_call(size_t size, int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MethodHandle BMScreateChunkMemory_call$handle() {
        return BMScreateChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_CHKMEM *BMScreateChunkMemory_call(size_t size, int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateChunkMemory_call$address() {
        return BMScreateChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_CHKMEM *BMScreateChunkMemory_call(size_t size, int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateChunkMemory_call(long size, int initchunksize, int garbagefactor, MemorySegment filename, int line) {
        var mh$ = BMScreateChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScreateChunkMemory_call", size, initchunksize, garbagefactor, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(size, initchunksize, garbagefactor, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSclearChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSclearChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSclearChunkMemory_call(BMS_CHKMEM *chkmem, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSclearChunkMemory_call$descriptor() {
        return BMSclearChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSclearChunkMemory_call(BMS_CHKMEM *chkmem, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSclearChunkMemory_call$handle() {
        return BMSclearChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSclearChunkMemory_call(BMS_CHKMEM *chkmem, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSclearChunkMemory_call$address() {
        return BMSclearChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSclearChunkMemory_call(BMS_CHKMEM *chkmem, const char *filename, int line)
     * }
     */
    public static void BMSclearChunkMemory_call(MemorySegment chkmem, MemorySegment filename, int line) {
        var mh$ = BMSclearChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSclearChunkMemory_call", chkmem, filename, line);
            }
            mh$.invokeExact(chkmem, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSdestroyChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSdestroyChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSdestroyChunkMemory_call(BMS_CHKMEM **chkmem, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSdestroyChunkMemory_call$descriptor() {
        return BMSdestroyChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSdestroyChunkMemory_call(BMS_CHKMEM **chkmem, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSdestroyChunkMemory_call$handle() {
        return BMSdestroyChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSdestroyChunkMemory_call(BMS_CHKMEM **chkmem, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSdestroyChunkMemory_call$address() {
        return BMSdestroyChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSdestroyChunkMemory_call(BMS_CHKMEM **chkmem, const char *filename, int line)
     * }
     */
    public static void BMSdestroyChunkMemory_call(MemorySegment chkmem, MemorySegment filename, int line) {
        var mh$ = BMSdestroyChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSdestroyChunkMemory_call", chkmem, filename, line);
            }
            mh$.invokeExact(chkmem, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocChunkMemory_call(BMS_CHKMEM *chkmem, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocChunkMemory_call$descriptor() {
        return BMSallocChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocChunkMemory_call(BMS_CHKMEM *chkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocChunkMemory_call$handle() {
        return BMSallocChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocChunkMemory_call(BMS_CHKMEM *chkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocChunkMemory_call$address() {
        return BMSallocChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocChunkMemory_call(BMS_CHKMEM *chkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocChunkMemory_call(MemorySegment chkmem, long size, MemorySegment filename, int line) {
        var mh$ = BMSallocChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocChunkMemory_call", chkmem, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(chkmem, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateChunkMemory_call(BMS_CHKMEM *chkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateChunkMemory_call$descriptor() {
        return BMSduplicateChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateChunkMemory_call(BMS_CHKMEM *chkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateChunkMemory_call$handle() {
        return BMSduplicateChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateChunkMemory_call(BMS_CHKMEM *chkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateChunkMemory_call$address() {
        return BMSduplicateChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateChunkMemory_call(BMS_CHKMEM *chkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateChunkMemory_call(MemorySegment chkmem, MemorySegment source, long size, MemorySegment filename, int line) {
        var mh$ = BMSduplicateChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateChunkMemory_call", chkmem, source, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(chkmem, source, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemory_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeChunkMemory_call$descriptor() {
        return BMSfreeChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemory_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeChunkMemory_call$handle() {
        return BMSfreeChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemory_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeChunkMemory_call$address() {
        return BMSfreeChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeChunkMemory_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static void BMSfreeChunkMemory_call(MemorySegment chkmem, MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSfreeChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeChunkMemory_call", chkmem, ptr, size, filename, line);
            }
            mh$.invokeExact(chkmem, ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeChunkMemoryNull_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeChunkMemoryNull_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemoryNull_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeChunkMemoryNull_call$descriptor() {
        return BMSfreeChunkMemoryNull_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemoryNull_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeChunkMemoryNull_call$handle() {
        return BMSfreeChunkMemoryNull_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeChunkMemoryNull_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeChunkMemoryNull_call$address() {
        return BMSfreeChunkMemoryNull_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeChunkMemoryNull_call(BMS_CHKMEM *chkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static void BMSfreeChunkMemoryNull_call(MemorySegment chkmem, MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSfreeChunkMemoryNull_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeChunkMemoryNull_call", chkmem, ptr, size, filename, line);
            }
            mh$.invokeExact(chkmem, ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgarbagecollectChunkMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgarbagecollectChunkMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSgarbagecollectChunkMemory_call(BMS_CHKMEM *chkmem)
     * }
     */
    public static FunctionDescriptor BMSgarbagecollectChunkMemory_call$descriptor() {
        return BMSgarbagecollectChunkMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSgarbagecollectChunkMemory_call(BMS_CHKMEM *chkmem)
     * }
     */
    public static MethodHandle BMSgarbagecollectChunkMemory_call$handle() {
        return BMSgarbagecollectChunkMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSgarbagecollectChunkMemory_call(BMS_CHKMEM *chkmem)
     * }
     */
    public static MemorySegment BMSgarbagecollectChunkMemory_call$address() {
        return BMSgarbagecollectChunkMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSgarbagecollectChunkMemory_call(BMS_CHKMEM *chkmem)
     * }
     */
    public static void BMSgarbagecollectChunkMemory_call(MemorySegment chkmem) {
        var mh$ = BMSgarbagecollectChunkMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgarbagecollectChunkMemory_call", chkmem);
            }
            mh$.invokeExact(chkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetChunkMemoryUsed_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetChunkMemoryUsed_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetChunkMemoryUsed_call(const BMS_CHKMEM *chkmem)
     * }
     */
    public static FunctionDescriptor BMSgetChunkMemoryUsed_call$descriptor() {
        return BMSgetChunkMemoryUsed_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetChunkMemoryUsed_call(const BMS_CHKMEM *chkmem)
     * }
     */
    public static MethodHandle BMSgetChunkMemoryUsed_call$handle() {
        return BMSgetChunkMemoryUsed_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetChunkMemoryUsed_call(const BMS_CHKMEM *chkmem)
     * }
     */
    public static MemorySegment BMSgetChunkMemoryUsed_call$address() {
        return BMSgetChunkMemoryUsed_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetChunkMemoryUsed_call(const BMS_CHKMEM *chkmem)
     * }
     */
    public static long BMSgetChunkMemoryUsed_call(MemorySegment chkmem) {
        var mh$ = BMSgetChunkMemoryUsed_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetChunkMemoryUsed_call", chkmem);
            }
            return (long)mh$.invokeExact(chkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScreateBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScreateBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_BLKMEM *BMScreateBlockMemory_call(int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMScreateBlockMemory_call$descriptor() {
        return BMScreateBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_BLKMEM *BMScreateBlockMemory_call(int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MethodHandle BMScreateBlockMemory_call$handle() {
        return BMScreateBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_BLKMEM *BMScreateBlockMemory_call(int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateBlockMemory_call$address() {
        return BMScreateBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_BLKMEM *BMScreateBlockMemory_call(int initchunksize, int garbagefactor, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateBlockMemory_call(int initchunksize, int garbagefactor, MemorySegment filename, int line) {
        var mh$ = BMScreateBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScreateBlockMemory_call", initchunksize, garbagefactor, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(initchunksize, garbagefactor, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSclearBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSclearBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSclearBlockMemory_call(BMS_BLKMEM *blkmem, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSclearBlockMemory_call$descriptor() {
        return BMSclearBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSclearBlockMemory_call(BMS_BLKMEM *blkmem, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSclearBlockMemory_call$handle() {
        return BMSclearBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSclearBlockMemory_call(BMS_BLKMEM *blkmem, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSclearBlockMemory_call$address() {
        return BMSclearBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSclearBlockMemory_call(BMS_BLKMEM *blkmem, const char *filename, int line)
     * }
     */
    public static void BMSclearBlockMemory_call(MemorySegment blkmem, MemorySegment filename, int line) {
        var mh$ = BMSclearBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSclearBlockMemory_call", blkmem, filename, line);
            }
            mh$.invokeExact(blkmem, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSdestroyBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSdestroyBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSdestroyBlockMemory_call(BMS_BLKMEM **blkmem, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSdestroyBlockMemory_call$descriptor() {
        return BMSdestroyBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSdestroyBlockMemory_call(BMS_BLKMEM **blkmem, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSdestroyBlockMemory_call$handle() {
        return BMSdestroyBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSdestroyBlockMemory_call(BMS_BLKMEM **blkmem, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSdestroyBlockMemory_call$address() {
        return BMSdestroyBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSdestroyBlockMemory_call(BMS_BLKMEM **blkmem, const char *filename, int line)
     * }
     */
    public static void BMSdestroyBlockMemory_call(MemorySegment blkmem, MemorySegment filename, int line) {
        var mh$ = BMSdestroyBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSdestroyBlockMemory_call", blkmem, filename, line);
            }
            mh$.invokeExact(blkmem, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocBlockMemory_call$descriptor() {
        return BMSallocBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocBlockMemory_call$handle() {
        return BMSallocBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBlockMemory_call$address() {
        return BMSallocBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBlockMemory_call(MemorySegment blkmem, long size, MemorySegment filename, int line) {
        var mh$ = BMSallocBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocBlockMemory_call", blkmem, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocClearBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocClearBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocClearBlockMemory_call$descriptor() {
        return BMSallocClearBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocClearBlockMemory_call$handle() {
        return BMSallocClearBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBlockMemory_call$address() {
        return BMSallocClearBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemory_call(BMS_BLKMEM *blkmem, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBlockMemory_call(MemorySegment blkmem, long size, MemorySegment filename, int line) {
        var mh$ = BMSallocClearBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocClearBlockMemory_call", blkmem, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocBlockMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocBlockMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocBlockMemoryArray_call$descriptor() {
        return BMSallocBlockMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocBlockMemoryArray_call$handle() {
        return BMSallocBlockMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBlockMemoryArray_call$address() {
        return BMSallocBlockMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBlockMemoryArray_call(MemorySegment blkmem, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocBlockMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocBlockMemoryArray_call", blkmem, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocClearBlockMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocClearBlockMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocClearBlockMemoryArray_call$descriptor() {
        return BMSallocClearBlockMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocClearBlockMemoryArray_call$handle() {
        return BMSallocClearBlockMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBlockMemoryArray_call$address() {
        return BMSallocClearBlockMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocClearBlockMemoryArray_call(BMS_BLKMEM *blkmem, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBlockMemoryArray_call(MemorySegment blkmem, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocClearBlockMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocClearBlockMemoryArray_call", blkmem, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemory_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldsize, size_t newsize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocBlockMemory_call$descriptor() {
        return BMSreallocBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemory_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldsize, size_t newsize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocBlockMemory_call$handle() {
        return BMSreallocBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemory_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldsize, size_t newsize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBlockMemory_call$address() {
        return BMSreallocBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocBlockMemory_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldsize, size_t newsize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBlockMemory_call(MemorySegment blkmem, MemorySegment ptr, long oldsize, long newsize, MemorySegment filename, int line) {
        var mh$ = BMSreallocBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocBlockMemory_call", blkmem, ptr, oldsize, newsize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, ptr, oldsize, newsize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocBlockMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocBlockMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldnum, size_t newnum, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocBlockMemoryArray_call$descriptor() {
        return BMSreallocBlockMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldnum, size_t newnum, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocBlockMemoryArray_call$handle() {
        return BMSreallocBlockMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldnum, size_t newnum, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBlockMemoryArray_call$address() {
        return BMSreallocBlockMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocBlockMemoryArray_call(BMS_BLKMEM *blkmem, void *ptr, size_t oldnum, size_t newnum, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBlockMemoryArray_call(MemorySegment blkmem, MemorySegment ptr, long oldnum, long newnum, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSreallocBlockMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocBlockMemoryArray_call", blkmem, ptr, oldnum, newnum, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, ptr, oldnum, newnum, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemory_call(BMS_BLKMEM *blkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateBlockMemory_call$descriptor() {
        return BMSduplicateBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemory_call(BMS_BLKMEM *blkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateBlockMemory_call$handle() {
        return BMSduplicateBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemory_call(BMS_BLKMEM *blkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBlockMemory_call$address() {
        return BMSduplicateBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemory_call(BMS_BLKMEM *blkmem, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBlockMemory_call(MemorySegment blkmem, MemorySegment source, long size, MemorySegment filename, int line) {
        var mh$ = BMSduplicateBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateBlockMemory_call", blkmem, source, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, source, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateBlockMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateBlockMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemoryArray_call(BMS_BLKMEM *blkmem, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateBlockMemoryArray_call$descriptor() {
        return BMSduplicateBlockMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemoryArray_call(BMS_BLKMEM *blkmem, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateBlockMemoryArray_call$handle() {
        return BMSduplicateBlockMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemoryArray_call(BMS_BLKMEM *blkmem, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBlockMemoryArray_call$address() {
        return BMSduplicateBlockMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateBlockMemoryArray_call(BMS_BLKMEM *blkmem, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBlockMemoryArray_call(MemorySegment blkmem, MemorySegment source, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSduplicateBlockMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateBlockMemoryArray_call", blkmem, source, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(blkmem, source, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemory_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeBlockMemory_call$descriptor() {
        return BMSfreeBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemory_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeBlockMemory_call$handle() {
        return BMSfreeBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemory_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeBlockMemory_call$address() {
        return BMSfreeBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeBlockMemory_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static void BMSfreeBlockMemory_call(MemorySegment blkmem, MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSfreeBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeBlockMemory_call", blkmem, ptr, size, filename, line);
            }
            mh$.invokeExact(blkmem, ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeBlockMemoryNull_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeBlockMemoryNull_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemoryNull_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeBlockMemoryNull_call$descriptor() {
        return BMSfreeBlockMemoryNull_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemoryNull_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeBlockMemoryNull_call$handle() {
        return BMSfreeBlockMemoryNull_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeBlockMemoryNull_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeBlockMemoryNull_call$address() {
        return BMSfreeBlockMemoryNull_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeBlockMemoryNull_call(BMS_BLKMEM *blkmem, void **ptr, size_t size, const char *filename, int line)
     * }
     */
    public static void BMSfreeBlockMemoryNull_call(MemorySegment blkmem, MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSfreeBlockMemoryNull_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeBlockMemoryNull_call", blkmem, ptr, size, filename, line);
            }
            mh$.invokeExact(blkmem, ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgarbagecollectBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgarbagecollectBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSgarbagecollectBlockMemory_call(BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgarbagecollectBlockMemory_call$descriptor() {
        return BMSgarbagecollectBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSgarbagecollectBlockMemory_call(BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgarbagecollectBlockMemory_call$handle() {
        return BMSgarbagecollectBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSgarbagecollectBlockMemory_call(BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgarbagecollectBlockMemory_call$address() {
        return BMSgarbagecollectBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSgarbagecollectBlockMemory_call(BMS_BLKMEM *blkmem)
     * }
     */
    public static void BMSgarbagecollectBlockMemory_call(MemorySegment blkmem) {
        var mh$ = BMSgarbagecollectBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgarbagecollectBlockMemory_call", blkmem);
            }
            mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryAllocated_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryAllocated_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocated_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryAllocated_call$descriptor() {
        return BMSgetBlockMemoryAllocated_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocated_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryAllocated_call$handle() {
        return BMSgetBlockMemoryAllocated_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocated_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryAllocated_call$address() {
        return BMSgetBlockMemoryAllocated_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocated_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryAllocated_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryAllocated_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryAllocated_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryUsed_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryUsed_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsed_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryUsed_call$descriptor() {
        return BMSgetBlockMemoryUsed_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsed_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryUsed_call$handle() {
        return BMSgetBlockMemoryUsed_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsed_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryUsed_call$address() {
        return BMSgetBlockMemoryUsed_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsed_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryUsed_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryUsed_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryUsed_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryUnused_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryUnused_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnused_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryUnused_call$descriptor() {
        return BMSgetBlockMemoryUnused_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnused_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryUnused_call$handle() {
        return BMSgetBlockMemoryUnused_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnused_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryUnused_call$address() {
        return BMSgetBlockMemoryUnused_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnused_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryUnused_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryUnused_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryUnused_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryUsedMax_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryUsedMax_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryUsedMax_call$descriptor() {
        return BMSgetBlockMemoryUsedMax_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryUsedMax_call$handle() {
        return BMSgetBlockMemoryUsedMax_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryUsedMax_call$address() {
        return BMSgetBlockMemoryUsedMax_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUsedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryUsedMax_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryUsedMax_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryUsedMax_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryUnusedMax_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryUnusedMax_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnusedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryUnusedMax_call$descriptor() {
        return BMSgetBlockMemoryUnusedMax_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnusedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryUnusedMax_call$handle() {
        return BMSgetBlockMemoryUnusedMax_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnusedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryUnusedMax_call$address() {
        return BMSgetBlockMemoryUnusedMax_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryUnusedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryUnusedMax_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryUnusedMax_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryUnusedMax_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockMemoryAllocatedMax_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockMemoryAllocatedMax_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocatedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSgetBlockMemoryAllocatedMax_call$descriptor() {
        return BMSgetBlockMemoryAllocatedMax_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocatedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSgetBlockMemoryAllocatedMax_call$handle() {
        return BMSgetBlockMemoryAllocatedMax_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocatedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSgetBlockMemoryAllocatedMax_call$address() {
        return BMSgetBlockMemoryAllocatedMax_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBlockMemoryAllocatedMax_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMSgetBlockMemoryAllocatedMax_call(MemorySegment blkmem) {
        var mh$ = BMSgetBlockMemoryAllocatedMax_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockMemoryAllocatedMax_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBlockPointerSize_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBlockPointerSize_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t BMSgetBlockPointerSize_call(const BMS_BLKMEM *blkmem, const void *ptr)
     * }
     */
    public static FunctionDescriptor BMSgetBlockPointerSize_call$descriptor() {
        return BMSgetBlockPointerSize_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t BMSgetBlockPointerSize_call(const BMS_BLKMEM *blkmem, const void *ptr)
     * }
     */
    public static MethodHandle BMSgetBlockPointerSize_call$handle() {
        return BMSgetBlockPointerSize_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t BMSgetBlockPointerSize_call(const BMS_BLKMEM *blkmem, const void *ptr)
     * }
     */
    public static MemorySegment BMSgetBlockPointerSize_call$address() {
        return BMSgetBlockPointerSize_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t BMSgetBlockPointerSize_call(const BMS_BLKMEM *blkmem, const void *ptr)
     * }
     */
    public static long BMSgetBlockPointerSize_call(MemorySegment blkmem, MemorySegment ptr) {
        var mh$ = BMSgetBlockPointerSize_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBlockPointerSize_call", blkmem, ptr);
            }
            return (long)mh$.invokeExact(blkmem, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSdisplayBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSdisplayBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSdisplayBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMSdisplayBlockMemory_call$descriptor() {
        return BMSdisplayBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSdisplayBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMSdisplayBlockMemory_call$handle() {
        return BMSdisplayBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSdisplayBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMSdisplayBlockMemory_call$address() {
        return BMSdisplayBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSdisplayBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static void BMSdisplayBlockMemory_call(MemorySegment blkmem) {
        var mh$ = BMSdisplayBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSdisplayBlockMemory_call", blkmem);
            }
            mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScheckEmptyBlockMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScheckEmptyBlockMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMScheckEmptyBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor BMScheckEmptyBlockMemory_call$descriptor() {
        return BMScheckEmptyBlockMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMScheckEmptyBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle BMScheckEmptyBlockMemory_call$handle() {
        return BMScheckEmptyBlockMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMScheckEmptyBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment BMScheckEmptyBlockMemory_call$address() {
        return BMScheckEmptyBlockMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMScheckEmptyBlockMemory_call(const BMS_BLKMEM *blkmem)
     * }
     */
    public static long BMScheckEmptyBlockMemory_call(MemorySegment blkmem) {
        var mh$ = BMScheckEmptyBlockMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScheckEmptyBlockMemory_call", blkmem);
            }
            return (long)mh$.invokeExact(blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMScreateBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMScreateBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_BUFMEM *BMScreateBufferMemory_call(double arraygrowfac, int arraygrowinit, unsigned int clean, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMScreateBufferMemory_call$descriptor() {
        return BMScreateBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_BUFMEM *BMScreateBufferMemory_call(double arraygrowfac, int arraygrowinit, unsigned int clean, const char *filename, int line)
     * }
     */
    public static MethodHandle BMScreateBufferMemory_call$handle() {
        return BMScreateBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_BUFMEM *BMScreateBufferMemory_call(double arraygrowfac, int arraygrowinit, unsigned int clean, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateBufferMemory_call$address() {
        return BMScreateBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_BUFMEM *BMScreateBufferMemory_call(double arraygrowfac, int arraygrowinit, unsigned int clean, const char *filename, int line)
     * }
     */
    public static MemorySegment BMScreateBufferMemory_call(double arraygrowfac, int arraygrowinit, int clean, MemorySegment filename, int line) {
        var mh$ = BMScreateBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMScreateBufferMemory_call", arraygrowfac, arraygrowinit, clean, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(arraygrowfac, arraygrowinit, clean, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSdestroyBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSdestroyBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSdestroyBufferMemory_call(BMS_BUFMEM **buffer, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSdestroyBufferMemory_call$descriptor() {
        return BMSdestroyBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSdestroyBufferMemory_call(BMS_BUFMEM **buffer, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSdestroyBufferMemory_call$handle() {
        return BMSdestroyBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSdestroyBufferMemory_call(BMS_BUFMEM **buffer, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSdestroyBufferMemory_call$address() {
        return BMSdestroyBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSdestroyBufferMemory_call(BMS_BUFMEM **buffer, const char *filename, int line)
     * }
     */
    public static void BMSdestroyBufferMemory_call(MemorySegment buffer, MemorySegment filename, int line) {
        var mh$ = BMSdestroyBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSdestroyBufferMemory_call", buffer, filename, line);
            }
            mh$.invokeExact(buffer, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSsetBufferMemoryArraygrowfac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSsetBufferMemoryArraygrowfac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowfac(BMS_BUFMEM *buffer, double arraygrowfac)
     * }
     */
    public static FunctionDescriptor BMSsetBufferMemoryArraygrowfac$descriptor() {
        return BMSsetBufferMemoryArraygrowfac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowfac(BMS_BUFMEM *buffer, double arraygrowfac)
     * }
     */
    public static MethodHandle BMSsetBufferMemoryArraygrowfac$handle() {
        return BMSsetBufferMemoryArraygrowfac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowfac(BMS_BUFMEM *buffer, double arraygrowfac)
     * }
     */
    public static MemorySegment BMSsetBufferMemoryArraygrowfac$address() {
        return BMSsetBufferMemoryArraygrowfac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowfac(BMS_BUFMEM *buffer, double arraygrowfac)
     * }
     */
    public static void BMSsetBufferMemoryArraygrowfac(MemorySegment buffer, double arraygrowfac) {
        var mh$ = BMSsetBufferMemoryArraygrowfac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSsetBufferMemoryArraygrowfac", buffer, arraygrowfac);
            }
            mh$.invokeExact(buffer, arraygrowfac);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSsetBufferMemoryArraygrowinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSsetBufferMemoryArraygrowinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowinit(BMS_BUFMEM *buffer, int arraygrowinit)
     * }
     */
    public static FunctionDescriptor BMSsetBufferMemoryArraygrowinit$descriptor() {
        return BMSsetBufferMemoryArraygrowinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowinit(BMS_BUFMEM *buffer, int arraygrowinit)
     * }
     */
    public static MethodHandle BMSsetBufferMemoryArraygrowinit$handle() {
        return BMSsetBufferMemoryArraygrowinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowinit(BMS_BUFMEM *buffer, int arraygrowinit)
     * }
     */
    public static MemorySegment BMSsetBufferMemoryArraygrowinit$address() {
        return BMSsetBufferMemoryArraygrowinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSsetBufferMemoryArraygrowinit(BMS_BUFMEM *buffer, int arraygrowinit)
     * }
     */
    public static void BMSsetBufferMemoryArraygrowinit(MemorySegment buffer, int arraygrowinit) {
        var mh$ = BMSsetBufferMemoryArraygrowinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSsetBufferMemoryArraygrowinit", buffer, arraygrowinit);
            }
            mh$.invokeExact(buffer, arraygrowinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemory_call(BMS_BUFMEM *buffer, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocBufferMemory_call$descriptor() {
        return BMSallocBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemory_call(BMS_BUFMEM *buffer, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocBufferMemory_call$handle() {
        return BMSallocBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemory_call(BMS_BUFMEM *buffer, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBufferMemory_call$address() {
        return BMSallocBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocBufferMemory_call(BMS_BUFMEM *buffer, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBufferMemory_call(MemorySegment buffer, long size, MemorySegment filename, int line) {
        var mh$ = BMSallocBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocBufferMemory_call", buffer, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocBufferMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocBufferMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocBufferMemoryArray_call$descriptor() {
        return BMSallocBufferMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocBufferMemoryArray_call$handle() {
        return BMSallocBufferMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBufferMemoryArray_call$address() {
        return BMSallocBufferMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocBufferMemoryArray_call(MemorySegment buffer, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocBufferMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocBufferMemoryArray_call", buffer, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSallocClearBufferMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSallocClearBufferMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSallocClearBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSallocClearBufferMemoryArray_call$descriptor() {
        return BMSallocClearBufferMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSallocClearBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSallocClearBufferMemoryArray_call$handle() {
        return BMSallocClearBufferMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSallocClearBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBufferMemoryArray_call$address() {
        return BMSallocClearBufferMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSallocClearBufferMemoryArray_call(BMS_BUFMEM *buffer, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSallocClearBufferMemoryArray_call(MemorySegment buffer, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSallocClearBufferMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSallocClearBufferMemoryArray_call", buffer, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemory_call(BMS_BUFMEM *buffer, void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocBufferMemory_call$descriptor() {
        return BMSreallocBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemory_call(BMS_BUFMEM *buffer, void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocBufferMemory_call$handle() {
        return BMSreallocBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemory_call(BMS_BUFMEM *buffer, void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBufferMemory_call$address() {
        return BMSreallocBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocBufferMemory_call(BMS_BUFMEM *buffer, void *ptr, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBufferMemory_call(MemorySegment buffer, MemorySegment ptr, long size, MemorySegment filename, int line) {
        var mh$ = BMSreallocBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocBufferMemory_call", buffer, ptr, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, ptr, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSreallocBufferMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSreallocBufferMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemoryArray_call(BMS_BUFMEM *buffer, void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSreallocBufferMemoryArray_call$descriptor() {
        return BMSreallocBufferMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemoryArray_call(BMS_BUFMEM *buffer, void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSreallocBufferMemoryArray_call$handle() {
        return BMSreallocBufferMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSreallocBufferMemoryArray_call(BMS_BUFMEM *buffer, void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBufferMemoryArray_call$address() {
        return BMSreallocBufferMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSreallocBufferMemoryArray_call(BMS_BUFMEM *buffer, void *ptr, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSreallocBufferMemoryArray_call(MemorySegment buffer, MemorySegment ptr, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSreallocBufferMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSreallocBufferMemoryArray_call", buffer, ptr, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, ptr, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemory_call(BMS_BUFMEM *buffer, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateBufferMemory_call$descriptor() {
        return BMSduplicateBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemory_call(BMS_BUFMEM *buffer, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateBufferMemory_call$handle() {
        return BMSduplicateBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemory_call(BMS_BUFMEM *buffer, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBufferMemory_call$address() {
        return BMSduplicateBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemory_call(BMS_BUFMEM *buffer, const void *source, size_t size, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBufferMemory_call(MemorySegment buffer, MemorySegment source, long size, MemorySegment filename, int line) {
        var mh$ = BMSduplicateBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateBufferMemory_call", buffer, source, size, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, source, size, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSduplicateBufferMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSduplicateBufferMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemoryArray_call(BMS_BUFMEM *buffer, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSduplicateBufferMemoryArray_call$descriptor() {
        return BMSduplicateBufferMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemoryArray_call(BMS_BUFMEM *buffer, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSduplicateBufferMemoryArray_call$handle() {
        return BMSduplicateBufferMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemoryArray_call(BMS_BUFMEM *buffer, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBufferMemoryArray_call$address() {
        return BMSduplicateBufferMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *BMSduplicateBufferMemoryArray_call(BMS_BUFMEM *buffer, const void *source, size_t num, size_t typesize, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSduplicateBufferMemoryArray_call(MemorySegment buffer, MemorySegment source, long num, long typesize, MemorySegment filename, int line) {
        var mh$ = BMSduplicateBufferMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSduplicateBufferMemoryArray_call", buffer, source, num, typesize, filename, line);
            }
            return (MemorySegment)mh$.invokeExact(buffer, source, num, typesize, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeBufferMemory_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeBufferMemory_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemory_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeBufferMemory_call$descriptor() {
        return BMSfreeBufferMemory_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemory_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeBufferMemory_call$handle() {
        return BMSfreeBufferMemory_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemory_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeBufferMemory_call$address() {
        return BMSfreeBufferMemory_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeBufferMemory_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static void BMSfreeBufferMemory_call(MemorySegment buffer, MemorySegment ptr, MemorySegment filename, int line) {
        var mh$ = BMSfreeBufferMemory_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeBufferMemory_call", buffer, ptr, filename, line);
            }
            mh$.invokeExact(buffer, ptr, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSfreeBufferMemoryNull_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSfreeBufferMemoryNull_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemoryNull_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static FunctionDescriptor BMSfreeBufferMemoryNull_call$descriptor() {
        return BMSfreeBufferMemoryNull_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemoryNull_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static MethodHandle BMSfreeBufferMemoryNull_call$handle() {
        return BMSfreeBufferMemoryNull_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSfreeBufferMemoryNull_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static MemorySegment BMSfreeBufferMemoryNull_call$address() {
        return BMSfreeBufferMemoryNull_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSfreeBufferMemoryNull_call(BMS_BUFMEM *buffer, void **ptr, const char *filename, int line)
     * }
     */
    public static void BMSfreeBufferMemoryNull_call(MemorySegment buffer, MemorySegment ptr, MemorySegment filename, int line) {
        var mh$ = BMSfreeBufferMemoryNull_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSfreeBufferMemoryNull_call", buffer, ptr, filename, line);
            }
            mh$.invokeExact(buffer, ptr, filename, line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetNUsedBufferMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetNUsedBufferMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t BMSgetNUsedBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static FunctionDescriptor BMSgetNUsedBufferMemory$descriptor() {
        return BMSgetNUsedBufferMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t BMSgetNUsedBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static MethodHandle BMSgetNUsedBufferMemory$handle() {
        return BMSgetNUsedBufferMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t BMSgetNUsedBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static MemorySegment BMSgetNUsedBufferMemory$address() {
        return BMSgetNUsedBufferMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t BMSgetNUsedBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static long BMSgetNUsedBufferMemory(MemorySegment buffer) {
        var mh$ = BMSgetNUsedBufferMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetNUsedBufferMemory", buffer);
            }
            return (long)mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSgetBufferMemoryUsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSgetBufferMemoryUsed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long BMSgetBufferMemoryUsed(const BMS_BUFMEM *bufmem)
     * }
     */
    public static FunctionDescriptor BMSgetBufferMemoryUsed$descriptor() {
        return BMSgetBufferMemoryUsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long BMSgetBufferMemoryUsed(const BMS_BUFMEM *bufmem)
     * }
     */
    public static MethodHandle BMSgetBufferMemoryUsed$handle() {
        return BMSgetBufferMemoryUsed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long BMSgetBufferMemoryUsed(const BMS_BUFMEM *bufmem)
     * }
     */
    public static MemorySegment BMSgetBufferMemoryUsed$address() {
        return BMSgetBufferMemoryUsed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long BMSgetBufferMemoryUsed(const BMS_BUFMEM *bufmem)
     * }
     */
    public static long BMSgetBufferMemoryUsed(MemorySegment bufmem) {
        var mh$ = BMSgetBufferMemoryUsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSgetBufferMemoryUsed", bufmem);
            }
            return (long)mh$.invokeExact(bufmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BMSprintBufferMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("BMSprintBufferMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BMSprintBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static FunctionDescriptor BMSprintBufferMemory$descriptor() {
        return BMSprintBufferMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BMSprintBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static MethodHandle BMSprintBufferMemory$handle() {
        return BMSprintBufferMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BMSprintBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static MemorySegment BMSprintBufferMemory$address() {
        return BMSprintBufferMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BMSprintBufferMemory(BMS_BUFMEM *buffer)
     * }
     */
    public static void BMSprintBufferMemory(MemorySegment buffer) {
        var mh$ = BMSprintBufferMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BMSprintBufferMemory", buffer);
            }
            mh$.invokeExact(buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_OKAY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_OKAY = 1
     * }
     */
    public static int SCIP_OKAY() {
        return SCIP_OKAY;
    }
    private static final int SCIP_ERROR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_ERROR = 0
     * }
     */
    public static int SCIP_ERROR() {
        return SCIP_ERROR;
    }
    private static final int SCIP_NOMEMORY = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_NOMEMORY = -1
     * }
     */
    public static int SCIP_NOMEMORY() {
        return SCIP_NOMEMORY;
    }
    private static final int SCIP_READERROR = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_READERROR = -2
     * }
     */
    public static int SCIP_READERROR() {
        return SCIP_READERROR;
    }
    private static final int SCIP_WRITEERROR = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_WRITEERROR = -3
     * }
     */
    public static int SCIP_WRITEERROR() {
        return SCIP_WRITEERROR;
    }
    private static final int SCIP_NOFILE = (int)-4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_NOFILE = -4
     * }
     */
    public static int SCIP_NOFILE() {
        return SCIP_NOFILE;
    }
    private static final int SCIP_FILECREATEERROR = (int)-5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_FILECREATEERROR = -5
     * }
     */
    public static int SCIP_FILECREATEERROR() {
        return SCIP_FILECREATEERROR;
    }
    private static final int SCIP_LPERROR = (int)-6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_LPERROR = -6
     * }
     */
    public static int SCIP_LPERROR() {
        return SCIP_LPERROR;
    }
    private static final int SCIP_NOPROBLEM = (int)-7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_NOPROBLEM = -7
     * }
     */
    public static int SCIP_NOPROBLEM() {
        return SCIP_NOPROBLEM;
    }
    private static final int SCIP_INVALIDCALL = (int)-8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_INVALIDCALL = -8
     * }
     */
    public static int SCIP_INVALIDCALL() {
        return SCIP_INVALIDCALL;
    }
    private static final int SCIP_INVALIDDATA = (int)-9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_INVALIDDATA = -9
     * }
     */
    public static int SCIP_INVALIDDATA() {
        return SCIP_INVALIDDATA;
    }
    private static final int SCIP_INVALIDRESULT = (int)-10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_INVALIDRESULT = -10
     * }
     */
    public static int SCIP_INVALIDRESULT() {
        return SCIP_INVALIDRESULT;
    }
    private static final int SCIP_PLUGINNOTFOUND = (int)-11L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_PLUGINNOTFOUND = -11
     * }
     */
    public static int SCIP_PLUGINNOTFOUND() {
        return SCIP_PLUGINNOTFOUND;
    }
    private static final int SCIP_PARAMETERUNKNOWN = (int)-12L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_PARAMETERUNKNOWN = -12
     * }
     */
    public static int SCIP_PARAMETERUNKNOWN() {
        return SCIP_PARAMETERUNKNOWN;
    }
    private static final int SCIP_PARAMETERWRONGTYPE = (int)-13L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_PARAMETERWRONGTYPE = -13
     * }
     */
    public static int SCIP_PARAMETERWRONGTYPE() {
        return SCIP_PARAMETERWRONGTYPE;
    }
    private static final int SCIP_PARAMETERWRONGVAL = (int)-14L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_PARAMETERWRONGVAL = -14
     * }
     */
    public static int SCIP_PARAMETERWRONGVAL() {
        return SCIP_PARAMETERWRONGVAL;
    }
    private static final int SCIP_KEYALREADYEXISTING = (int)-15L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_KEYALREADYEXISTING = -15
     * }
     */
    public static int SCIP_KEYALREADYEXISTING() {
        return SCIP_KEYALREADYEXISTING;
    }
    private static final int SCIP_MAXDEPTHLEVEL = (int)-16L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_MAXDEPTHLEVEL = -16
     * }
     */
    public static int SCIP_MAXDEPTHLEVEL() {
        return SCIP_MAXDEPTHLEVEL;
    }
    private static final int SCIP_BRANCHERROR = (int)-17L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_BRANCHERROR = -17
     * }
     */
    public static int SCIP_BRANCHERROR() {
        return SCIP_BRANCHERROR;
    }
    private static final int SCIP_NOTIMPLEMENTED = (int)-18L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Retcode.SCIP_NOTIMPLEMENTED = -18
     * }
     */
    public static int SCIP_NOTIMPLEMENTED() {
        return SCIP_NOTIMPLEMENTED;
    }
    private static final int SCIP_DIDNOTRUN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_DIDNOTRUN = 1
     * }
     */
    public static int SCIP_DIDNOTRUN() {
        return SCIP_DIDNOTRUN;
    }
    private static final int SCIP_DELAYED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_DELAYED = 2
     * }
     */
    public static int SCIP_DELAYED() {
        return SCIP_DELAYED;
    }
    private static final int SCIP_DIDNOTFIND = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_DIDNOTFIND = 3
     * }
     */
    public static int SCIP_DIDNOTFIND() {
        return SCIP_DIDNOTFIND;
    }
    private static final int SCIP_FEASIBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_FEASIBLE = 4
     * }
     */
    public static int SCIP_FEASIBLE() {
        return SCIP_FEASIBLE;
    }
    private static final int SCIP_INFEASIBLE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_INFEASIBLE = 5
     * }
     */
    public static int SCIP_INFEASIBLE() {
        return SCIP_INFEASIBLE;
    }
    private static final int SCIP_UNBOUNDED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_UNBOUNDED = 6
     * }
     */
    public static int SCIP_UNBOUNDED() {
        return SCIP_UNBOUNDED;
    }
    private static final int SCIP_CUTOFF = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_CUTOFF = 7
     * }
     */
    public static int SCIP_CUTOFF() {
        return SCIP_CUTOFF;
    }
    private static final int SCIP_SEPARATED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_SEPARATED = 8
     * }
     */
    public static int SCIP_SEPARATED() {
        return SCIP_SEPARATED;
    }
    private static final int SCIP_NEWROUND = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_NEWROUND = 9
     * }
     */
    public static int SCIP_NEWROUND() {
        return SCIP_NEWROUND;
    }
    private static final int SCIP_REDUCEDDOM = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_REDUCEDDOM = 10
     * }
     */
    public static int SCIP_REDUCEDDOM() {
        return SCIP_REDUCEDDOM;
    }
    private static final int SCIP_CONSADDED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_CONSADDED = 11
     * }
     */
    public static int SCIP_CONSADDED() {
        return SCIP_CONSADDED;
    }
    private static final int SCIP_CONSCHANGED = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_CONSCHANGED = 12
     * }
     */
    public static int SCIP_CONSCHANGED() {
        return SCIP_CONSCHANGED;
    }
    private static final int SCIP_BRANCHED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_BRANCHED = 13
     * }
     */
    public static int SCIP_BRANCHED() {
        return SCIP_BRANCHED;
    }
    private static final int SCIP_SOLVELP = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_SOLVELP = 14
     * }
     */
    public static int SCIP_SOLVELP() {
        return SCIP_SOLVELP;
    }
    private static final int SCIP_FOUNDSOL = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_FOUNDSOL = 15
     * }
     */
    public static int SCIP_FOUNDSOL() {
        return SCIP_FOUNDSOL;
    }
    private static final int SCIP_SUSPENDED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_SUSPENDED = 16
     * }
     */
    public static int SCIP_SUSPENDED() {
        return SCIP_SUSPENDED;
    }
    private static final int SCIP_SUCCESS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_SUCCESS = 17
     * }
     */
    public static int SCIP_SUCCESS() {
        return SCIP_SUCCESS;
    }
    private static final int SCIP_DELAYNODE = (int)18L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Result.SCIP_DELAYNODE = 18
     * }
     */
    public static int SCIP_DELAYNODE() {
        return SCIP_DELAYNODE;
    }
    private static final int SCIP_CLOCKTYPE_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ClockType.SCIP_CLOCKTYPE_DEFAULT = 0
     * }
     */
    public static int SCIP_CLOCKTYPE_DEFAULT() {
        return SCIP_CLOCKTYPE_DEFAULT;
    }
    private static final int SCIP_CLOCKTYPE_CPU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ClockType.SCIP_CLOCKTYPE_CPU = 1
     * }
     */
    public static int SCIP_CLOCKTYPE_CPU() {
        return SCIP_CLOCKTYPE_CPU;
    }
    private static final int SCIP_CLOCKTYPE_WALL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ClockType.SCIP_CLOCKTYPE_WALL = 2
     * }
     */
    public static int SCIP_CLOCKTYPE_WALL() {
        return SCIP_CLOCKTYPE_WALL;
    }
    private static final int SCIP_CONFIDENCELEVEL_MIN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Confidencelevel.SCIP_CONFIDENCELEVEL_MIN = 0
     * }
     */
    public static int SCIP_CONFIDENCELEVEL_MIN() {
        return SCIP_CONFIDENCELEVEL_MIN;
    }
    private static final int SCIP_CONFIDENCELEVEL_LOW = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Confidencelevel.SCIP_CONFIDENCELEVEL_LOW = 1
     * }
     */
    public static int SCIP_CONFIDENCELEVEL_LOW() {
        return SCIP_CONFIDENCELEVEL_LOW;
    }
    private static final int SCIP_CONFIDENCELEVEL_MEDIUM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Confidencelevel.SCIP_CONFIDENCELEVEL_MEDIUM = 2
     * }
     */
    public static int SCIP_CONFIDENCELEVEL_MEDIUM() {
        return SCIP_CONFIDENCELEVEL_MEDIUM;
    }
    private static final int SCIP_CONFIDENCELEVEL_HIGH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Confidencelevel.SCIP_CONFIDENCELEVEL_HIGH = 3
     * }
     */
    public static int SCIP_CONFIDENCELEVEL_HIGH() {
        return SCIP_CONFIDENCELEVEL_HIGH;
    }
    private static final int SCIP_CONFIDENCELEVEL_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Confidencelevel.SCIP_CONFIDENCELEVEL_MAX = 4
     * }
     */
    public static int SCIP_CONFIDENCELEVEL_MAX() {
        return SCIP_CONFIDENCELEVEL_MAX;
    }
    private static final int SCIP_HASHMAPTYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Hashmaptype.SCIP_HASHMAPTYPE_UNKNOWN = 0
     * }
     */
    public static int SCIP_HASHMAPTYPE_UNKNOWN() {
        return SCIP_HASHMAPTYPE_UNKNOWN;
    }
    private static final int SCIP_HASHMAPTYPE_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Hashmaptype.SCIP_HASHMAPTYPE_POINTER = 1
     * }
     */
    public static int SCIP_HASHMAPTYPE_POINTER() {
        return SCIP_HASHMAPTYPE_POINTER;
    }
    private static final int SCIP_HASHMAPTYPE_REAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Hashmaptype.SCIP_HASHMAPTYPE_REAL = 2
     * }
     */
    public static int SCIP_HASHMAPTYPE_REAL() {
        return SCIP_HASHMAPTYPE_REAL;
    }
    private static final int SCIP_HASHMAPTYPE_INT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Hashmaptype.SCIP_HASHMAPTYPE_INT = 3
     * }
     */
    public static int SCIP_HASHMAPTYPE_INT() {
        return SCIP_HASHMAPTYPE_INT;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_PRESOLTIMING
     * }
     */
    public static final OfInt SCIP_PRESOLTIMING = scip_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_PROPTIMING
     * }
     */
    public static final OfInt SCIP_PROPTIMING = scip_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_HEURTIMING
     * }
     */
    public static final OfInt SCIP_HEURTIMING = scip_h.C_INT;
    private static final int SCIP_PARAMTYPE_BOOL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_BOOL = 0
     * }
     */
    public static int SCIP_PARAMTYPE_BOOL() {
        return SCIP_PARAMTYPE_BOOL;
    }
    private static final int SCIP_PARAMTYPE_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_INT = 1
     * }
     */
    public static int SCIP_PARAMTYPE_INT() {
        return SCIP_PARAMTYPE_INT;
    }
    private static final int SCIP_PARAMTYPE_LONGINT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_LONGINT = 2
     * }
     */
    public static int SCIP_PARAMTYPE_LONGINT() {
        return SCIP_PARAMTYPE_LONGINT;
    }
    private static final int SCIP_PARAMTYPE_REAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_REAL = 3
     * }
     */
    public static int SCIP_PARAMTYPE_REAL() {
        return SCIP_PARAMTYPE_REAL;
    }
    private static final int SCIP_PARAMTYPE_CHAR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_CHAR = 4
     * }
     */
    public static int SCIP_PARAMTYPE_CHAR() {
        return SCIP_PARAMTYPE_CHAR;
    }
    private static final int SCIP_PARAMTYPE_STRING = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamType.SCIP_PARAMTYPE_STRING = 5
     * }
     */
    public static int SCIP_PARAMTYPE_STRING() {
        return SCIP_PARAMTYPE_STRING;
    }
    private static final int SCIP_PARAMSETTING_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamSetting.SCIP_PARAMSETTING_DEFAULT = 0
     * }
     */
    public static int SCIP_PARAMSETTING_DEFAULT() {
        return SCIP_PARAMSETTING_DEFAULT;
    }
    private static final int SCIP_PARAMSETTING_AGGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamSetting.SCIP_PARAMSETTING_AGGRESSIVE = 1
     * }
     */
    public static int SCIP_PARAMSETTING_AGGRESSIVE() {
        return SCIP_PARAMSETTING_AGGRESSIVE;
    }
    private static final int SCIP_PARAMSETTING_FAST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamSetting.SCIP_PARAMSETTING_FAST = 2
     * }
     */
    public static int SCIP_PARAMSETTING_FAST() {
        return SCIP_PARAMSETTING_FAST;
    }
    private static final int SCIP_PARAMSETTING_OFF = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamSetting.SCIP_PARAMSETTING_OFF = 3
     * }
     */
    public static int SCIP_PARAMSETTING_OFF() {
        return SCIP_PARAMSETTING_OFF;
    }
    private static final int SCIP_PARAMEMPHASIS_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_DEFAULT = 0
     * }
     */
    public static int SCIP_PARAMEMPHASIS_DEFAULT() {
        return SCIP_PARAMEMPHASIS_DEFAULT;
    }
    private static final int SCIP_PARAMEMPHASIS_CPSOLVER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_CPSOLVER = 1
     * }
     */
    public static int SCIP_PARAMEMPHASIS_CPSOLVER() {
        return SCIP_PARAMEMPHASIS_CPSOLVER;
    }
    private static final int SCIP_PARAMEMPHASIS_EASYCIP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_EASYCIP = 2
     * }
     */
    public static int SCIP_PARAMEMPHASIS_EASYCIP() {
        return SCIP_PARAMEMPHASIS_EASYCIP;
    }
    private static final int SCIP_PARAMEMPHASIS_FEASIBILITY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_FEASIBILITY = 3
     * }
     */
    public static int SCIP_PARAMEMPHASIS_FEASIBILITY() {
        return SCIP_PARAMEMPHASIS_FEASIBILITY;
    }
    private static final int SCIP_PARAMEMPHASIS_HARDLP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_HARDLP = 4
     * }
     */
    public static int SCIP_PARAMEMPHASIS_HARDLP() {
        return SCIP_PARAMEMPHASIS_HARDLP;
    }
    private static final int SCIP_PARAMEMPHASIS_OPTIMALITY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_OPTIMALITY = 5
     * }
     */
    public static int SCIP_PARAMEMPHASIS_OPTIMALITY() {
        return SCIP_PARAMEMPHASIS_OPTIMALITY;
    }
    private static final int SCIP_PARAMEMPHASIS_COUNTER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_COUNTER = 6
     * }
     */
    public static int SCIP_PARAMEMPHASIS_COUNTER() {
        return SCIP_PARAMEMPHASIS_COUNTER;
    }
    private static final int SCIP_PARAMEMPHASIS_PHASEFEAS = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_PHASEFEAS = 7
     * }
     */
    public static int SCIP_PARAMEMPHASIS_PHASEFEAS() {
        return SCIP_PARAMEMPHASIS_PHASEFEAS;
    }
    private static final int SCIP_PARAMEMPHASIS_PHASEIMPROVE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_PHASEIMPROVE = 8
     * }
     */
    public static int SCIP_PARAMEMPHASIS_PHASEIMPROVE() {
        return SCIP_PARAMEMPHASIS_PHASEIMPROVE;
    }
    private static final int SCIP_PARAMEMPHASIS_PHASEPROOF = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_PHASEPROOF = 9
     * }
     */
    public static int SCIP_PARAMEMPHASIS_PHASEPROOF() {
        return SCIP_PARAMEMPHASIS_PHASEPROOF;
    }
    private static final int SCIP_PARAMEMPHASIS_NUMERICS = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_NUMERICS = 10
     * }
     */
    public static int SCIP_PARAMEMPHASIS_NUMERICS() {
        return SCIP_PARAMEMPHASIS_NUMERICS;
    }
    private static final int SCIP_PARAMEMPHASIS_BENCHMARK = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ParamEmphasis.SCIP_PARAMEMPHASIS_BENCHMARK = 11
     * }
     */
    public static int SCIP_PARAMEMPHASIS_BENCHMARK() {
        return SCIP_PARAMEMPHASIS_BENCHMARK;
    }
    /**
     * {@snippet lang=c :
     * typedef uint64_t SCIP_EVENTTYPE
     * }
     */
    public static final OfLong SCIP_EVENTTYPE = scip_h.C_LONG;
    private static final int SCIP_LPSOLSTAT_NOTSOLVED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_NOTSOLVED = 0
     * }
     */
    public static int SCIP_LPSOLSTAT_NOTSOLVED() {
        return SCIP_LPSOLSTAT_NOTSOLVED;
    }
    private static final int SCIP_LPSOLSTAT_OPTIMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_OPTIMAL = 1
     * }
     */
    public static int SCIP_LPSOLSTAT_OPTIMAL() {
        return SCIP_LPSOLSTAT_OPTIMAL;
    }
    private static final int SCIP_LPSOLSTAT_INFEASIBLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_INFEASIBLE = 2
     * }
     */
    public static int SCIP_LPSOLSTAT_INFEASIBLE() {
        return SCIP_LPSOLSTAT_INFEASIBLE;
    }
    private static final int SCIP_LPSOLSTAT_UNBOUNDEDRAY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_UNBOUNDEDRAY = 3
     * }
     */
    public static int SCIP_LPSOLSTAT_UNBOUNDEDRAY() {
        return SCIP_LPSOLSTAT_UNBOUNDEDRAY;
    }
    private static final int SCIP_LPSOLSTAT_OBJLIMIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_OBJLIMIT = 4
     * }
     */
    public static int SCIP_LPSOLSTAT_OBJLIMIT() {
        return SCIP_LPSOLSTAT_OBJLIMIT;
    }
    private static final int SCIP_LPSOLSTAT_ITERLIMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_ITERLIMIT = 5
     * }
     */
    public static int SCIP_LPSOLSTAT_ITERLIMIT() {
        return SCIP_LPSOLSTAT_ITERLIMIT;
    }
    private static final int SCIP_LPSOLSTAT_TIMELIMIT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_TIMELIMIT = 6
     * }
     */
    public static int SCIP_LPSOLSTAT_TIMELIMIT() {
        return SCIP_LPSOLSTAT_TIMELIMIT;
    }
    private static final int SCIP_LPSOLSTAT_ERROR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPSolStat.SCIP_LPSOLSTAT_ERROR = 7
     * }
     */
    public static int SCIP_LPSOLSTAT_ERROR() {
        return SCIP_LPSOLSTAT_ERROR;
    }
    private static final int SCIP_BOUNDTYPE_LOWER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BoundType.SCIP_BOUNDTYPE_LOWER = 0
     * }
     */
    public static int SCIP_BOUNDTYPE_LOWER() {
        return SCIP_BOUNDTYPE_LOWER;
    }
    private static final int SCIP_BOUNDTYPE_UPPER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BoundType.SCIP_BOUNDTYPE_UPPER = 1
     * }
     */
    public static int SCIP_BOUNDTYPE_UPPER() {
        return SCIP_BOUNDTYPE_UPPER;
    }
    private static final int SCIP_SIDETYPE_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SideType.SCIP_SIDETYPE_LEFT = 0
     * }
     */
    public static int SCIP_SIDETYPE_LEFT() {
        return SCIP_SIDETYPE_LEFT;
    }
    private static final int SCIP_SIDETYPE_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SideType.SCIP_SIDETYPE_RIGHT = 1
     * }
     */
    public static int SCIP_SIDETYPE_RIGHT() {
        return SCIP_SIDETYPE_RIGHT;
    }
    private static final int SCIP_ROWORIGINTYPE_UNSPEC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_RowOriginType.SCIP_ROWORIGINTYPE_UNSPEC = 0
     * }
     */
    public static int SCIP_ROWORIGINTYPE_UNSPEC() {
        return SCIP_ROWORIGINTYPE_UNSPEC;
    }
    private static final int SCIP_ROWORIGINTYPE_CONSHDLR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_RowOriginType.SCIP_ROWORIGINTYPE_CONSHDLR = 1
     * }
     */
    public static int SCIP_ROWORIGINTYPE_CONSHDLR() {
        return SCIP_ROWORIGINTYPE_CONSHDLR;
    }
    private static final int SCIP_ROWORIGINTYPE_CONS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_RowOriginType.SCIP_ROWORIGINTYPE_CONS = 2
     * }
     */
    public static int SCIP_ROWORIGINTYPE_CONS() {
        return SCIP_ROWORIGINTYPE_CONS;
    }
    private static final int SCIP_ROWORIGINTYPE_SEPA = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_RowOriginType.SCIP_ROWORIGINTYPE_SEPA = 3
     * }
     */
    public static int SCIP_ROWORIGINTYPE_SEPA() {
        return SCIP_ROWORIGINTYPE_SEPA;
    }
    private static final int SCIP_ROWORIGINTYPE_REOPT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_RowOriginType.SCIP_ROWORIGINTYPE_REOPT = 4
     * }
     */
    public static int SCIP_ROWORIGINTYPE_REOPT() {
        return SCIP_ROWORIGINTYPE_REOPT;
    }
    private static final int SCIP_LPALGO_PRIMALSIMPLEX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPAlgo.SCIP_LPALGO_PRIMALSIMPLEX = 0
     * }
     */
    public static int SCIP_LPALGO_PRIMALSIMPLEX() {
        return SCIP_LPALGO_PRIMALSIMPLEX;
    }
    private static final int SCIP_LPALGO_DUALSIMPLEX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPAlgo.SCIP_LPALGO_DUALSIMPLEX = 1
     * }
     */
    public static int SCIP_LPALGO_DUALSIMPLEX() {
        return SCIP_LPALGO_DUALSIMPLEX;
    }
    private static final int SCIP_LPALGO_BARRIER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPAlgo.SCIP_LPALGO_BARRIER = 2
     * }
     */
    public static int SCIP_LPALGO_BARRIER() {
        return SCIP_LPALGO_BARRIER;
    }
    private static final int SCIP_LPALGO_BARRIERCROSSOVER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPAlgo.SCIP_LPALGO_BARRIERCROSSOVER = 3
     * }
     */
    public static int SCIP_LPALGO_BARRIERCROSSOVER() {
        return SCIP_LPALGO_BARRIERCROSSOVER;
    }
    private static final int SCIP_VARSTATUS_ORIGINAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_ORIGINAL = 0
     * }
     */
    public static int SCIP_VARSTATUS_ORIGINAL() {
        return SCIP_VARSTATUS_ORIGINAL;
    }
    private static final int SCIP_VARSTATUS_LOOSE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_LOOSE = 1
     * }
     */
    public static int SCIP_VARSTATUS_LOOSE() {
        return SCIP_VARSTATUS_LOOSE;
    }
    private static final int SCIP_VARSTATUS_COLUMN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_COLUMN = 2
     * }
     */
    public static int SCIP_VARSTATUS_COLUMN() {
        return SCIP_VARSTATUS_COLUMN;
    }
    private static final int SCIP_VARSTATUS_FIXED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_FIXED = 3
     * }
     */
    public static int SCIP_VARSTATUS_FIXED() {
        return SCIP_VARSTATUS_FIXED;
    }
    private static final int SCIP_VARSTATUS_AGGREGATED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_AGGREGATED = 4
     * }
     */
    public static int SCIP_VARSTATUS_AGGREGATED() {
        return SCIP_VARSTATUS_AGGREGATED;
    }
    private static final int SCIP_VARSTATUS_MULTAGGR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_MULTAGGR = 5
     * }
     */
    public static int SCIP_VARSTATUS_MULTAGGR() {
        return SCIP_VARSTATUS_MULTAGGR;
    }
    private static final int SCIP_VARSTATUS_NEGATED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Varstatus.SCIP_VARSTATUS_NEGATED = 6
     * }
     */
    public static int SCIP_VARSTATUS_NEGATED() {
        return SCIP_VARSTATUS_NEGATED;
    }
    private static final int SCIP_VARTYPE_BINARY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Vartype.SCIP_VARTYPE_BINARY = 0
     * }
     */
    public static int SCIP_VARTYPE_BINARY() {
        return SCIP_VARTYPE_BINARY;
    }
    private static final int SCIP_VARTYPE_INTEGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Vartype.SCIP_VARTYPE_INTEGER = 1
     * }
     */
    public static int SCIP_VARTYPE_INTEGER() {
        return SCIP_VARTYPE_INTEGER;
    }
    private static final int SCIP_VARTYPE_IMPLINT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Vartype.SCIP_VARTYPE_IMPLINT = 2
     * }
     */
    public static int SCIP_VARTYPE_IMPLINT() {
        return SCIP_VARTYPE_IMPLINT;
    }
    private static final int SCIP_VARTYPE_CONTINUOUS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Vartype.SCIP_VARTYPE_CONTINUOUS = 3
     * }
     */
    public static int SCIP_VARTYPE_CONTINUOUS() {
        return SCIP_VARTYPE_CONTINUOUS;
    }
    private static final int SCIP_DOMCHGTYPE_DYNAMIC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DomchgType.SCIP_DOMCHGTYPE_DYNAMIC = 0
     * }
     */
    public static int SCIP_DOMCHGTYPE_DYNAMIC() {
        return SCIP_DOMCHGTYPE_DYNAMIC;
    }
    private static final int SCIP_DOMCHGTYPE_BOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DomchgType.SCIP_DOMCHGTYPE_BOTH = 1
     * }
     */
    public static int SCIP_DOMCHGTYPE_BOTH() {
        return SCIP_DOMCHGTYPE_BOTH;
    }
    private static final int SCIP_DOMCHGTYPE_BOUND = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DomchgType.SCIP_DOMCHGTYPE_BOUND = 2
     * }
     */
    public static int SCIP_DOMCHGTYPE_BOUND() {
        return SCIP_DOMCHGTYPE_BOUND;
    }
    private static final int SCIP_BOUNDCHGTYPE_BRANCHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BoundchgType.SCIP_BOUNDCHGTYPE_BRANCHING = 0
     * }
     */
    public static int SCIP_BOUNDCHGTYPE_BRANCHING() {
        return SCIP_BOUNDCHGTYPE_BRANCHING;
    }
    private static final int SCIP_BOUNDCHGTYPE_CONSINFER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BoundchgType.SCIP_BOUNDCHGTYPE_CONSINFER = 1
     * }
     */
    public static int SCIP_BOUNDCHGTYPE_CONSINFER() {
        return SCIP_BOUNDCHGTYPE_CONSINFER;
    }
    private static final int SCIP_BOUNDCHGTYPE_PROPINFER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BoundchgType.SCIP_BOUNDCHGTYPE_PROPINFER = 2
     * }
     */
    public static int SCIP_BOUNDCHGTYPE_PROPINFER() {
        return SCIP_BOUNDCHGTYPE_PROPINFER;
    }
    private static final int SCIP_LOCKTYPE_MODEL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LockType.SCIP_LOCKTYPE_MODEL = 0
     * }
     */
    public static int SCIP_LOCKTYPE_MODEL() {
        return SCIP_LOCKTYPE_MODEL;
    }
    private static final int SCIP_LOCKTYPE_CONFLICT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LockType.SCIP_LOCKTYPE_CONFLICT = 1
     * }
     */
    public static int SCIP_LOCKTYPE_CONFLICT() {
        return SCIP_LOCKTYPE_CONFLICT;
    }
    private static final int SCIP_OBJSENSE_MAXIMIZE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Objsense.SCIP_OBJSENSE_MAXIMIZE = -1
     * }
     */
    public static int SCIP_OBJSENSE_MAXIMIZE() {
        return SCIP_OBJSENSE_MAXIMIZE;
    }
    private static final int SCIP_OBJSENSE_MINIMIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Objsense.SCIP_OBJSENSE_MINIMIZE = 1
     * }
     */
    public static int SCIP_OBJSENSE_MINIMIZE() {
        return SCIP_OBJSENSE_MINIMIZE;
    }
    private static final int SCIP_NODETYPE_FOCUSNODE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_FOCUSNODE = 0
     * }
     */
    public static int SCIP_NODETYPE_FOCUSNODE() {
        return SCIP_NODETYPE_FOCUSNODE;
    }
    private static final int SCIP_NODETYPE_PROBINGNODE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_PROBINGNODE = 1
     * }
     */
    public static int SCIP_NODETYPE_PROBINGNODE() {
        return SCIP_NODETYPE_PROBINGNODE;
    }
    private static final int SCIP_NODETYPE_SIBLING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_SIBLING = 2
     * }
     */
    public static int SCIP_NODETYPE_SIBLING() {
        return SCIP_NODETYPE_SIBLING;
    }
    private static final int SCIP_NODETYPE_CHILD = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_CHILD = 3
     * }
     */
    public static int SCIP_NODETYPE_CHILD() {
        return SCIP_NODETYPE_CHILD;
    }
    private static final int SCIP_NODETYPE_LEAF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_LEAF = 4
     * }
     */
    public static int SCIP_NODETYPE_LEAF() {
        return SCIP_NODETYPE_LEAF;
    }
    private static final int SCIP_NODETYPE_DEADEND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_DEADEND = 5
     * }
     */
    public static int SCIP_NODETYPE_DEADEND() {
        return SCIP_NODETYPE_DEADEND;
    }
    private static final int SCIP_NODETYPE_JUNCTION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_JUNCTION = 6
     * }
     */
    public static int SCIP_NODETYPE_JUNCTION() {
        return SCIP_NODETYPE_JUNCTION;
    }
    private static final int SCIP_NODETYPE_PSEUDOFORK = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_PSEUDOFORK = 7
     * }
     */
    public static int SCIP_NODETYPE_PSEUDOFORK() {
        return SCIP_NODETYPE_PSEUDOFORK;
    }
    private static final int SCIP_NODETYPE_FORK = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_FORK = 8
     * }
     */
    public static int SCIP_NODETYPE_FORK() {
        return SCIP_NODETYPE_FORK;
    }
    private static final int SCIP_NODETYPE_SUBROOT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_SUBROOT = 9
     * }
     */
    public static int SCIP_NODETYPE_SUBROOT() {
        return SCIP_NODETYPE_SUBROOT;
    }
    private static final int SCIP_NODETYPE_REFOCUSNODE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NodeType.SCIP_NODETYPE_REFOCUSNODE = 10
     * }
     */
    public static int SCIP_NODETYPE_REFOCUSNODE() {
        return SCIP_NODETYPE_REFOCUSNODE;
    }
    private static final int SCIP_CONFTYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_UNKNOWN = 0
     * }
     */
    public static int SCIP_CONFTYPE_UNKNOWN() {
        return SCIP_CONFTYPE_UNKNOWN;
    }
    private static final int SCIP_CONFTYPE_PROPAGATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_PROPAGATION = 1
     * }
     */
    public static int SCIP_CONFTYPE_PROPAGATION() {
        return SCIP_CONFTYPE_PROPAGATION;
    }
    private static final int SCIP_CONFTYPE_INFEASLP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_INFEASLP = 2
     * }
     */
    public static int SCIP_CONFTYPE_INFEASLP() {
        return SCIP_CONFTYPE_INFEASLP;
    }
    private static final int SCIP_CONFTYPE_BNDEXCEEDING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_BNDEXCEEDING = 3
     * }
     */
    public static int SCIP_CONFTYPE_BNDEXCEEDING() {
        return SCIP_CONFTYPE_BNDEXCEEDING;
    }
    private static final int SCIP_CONFTYPE_ALTINFPROOF = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_ALTINFPROOF = 4
     * }
     */
    public static int SCIP_CONFTYPE_ALTINFPROOF() {
        return SCIP_CONFTYPE_ALTINFPROOF;
    }
    private static final int SCIP_CONFTYPE_ALTBNDPROOF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictType.SCIP_CONFTYPE_ALTBNDPROOF = 5
     * }
     */
    public static int SCIP_CONFTYPE_ALTBNDPROOF() {
        return SCIP_CONFTYPE_ALTBNDPROOF;
    }
    private static final int SCIP_CONFPRES_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictPresolStrat.SCIP_CONFPRES_DISABLED = 0
     * }
     */
    public static int SCIP_CONFPRES_DISABLED() {
        return SCIP_CONFPRES_DISABLED;
    }
    private static final int SCIP_CONFPRES_ONLYLOCAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictPresolStrat.SCIP_CONFPRES_ONLYLOCAL = 1
     * }
     */
    public static int SCIP_CONFPRES_ONLYLOCAL() {
        return SCIP_CONFPRES_ONLYLOCAL;
    }
    private static final int SCIP_CONFPRES_ONLYGLOBAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictPresolStrat.SCIP_CONFPRES_ONLYGLOBAL = 2
     * }
     */
    public static int SCIP_CONFPRES_ONLYGLOBAL() {
        return SCIP_CONFPRES_ONLYGLOBAL;
    }
    private static final int SCIP_CONFPRES_BOTH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ConflictPresolStrat.SCIP_CONFPRES_BOTH = 3
     * }
     */
    public static int SCIP_CONFPRES_BOTH() {
        return SCIP_CONFPRES_BOTH;
    }
    private static final int SCIP_SOLORIGIN_ORIGINAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_ORIGINAL = 0
     * }
     */
    public static int SCIP_SOLORIGIN_ORIGINAL() {
        return SCIP_SOLORIGIN_ORIGINAL;
    }
    private static final int SCIP_SOLORIGIN_ZERO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_ZERO = 1
     * }
     */
    public static int SCIP_SOLORIGIN_ZERO() {
        return SCIP_SOLORIGIN_ZERO;
    }
    private static final int SCIP_SOLORIGIN_LPSOL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_LPSOL = 2
     * }
     */
    public static int SCIP_SOLORIGIN_LPSOL() {
        return SCIP_SOLORIGIN_LPSOL;
    }
    private static final int SCIP_SOLORIGIN_NLPSOL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_NLPSOL = 3
     * }
     */
    public static int SCIP_SOLORIGIN_NLPSOL() {
        return SCIP_SOLORIGIN_NLPSOL;
    }
    private static final int SCIP_SOLORIGIN_RELAXSOL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_RELAXSOL = 4
     * }
     */
    public static int SCIP_SOLORIGIN_RELAXSOL() {
        return SCIP_SOLORIGIN_RELAXSOL;
    }
    private static final int SCIP_SOLORIGIN_PSEUDOSOL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_PSEUDOSOL = 5
     * }
     */
    public static int SCIP_SOLORIGIN_PSEUDOSOL() {
        return SCIP_SOLORIGIN_PSEUDOSOL;
    }
    private static final int SCIP_SOLORIGIN_PARTIAL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_PARTIAL = 6
     * }
     */
    public static int SCIP_SOLORIGIN_PARTIAL() {
        return SCIP_SOLORIGIN_PARTIAL;
    }
    private static final int SCIP_SOLORIGIN_UNKNOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolOrigin.SCIP_SOLORIGIN_UNKNOWN = 7
     * }
     */
    public static int SCIP_SOLORIGIN_UNKNOWN() {
        return SCIP_SOLORIGIN_UNKNOWN;
    }
    private static final int SCIP_SOLTYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_UNKNOWN = 0
     * }
     */
    public static int SCIP_SOLTYPE_UNKNOWN() {
        return SCIP_SOLTYPE_UNKNOWN;
    }
    private static final int SCIP_SOLTYPE_HEUR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_HEUR = 1
     * }
     */
    public static int SCIP_SOLTYPE_HEUR() {
        return SCIP_SOLTYPE_HEUR;
    }
    private static final int SCIP_SOLTYPE_RELAX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_RELAX = 2
     * }
     */
    public static int SCIP_SOLTYPE_RELAX() {
        return SCIP_SOLTYPE_RELAX;
    }
    private static final int SCIP_SOLTYPE_LPRELAX = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_LPRELAX = 3
     * }
     */
    public static int SCIP_SOLTYPE_LPRELAX() {
        return SCIP_SOLTYPE_LPRELAX;
    }
    private static final int SCIP_SOLTYPE_STRONGBRANCH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_STRONGBRANCH = 4
     * }
     */
    public static int SCIP_SOLTYPE_STRONGBRANCH() {
        return SCIP_SOLTYPE_STRONGBRANCH;
    }
    private static final int SCIP_SOLTYPE_PSEUDO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SolType.SCIP_SOLTYPE_PSEUDO = 5
     * }
     */
    public static int SCIP_SOLTYPE_PSEUDO() {
        return SCIP_SOLTYPE_PSEUDO;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_DIVETYPE
     * }
     */
    public static final OfInt SCIP_DIVETYPE = scip_h.C_INT;
    private static final int SCIP_DIVECONTEXT_TOTAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DiveContext.SCIP_DIVECONTEXT_TOTAL = 0
     * }
     */
    public static int SCIP_DIVECONTEXT_TOTAL() {
        return SCIP_DIVECONTEXT_TOTAL;
    }
    private static final int SCIP_DIVECONTEXT_SINGLE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DiveContext.SCIP_DIVECONTEXT_SINGLE = 1
     * }
     */
    public static int SCIP_DIVECONTEXT_SINGLE() {
        return SCIP_DIVECONTEXT_SINGLE;
    }
    private static final int SCIP_DIVECONTEXT_ADAPTIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DiveContext.SCIP_DIVECONTEXT_ADAPTIVE = 2
     * }
     */
    public static int SCIP_DIVECONTEXT_ADAPTIVE() {
        return SCIP_DIVECONTEXT_ADAPTIVE;
    }
    private static final int SCIP_DIVECONTEXT_SCHEDULER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DiveContext.SCIP_DIVECONTEXT_SCHEDULER = 3
     * }
     */
    public static int SCIP_DIVECONTEXT_SCHEDULER() {
        return SCIP_DIVECONTEXT_SCHEDULER;
    }
    private static final int SCIP_LINCONSTYPE_EMPTY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_EMPTY = 0
     * }
     */
    public static int SCIP_LINCONSTYPE_EMPTY() {
        return SCIP_LINCONSTYPE_EMPTY;
    }
    private static final int SCIP_LINCONSTYPE_FREE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_FREE = 1
     * }
     */
    public static int SCIP_LINCONSTYPE_FREE() {
        return SCIP_LINCONSTYPE_FREE;
    }
    private static final int SCIP_LINCONSTYPE_SINGLETON = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_SINGLETON = 2
     * }
     */
    public static int SCIP_LINCONSTYPE_SINGLETON() {
        return SCIP_LINCONSTYPE_SINGLETON;
    }
    private static final int SCIP_LINCONSTYPE_AGGREGATION = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_AGGREGATION = 3
     * }
     */
    public static int SCIP_LINCONSTYPE_AGGREGATION() {
        return SCIP_LINCONSTYPE_AGGREGATION;
    }
    private static final int SCIP_LINCONSTYPE_PRECEDENCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_PRECEDENCE = 4
     * }
     */
    public static int SCIP_LINCONSTYPE_PRECEDENCE() {
        return SCIP_LINCONSTYPE_PRECEDENCE;
    }
    private static final int SCIP_LINCONSTYPE_VARBOUND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_VARBOUND = 5
     * }
     */
    public static int SCIP_LINCONSTYPE_VARBOUND() {
        return SCIP_LINCONSTYPE_VARBOUND;
    }
    private static final int SCIP_LINCONSTYPE_SETPARTITION = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_SETPARTITION = 6
     * }
     */
    public static int SCIP_LINCONSTYPE_SETPARTITION() {
        return SCIP_LINCONSTYPE_SETPARTITION;
    }
    private static final int SCIP_LINCONSTYPE_SETPACKING = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_SETPACKING = 7
     * }
     */
    public static int SCIP_LINCONSTYPE_SETPACKING() {
        return SCIP_LINCONSTYPE_SETPACKING;
    }
    private static final int SCIP_LINCONSTYPE_SETCOVERING = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_SETCOVERING = 8
     * }
     */
    public static int SCIP_LINCONSTYPE_SETCOVERING() {
        return SCIP_LINCONSTYPE_SETCOVERING;
    }
    private static final int SCIP_LINCONSTYPE_CARDINALITY = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_CARDINALITY = 9
     * }
     */
    public static int SCIP_LINCONSTYPE_CARDINALITY() {
        return SCIP_LINCONSTYPE_CARDINALITY;
    }
    private static final int SCIP_LINCONSTYPE_INVKNAPSACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_INVKNAPSACK = 10
     * }
     */
    public static int SCIP_LINCONSTYPE_INVKNAPSACK() {
        return SCIP_LINCONSTYPE_INVKNAPSACK;
    }
    private static final int SCIP_LINCONSTYPE_EQKNAPSACK = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_EQKNAPSACK = 11
     * }
     */
    public static int SCIP_LINCONSTYPE_EQKNAPSACK() {
        return SCIP_LINCONSTYPE_EQKNAPSACK;
    }
    private static final int SCIP_LINCONSTYPE_BINPACKING = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_BINPACKING = 12
     * }
     */
    public static int SCIP_LINCONSTYPE_BINPACKING() {
        return SCIP_LINCONSTYPE_BINPACKING;
    }
    private static final int SCIP_LINCONSTYPE_KNAPSACK = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_KNAPSACK = 13
     * }
     */
    public static int SCIP_LINCONSTYPE_KNAPSACK() {
        return SCIP_LINCONSTYPE_KNAPSACK;
    }
    private static final int SCIP_LINCONSTYPE_INTKNAPSACK = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_INTKNAPSACK = 14
     * }
     */
    public static int SCIP_LINCONSTYPE_INTKNAPSACK() {
        return SCIP_LINCONSTYPE_INTKNAPSACK;
    }
    private static final int SCIP_LINCONSTYPE_MIXEDBINARY = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_MIXEDBINARY = 15
     * }
     */
    public static int SCIP_LINCONSTYPE_MIXEDBINARY() {
        return SCIP_LINCONSTYPE_MIXEDBINARY;
    }
    private static final int SCIP_LINCONSTYPE_GENERAL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinConstype.SCIP_LINCONSTYPE_GENERAL = 16
     * }
     */
    public static int SCIP_LINCONSTYPE_GENERAL() {
        return SCIP_LINCONSTYPE_GENERAL;
    }
    private static final int SCIP_DISPSTATUS_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispStatus.SCIP_DISPSTATUS_OFF = 0
     * }
     */
    public static int SCIP_DISPSTATUS_OFF() {
        return SCIP_DISPSTATUS_OFF;
    }
    private static final int SCIP_DISPSTATUS_AUTO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispStatus.SCIP_DISPSTATUS_AUTO = 1
     * }
     */
    public static int SCIP_DISPSTATUS_AUTO() {
        return SCIP_DISPSTATUS_AUTO;
    }
    private static final int SCIP_DISPSTATUS_ON = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispStatus.SCIP_DISPSTATUS_ON = 2
     * }
     */
    public static int SCIP_DISPSTATUS_ON() {
        return SCIP_DISPSTATUS_ON;
    }
    private static final int SCIP_DISPMODE_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispMode.SCIP_DISPMODE_DEFAULT = 1
     * }
     */
    public static int SCIP_DISPMODE_DEFAULT() {
        return SCIP_DISPMODE_DEFAULT;
    }
    private static final int SCIP_DISPMODE_CONCURRENT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispMode.SCIP_DISPMODE_CONCURRENT = 2
     * }
     */
    public static int SCIP_DISPMODE_CONCURRENT() {
        return SCIP_DISPMODE_CONCURRENT;
    }
    private static final int SCIP_DISPMODE_ALL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_DispMode.SCIP_DISPMODE_ALL = 3
     * }
     */
    public static int SCIP_DISPMODE_ALL() {
        return SCIP_DISPMODE_ALL;
    }
    /**
     * {@snippet lang=c :
     * typedef int SCIP_ROUNDMODE
     * }
     */
    public static final OfInt SCIP_ROUNDMODE = scip_h.C_INT;

    private static class SCIPintervalHasRoundingControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalHasRoundingControl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalHasRoundingControl()
     * }
     */
    public static FunctionDescriptor SCIPintervalHasRoundingControl$descriptor() {
        return SCIPintervalHasRoundingControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalHasRoundingControl()
     * }
     */
    public static MethodHandle SCIPintervalHasRoundingControl$handle() {
        return SCIPintervalHasRoundingControl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalHasRoundingControl()
     * }
     */
    public static MemorySegment SCIPintervalHasRoundingControl$address() {
        return SCIPintervalHasRoundingControl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalHasRoundingControl()
     * }
     */
    public static int SCIPintervalHasRoundingControl() {
        var mh$ = SCIPintervalHasRoundingControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalHasRoundingControl");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetRoundingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetRoundingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingMode(SCIP_ROUNDMODE roundmode)
     * }
     */
    public static FunctionDescriptor SCIPintervalSetRoundingMode$descriptor() {
        return SCIPintervalSetRoundingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingMode(SCIP_ROUNDMODE roundmode)
     * }
     */
    public static MethodHandle SCIPintervalSetRoundingMode$handle() {
        return SCIPintervalSetRoundingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingMode(SCIP_ROUNDMODE roundmode)
     * }
     */
    public static MemorySegment SCIPintervalSetRoundingMode$address() {
        return SCIPintervalSetRoundingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingMode(SCIP_ROUNDMODE roundmode)
     * }
     */
    public static void SCIPintervalSetRoundingMode(int roundmode) {
        var mh$ = SCIPintervalSetRoundingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetRoundingMode", roundmode);
            }
            mh$.invokeExact(roundmode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalGetRoundingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalGetRoundingMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROUNDMODE SCIPintervalGetRoundingMode()
     * }
     */
    public static FunctionDescriptor SCIPintervalGetRoundingMode$descriptor() {
        return SCIPintervalGetRoundingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROUNDMODE SCIPintervalGetRoundingMode()
     * }
     */
    public static MethodHandle SCIPintervalGetRoundingMode$handle() {
        return SCIPintervalGetRoundingMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROUNDMODE SCIPintervalGetRoundingMode()
     * }
     */
    public static MemorySegment SCIPintervalGetRoundingMode$address() {
        return SCIPintervalGetRoundingMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROUNDMODE SCIPintervalGetRoundingMode()
     * }
     */
    public static int SCIPintervalGetRoundingMode() {
        var mh$ = SCIPintervalGetRoundingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalGetRoundingMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetRoundingModeDownwards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetRoundingModeDownwards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeDownwards()
     * }
     */
    public static FunctionDescriptor SCIPintervalSetRoundingModeDownwards$descriptor() {
        return SCIPintervalSetRoundingModeDownwards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeDownwards()
     * }
     */
    public static MethodHandle SCIPintervalSetRoundingModeDownwards$handle() {
        return SCIPintervalSetRoundingModeDownwards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeDownwards()
     * }
     */
    public static MemorySegment SCIPintervalSetRoundingModeDownwards$address() {
        return SCIPintervalSetRoundingModeDownwards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeDownwards()
     * }
     */
    public static void SCIPintervalSetRoundingModeDownwards() {
        var mh$ = SCIPintervalSetRoundingModeDownwards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetRoundingModeDownwards");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetRoundingModeUpwards {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetRoundingModeUpwards");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeUpwards()
     * }
     */
    public static FunctionDescriptor SCIPintervalSetRoundingModeUpwards$descriptor() {
        return SCIPintervalSetRoundingModeUpwards.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeUpwards()
     * }
     */
    public static MethodHandle SCIPintervalSetRoundingModeUpwards$handle() {
        return SCIPintervalSetRoundingModeUpwards.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeUpwards()
     * }
     */
    public static MemorySegment SCIPintervalSetRoundingModeUpwards$address() {
        return SCIPintervalSetRoundingModeUpwards.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeUpwards()
     * }
     */
    public static void SCIPintervalSetRoundingModeUpwards() {
        var mh$ = SCIPintervalSetRoundingModeUpwards.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetRoundingModeUpwards");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetRoundingModeToNearest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetRoundingModeToNearest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeToNearest()
     * }
     */
    public static FunctionDescriptor SCIPintervalSetRoundingModeToNearest$descriptor() {
        return SCIPintervalSetRoundingModeToNearest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeToNearest()
     * }
     */
    public static MethodHandle SCIPintervalSetRoundingModeToNearest$handle() {
        return SCIPintervalSetRoundingModeToNearest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeToNearest()
     * }
     */
    public static MemorySegment SCIPintervalSetRoundingModeToNearest$address() {
        return SCIPintervalSetRoundingModeToNearest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeToNearest()
     * }
     */
    public static void SCIPintervalSetRoundingModeToNearest() {
        var mh$ = SCIPintervalSetRoundingModeToNearest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetRoundingModeToNearest");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetRoundingModeTowardsZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetRoundingModeTowardsZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeTowardsZero()
     * }
     */
    public static FunctionDescriptor SCIPintervalSetRoundingModeTowardsZero$descriptor() {
        return SCIPintervalSetRoundingModeTowardsZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeTowardsZero()
     * }
     */
    public static MethodHandle SCIPintervalSetRoundingModeTowardsZero$handle() {
        return SCIPintervalSetRoundingModeTowardsZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeTowardsZero()
     * }
     */
    public static MemorySegment SCIPintervalSetRoundingModeTowardsZero$address() {
        return SCIPintervalSetRoundingModeTowardsZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetRoundingModeTowardsZero()
     * }
     */
    public static void SCIPintervalSetRoundingModeTowardsZero() {
        var mh$ = SCIPintervalSetRoundingModeTowardsZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetRoundingModeTowardsZero");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalNegateReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalNegateReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalNegateReal(double x)
     * }
     */
    public static FunctionDescriptor SCIPintervalNegateReal$descriptor() {
        return SCIPintervalNegateReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalNegateReal(double x)
     * }
     */
    public static MethodHandle SCIPintervalNegateReal$handle() {
        return SCIPintervalNegateReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalNegateReal(double x)
     * }
     */
    public static MemorySegment SCIPintervalNegateReal$address() {
        return SCIPintervalNegateReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalNegateReal(double x)
     * }
     */
    public static double SCIPintervalNegateReal(double x) {
        var mh$ = SCIPintervalNegateReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalNegateReal", x);
            }
            return (double)mh$.invokeExact(x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalGetInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalGetInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalGetInf(SCIP_INTERVAL interval)
     * }
     */
    public static FunctionDescriptor SCIPintervalGetInf$descriptor() {
        return SCIPintervalGetInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalGetInf(SCIP_INTERVAL interval)
     * }
     */
    public static MethodHandle SCIPintervalGetInf$handle() {
        return SCIPintervalGetInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalGetInf(SCIP_INTERVAL interval)
     * }
     */
    public static MemorySegment SCIPintervalGetInf$address() {
        return SCIPintervalGetInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalGetInf(SCIP_INTERVAL interval)
     * }
     */
    public static double SCIPintervalGetInf(MemorySegment interval) {
        var mh$ = SCIPintervalGetInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalGetInf", interval);
            }
            return (double)mh$.invokeExact(interval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalGetSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalGetSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalGetSup(SCIP_INTERVAL interval)
     * }
     */
    public static FunctionDescriptor SCIPintervalGetSup$descriptor() {
        return SCIPintervalGetSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalGetSup(SCIP_INTERVAL interval)
     * }
     */
    public static MethodHandle SCIPintervalGetSup$handle() {
        return SCIPintervalGetSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalGetSup(SCIP_INTERVAL interval)
     * }
     */
    public static MemorySegment SCIPintervalGetSup$address() {
        return SCIPintervalGetSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalGetSup(SCIP_INTERVAL interval)
     * }
     */
    public static double SCIPintervalGetSup(MemorySegment interval) {
        var mh$ = SCIPintervalGetSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalGetSup", interval);
            }
            return (double)mh$.invokeExact(interval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSet(SCIP_INTERVAL *resultant, double value)
     * }
     */
    public static FunctionDescriptor SCIPintervalSet$descriptor() {
        return SCIPintervalSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSet(SCIP_INTERVAL *resultant, double value)
     * }
     */
    public static MethodHandle SCIPintervalSet$handle() {
        return SCIPintervalSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSet(SCIP_INTERVAL *resultant, double value)
     * }
     */
    public static MemorySegment SCIPintervalSet$address() {
        return SCIPintervalSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSet(SCIP_INTERVAL *resultant, double value)
     * }
     */
    public static void SCIPintervalSet(MemorySegment resultant, double value) {
        var mh$ = SCIPintervalSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSet", resultant, value);
            }
            mh$.invokeExact(resultant, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetBounds(SCIP_INTERVAL *resultant, double inf, double sup)
     * }
     */
    public static FunctionDescriptor SCIPintervalSetBounds$descriptor() {
        return SCIPintervalSetBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetBounds(SCIP_INTERVAL *resultant, double inf, double sup)
     * }
     */
    public static MethodHandle SCIPintervalSetBounds$handle() {
        return SCIPintervalSetBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetBounds(SCIP_INTERVAL *resultant, double inf, double sup)
     * }
     */
    public static MemorySegment SCIPintervalSetBounds$address() {
        return SCIPintervalSetBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetBounds(SCIP_INTERVAL *resultant, double inf, double sup)
     * }
     */
    public static void SCIPintervalSetBounds(MemorySegment resultant, double inf, double sup) {
        var mh$ = SCIPintervalSetBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetBounds", resultant, inf, sup);
            }
            mh$.invokeExact(resultant, inf, sup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetEmpty(SCIP_INTERVAL *resultant)
     * }
     */
    public static FunctionDescriptor SCIPintervalSetEmpty$descriptor() {
        return SCIPintervalSetEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetEmpty(SCIP_INTERVAL *resultant)
     * }
     */
    public static MethodHandle SCIPintervalSetEmpty$handle() {
        return SCIPintervalSetEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetEmpty(SCIP_INTERVAL *resultant)
     * }
     */
    public static MemorySegment SCIPintervalSetEmpty$address() {
        return SCIPintervalSetEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetEmpty(SCIP_INTERVAL *resultant)
     * }
     */
    public static void SCIPintervalSetEmpty(MemorySegment resultant) {
        var mh$ = SCIPintervalSetEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetEmpty", resultant);
            }
            mh$.invokeExact(resultant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIsEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIsEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEmpty(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalIsEmpty$descriptor() {
        return SCIPintervalIsEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEmpty(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalIsEmpty$handle() {
        return SCIPintervalIsEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEmpty(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalIsEmpty$address() {
        return SCIPintervalIsEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEmpty(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static int SCIPintervalIsEmpty(double infinity, MemorySegment operand) {
        var mh$ = SCIPintervalIsEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIsEmpty", infinity, operand);
            }
            return (int)mh$.invokeExact(infinity, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSetEntire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSetEntire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSetEntire(double infinity, SCIP_INTERVAL *resultant)
     * }
     */
    public static FunctionDescriptor SCIPintervalSetEntire$descriptor() {
        return SCIPintervalSetEntire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSetEntire(double infinity, SCIP_INTERVAL *resultant)
     * }
     */
    public static MethodHandle SCIPintervalSetEntire$handle() {
        return SCIPintervalSetEntire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSetEntire(double infinity, SCIP_INTERVAL *resultant)
     * }
     */
    public static MemorySegment SCIPintervalSetEntire$address() {
        return SCIPintervalSetEntire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSetEntire(double infinity, SCIP_INTERVAL *resultant)
     * }
     */
    public static void SCIPintervalSetEntire(double infinity, MemorySegment resultant) {
        var mh$ = SCIPintervalSetEntire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSetEntire", infinity, resultant);
            }
            mh$.invokeExact(infinity, resultant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIsEntire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIsEntire");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEntire(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalIsEntire$descriptor() {
        return SCIPintervalIsEntire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEntire(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalIsEntire$handle() {
        return SCIPintervalIsEntire.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEntire(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalIsEntire$address() {
        return SCIPintervalIsEntire.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsEntire(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static int SCIPintervalIsEntire(double infinity, MemorySegment operand) {
        var mh$ = SCIPintervalIsEntire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIsEntire", infinity, operand);
            }
            return (int)mh$.invokeExact(infinity, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIsPositiveInfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIsPositiveInfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsPositiveInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalIsPositiveInfinity$descriptor() {
        return SCIPintervalIsPositiveInfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsPositiveInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalIsPositiveInfinity$handle() {
        return SCIPintervalIsPositiveInfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsPositiveInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalIsPositiveInfinity$address() {
        return SCIPintervalIsPositiveInfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsPositiveInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static int SCIPintervalIsPositiveInfinity(double infinity, MemorySegment operand) {
        var mh$ = SCIPintervalIsPositiveInfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIsPositiveInfinity", infinity, operand);
            }
            return (int)mh$.invokeExact(infinity, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIsNegativeInfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIsNegativeInfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsNegativeInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalIsNegativeInfinity$descriptor() {
        return SCIPintervalIsNegativeInfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsNegativeInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalIsNegativeInfinity$handle() {
        return SCIPintervalIsNegativeInfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsNegativeInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalIsNegativeInfinity$address() {
        return SCIPintervalIsNegativeInfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsNegativeInfinity(double infinity, SCIP_INTERVAL operand)
     * }
     */
    public static int SCIPintervalIsNegativeInfinity(double infinity, MemorySegment operand) {
        var mh$ = SCIPintervalIsNegativeInfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIsNegativeInfinity", infinity, operand);
            }
            return (int)mh$.invokeExact(infinity, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIsSubsetEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIsSubsetEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsSubsetEQ(double infinity, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalIsSubsetEQ$descriptor() {
        return SCIPintervalIsSubsetEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsSubsetEQ(double infinity, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalIsSubsetEQ$handle() {
        return SCIPintervalIsSubsetEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsSubsetEQ(double infinity, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalIsSubsetEQ$address() {
        return SCIPintervalIsSubsetEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalIsSubsetEQ(double infinity, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static int SCIPintervalIsSubsetEQ(double infinity, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalIsSubsetEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIsSubsetEQ", infinity, operand1, operand2);
            }
            return (int)mh$.invokeExact(infinity, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAreDisjoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAreDisjoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjoint(SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAreDisjoint$descriptor() {
        return SCIPintervalAreDisjoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjoint(SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalAreDisjoint$handle() {
        return SCIPintervalAreDisjoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjoint(SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalAreDisjoint$address() {
        return SCIPintervalAreDisjoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjoint(SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static int SCIPintervalAreDisjoint(MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAreDisjoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAreDisjoint", operand1, operand2);
            }
            return (int)mh$.invokeExact(operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAreDisjointEps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAreDisjointEps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjointEps(double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAreDisjointEps$descriptor() {
        return SCIPintervalAreDisjointEps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjointEps(double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalAreDisjointEps$handle() {
        return SCIPintervalAreDisjointEps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjointEps(double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalAreDisjointEps$address() {
        return SCIPintervalAreDisjointEps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPintervalAreDisjointEps(double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static int SCIPintervalAreDisjointEps(double eps, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAreDisjointEps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAreDisjointEps", eps, operand1, operand2);
            }
            return (int)mh$.invokeExact(eps, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIntersect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIntersect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalIntersect(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalIntersect$descriptor() {
        return SCIPintervalIntersect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalIntersect(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalIntersect$handle() {
        return SCIPintervalIntersect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalIntersect(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalIntersect$address() {
        return SCIPintervalIntersect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalIntersect(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalIntersect(MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalIntersect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIntersect", resultant, operand1, operand2);
            }
            mh$.invokeExact(resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalIntersectEps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalIntersectEps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalIntersectEps(SCIP_INTERVAL *resultant, double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalIntersectEps$descriptor() {
        return SCIPintervalIntersectEps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalIntersectEps(SCIP_INTERVAL *resultant, double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalIntersectEps$handle() {
        return SCIPintervalIntersectEps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalIntersectEps(SCIP_INTERVAL *resultant, double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalIntersectEps$address() {
        return SCIPintervalIntersectEps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalIntersectEps(SCIP_INTERVAL *resultant, double eps, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalIntersectEps(MemorySegment resultant, double eps, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalIntersectEps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalIntersectEps", resultant, eps, operand1, operand2);
            }
            mh$.invokeExact(resultant, eps, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalUnify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalUnify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalUnify(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalUnify$descriptor() {
        return SCIPintervalUnify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalUnify(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalUnify$handle() {
        return SCIPintervalUnify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalUnify(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalUnify$address() {
        return SCIPintervalUnify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalUnify(SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalUnify(MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalUnify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalUnify", resultant, operand1, operand2);
            }
            mh$.invokeExact(resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAddInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAddInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAddInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAddInf$descriptor() {
        return SCIPintervalAddInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAddInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalAddInf$handle() {
        return SCIPintervalAddInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAddInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalAddInf$address() {
        return SCIPintervalAddInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAddInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalAddInf(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAddInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAddInf", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAddSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAddSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAddSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAddSup$descriptor() {
        return SCIPintervalAddSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAddSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalAddSup$handle() {
        return SCIPintervalAddSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAddSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalAddSup$address() {
        return SCIPintervalAddSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAddSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalAddSup(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAddSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAddSup", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAdd(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAdd$descriptor() {
        return SCIPintervalAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAdd(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalAdd$handle() {
        return SCIPintervalAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAdd(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalAdd$address() {
        return SCIPintervalAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAdd(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalAdd(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAdd", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAddScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAddScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAddScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAddScalar$descriptor() {
        return SCIPintervalAddScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAddScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalAddScalar$handle() {
        return SCIPintervalAddScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAddScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalAddScalar$address() {
        return SCIPintervalAddScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAddScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalAddScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalAddScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAddScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAddVectors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAddVectors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAddVectors(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalAddVectors$descriptor() {
        return SCIPintervalAddVectors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAddVectors(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static MethodHandle SCIPintervalAddVectors$handle() {
        return SCIPintervalAddVectors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAddVectors(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static MemorySegment SCIPintervalAddVectors$address() {
        return SCIPintervalAddVectors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAddVectors(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static void SCIPintervalAddVectors(double infinity, MemorySegment resultant, int length, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalAddVectors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAddVectors", infinity, resultant, length, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, length, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSub(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalSub$descriptor() {
        return SCIPintervalSub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSub(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalSub$handle() {
        return SCIPintervalSub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSub(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalSub$address() {
        return SCIPintervalSub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSub(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalSub(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalSub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSub", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSubScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSubScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSubScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalSubScalar$descriptor() {
        return SCIPintervalSubScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSubScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalSubScalar$handle() {
        return SCIPintervalSubScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSubScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalSubScalar$address() {
        return SCIPintervalSubScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSubScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalSubScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalSubScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSubScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMulInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMulInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMulInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMulInf$descriptor() {
        return SCIPintervalMulInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMulInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalMulInf$handle() {
        return SCIPintervalMulInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMulInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalMulInf$address() {
        return SCIPintervalMulInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMulInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalMulInf(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalMulInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMulInf", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMulSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMulSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMulSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMulSup$descriptor() {
        return SCIPintervalMulSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMulSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalMulSup$handle() {
        return SCIPintervalMulSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMulSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalMulSup$address() {
        return SCIPintervalMulSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMulSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalMulSup(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalMulSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMulSup", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMul(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMul$descriptor() {
        return SCIPintervalMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMul(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalMul$handle() {
        return SCIPintervalMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMul(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalMul$address() {
        return SCIPintervalMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMul(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalMul(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMul", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMulScalarInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMulScalarInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMulScalarInf$descriptor() {
        return SCIPintervalMulScalarInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalMulScalarInf$handle() {
        return SCIPintervalMulScalarInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalMulScalarInf$address() {
        return SCIPintervalMulScalarInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMulScalarInf(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalMulScalarInf(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalMulScalarInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMulScalarInf", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMulScalarSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMulScalarSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMulScalarSup$descriptor() {
        return SCIPintervalMulScalarSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalMulScalarSup$handle() {
        return SCIPintervalMulScalarSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalarSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalMulScalarSup$address() {
        return SCIPintervalMulScalarSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMulScalarSup(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalMulScalarSup(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalMulScalarSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMulScalarSup", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMulScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMulScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMulScalar$descriptor() {
        return SCIPintervalMulScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalMulScalar$handle() {
        return SCIPintervalMulScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMulScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalMulScalar$address() {
        return SCIPintervalMulScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMulScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalMulScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalMulScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMulScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalDiv(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalDiv$descriptor() {
        return SCIPintervalDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalDiv(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalDiv$handle() {
        return SCIPintervalDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalDiv(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalDiv$address() {
        return SCIPintervalDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalDiv(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalDiv(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalDiv", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalDivScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalDivScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalDivScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalDivScalar$descriptor() {
        return SCIPintervalDivScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalDivScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalDivScalar$handle() {
        return SCIPintervalDivScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalDivScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalDivScalar$address() {
        return SCIPintervalDivScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalDivScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalDivScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalDivScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalDivScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalScalprod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalScalprod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalScalprod(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalScalprod$descriptor() {
        return SCIPintervalScalprod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalScalprod(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static MethodHandle SCIPintervalScalprod$handle() {
        return SCIPintervalScalprod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalScalprod(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static MemorySegment SCIPintervalScalprod$address() {
        return SCIPintervalScalprod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalScalprod(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, SCIP_INTERVAL *operand2)
     * }
     */
    public static void SCIPintervalScalprod(double infinity, MemorySegment resultant, int length, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalScalprod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalScalprod", infinity, resultant, length, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, length, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalScalprodScalarsInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalScalprodScalarsInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsInf(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalScalprodScalarsInf$descriptor() {
        return SCIPintervalScalprodScalarsInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsInf(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MethodHandle SCIPintervalScalprodScalarsInf$handle() {
        return SCIPintervalScalprodScalarsInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsInf(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MemorySegment SCIPintervalScalprodScalarsInf$address() {
        return SCIPintervalScalprodScalarsInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsInf(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static void SCIPintervalScalprodScalarsInf(double infinity, MemorySegment resultant, int length, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalScalprodScalarsInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalScalprodScalarsInf", infinity, resultant, length, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, length, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalScalprodScalarsSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalScalprodScalarsSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsSup(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalScalprodScalarsSup$descriptor() {
        return SCIPintervalScalprodScalarsSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsSup(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MethodHandle SCIPintervalScalprodScalarsSup$handle() {
        return SCIPintervalScalprodScalarsSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsSup(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MemorySegment SCIPintervalScalprodScalarsSup$address() {
        return SCIPintervalScalprodScalarsSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalarsSup(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static void SCIPintervalScalprodScalarsSup(double infinity, MemorySegment resultant, int length, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalScalprodScalarsSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalScalprodScalarsSup", infinity, resultant, length, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, length, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalScalprodScalars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalScalprodScalars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalars(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalScalprodScalars$descriptor() {
        return SCIPintervalScalprodScalars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalars(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MethodHandle SCIPintervalScalprodScalars$handle() {
        return SCIPintervalScalprodScalars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalars(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static MemorySegment SCIPintervalScalprodScalars$address() {
        return SCIPintervalScalprodScalars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalScalprodScalars(double infinity, SCIP_INTERVAL *resultant, int length, SCIP_INTERVAL *operand1, double *operand2)
     * }
     */
    public static void SCIPintervalScalprodScalars(double infinity, MemorySegment resultant, int length, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalScalprodScalars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalScalprodScalars", infinity, resultant, length, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, length, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSquare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSquare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSquare(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalSquare$descriptor() {
        return SCIPintervalSquare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSquare(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalSquare$handle() {
        return SCIPintervalSquare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSquare(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalSquare$address() {
        return SCIPintervalSquare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSquare(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalSquare(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalSquare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSquare", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSquareRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSquareRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSquareRoot(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalSquareRoot$descriptor() {
        return SCIPintervalSquareRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSquareRoot(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalSquareRoot$handle() {
        return SCIPintervalSquareRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSquareRoot(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalSquareRoot$address() {
        return SCIPintervalSquareRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSquareRoot(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalSquareRoot(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalSquareRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSquareRoot", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalPower(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPower$descriptor() {
        return SCIPintervalPower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalPower(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalPower$handle() {
        return SCIPintervalPower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalPower(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalPower$address() {
        return SCIPintervalPower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalPower(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalPower(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalPower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPower", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalar$descriptor() {
        return SCIPintervalPowerScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalar$handle() {
        return SCIPintervalPowerScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalar$address() {
        return SCIPintervalPowerScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalPowerScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalPowerScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalarScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalarScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarScalar(SCIP_INTERVAL *resultant, double operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalarScalar$descriptor() {
        return SCIPintervalPowerScalarScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarScalar(SCIP_INTERVAL *resultant, double operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalarScalar$handle() {
        return SCIPintervalPowerScalarScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarScalar(SCIP_INTERVAL *resultant, double operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalarScalar$address() {
        return SCIPintervalPowerScalarScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarScalar(SCIP_INTERVAL *resultant, double operand1, double operand2)
     * }
     */
    public static void SCIPintervalPowerScalarScalar(MemorySegment resultant, double operand1, double operand2) {
        var mh$ = SCIPintervalPowerScalarScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalarScalar", resultant, operand1, operand2);
            }
            mh$.invokeExact(resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalarIntegerInf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalarIntegerInf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerInf(double operand1, int operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalarIntegerInf$descriptor() {
        return SCIPintervalPowerScalarIntegerInf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerInf(double operand1, int operand2)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalarIntegerInf$handle() {
        return SCIPintervalPowerScalarIntegerInf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerInf(double operand1, int operand2)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalarIntegerInf$address() {
        return SCIPintervalPowerScalarIntegerInf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerInf(double operand1, int operand2)
     * }
     */
    public static double SCIPintervalPowerScalarIntegerInf(double operand1, int operand2) {
        var mh$ = SCIPintervalPowerScalarIntegerInf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalarIntegerInf", operand1, operand2);
            }
            return (double)mh$.invokeExact(operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalarIntegerSup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalarIntegerSup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerSup(double operand1, int operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalarIntegerSup$descriptor() {
        return SCIPintervalPowerScalarIntegerSup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerSup(double operand1, int operand2)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalarIntegerSup$handle() {
        return SCIPintervalPowerScalarIntegerSup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerSup(double operand1, int operand2)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalarIntegerSup$address() {
        return SCIPintervalPowerScalarIntegerSup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalPowerScalarIntegerSup(double operand1, int operand2)
     * }
     */
    public static double SCIPintervalPowerScalarIntegerSup(double operand1, int operand2) {
        var mh$ = SCIPintervalPowerScalarIntegerSup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalarIntegerSup", operand1, operand2);
            }
            return (double)mh$.invokeExact(operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalarInteger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalarInteger");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInteger(SCIP_INTERVAL *resultant, double operand1, int operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalarInteger$descriptor() {
        return SCIPintervalPowerScalarInteger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInteger(SCIP_INTERVAL *resultant, double operand1, int operand2)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalarInteger$handle() {
        return SCIPintervalPowerScalarInteger.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInteger(SCIP_INTERVAL *resultant, double operand1, int operand2)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalarInteger$address() {
        return SCIPintervalPowerScalarInteger.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInteger(SCIP_INTERVAL *resultant, double operand1, int operand2)
     * }
     */
    public static void SCIPintervalPowerScalarInteger(MemorySegment resultant, double operand1, int operand2) {
        var mh$ = SCIPintervalPowerScalarInteger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalarInteger", resultant, operand1, operand2);
            }
            mh$.invokeExact(resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPowerScalarInverse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPowerScalarInverse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInverse(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL basedomain, double exponent, SCIP_INTERVAL image)
     * }
     */
    public static FunctionDescriptor SCIPintervalPowerScalarInverse$descriptor() {
        return SCIPintervalPowerScalarInverse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInverse(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL basedomain, double exponent, SCIP_INTERVAL image)
     * }
     */
    public static MethodHandle SCIPintervalPowerScalarInverse$handle() {
        return SCIPintervalPowerScalarInverse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInverse(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL basedomain, double exponent, SCIP_INTERVAL image)
     * }
     */
    public static MemorySegment SCIPintervalPowerScalarInverse$address() {
        return SCIPintervalPowerScalarInverse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalPowerScalarInverse(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL basedomain, double exponent, SCIP_INTERVAL image)
     * }
     */
    public static void SCIPintervalPowerScalarInverse(double infinity, MemorySegment resultant, MemorySegment basedomain, double exponent, MemorySegment image) {
        var mh$ = SCIPintervalPowerScalarInverse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPowerScalarInverse", infinity, resultant, basedomain, exponent, image);
            }
            mh$.invokeExact(infinity, resultant, basedomain, exponent, image);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSignPowerScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSignPowerScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSignPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalSignPowerScalar$descriptor() {
        return SCIPintervalSignPowerScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSignPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MethodHandle SCIPintervalSignPowerScalar$handle() {
        return SCIPintervalSignPowerScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSignPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static MemorySegment SCIPintervalSignPowerScalar$address() {
        return SCIPintervalSignPowerScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSignPowerScalar(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, double operand2)
     * }
     */
    public static void SCIPintervalSignPowerScalar(double infinity, MemorySegment resultant, MemorySegment operand1, double operand2) {
        var mh$ = SCIPintervalSignPowerScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSignPowerScalar", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalReciprocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalReciprocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalReciprocal(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalReciprocal$descriptor() {
        return SCIPintervalReciprocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalReciprocal(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalReciprocal$handle() {
        return SCIPintervalReciprocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalReciprocal(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalReciprocal$address() {
        return SCIPintervalReciprocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalReciprocal(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalReciprocal(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalReciprocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalReciprocal", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalExp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalExp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalExp(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalExp$descriptor() {
        return SCIPintervalExp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalExp(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalExp$handle() {
        return SCIPintervalExp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalExp(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalExp$address() {
        return SCIPintervalExp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalExp(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalExp(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalExp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalExp", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalLog(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalLog$descriptor() {
        return SCIPintervalLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalLog(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalLog$handle() {
        return SCIPintervalLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalLog(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalLog$address() {
        return SCIPintervalLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalLog(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalLog(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalLog", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMin$descriptor() {
        return SCIPintervalMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalMin$handle() {
        return SCIPintervalMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalMin$address() {
        return SCIPintervalMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalMin(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMin", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalMax(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static FunctionDescriptor SCIPintervalMax$descriptor() {
        return SCIPintervalMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalMax(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MethodHandle SCIPintervalMax$handle() {
        return SCIPintervalMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalMax(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static MemorySegment SCIPintervalMax$address() {
        return SCIPintervalMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalMax(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand1, SCIP_INTERVAL operand2)
     * }
     */
    public static void SCIPintervalMax(double infinity, MemorySegment resultant, MemorySegment operand1, MemorySegment operand2) {
        var mh$ = SCIPintervalMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalMax", infinity, resultant, operand1, operand2);
            }
            mh$.invokeExact(infinity, resultant, operand1, operand2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalAbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalAbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalAbs(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalAbs$descriptor() {
        return SCIPintervalAbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalAbs(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalAbs$handle() {
        return SCIPintervalAbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalAbs(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalAbs$address() {
        return SCIPintervalAbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalAbs(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalAbs(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalAbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalAbs", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalSin$descriptor() {
        return SCIPintervalSin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalSin$handle() {
        return SCIPintervalSin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalSin$address() {
        return SCIPintervalSin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSin(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalSin(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalSin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSin", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalCos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalCos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalCos(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalCos$descriptor() {
        return SCIPintervalCos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalCos(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalCos$handle() {
        return SCIPintervalCos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalCos(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalCos$address() {
        return SCIPintervalCos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalCos(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalCos(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalCos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalCos", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSign(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalSign$descriptor() {
        return SCIPintervalSign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSign(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalSign$handle() {
        return SCIPintervalSign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSign(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalSign$address() {
        return SCIPintervalSign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSign(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalSign(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalSign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSign", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalEntropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalEntropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalEntropy(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static FunctionDescriptor SCIPintervalEntropy$descriptor() {
        return SCIPintervalEntropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalEntropy(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MethodHandle SCIPintervalEntropy$handle() {
        return SCIPintervalEntropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalEntropy(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static MemorySegment SCIPintervalEntropy$address() {
        return SCIPintervalEntropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalEntropy(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL operand)
     * }
     */
    public static void SCIPintervalEntropy(double infinity, MemorySegment resultant, MemorySegment operand) {
        var mh$ = SCIPintervalEntropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalEntropy", infinity, resultant, operand);
            }
            mh$.invokeExact(infinity, resultant, operand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalQuadUpperBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalQuadUpperBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPintervalQuadUpperBound(double infinity, double a, SCIP_INTERVAL b_, SCIP_INTERVAL x)
     * }
     */
    public static FunctionDescriptor SCIPintervalQuadUpperBound$descriptor() {
        return SCIPintervalQuadUpperBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPintervalQuadUpperBound(double infinity, double a, SCIP_INTERVAL b_, SCIP_INTERVAL x)
     * }
     */
    public static MethodHandle SCIPintervalQuadUpperBound$handle() {
        return SCIPintervalQuadUpperBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPintervalQuadUpperBound(double infinity, double a, SCIP_INTERVAL b_, SCIP_INTERVAL x)
     * }
     */
    public static MemorySegment SCIPintervalQuadUpperBound$address() {
        return SCIPintervalQuadUpperBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPintervalQuadUpperBound(double infinity, double a, SCIP_INTERVAL b_, SCIP_INTERVAL x)
     * }
     */
    public static double SCIPintervalQuadUpperBound(double infinity, double a, MemorySegment b_, MemorySegment x) {
        var mh$ = SCIPintervalQuadUpperBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalQuadUpperBound", infinity, a, b_, x);
            }
            return (double)mh$.invokeExact(infinity, a, b_, x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalQuad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalQuad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalQuad(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL xrng)
     * }
     */
    public static FunctionDescriptor SCIPintervalQuad$descriptor() {
        return SCIPintervalQuad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalQuad(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL xrng)
     * }
     */
    public static MethodHandle SCIPintervalQuad$handle() {
        return SCIPintervalQuad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalQuad(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL xrng)
     * }
     */
    public static MemorySegment SCIPintervalQuad$address() {
        return SCIPintervalQuad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalQuad(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL xrng)
     * }
     */
    public static void SCIPintervalQuad(double infinity, MemorySegment resultant, double sqrcoeff, MemorySegment lincoeff, MemorySegment xrng) {
        var mh$ = SCIPintervalQuad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalQuad", infinity, resultant, sqrcoeff, lincoeff, xrng);
            }
            mh$.invokeExact(infinity, resultant, sqrcoeff, lincoeff, xrng);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSolveUnivariateQuadExpressionPositive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSolveUnivariateQuadExpressionPositive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositive(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalSolveUnivariateQuadExpressionPositive$descriptor() {
        return SCIPintervalSolveUnivariateQuadExpressionPositive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositive(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MethodHandle SCIPintervalSolveUnivariateQuadExpressionPositive$handle() {
        return SCIPintervalSolveUnivariateQuadExpressionPositive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositive(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MemorySegment SCIPintervalSolveUnivariateQuadExpressionPositive$address() {
        return SCIPintervalSolveUnivariateQuadExpressionPositive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositive(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static void SCIPintervalSolveUnivariateQuadExpressionPositive(double infinity, MemorySegment resultant, MemorySegment sqrcoeff, MemorySegment lincoeff, MemorySegment rhs, MemorySegment xbnds) {
        var mh$ = SCIPintervalSolveUnivariateQuadExpressionPositive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSolveUnivariateQuadExpressionPositive", infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
            }
            mh$.invokeExact(infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSolveUnivariateQuadExpressionNegative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSolveUnivariateQuadExpressionNegative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionNegative(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalSolveUnivariateQuadExpressionNegative$descriptor() {
        return SCIPintervalSolveUnivariateQuadExpressionNegative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionNegative(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MethodHandle SCIPintervalSolveUnivariateQuadExpressionNegative$handle() {
        return SCIPintervalSolveUnivariateQuadExpressionNegative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionNegative(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MemorySegment SCIPintervalSolveUnivariateQuadExpressionNegative$address() {
        return SCIPintervalSolveUnivariateQuadExpressionNegative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionNegative(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static void SCIPintervalSolveUnivariateQuadExpressionNegative(double infinity, MemorySegment resultant, MemorySegment sqrcoeff, MemorySegment lincoeff, MemorySegment rhs, MemorySegment xbnds) {
        var mh$ = SCIPintervalSolveUnivariateQuadExpressionNegative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSolveUnivariateQuadExpressionNegative", infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
            }
            mh$.invokeExact(infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, double lincoeff, double rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar$descriptor() {
        return SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, double lincoeff, double rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MethodHandle SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar$handle() {
        return SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, double lincoeff, double rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MemorySegment SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar$address() {
        return SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(double infinity, SCIP_INTERVAL *resultant, double sqrcoeff, double lincoeff, double rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static void SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar(double infinity, MemorySegment resultant, double sqrcoeff, double lincoeff, double rhs, MemorySegment xbnds) {
        var mh$ = SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSolveUnivariateQuadExpressionPositiveAllScalar", infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
            }
            mh$.invokeExact(infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSolveUnivariateQuadExpression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSolveUnivariateQuadExpression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpression(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalSolveUnivariateQuadExpression$descriptor() {
        return SCIPintervalSolveUnivariateQuadExpression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpression(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MethodHandle SCIPintervalSolveUnivariateQuadExpression$handle() {
        return SCIPintervalSolveUnivariateQuadExpression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpression(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static MemorySegment SCIPintervalSolveUnivariateQuadExpression$address() {
        return SCIPintervalSolveUnivariateQuadExpression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSolveUnivariateQuadExpression(double infinity, SCIP_INTERVAL *resultant, SCIP_INTERVAL sqrcoeff, SCIP_INTERVAL lincoeff, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds)
     * }
     */
    public static void SCIPintervalSolveUnivariateQuadExpression(double infinity, MemorySegment resultant, MemorySegment sqrcoeff, MemorySegment lincoeff, MemorySegment rhs, MemorySegment xbnds) {
        var mh$ = SCIPintervalSolveUnivariateQuadExpression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSolveUnivariateQuadExpression", infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
            }
            mh$.invokeExact(infinity, resultant, sqrcoeff, lincoeff, rhs, xbnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalQuadBivar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalQuadBivar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalQuadBivar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalQuadBivar$descriptor() {
        return SCIPintervalQuadBivar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalQuadBivar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static MethodHandle SCIPintervalQuadBivar$handle() {
        return SCIPintervalQuadBivar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalQuadBivar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static MemorySegment SCIPintervalQuadBivar$address() {
        return SCIPintervalQuadBivar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalQuadBivar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static void SCIPintervalQuadBivar(double infinity, MemorySegment resultant, double ax, double ay, double axy, double bx, double by, MemorySegment xbnds, MemorySegment ybnds) {
        var mh$ = SCIPintervalQuadBivar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalQuadBivar", infinity, resultant, ax, ay, axy, bx, by, xbnds, ybnds);
            }
            mh$.invokeExact(infinity, resultant, ax, ay, axy, bx, by, xbnds, ybnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalSolveBivariateQuadExpressionAllScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            SCIP_Interval.layout(),
            SCIP_Interval.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalSolveBivariateQuadExpressionAllScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPintervalSolveBivariateQuadExpressionAllScalar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static FunctionDescriptor SCIPintervalSolveBivariateQuadExpressionAllScalar$descriptor() {
        return SCIPintervalSolveBivariateQuadExpressionAllScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPintervalSolveBivariateQuadExpressionAllScalar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static MethodHandle SCIPintervalSolveBivariateQuadExpressionAllScalar$handle() {
        return SCIPintervalSolveBivariateQuadExpressionAllScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPintervalSolveBivariateQuadExpressionAllScalar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static MemorySegment SCIPintervalSolveBivariateQuadExpressionAllScalar$address() {
        return SCIPintervalSolveBivariateQuadExpressionAllScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPintervalSolveBivariateQuadExpressionAllScalar(double infinity, SCIP_INTERVAL *resultant, double ax, double ay, double axy, double bx, double by, SCIP_INTERVAL rhs, SCIP_INTERVAL xbnds, SCIP_INTERVAL ybnds)
     * }
     */
    public static void SCIPintervalSolveBivariateQuadExpressionAllScalar(double infinity, MemorySegment resultant, double ax, double ay, double axy, double bx, double by, MemorySegment rhs, MemorySegment xbnds, MemorySegment ybnds) {
        var mh$ = SCIPintervalSolveBivariateQuadExpressionAllScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalSolveBivariateQuadExpressionAllScalar", infinity, resultant, ax, ay, axy, bx, by, rhs, xbnds, ybnds);
            }
            mh$.invokeExact(infinity, resultant, ax, ay, axy, bx, by, rhs, xbnds, ybnds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPintervalPropagateWeightedSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            SCIP_Interval.layout(),
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPintervalPropagateWeightedSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPintervalPropagateWeightedSum(double infinity, int noperands, SCIP_INTERVAL *operands, double *weights, double constant, SCIP_INTERVAL rhs, SCIP_INTERVAL *resultants, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPintervalPropagateWeightedSum$descriptor() {
        return SCIPintervalPropagateWeightedSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPintervalPropagateWeightedSum(double infinity, int noperands, SCIP_INTERVAL *operands, double *weights, double constant, SCIP_INTERVAL rhs, SCIP_INTERVAL *resultants, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPintervalPropagateWeightedSum$handle() {
        return SCIPintervalPropagateWeightedSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPintervalPropagateWeightedSum(double infinity, int noperands, SCIP_INTERVAL *operands, double *weights, double constant, SCIP_INTERVAL rhs, SCIP_INTERVAL *resultants, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPintervalPropagateWeightedSum$address() {
        return SCIPintervalPropagateWeightedSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPintervalPropagateWeightedSum(double infinity, int noperands, SCIP_INTERVAL *operands, double *weights, double constant, SCIP_INTERVAL rhs, SCIP_INTERVAL *resultants, unsigned int *infeasible)
     * }
     */
    public static int SCIPintervalPropagateWeightedSum(double infinity, int noperands, MemorySegment operands, MemorySegment weights, double constant, MemorySegment rhs, MemorySegment resultants, MemorySegment infeasible) {
        var mh$ = SCIPintervalPropagateWeightedSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPintervalPropagateWeightedSum", infinity, noperands, operands, weights, constant, rhs, resultants, infeasible);
            }
            return (int)mh$.invokeExact(infinity, noperands, operands, weights, constant, rhs, resultants, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_EXPRCURV_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRCURV_UNKNOWN = 0
     * }
     */
    public static int SCIP_EXPRCURV_UNKNOWN() {
        return SCIP_EXPRCURV_UNKNOWN;
    }
    private static final int SCIP_EXPRCURV_CONVEX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRCURV_CONVEX = 1
     * }
     */
    public static int SCIP_EXPRCURV_CONVEX() {
        return SCIP_EXPRCURV_CONVEX;
    }
    private static final int SCIP_EXPRCURV_CONCAVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRCURV_CONCAVE = 2
     * }
     */
    public static int SCIP_EXPRCURV_CONCAVE() {
        return SCIP_EXPRCURV_CONCAVE;
    }
    private static final int SCIP_EXPRCURV_LINEAR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRCURV_LINEAR = 3
     * }
     */
    public static int SCIP_EXPRCURV_LINEAR() {
        return SCIP_EXPRCURV_LINEAR;
    }
    private static final int SCIP_MONOTONE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_MONOTONE_UNKNOWN = 0
     * }
     */
    public static int SCIP_MONOTONE_UNKNOWN() {
        return SCIP_MONOTONE_UNKNOWN;
    }
    private static final int SCIP_MONOTONE_INC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_MONOTONE_INC = 1
     * }
     */
    public static int SCIP_MONOTONE_INC() {
        return SCIP_MONOTONE_INC;
    }
    private static final int SCIP_MONOTONE_DEC = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_MONOTONE_DEC = 2
     * }
     */
    public static int SCIP_MONOTONE_DEC() {
        return SCIP_MONOTONE_DEC;
    }
    private static final int SCIP_MONOTONE_CONST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_MONOTONE_CONST = 3
     * }
     */
    public static int SCIP_MONOTONE_CONST() {
        return SCIP_MONOTONE_CONST;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_EXPRITER_STAGE
     * }
     */
    public static final OfInt SCIP_EXPRITER_STAGE = scip_h.C_INT;
    private static final int SCIP_EXPRITER_RTOPOLOGIC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRITER_RTOPOLOGIC = 0
     * }
     */
    public static int SCIP_EXPRITER_RTOPOLOGIC() {
        return SCIP_EXPRITER_RTOPOLOGIC;
    }
    private static final int SCIP_EXPRITER_BFS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRITER_BFS = 1
     * }
     */
    public static int SCIP_EXPRITER_BFS() {
        return SCIP_EXPRITER_BFS;
    }
    private static final int SCIP_EXPRITER_DFS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.SCIP_EXPRITER_DFS = 2
     * }
     */
    public static int SCIP_EXPRITER_DFS() {
        return SCIP_EXPRITER_DFS;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_EXPRPRINT_WHAT
     * }
     */
    public static final OfInt SCIP_EXPRPRINT_WHAT = scip_h.C_INT;
    private static final int SCIP_BRANCHDIR_DOWNWARDS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BranchDir.SCIP_BRANCHDIR_DOWNWARDS = 0
     * }
     */
    public static int SCIP_BRANCHDIR_DOWNWARDS() {
        return SCIP_BRANCHDIR_DOWNWARDS;
    }
    private static final int SCIP_BRANCHDIR_UPWARDS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BranchDir.SCIP_BRANCHDIR_UPWARDS = 1
     * }
     */
    public static int SCIP_BRANCHDIR_UPWARDS() {
        return SCIP_BRANCHDIR_UPWARDS;
    }
    private static final int SCIP_BRANCHDIR_FIXED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BranchDir.SCIP_BRANCHDIR_FIXED = 2
     * }
     */
    public static int SCIP_BRANCHDIR_FIXED() {
        return SCIP_BRANCHDIR_FIXED;
    }
    private static final int SCIP_BRANCHDIR_AUTO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BranchDir.SCIP_BRANCHDIR_AUTO = 3
     * }
     */
    public static int SCIP_BRANCHDIR_AUTO() {
        return SCIP_BRANCHDIR_AUTO;
    }
    private static final int SCIP_REOPTTYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_NONE = 0
     * }
     */
    public static int SCIP_REOPTTYPE_NONE() {
        return SCIP_REOPTTYPE_NONE;
    }
    private static final int SCIP_REOPTTYPE_TRANSIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_TRANSIT = 1
     * }
     */
    public static int SCIP_REOPTTYPE_TRANSIT() {
        return SCIP_REOPTTYPE_TRANSIT;
    }
    private static final int SCIP_REOPTTYPE_INFSUBTREE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_INFSUBTREE = 2
     * }
     */
    public static int SCIP_REOPTTYPE_INFSUBTREE() {
        return SCIP_REOPTTYPE_INFSUBTREE;
    }
    private static final int SCIP_REOPTTYPE_STRBRANCHED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_STRBRANCHED = 3
     * }
     */
    public static int SCIP_REOPTTYPE_STRBRANCHED() {
        return SCIP_REOPTTYPE_STRBRANCHED;
    }
    private static final int SCIP_REOPTTYPE_LOGICORNODE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_LOGICORNODE = 4
     * }
     */
    public static int SCIP_REOPTTYPE_LOGICORNODE() {
        return SCIP_REOPTTYPE_LOGICORNODE;
    }
    private static final int SCIP_REOPTTYPE_LEAF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_LEAF = 5
     * }
     */
    public static int SCIP_REOPTTYPE_LEAF() {
        return SCIP_REOPTTYPE_LEAF;
    }
    private static final int SCIP_REOPTTYPE_PRUNED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_PRUNED = 6
     * }
     */
    public static int SCIP_REOPTTYPE_PRUNED() {
        return SCIP_REOPTTYPE_PRUNED;
    }
    private static final int SCIP_REOPTTYPE_FEASIBLE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ReoptType.SCIP_REOPTTYPE_FEASIBLE = 7
     * }
     */
    public static int SCIP_REOPTTYPE_FEASIBLE() {
        return SCIP_REOPTTYPE_FEASIBLE;
    }
    private static final int REOPT_CONSTYPE_INFSUBTREE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Reopt_ConsType.REOPT_CONSTYPE_INFSUBTREE = 0
     * }
     */
    public static int REOPT_CONSTYPE_INFSUBTREE() {
        return REOPT_CONSTYPE_INFSUBTREE;
    }
    private static final int REOPT_CONSTYPE_DUALREDS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Reopt_ConsType.REOPT_CONSTYPE_DUALREDS = 1
     * }
     */
    public static int REOPT_CONSTYPE_DUALREDS() {
        return REOPT_CONSTYPE_DUALREDS;
    }
    private static final int REOPT_CONSTYPE_CUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Reopt_ConsType.REOPT_CONSTYPE_CUT = 2
     * }
     */
    public static int REOPT_CONSTYPE_CUT() {
        return REOPT_CONSTYPE_CUT;
    }
    private static final int REOPT_CONSTYPE_UNKNOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Reopt_ConsType.REOPT_CONSTYPE_UNKNOWN = 3
     * }
     */
    public static int REOPT_CONSTYPE_UNKNOWN() {
        return REOPT_CONSTYPE_UNKNOWN;
    }
    private static final int SCIP_NLPPARAM_FASTFAIL_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpParam_FastFail.SCIP_NLPPARAM_FASTFAIL_OFF = 0
     * }
     */
    public static int SCIP_NLPPARAM_FASTFAIL_OFF() {
        return SCIP_NLPPARAM_FASTFAIL_OFF;
    }
    private static final int SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpParam_FastFail.SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE = 1
     * }
     */
    public static int SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE() {
        return SCIP_NLPPARAM_FASTFAIL_CONSERVATIVE;
    }
    private static final int SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpParam_FastFail.SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE = 2
     * }
     */
    public static int SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE() {
        return SCIP_NLPPARAM_FASTFAIL_AGGRESSIVE;
    }
    private static final int SCIP_NLPSOLSTAT_GLOBOPT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_GLOBOPT = 0
     * }
     */
    public static int SCIP_NLPSOLSTAT_GLOBOPT() {
        return SCIP_NLPSOLSTAT_GLOBOPT;
    }
    private static final int SCIP_NLPSOLSTAT_LOCOPT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_LOCOPT = 1
     * }
     */
    public static int SCIP_NLPSOLSTAT_LOCOPT() {
        return SCIP_NLPSOLSTAT_LOCOPT;
    }
    private static final int SCIP_NLPSOLSTAT_FEASIBLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_FEASIBLE = 2
     * }
     */
    public static int SCIP_NLPSOLSTAT_FEASIBLE() {
        return SCIP_NLPSOLSTAT_FEASIBLE;
    }
    private static final int SCIP_NLPSOLSTAT_LOCINFEASIBLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_LOCINFEASIBLE = 3
     * }
     */
    public static int SCIP_NLPSOLSTAT_LOCINFEASIBLE() {
        return SCIP_NLPSOLSTAT_LOCINFEASIBLE;
    }
    private static final int SCIP_NLPSOLSTAT_GLOBINFEASIBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_GLOBINFEASIBLE = 4
     * }
     */
    public static int SCIP_NLPSOLSTAT_GLOBINFEASIBLE() {
        return SCIP_NLPSOLSTAT_GLOBINFEASIBLE;
    }
    private static final int SCIP_NLPSOLSTAT_UNBOUNDED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_UNBOUNDED = 5
     * }
     */
    public static int SCIP_NLPSOLSTAT_UNBOUNDED() {
        return SCIP_NLPSOLSTAT_UNBOUNDED;
    }
    private static final int SCIP_NLPSOLSTAT_UNKNOWN = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpSolStat.SCIP_NLPSOLSTAT_UNKNOWN = 6
     * }
     */
    public static int SCIP_NLPSOLSTAT_UNKNOWN() {
        return SCIP_NLPSOLSTAT_UNKNOWN;
    }
    private static final int SCIP_NLPTERMSTAT_OKAY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_OKAY = 0
     * }
     */
    public static int SCIP_NLPTERMSTAT_OKAY() {
        return SCIP_NLPTERMSTAT_OKAY;
    }
    private static final int SCIP_NLPTERMSTAT_TIMELIMIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_TIMELIMIT = 1
     * }
     */
    public static int SCIP_NLPTERMSTAT_TIMELIMIT() {
        return SCIP_NLPTERMSTAT_TIMELIMIT;
    }
    private static final int SCIP_NLPTERMSTAT_ITERLIMIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_ITERLIMIT = 2
     * }
     */
    public static int SCIP_NLPTERMSTAT_ITERLIMIT() {
        return SCIP_NLPTERMSTAT_ITERLIMIT;
    }
    private static final int SCIP_NLPTERMSTAT_LOBJLIMIT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_LOBJLIMIT = 3
     * }
     */
    public static int SCIP_NLPTERMSTAT_LOBJLIMIT() {
        return SCIP_NLPTERMSTAT_LOBJLIMIT;
    }
    private static final int SCIP_NLPTERMSTAT_INTERRUPT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_INTERRUPT = 4
     * }
     */
    public static int SCIP_NLPTERMSTAT_INTERRUPT() {
        return SCIP_NLPTERMSTAT_INTERRUPT;
    }
    private static final int SCIP_NLPTERMSTAT_NUMERICERROR = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_NUMERICERROR = 5
     * }
     */
    public static int SCIP_NLPTERMSTAT_NUMERICERROR() {
        return SCIP_NLPTERMSTAT_NUMERICERROR;
    }
    private static final int SCIP_NLPTERMSTAT_EVALERROR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_EVALERROR = 6
     * }
     */
    public static int SCIP_NLPTERMSTAT_EVALERROR() {
        return SCIP_NLPTERMSTAT_EVALERROR;
    }
    private static final int SCIP_NLPTERMSTAT_OUTOFMEMORY = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_OUTOFMEMORY = 7
     * }
     */
    public static int SCIP_NLPTERMSTAT_OUTOFMEMORY() {
        return SCIP_NLPTERMSTAT_OUTOFMEMORY;
    }
    private static final int SCIP_NLPTERMSTAT_LICENSEERROR = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_LICENSEERROR = 8
     * }
     */
    public static int SCIP_NLPTERMSTAT_LICENSEERROR() {
        return SCIP_NLPTERMSTAT_LICENSEERROR;
    }
    private static final int SCIP_NLPTERMSTAT_OTHER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_NlpTermStat.SCIP_NLPTERMSTAT_OTHER = 9
     * }
     */
    public static int SCIP_NLPTERMSTAT_OTHER() {
        return SCIP_NLPTERMSTAT_OTHER;
    }
    private static final int SCIP_STATUS_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_UNKNOWN = 0
     * }
     */
    public static int SCIP_STATUS_UNKNOWN() {
        return SCIP_STATUS_UNKNOWN;
    }
    private static final int SCIP_STATUS_USERINTERRUPT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_USERINTERRUPT = 1
     * }
     */
    public static int SCIP_STATUS_USERINTERRUPT() {
        return SCIP_STATUS_USERINTERRUPT;
    }
    private static final int SCIP_STATUS_NODELIMIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_NODELIMIT = 2
     * }
     */
    public static int SCIP_STATUS_NODELIMIT() {
        return SCIP_STATUS_NODELIMIT;
    }
    private static final int SCIP_STATUS_TOTALNODELIMIT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_TOTALNODELIMIT = 3
     * }
     */
    public static int SCIP_STATUS_TOTALNODELIMIT() {
        return SCIP_STATUS_TOTALNODELIMIT;
    }
    private static final int SCIP_STATUS_STALLNODELIMIT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_STALLNODELIMIT = 4
     * }
     */
    public static int SCIP_STATUS_STALLNODELIMIT() {
        return SCIP_STATUS_STALLNODELIMIT;
    }
    private static final int SCIP_STATUS_TIMELIMIT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_TIMELIMIT = 5
     * }
     */
    public static int SCIP_STATUS_TIMELIMIT() {
        return SCIP_STATUS_TIMELIMIT;
    }
    private static final int SCIP_STATUS_MEMLIMIT = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_MEMLIMIT = 6
     * }
     */
    public static int SCIP_STATUS_MEMLIMIT() {
        return SCIP_STATUS_MEMLIMIT;
    }
    private static final int SCIP_STATUS_GAPLIMIT = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_GAPLIMIT = 7
     * }
     */
    public static int SCIP_STATUS_GAPLIMIT() {
        return SCIP_STATUS_GAPLIMIT;
    }
    private static final int SCIP_STATUS_PRIMALLIMIT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_PRIMALLIMIT = 16
     * }
     */
    public static int SCIP_STATUS_PRIMALLIMIT() {
        return SCIP_STATUS_PRIMALLIMIT;
    }
    private static final int SCIP_STATUS_DUALLIMIT = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_DUALLIMIT = 17
     * }
     */
    public static int SCIP_STATUS_DUALLIMIT() {
        return SCIP_STATUS_DUALLIMIT;
    }
    private static final int SCIP_STATUS_SOLLIMIT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_SOLLIMIT = 8
     * }
     */
    public static int SCIP_STATUS_SOLLIMIT() {
        return SCIP_STATUS_SOLLIMIT;
    }
    private static final int SCIP_STATUS_BESTSOLLIMIT = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_BESTSOLLIMIT = 9
     * }
     */
    public static int SCIP_STATUS_BESTSOLLIMIT() {
        return SCIP_STATUS_BESTSOLLIMIT;
    }
    private static final int SCIP_STATUS_RESTARTLIMIT = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_RESTARTLIMIT = 10
     * }
     */
    public static int SCIP_STATUS_RESTARTLIMIT() {
        return SCIP_STATUS_RESTARTLIMIT;
    }
    private static final int SCIP_STATUS_OPTIMAL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_OPTIMAL = 11
     * }
     */
    public static int SCIP_STATUS_OPTIMAL() {
        return SCIP_STATUS_OPTIMAL;
    }
    private static final int SCIP_STATUS_INFEASIBLE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_INFEASIBLE = 12
     * }
     */
    public static int SCIP_STATUS_INFEASIBLE() {
        return SCIP_STATUS_INFEASIBLE;
    }
    private static final int SCIP_STATUS_UNBOUNDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_UNBOUNDED = 13
     * }
     */
    public static int SCIP_STATUS_UNBOUNDED() {
        return SCIP_STATUS_UNBOUNDED;
    }
    private static final int SCIP_STATUS_INFORUNBD = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_INFORUNBD = 14
     * }
     */
    public static int SCIP_STATUS_INFORUNBD() {
        return SCIP_STATUS_INFORUNBD;
    }
    private static final int SCIP_STATUS_TERMINATE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Status.SCIP_STATUS_TERMINATE = 15
     * }
     */
    public static int SCIP_STATUS_TERMINATE() {
        return SCIP_STATUS_TERMINATE;
    }
    private static final int SCIP_PARA_OPPORTUNISTIC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Parallelmode.SCIP_PARA_OPPORTUNISTIC = 0
     * }
     */
    public static int SCIP_PARA_OPPORTUNISTIC() {
        return SCIP_PARA_OPPORTUNISTIC;
    }
    private static final int SCIP_PARA_DETERMINISTIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_Parallelmode.SCIP_PARA_DETERMINISTIC = 1
     * }
     */
    public static int SCIP_PARA_DETERMINISTIC() {
        return SCIP_PARA_DETERMINISTIC;
    }
    private static final int SCIP_BENDERSENFOTYPE_LP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersEnfoType.SCIP_BENDERSENFOTYPE_LP = 1
     * }
     */
    public static int SCIP_BENDERSENFOTYPE_LP() {
        return SCIP_BENDERSENFOTYPE_LP;
    }
    private static final int SCIP_BENDERSENFOTYPE_RELAX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersEnfoType.SCIP_BENDERSENFOTYPE_RELAX = 2
     * }
     */
    public static int SCIP_BENDERSENFOTYPE_RELAX() {
        return SCIP_BENDERSENFOTYPE_RELAX;
    }
    private static final int SCIP_BENDERSENFOTYPE_PSEUDO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersEnfoType.SCIP_BENDERSENFOTYPE_PSEUDO = 3
     * }
     */
    public static int SCIP_BENDERSENFOTYPE_PSEUDO() {
        return SCIP_BENDERSENFOTYPE_PSEUDO;
    }
    private static final int SCIP_BENDERSENFOTYPE_CHECK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersEnfoType.SCIP_BENDERSENFOTYPE_CHECK = 4
     * }
     */
    public static int SCIP_BENDERSENFOTYPE_CHECK() {
        return SCIP_BENDERSENFOTYPE_CHECK;
    }
    private static final int SCIP_BENDERSSOLVELOOP_CONVEX = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSolveLoop.SCIP_BENDERSSOLVELOOP_CONVEX = 0
     * }
     */
    public static int SCIP_BENDERSSOLVELOOP_CONVEX() {
        return SCIP_BENDERSSOLVELOOP_CONVEX;
    }
    private static final int SCIP_BENDERSSOLVELOOP_CIP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSolveLoop.SCIP_BENDERSSOLVELOOP_CIP = 1
     * }
     */
    public static int SCIP_BENDERSSOLVELOOP_CIP() {
        return SCIP_BENDERSSOLVELOOP_CIP;
    }
    private static final int SCIP_BENDERSSOLVELOOP_USERCONVEX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSolveLoop.SCIP_BENDERSSOLVELOOP_USERCONVEX = 2
     * }
     */
    public static int SCIP_BENDERSSOLVELOOP_USERCONVEX() {
        return SCIP_BENDERSSOLVELOOP_USERCONVEX;
    }
    private static final int SCIP_BENDERSSOLVELOOP_USERCIP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSolveLoop.SCIP_BENDERSSOLVELOOP_USERCIP = 3
     * }
     */
    public static int SCIP_BENDERSSOLVELOOP_USERCIP() {
        return SCIP_BENDERSSOLVELOOP_USERCIP;
    }
    private static final int SCIP_BENDERSSUBSTATUS_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubStatus.SCIP_BENDERSSUBSTATUS_UNKNOWN = 0
     * }
     */
    public static int SCIP_BENDERSSUBSTATUS_UNKNOWN() {
        return SCIP_BENDERSSUBSTATUS_UNKNOWN;
    }
    private static final int SCIP_BENDERSSUBSTATUS_OPTIMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubStatus.SCIP_BENDERSSUBSTATUS_OPTIMAL = 1
     * }
     */
    public static int SCIP_BENDERSSUBSTATUS_OPTIMAL() {
        return SCIP_BENDERSSUBSTATUS_OPTIMAL;
    }
    private static final int SCIP_BENDERSSUBSTATUS_AUXVIOL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubStatus.SCIP_BENDERSSUBSTATUS_AUXVIOL = 2
     * }
     */
    public static int SCIP_BENDERSSUBSTATUS_AUXVIOL() {
        return SCIP_BENDERSSUBSTATUS_AUXVIOL;
    }
    private static final int SCIP_BENDERSSUBSTATUS_INFEAS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubStatus.SCIP_BENDERSSUBSTATUS_INFEAS = 3
     * }
     */
    public static int SCIP_BENDERSSUBSTATUS_INFEAS() {
        return SCIP_BENDERSSUBSTATUS_INFEAS;
    }
    private static final int SCIP_BENDERSSUBTYPE_CONVEXCONT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubType.SCIP_BENDERSSUBTYPE_CONVEXCONT = 0
     * }
     */
    public static int SCIP_BENDERSSUBTYPE_CONVEXCONT() {
        return SCIP_BENDERSSUBTYPE_CONVEXCONT;
    }
    private static final int SCIP_BENDERSSUBTYPE_CONVEXDIS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubType.SCIP_BENDERSSUBTYPE_CONVEXDIS = 1
     * }
     */
    public static int SCIP_BENDERSSUBTYPE_CONVEXDIS() {
        return SCIP_BENDERSSUBTYPE_CONVEXDIS;
    }
    private static final int SCIP_BENDERSSUBTYPE_NONCONVEXCONT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubType.SCIP_BENDERSSUBTYPE_NONCONVEXCONT = 2
     * }
     */
    public static int SCIP_BENDERSSUBTYPE_NONCONVEXCONT() {
        return SCIP_BENDERSSUBTYPE_NONCONVEXCONT;
    }
    private static final int SCIP_BENDERSSUBTYPE_NONCONVEXDIS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubType.SCIP_BENDERSSUBTYPE_NONCONVEXDIS = 3
     * }
     */
    public static int SCIP_BENDERSSUBTYPE_NONCONVEXDIS() {
        return SCIP_BENDERSSUBTYPE_NONCONVEXDIS;
    }
    private static final int SCIP_BENDERSSUBTYPE_UNKNOWN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_BendersSubType.SCIP_BENDERSSUBTYPE_UNKNOWN = 4
     * }
     */
    public static int SCIP_BENDERSSUBTYPE_UNKNOWN() {
        return SCIP_BENDERSSUBTYPE_UNKNOWN;
    }

    private static class SCIPcreateBanditEpsgreedy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBanditEpsgreedy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditEpsgreedy(SCIP *scip, SCIP_BANDIT **epsgreedy, double *priorities, double eps, unsigned int usemodification, unsigned int preferrecent, double decayfactor, int avglim, int nactions, unsigned int initseed)
     * }
     */
    public static FunctionDescriptor SCIPcreateBanditEpsgreedy$descriptor() {
        return SCIPcreateBanditEpsgreedy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditEpsgreedy(SCIP *scip, SCIP_BANDIT **epsgreedy, double *priorities, double eps, unsigned int usemodification, unsigned int preferrecent, double decayfactor, int avglim, int nactions, unsigned int initseed)
     * }
     */
    public static MethodHandle SCIPcreateBanditEpsgreedy$handle() {
        return SCIPcreateBanditEpsgreedy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditEpsgreedy(SCIP *scip, SCIP_BANDIT **epsgreedy, double *priorities, double eps, unsigned int usemodification, unsigned int preferrecent, double decayfactor, int avglim, int nactions, unsigned int initseed)
     * }
     */
    public static MemorySegment SCIPcreateBanditEpsgreedy$address() {
        return SCIPcreateBanditEpsgreedy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditEpsgreedy(SCIP *scip, SCIP_BANDIT **epsgreedy, double *priorities, double eps, unsigned int usemodification, unsigned int preferrecent, double decayfactor, int avglim, int nactions, unsigned int initseed)
     * }
     */
    public static int SCIPcreateBanditEpsgreedy(MemorySegment scip, MemorySegment epsgreedy, MemorySegment priorities, double eps, int usemodification, int preferrecent, double decayfactor, int avglim, int nactions, int initseed) {
        var mh$ = SCIPcreateBanditEpsgreedy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBanditEpsgreedy", scip, epsgreedy, priorities, eps, usemodification, preferrecent, decayfactor, avglim, nactions, initseed);
            }
            return (int)mh$.invokeExact(scip, epsgreedy, priorities, eps, usemodification, preferrecent, decayfactor, avglim, nactions, initseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetWeightsEpsgreedy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetWeightsEpsgreedy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsEpsgreedy(SCIP_BANDIT *epsgreedy)
     * }
     */
    public static FunctionDescriptor SCIPgetWeightsEpsgreedy$descriptor() {
        return SCIPgetWeightsEpsgreedy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsEpsgreedy(SCIP_BANDIT *epsgreedy)
     * }
     */
    public static MethodHandle SCIPgetWeightsEpsgreedy$handle() {
        return SCIPgetWeightsEpsgreedy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsEpsgreedy(SCIP_BANDIT *epsgreedy)
     * }
     */
    public static MemorySegment SCIPgetWeightsEpsgreedy$address() {
        return SCIPgetWeightsEpsgreedy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetWeightsEpsgreedy(SCIP_BANDIT *epsgreedy)
     * }
     */
    public static MemorySegment SCIPgetWeightsEpsgreedy(MemorySegment epsgreedy) {
        var mh$ = SCIPgetWeightsEpsgreedy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetWeightsEpsgreedy", epsgreedy);
            }
            return (MemorySegment)mh$.invokeExact(epsgreedy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEpsilonEpsgreedy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEpsilonEpsgreedy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetEpsilonEpsgreedy(SCIP_BANDIT *epsgreedy, double eps)
     * }
     */
    public static FunctionDescriptor SCIPsetEpsilonEpsgreedy$descriptor() {
        return SCIPsetEpsilonEpsgreedy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetEpsilonEpsgreedy(SCIP_BANDIT *epsgreedy, double eps)
     * }
     */
    public static MethodHandle SCIPsetEpsilonEpsgreedy$handle() {
        return SCIPsetEpsilonEpsgreedy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetEpsilonEpsgreedy(SCIP_BANDIT *epsgreedy, double eps)
     * }
     */
    public static MemorySegment SCIPsetEpsilonEpsgreedy$address() {
        return SCIPsetEpsilonEpsgreedy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetEpsilonEpsgreedy(SCIP_BANDIT *epsgreedy, double eps)
     * }
     */
    public static void SCIPsetEpsilonEpsgreedy(MemorySegment epsgreedy, double eps) {
        var mh$ = SCIPsetEpsilonEpsgreedy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEpsilonEpsgreedy", epsgreedy, eps);
            }
            mh$.invokeExact(epsgreedy, eps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateBanditExp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBanditExp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3(SCIP *scip, SCIP_BANDIT **exp3, double *priorities, double gammaparam, double beta, int nactions, unsigned int initseed)
     * }
     */
    public static FunctionDescriptor SCIPcreateBanditExp3$descriptor() {
        return SCIPcreateBanditExp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3(SCIP *scip, SCIP_BANDIT **exp3, double *priorities, double gammaparam, double beta, int nactions, unsigned int initseed)
     * }
     */
    public static MethodHandle SCIPcreateBanditExp3$handle() {
        return SCIPcreateBanditExp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3(SCIP *scip, SCIP_BANDIT **exp3, double *priorities, double gammaparam, double beta, int nactions, unsigned int initseed)
     * }
     */
    public static MemorySegment SCIPcreateBanditExp3$address() {
        return SCIPcreateBanditExp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3(SCIP *scip, SCIP_BANDIT **exp3, double *priorities, double gammaparam, double beta, int nactions, unsigned int initseed)
     * }
     */
    public static int SCIPcreateBanditExp3(MemorySegment scip, MemorySegment exp3, MemorySegment priorities, double gammaparam, double beta, int nactions, int initseed) {
        var mh$ = SCIPcreateBanditExp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBanditExp3", scip, exp3, priorities, gammaparam, beta, nactions, initseed);
            }
            return (int)mh$.invokeExact(scip, exp3, priorities, gammaparam, beta, nactions, initseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetGammaExp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetGammaExp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetGammaExp3(SCIP_BANDIT *exp3, double gammaparam)
     * }
     */
    public static FunctionDescriptor SCIPsetGammaExp3$descriptor() {
        return SCIPsetGammaExp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetGammaExp3(SCIP_BANDIT *exp3, double gammaparam)
     * }
     */
    public static MethodHandle SCIPsetGammaExp3$handle() {
        return SCIPsetGammaExp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetGammaExp3(SCIP_BANDIT *exp3, double gammaparam)
     * }
     */
    public static MemorySegment SCIPsetGammaExp3$address() {
        return SCIPsetGammaExp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetGammaExp3(SCIP_BANDIT *exp3, double gammaparam)
     * }
     */
    public static void SCIPsetGammaExp3(MemorySegment exp3, double gammaparam) {
        var mh$ = SCIPsetGammaExp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetGammaExp3", exp3, gammaparam);
            }
            mh$.invokeExact(exp3, gammaparam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBetaExp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBetaExp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetBetaExp3(SCIP_BANDIT *exp3, double beta)
     * }
     */
    public static FunctionDescriptor SCIPsetBetaExp3$descriptor() {
        return SCIPsetBetaExp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetBetaExp3(SCIP_BANDIT *exp3, double beta)
     * }
     */
    public static MethodHandle SCIPsetBetaExp3$handle() {
        return SCIPsetBetaExp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetBetaExp3(SCIP_BANDIT *exp3, double beta)
     * }
     */
    public static MemorySegment SCIPsetBetaExp3$address() {
        return SCIPsetBetaExp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetBetaExp3(SCIP_BANDIT *exp3, double beta)
     * }
     */
    public static void SCIPsetBetaExp3(MemorySegment exp3, double beta) {
        var mh$ = SCIPsetBetaExp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBetaExp3", exp3, beta);
            }
            mh$.invokeExact(exp3, beta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbabilityExp3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbabilityExp3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3(SCIP_BANDIT *exp3, int action)
     * }
     */
    public static FunctionDescriptor SCIPgetProbabilityExp3$descriptor() {
        return SCIPgetProbabilityExp3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3(SCIP_BANDIT *exp3, int action)
     * }
     */
    public static MethodHandle SCIPgetProbabilityExp3$handle() {
        return SCIPgetProbabilityExp3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3(SCIP_BANDIT *exp3, int action)
     * }
     */
    public static MemorySegment SCIPgetProbabilityExp3$address() {
        return SCIPgetProbabilityExp3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3(SCIP_BANDIT *exp3, int action)
     * }
     */
    public static double SCIPgetProbabilityExp3(MemorySegment exp3, int action) {
        var mh$ = SCIPgetProbabilityExp3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbabilityExp3", exp3, action);
            }
            return (double)mh$.invokeExact(exp3, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateBanditExp3IX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBanditExp3IX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3IX(SCIP *scip, SCIP_BANDIT **exp3ix, double *priorities, int nactions, unsigned int initseed)
     * }
     */
    public static FunctionDescriptor SCIPcreateBanditExp3IX$descriptor() {
        return SCIPcreateBanditExp3IX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3IX(SCIP *scip, SCIP_BANDIT **exp3ix, double *priorities, int nactions, unsigned int initseed)
     * }
     */
    public static MethodHandle SCIPcreateBanditExp3IX$handle() {
        return SCIPcreateBanditExp3IX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3IX(SCIP *scip, SCIP_BANDIT **exp3ix, double *priorities, int nactions, unsigned int initseed)
     * }
     */
    public static MemorySegment SCIPcreateBanditExp3IX$address() {
        return SCIPcreateBanditExp3IX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditExp3IX(SCIP *scip, SCIP_BANDIT **exp3ix, double *priorities, int nactions, unsigned int initseed)
     * }
     */
    public static int SCIPcreateBanditExp3IX(MemorySegment scip, MemorySegment exp3ix, MemorySegment priorities, int nactions, int initseed) {
        var mh$ = SCIPcreateBanditExp3IX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBanditExp3IX", scip, exp3ix, priorities, nactions, initseed);
            }
            return (int)mh$.invokeExact(scip, exp3ix, priorities, nactions, initseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbabilityExp3IX {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbabilityExp3IX");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3IX(SCIP_BANDIT *exp3ix, int action)
     * }
     */
    public static FunctionDescriptor SCIPgetProbabilityExp3IX$descriptor() {
        return SCIPgetProbabilityExp3IX.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3IX(SCIP_BANDIT *exp3ix, int action)
     * }
     */
    public static MethodHandle SCIPgetProbabilityExp3IX$handle() {
        return SCIPgetProbabilityExp3IX.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3IX(SCIP_BANDIT *exp3ix, int action)
     * }
     */
    public static MemorySegment SCIPgetProbabilityExp3IX$address() {
        return SCIPgetProbabilityExp3IX.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetProbabilityExp3IX(SCIP_BANDIT *exp3ix, int action)
     * }
     */
    public static double SCIPgetProbabilityExp3IX(MemorySegment exp3ix, int action) {
        var mh$ = SCIPgetProbabilityExp3IX.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbabilityExp3IX", exp3ix, action);
            }
            return (double)mh$.invokeExact(exp3ix, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateBanditUcb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBanditUcb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditUcb(SCIP *scip, SCIP_BANDIT **ucb, double *priorities, double alpha, int nactions, unsigned int initseed)
     * }
     */
    public static FunctionDescriptor SCIPcreateBanditUcb$descriptor() {
        return SCIPcreateBanditUcb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditUcb(SCIP *scip, SCIP_BANDIT **ucb, double *priorities, double alpha, int nactions, unsigned int initseed)
     * }
     */
    public static MethodHandle SCIPcreateBanditUcb$handle() {
        return SCIPcreateBanditUcb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditUcb(SCIP *scip, SCIP_BANDIT **ucb, double *priorities, double alpha, int nactions, unsigned int initseed)
     * }
     */
    public static MemorySegment SCIPcreateBanditUcb$address() {
        return SCIPcreateBanditUcb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBanditUcb(SCIP *scip, SCIP_BANDIT **ucb, double *priorities, double alpha, int nactions, unsigned int initseed)
     * }
     */
    public static int SCIPcreateBanditUcb(MemorySegment scip, MemorySegment ucb, MemorySegment priorities, double alpha, int nactions, int initseed) {
        var mh$ = SCIPcreateBanditUcb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBanditUcb", scip, ucb, priorities, alpha, nactions, initseed);
            }
            return (int)mh$.invokeExact(scip, ucb, priorities, alpha, nactions, initseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConfidenceBoundUcb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConfidenceBoundUcb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetConfidenceBoundUcb(SCIP_BANDIT *ucb, int action)
     * }
     */
    public static FunctionDescriptor SCIPgetConfidenceBoundUcb$descriptor() {
        return SCIPgetConfidenceBoundUcb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetConfidenceBoundUcb(SCIP_BANDIT *ucb, int action)
     * }
     */
    public static MethodHandle SCIPgetConfidenceBoundUcb$handle() {
        return SCIPgetConfidenceBoundUcb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetConfidenceBoundUcb(SCIP_BANDIT *ucb, int action)
     * }
     */
    public static MemorySegment SCIPgetConfidenceBoundUcb$address() {
        return SCIPgetConfidenceBoundUcb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetConfidenceBoundUcb(SCIP_BANDIT *ucb, int action)
     * }
     */
    public static double SCIPgetConfidenceBoundUcb(MemorySegment ucb, int action) {
        var mh$ = SCIPgetConfidenceBoundUcb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConfidenceBoundUcb", ucb, action);
            }
            return (double)mh$.invokeExact(ucb, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetStartPermutationUcb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetStartPermutationUcb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPgetStartPermutationUcb(SCIP_BANDIT *ucb)
     * }
     */
    public static FunctionDescriptor SCIPgetStartPermutationUcb$descriptor() {
        return SCIPgetStartPermutationUcb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPgetStartPermutationUcb(SCIP_BANDIT *ucb)
     * }
     */
    public static MethodHandle SCIPgetStartPermutationUcb$handle() {
        return SCIPgetStartPermutationUcb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPgetStartPermutationUcb(SCIP_BANDIT *ucb)
     * }
     */
    public static MemorySegment SCIPgetStartPermutationUcb$address() {
        return SCIPgetStartPermutationUcb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPgetStartPermutationUcb(SCIP_BANDIT *ucb)
     * }
     */
    public static MemorySegment SCIPgetStartPermutationUcb(MemorySegment ucb) {
        var mh$ = SCIPgetStartPermutationUcb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetStartPermutationUcb", ucb);
            }
            return (MemorySegment)mh$.invokeExact(ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbanditSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbanditSelect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditSelect(SCIP_BANDIT *bandit, int *action)
     * }
     */
    public static FunctionDescriptor SCIPbanditSelect$descriptor() {
        return SCIPbanditSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditSelect(SCIP_BANDIT *bandit, int *action)
     * }
     */
    public static MethodHandle SCIPbanditSelect$handle() {
        return SCIPbanditSelect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditSelect(SCIP_BANDIT *bandit, int *action)
     * }
     */
    public static MemorySegment SCIPbanditSelect$address() {
        return SCIPbanditSelect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditSelect(SCIP_BANDIT *bandit, int *action)
     * }
     */
    public static int SCIPbanditSelect(MemorySegment bandit, MemorySegment action) {
        var mh$ = SCIPbanditSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbanditSelect", bandit, action);
            }
            return (int)mh$.invokeExact(bandit, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbanditUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbanditUpdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditUpdate(SCIP_BANDIT *bandit, int action, double score)
     * }
     */
    public static FunctionDescriptor SCIPbanditUpdate$descriptor() {
        return SCIPbanditUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditUpdate(SCIP_BANDIT *bandit, int action, double score)
     * }
     */
    public static MethodHandle SCIPbanditUpdate$handle() {
        return SCIPbanditUpdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditUpdate(SCIP_BANDIT *bandit, int action, double score)
     * }
     */
    public static MemorySegment SCIPbanditUpdate$address() {
        return SCIPbanditUpdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbanditUpdate(SCIP_BANDIT *bandit, int action, double score)
     * }
     */
    public static int SCIPbanditUpdate(MemorySegment bandit, int action, double score) {
        var mh$ = SCIPbanditUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbanditUpdate", bandit, action, score);
            }
            return (int)mh$.invokeExact(bandit, action, score);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbanditvtableGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbanditvtableGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbanditvtableGetName(SCIP_BANDITVTABLE *banditvtable)
     * }
     */
    public static FunctionDescriptor SCIPbanditvtableGetName$descriptor() {
        return SCIPbanditvtableGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbanditvtableGetName(SCIP_BANDITVTABLE *banditvtable)
     * }
     */
    public static MethodHandle SCIPbanditvtableGetName$handle() {
        return SCIPbanditvtableGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbanditvtableGetName(SCIP_BANDITVTABLE *banditvtable)
     * }
     */
    public static MemorySegment SCIPbanditvtableGetName$address() {
        return SCIPbanditvtableGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbanditvtableGetName(SCIP_BANDITVTABLE *banditvtable)
     * }
     */
    public static MemorySegment SCIPbanditvtableGetName(MemorySegment banditvtable) {
        var mh$ = SCIPbanditvtableGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbanditvtableGetName", banditvtable);
            }
            return (MemorySegment)mh$.invokeExact(banditvtable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbanditGetRandnumgen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbanditGetRandnumgen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPbanditGetRandnumgen(SCIP_BANDIT *bandit)
     * }
     */
    public static FunctionDescriptor SCIPbanditGetRandnumgen$descriptor() {
        return SCIPbanditGetRandnumgen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPbanditGetRandnumgen(SCIP_BANDIT *bandit)
     * }
     */
    public static MethodHandle SCIPbanditGetRandnumgen$handle() {
        return SCIPbanditGetRandnumgen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPbanditGetRandnumgen(SCIP_BANDIT *bandit)
     * }
     */
    public static MemorySegment SCIPbanditGetRandnumgen$address() {
        return SCIPbanditGetRandnumgen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPbanditGetRandnumgen(SCIP_BANDIT *bandit)
     * }
     */
    public static MemorySegment SCIPbanditGetRandnumgen(MemorySegment bandit) {
        var mh$ = SCIPbanditGetRandnumgen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbanditGetRandnumgen", bandit);
            }
            return (MemorySegment)mh$.invokeExact(bandit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbanditGetNActions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbanditGetNActions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbanditGetNActions(SCIP_BANDIT *bandit)
     * }
     */
    public static FunctionDescriptor SCIPbanditGetNActions$descriptor() {
        return SCIPbanditGetNActions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbanditGetNActions(SCIP_BANDIT *bandit)
     * }
     */
    public static MethodHandle SCIPbanditGetNActions$handle() {
        return SCIPbanditGetNActions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbanditGetNActions(SCIP_BANDIT *bandit)
     * }
     */
    public static MemorySegment SCIPbanditGetNActions$address() {
        return SCIPbanditGetNActions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbanditGetNActions(SCIP_BANDIT *bandit)
     * }
     */
    public static int SCIPbanditGetNActions(MemorySegment bandit) {
        var mh$ = SCIPbanditGetNActions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbanditGetNActions", bandit);
            }
            return (int)mh$.invokeExact(bandit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbendersComp$descriptor() {
        return SCIPbendersComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbendersComp$handle() {
        return SCIPbendersComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbendersComp$address() {
        return SCIPbendersComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbendersComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbendersComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbendersCompName$descriptor() {
        return SCIPbendersCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbendersCompName$handle() {
        return SCIPbendersCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbendersCompName$address() {
        return SCIPbendersCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbendersCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbendersCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERSDATA *SCIPbendersGetData(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetData$descriptor() {
        return SCIPbendersGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERSDATA *SCIPbendersGetData(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetData$handle() {
        return SCIPbendersGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERSDATA *SCIPbendersGetData(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetData$address() {
        return SCIPbendersGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERSDATA *SCIPbendersGetData(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetData(MemorySegment benders) {
        var mh$ = SCIPbendersGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetData", benders);
            }
            return (MemorySegment)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetData(SCIP_BENDERS *benders, SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetData$descriptor() {
        return SCIPbendersSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetData(SCIP_BENDERS *benders, SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MethodHandle SCIPbendersSetData$handle() {
        return SCIPbendersSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetData(SCIP_BENDERS *benders, SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MemorySegment SCIPbendersSetData$address() {
        return SCIPbendersSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetData(SCIP_BENDERS *benders, SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static void SCIPbendersSetData(MemorySegment benders, MemorySegment bendersdata) {
        var mh$ = SCIPbendersSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetData", benders, bendersdata);
            }
            mh$.invokeExact(benders, bendersdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetName(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetName$descriptor() {
        return SCIPbendersGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetName(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetName$handle() {
        return SCIPbendersGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetName(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetName$address() {
        return SCIPbendersGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbendersGetName(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetName(MemorySegment benders) {
        var mh$ = SCIPbendersGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetName", benders);
            }
            return (MemorySegment)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetDesc(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetDesc$descriptor() {
        return SCIPbendersGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetDesc(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetDesc$handle() {
        return SCIPbendersGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbendersGetDesc(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetDesc$address() {
        return SCIPbendersGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbendersGetDesc(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetDesc(MemorySegment benders) {
        var mh$ = SCIPbendersGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetDesc", benders);
            }
            return (MemorySegment)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetPriority(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetPriority$descriptor() {
        return SCIPbendersGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetPriority(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetPriority$handle() {
        return SCIPbendersGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetPriority(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetPriority$address() {
        return SCIPbendersGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetPriority(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetPriority(MemorySegment benders) {
        var mh$ = SCIPbendersGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetPriority", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNSubproblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNSubproblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNSubproblems$descriptor() {
        return SCIPbendersGetNSubproblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNSubproblems$handle() {
        return SCIPbendersGetNSubproblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNSubproblems$address() {
        return SCIPbendersGetNSubproblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNSubproblems(MemorySegment benders) {
        var mh$ = SCIPbendersGetNSubproblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNSubproblems", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP *SCIPbendersSubproblem(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblem$descriptor() {
        return SCIPbendersSubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP *SCIPbendersSubproblem(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblem$handle() {
        return SCIPbendersSubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP *SCIPbendersSubproblem(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblem$address() {
        return SCIPbendersSubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP *SCIPbendersSubproblem(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblem(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblem", benders, probnumber);
            }
            return (MemorySegment)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCalls(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNCalls$descriptor() {
        return SCIPbendersGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCalls(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNCalls$handle() {
        return SCIPbendersGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCalls(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNCalls$address() {
        return SCIPbendersGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNCalls(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNCalls(MemorySegment benders) {
        var mh$ = SCIPbendersGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNCalls", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNCutsFound$descriptor() {
        return SCIPbendersGetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNCutsFound$handle() {
        return SCIPbendersGetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNCutsFound$address() {
        return SCIPbendersGetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNCutsFound(MemorySegment benders) {
        var mh$ = SCIPbendersGetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNCutsFound", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNStrengthenCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNStrengthenCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNStrengthenCutsFound$descriptor() {
        return SCIPbendersGetNStrengthenCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNStrengthenCutsFound$handle() {
        return SCIPbendersGetNStrengthenCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNStrengthenCutsFound$address() {
        return SCIPbendersGetNStrengthenCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCutsFound(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNStrengthenCutsFound(MemorySegment benders) {
        var mh$ = SCIPbendersGetNStrengthenCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNStrengthenCutsFound", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNStrengthenCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNStrengthenCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCalls(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNStrengthenCalls$descriptor() {
        return SCIPbendersGetNStrengthenCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCalls(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNStrengthenCalls$handle() {
        return SCIPbendersGetNStrengthenCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCalls(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNStrengthenCalls$address() {
        return SCIPbendersGetNStrengthenCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenCalls(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNStrengthenCalls(MemorySegment benders) {
        var mh$ = SCIPbendersGetNStrengthenCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNStrengthenCalls", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNStrengthenFails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNStrengthenFails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenFails(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNStrengthenFails$descriptor() {
        return SCIPbendersGetNStrengthenFails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenFails(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNStrengthenFails$handle() {
        return SCIPbendersGetNStrengthenFails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenFails(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNStrengthenFails$address() {
        return SCIPbendersGetNStrengthenFails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNStrengthenFails(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNStrengthenFails(MemorySegment benders) {
        var mh$ = SCIPbendersGetNStrengthenFails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNStrengthenFails", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbendersGetSetupTime(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetSetupTime$descriptor() {
        return SCIPbendersGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbendersGetSetupTime(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetSetupTime$handle() {
        return SCIPbendersGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbendersGetSetupTime(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetSetupTime$address() {
        return SCIPbendersGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbendersGetSetupTime(SCIP_BENDERS *benders)
     * }
     */
    public static double SCIPbendersGetSetupTime(MemorySegment benders) {
        var mh$ = SCIPbendersGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetSetupTime", benders);
            }
            return (double)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbendersGetTime(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetTime$descriptor() {
        return SCIPbendersGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbendersGetTime(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetTime$handle() {
        return SCIPbendersGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbendersGetTime(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetTime$address() {
        return SCIPbendersGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbendersGetTime(SCIP_BENDERS *benders)
     * }
     */
    public static double SCIPbendersGetTime(MemorySegment benders) {
        var mh$ = SCIPbendersGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetTime", benders);
            }
            return (double)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsInitialized(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersIsInitialized$descriptor() {
        return SCIPbendersIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsInitialized(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersIsInitialized$handle() {
        return SCIPbendersIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsInitialized(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersIsInitialized$address() {
        return SCIPbendersIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsInitialized(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersIsInitialized(MemorySegment benders) {
        var mh$ = SCIPbendersIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersIsInitialized", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsActive(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersIsActive$descriptor() {
        return SCIPbendersIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsActive(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersIsActive$handle() {
        return SCIPbendersIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsActive(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersIsActive$address() {
        return SCIPbendersIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersIsActive(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersIsActive(MemorySegment benders) {
        var mh$ = SCIPbendersIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersIsActive", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersOnlyCheckConvexRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersOnlyCheckConvexRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersOnlyCheckConvexRelax(SCIP_BENDERS *benders, unsigned int subscipsoff)
     * }
     */
    public static FunctionDescriptor SCIPbendersOnlyCheckConvexRelax$descriptor() {
        return SCIPbendersOnlyCheckConvexRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersOnlyCheckConvexRelax(SCIP_BENDERS *benders, unsigned int subscipsoff)
     * }
     */
    public static MethodHandle SCIPbendersOnlyCheckConvexRelax$handle() {
        return SCIPbendersOnlyCheckConvexRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersOnlyCheckConvexRelax(SCIP_BENDERS *benders, unsigned int subscipsoff)
     * }
     */
    public static MemorySegment SCIPbendersOnlyCheckConvexRelax$address() {
        return SCIPbendersOnlyCheckConvexRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersOnlyCheckConvexRelax(SCIP_BENDERS *benders, unsigned int subscipsoff)
     * }
     */
    public static int SCIPbendersOnlyCheckConvexRelax(MemorySegment benders, int subscipsoff) {
        var mh$ = SCIPbendersOnlyCheckConvexRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersOnlyCheckConvexRelax", benders, subscipsoff);
            }
            return (int)mh$.invokeExact(benders, subscipsoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNLPParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_NlpParam.layout(),
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNLPParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPPARAM SCIPbendersGetNLPParam(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNLPParam$descriptor() {
        return SCIPbendersGetNLPParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPPARAM SCIPbendersGetNLPParam(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNLPParam$handle() {
        return SCIPbendersGetNLPParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPPARAM SCIPbendersGetNLPParam(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNLPParam$address() {
        return SCIPbendersGetNLPParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPPARAM SCIPbendersGetNLPParam(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNLPParam(SegmentAllocator allocator, MemorySegment benders) {
        var mh$ = SCIPbendersGetNLPParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNLPParam", allocator, benders);
            }
            return (MemorySegment)mh$.invokeExact(allocator, benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersCutLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersCutLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutLP(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersCutLP$descriptor() {
        return SCIPbendersCutLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutLP(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersCutLP$handle() {
        return SCIPbendersCutLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutLP(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersCutLP$address() {
        return SCIPbendersCutLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutLP(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersCutLP(MemorySegment benders) {
        var mh$ = SCIPbendersCutLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersCutLP", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersCutPseudo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersCutPseudo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutPseudo(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersCutPseudo$descriptor() {
        return SCIPbendersCutPseudo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutPseudo(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersCutPseudo$handle() {
        return SCIPbendersCutPseudo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutPseudo(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersCutPseudo$address() {
        return SCIPbendersCutPseudo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutPseudo(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersCutPseudo(MemorySegment benders) {
        var mh$ = SCIPbendersCutPseudo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersCutPseudo", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersCutRelaxation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersCutRelaxation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutRelaxation(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersCutRelaxation$descriptor() {
        return SCIPbendersCutRelaxation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutRelaxation(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersCutRelaxation$handle() {
        return SCIPbendersCutRelaxation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutRelaxation(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersCutRelaxation$address() {
        return SCIPbendersCutRelaxation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersCutRelaxation(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersCutRelaxation(MemorySegment benders) {
        var mh$ = SCIPbendersCutRelaxation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersCutRelaxation", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersShareAuxVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersShareAuxVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersShareAuxVars(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersShareAuxVars$descriptor() {
        return SCIPbendersShareAuxVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersShareAuxVars(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersShareAuxVars$handle() {
        return SCIPbendersShareAuxVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersShareAuxVars(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersShareAuxVars$address() {
        return SCIPbendersShareAuxVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersShareAuxVars(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersShareAuxVars(MemorySegment benders) {
        var mh$ = SCIPbendersShareAuxVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersShareAuxVars", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemIsSetup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemIsSetup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber, unsigned int issetup)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemIsSetup$descriptor() {
        return SCIPbendersSetSubproblemIsSetup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber, unsigned int issetup)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemIsSetup$handle() {
        return SCIPbendersSetSubproblemIsSetup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber, unsigned int issetup)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemIsSetup$address() {
        return SCIPbendersSetSubproblemIsSetup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber, unsigned int issetup)
     * }
     */
    public static void SCIPbendersSetSubproblemIsSetup(MemorySegment benders, int probnumber, int issetup) {
        var mh$ = SCIPbendersSetSubproblemIsSetup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemIsSetup", benders, probnumber, issetup);
            }
            mh$.invokeExact(benders, probnumber, issetup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblemIsSetup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblemIsSetup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblemIsSetup$descriptor() {
        return SCIPbendersSubproblemIsSetup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblemIsSetup$handle() {
        return SCIPbendersSubproblemIsSetup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblemIsSetup$address() {
        return SCIPbendersSubproblemIsSetup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsSetup(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersSubproblemIsSetup(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblemIsSetup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblemIsSetup", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetAuxiliaryVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetAuxiliaryVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbendersGetAuxiliaryVar(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetAuxiliaryVar$descriptor() {
        return SCIPbendersGetAuxiliaryVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbendersGetAuxiliaryVar(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersGetAuxiliaryVar$handle() {
        return SCIPbendersGetAuxiliaryVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbendersGetAuxiliaryVar(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersGetAuxiliaryVar$address() {
        return SCIPbendersGetAuxiliaryVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbendersGetAuxiliaryVar(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersGetAuxiliaryVar(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersGetAuxiliaryVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetAuxiliaryVar", benders, probnumber);
            }
            return (MemorySegment)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetAuxiliaryVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetAuxiliaryVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPbendersGetAuxiliaryVars(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetAuxiliaryVars$descriptor() {
        return SCIPbendersGetAuxiliaryVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPbendersGetAuxiliaryVars(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetAuxiliaryVars$handle() {
        return SCIPbendersGetAuxiliaryVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPbendersGetAuxiliaryVars(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetAuxiliaryVars$address() {
        return SCIPbendersGetAuxiliaryVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPbendersGetAuxiliaryVars(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetAuxiliaryVars(MemorySegment benders) {
        var mh$ = SCIPbendersGetAuxiliaryVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetAuxiliaryVars", benders);
            }
            return (MemorySegment)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemObjval(SCIP_BENDERS *benders, int probnumber, double objval)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemObjval$descriptor() {
        return SCIPbendersSetSubproblemObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemObjval(SCIP_BENDERS *benders, int probnumber, double objval)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemObjval$handle() {
        return SCIPbendersSetSubproblemObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemObjval(SCIP_BENDERS *benders, int probnumber, double objval)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemObjval$address() {
        return SCIPbendersSetSubproblemObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemObjval(SCIP_BENDERS *benders, int probnumber, double objval)
     * }
     */
    public static void SCIPbendersSetSubproblemObjval(MemorySegment benders, int probnumber, double objval) {
        var mh$ = SCIPbendersSetSubproblemObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemObjval", benders, probnumber, objval);
            }
            mh$.invokeExact(benders, probnumber, objval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetSubproblemObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetSubproblemObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemObjval(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetSubproblemObjval$descriptor() {
        return SCIPbendersGetSubproblemObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemObjval(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersGetSubproblemObjval$handle() {
        return SCIPbendersGetSubproblemObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemObjval(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersGetSubproblemObjval$address() {
        return SCIPbendersGetSubproblemObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemObjval(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static double SCIPbendersGetSubproblemObjval(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersGetSubproblemObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetSubproblemObjval", benders, probnumber);
            }
            return (double)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNStoredCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNStoredCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStoredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNStoredCuts$descriptor() {
        return SCIPbendersGetNStoredCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStoredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNStoredCuts$handle() {
        return SCIPbendersGetNStoredCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNStoredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNStoredCuts$address() {
        return SCIPbendersGetNStoredCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNStoredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNStoredCuts(MemorySegment benders) {
        var mh$ = SCIPbendersGetNStoredCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNStoredCuts", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetStoredCutData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetStoredCutData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetStoredCutData$descriptor() {
        return SCIPbendersGetStoredCutData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars)
     * }
     */
    public static MethodHandle SCIPbendersGetStoredCutData$handle() {
        return SCIPbendersGetStoredCutData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars)
     * }
     */
    public static MemorySegment SCIPbendersGetStoredCutData$address() {
        return SCIPbendersGetStoredCutData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars)
     * }
     */
    public static int SCIPbendersGetStoredCutData(MemorySegment benders, int cutidx, MemorySegment vars, MemorySegment vals, MemorySegment lhs, MemorySegment rhs, MemorySegment nvars) {
        var mh$ = SCIPbendersGetStoredCutData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetStoredCutData", benders, cutidx, vars, vals, lhs, rhs, nvars);
            }
            return (int)mh$.invokeExact(benders, cutidx, vars, vals, lhs, rhs, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetStoredCutOrigData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetStoredCutOrigData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutOrigData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars, int varssize)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetStoredCutOrigData$descriptor() {
        return SCIPbendersGetStoredCutOrigData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutOrigData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars, int varssize)
     * }
     */
    public static MethodHandle SCIPbendersGetStoredCutOrigData$handle() {
        return SCIPbendersGetStoredCutOrigData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutOrigData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars, int varssize)
     * }
     */
    public static MemorySegment SCIPbendersGetStoredCutOrigData$address() {
        return SCIPbendersGetStoredCutOrigData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersGetStoredCutOrigData(SCIP_BENDERS *benders, int cutidx, SCIP_VAR ***vars, double **vals, double *lhs, double *rhs, int *nvars, int varssize)
     * }
     */
    public static int SCIPbendersGetStoredCutOrigData(MemorySegment benders, int cutidx, MemorySegment vars, MemorySegment vals, MemorySegment lhs, MemorySegment rhs, MemorySegment nvars, int varssize) {
        var mh$ = SCIPbendersGetStoredCutOrigData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetStoredCutOrigData", benders, cutidx, vars, vals, lhs, rhs, nvars, varssize);
            }
            return (int)mh$.invokeExact(benders, cutidx, vars, vals, lhs, rhs, nvars, varssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindBenderscut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindBenderscut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT *SCIPfindBenderscut(SCIP_BENDERS *benders, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindBenderscut$descriptor() {
        return SCIPfindBenderscut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT *SCIPfindBenderscut(SCIP_BENDERS *benders, const char *name)
     * }
     */
    public static MethodHandle SCIPfindBenderscut$handle() {
        return SCIPfindBenderscut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT *SCIPfindBenderscut(SCIP_BENDERS *benders, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBenderscut$address() {
        return SCIPfindBenderscut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERSCUT *SCIPfindBenderscut(SCIP_BENDERS *benders, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBenderscut(MemorySegment benders, MemorySegment name) {
        var mh$ = SCIPfindBenderscut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindBenderscut", benders, name);
            }
            return (MemorySegment)mh$.invokeExact(benders, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetBenderscuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetBenderscuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT **SCIPbendersGetBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetBenderscuts$descriptor() {
        return SCIPbendersGetBenderscuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT **SCIPbendersGetBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetBenderscuts$handle() {
        return SCIPbendersGetBenderscuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUT **SCIPbendersGetBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetBenderscuts$address() {
        return SCIPbendersGetBenderscuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERSCUT **SCIPbendersGetBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetBenderscuts(MemorySegment benders) {
        var mh$ = SCIPbendersGetBenderscuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetBenderscuts", benders);
            }
            return (MemorySegment)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNBenderscuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNBenderscuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNBenderscuts$descriptor() {
        return SCIPbendersGetNBenderscuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNBenderscuts$handle() {
        return SCIPbendersGetNBenderscuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNBenderscuts$address() {
        return SCIPbendersGetNBenderscuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNBenderscuts(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNBenderscuts(MemorySegment benders) {
        var mh$ = SCIPbendersGetNBenderscuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNBenderscuts", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetBenderscutPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetBenderscutPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSetBenderscutPriority(SCIP_BENDERS *benders, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetBenderscutPriority$descriptor() {
        return SCIPbendersSetBenderscutPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSetBenderscutPriority(SCIP_BENDERS *benders, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static MethodHandle SCIPbendersSetBenderscutPriority$handle() {
        return SCIPbendersSetBenderscutPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSetBenderscutPriority(SCIP_BENDERS *benders, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static MemorySegment SCIPbendersSetBenderscutPriority$address() {
        return SCIPbendersSetBenderscutPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSetBenderscutPriority(SCIP_BENDERS *benders, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static int SCIPbendersSetBenderscutPriority(MemorySegment benders, MemorySegment benderscut, int priority) {
        var mh$ = SCIPbendersSetBenderscutPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetBenderscutPriority", benders, benderscut, priority);
            }
            return (int)mh$.invokeExact(benders, benderscut, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSolSlackVarsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSolSlackVarsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolSlackVarsActive(SCIP_BENDERS *benders, unsigned int *activeslack)
     * }
     */
    public static FunctionDescriptor SCIPbendersSolSlackVarsActive$descriptor() {
        return SCIPbendersSolSlackVarsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolSlackVarsActive(SCIP_BENDERS *benders, unsigned int *activeslack)
     * }
     */
    public static MethodHandle SCIPbendersSolSlackVarsActive$handle() {
        return SCIPbendersSolSlackVarsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolSlackVarsActive(SCIP_BENDERS *benders, unsigned int *activeslack)
     * }
     */
    public static MemorySegment SCIPbendersSolSlackVarsActive$address() {
        return SCIPbendersSolSlackVarsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolSlackVarsActive(SCIP_BENDERS *benders, unsigned int *activeslack)
     * }
     */
    public static int SCIPbendersSolSlackVarsActive(MemorySegment benders, MemorySegment activeslack) {
        var mh$ = SCIPbendersSolSlackVarsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSolSlackVarsActive", benders, activeslack);
            }
            return (int)mh$.invokeExact(benders, activeslack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemType(SCIP_BENDERS *benders, int probnumber, SCIP_BENDERSSUBTYPE subprobtype)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemType$descriptor() {
        return SCIPbendersSetSubproblemType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemType(SCIP_BENDERS *benders, int probnumber, SCIP_BENDERSSUBTYPE subprobtype)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemType$handle() {
        return SCIPbendersSetSubproblemType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemType(SCIP_BENDERS *benders, int probnumber, SCIP_BENDERSSUBTYPE subprobtype)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemType$address() {
        return SCIPbendersSetSubproblemType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemType(SCIP_BENDERS *benders, int probnumber, SCIP_BENDERSSUBTYPE subprobtype)
     * }
     */
    public static void SCIPbendersSetSubproblemType(MemorySegment benders, int probnumber, int subprobtype) {
        var mh$ = SCIPbendersSetSubproblemType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemType", benders, probnumber, subprobtype);
            }
            mh$.invokeExact(benders, probnumber, subprobtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetSubproblemType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetSubproblemType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERSSUBTYPE SCIPbendersGetSubproblemType(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetSubproblemType$descriptor() {
        return SCIPbendersGetSubproblemType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERSSUBTYPE SCIPbendersGetSubproblemType(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersGetSubproblemType$handle() {
        return SCIPbendersGetSubproblemType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERSSUBTYPE SCIPbendersGetSubproblemType(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersGetSubproblemType$address() {
        return SCIPbendersGetSubproblemType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERSSUBTYPE SCIPbendersGetSubproblemType(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersGetSubproblemType(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersGetSubproblemType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetSubproblemType", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemIsConvex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemIsConvex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber, unsigned int isconvex)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemIsConvex$descriptor() {
        return SCIPbendersSetSubproblemIsConvex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber, unsigned int isconvex)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemIsConvex$handle() {
        return SCIPbendersSetSubproblemIsConvex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber, unsigned int isconvex)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemIsConvex$address() {
        return SCIPbendersSetSubproblemIsConvex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber, unsigned int isconvex)
     * }
     */
    public static void SCIPbendersSetSubproblemIsConvex(MemorySegment benders, int probnumber, int isconvex) {
        var mh$ = SCIPbendersSetSubproblemIsConvex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemIsConvex", benders, probnumber, isconvex);
            }
            mh$.invokeExact(benders, probnumber, isconvex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblemIsConvex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblemIsConvex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblemIsConvex$descriptor() {
        return SCIPbendersSubproblemIsConvex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblemIsConvex$handle() {
        return SCIPbendersSubproblemIsConvex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblemIsConvex$address() {
        return SCIPbendersSubproblemIsConvex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsConvex(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersSubproblemIsConvex(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblemIsConvex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblemIsConvex", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNConvexSubproblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNConvexSubproblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNConvexSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNConvexSubproblems$descriptor() {
        return SCIPbendersGetNConvexSubproblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNConvexSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNConvexSubproblems$handle() {
        return SCIPbendersGetNConvexSubproblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNConvexSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNConvexSubproblems$address() {
        return SCIPbendersGetNConvexSubproblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNConvexSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNConvexSubproblems(MemorySegment benders) {
        var mh$ = SCIPbendersGetNConvexSubproblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNConvexSubproblems", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemIsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemIsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber, unsigned int isnonlinear)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemIsNonlinear$descriptor() {
        return SCIPbendersSetSubproblemIsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber, unsigned int isnonlinear)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemIsNonlinear$handle() {
        return SCIPbendersSetSubproblemIsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber, unsigned int isnonlinear)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemIsNonlinear$address() {
        return SCIPbendersSetSubproblemIsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber, unsigned int isnonlinear)
     * }
     */
    public static void SCIPbendersSetSubproblemIsNonlinear(MemorySegment benders, int probnumber, int isnonlinear) {
        var mh$ = SCIPbendersSetSubproblemIsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemIsNonlinear", benders, probnumber, isnonlinear);
            }
            mh$.invokeExact(benders, probnumber, isnonlinear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblemIsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblemIsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblemIsNonlinear$descriptor() {
        return SCIPbendersSubproblemIsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblemIsNonlinear$handle() {
        return SCIPbendersSubproblemIsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblemIsNonlinear$address() {
        return SCIPbendersSubproblemIsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsNonlinear(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersSubproblemIsNonlinear(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblemIsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblemIsNonlinear", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNNonlinearSubproblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNNonlinearSubproblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNNonlinearSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNNonlinearSubproblems$descriptor() {
        return SCIPbendersGetNNonlinearSubproblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNNonlinearSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNNonlinearSubproblems$handle() {
        return SCIPbendersGetNNonlinearSubproblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNNonlinearSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNNonlinearSubproblems$address() {
        return SCIPbendersGetNNonlinearSubproblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNNonlinearSubproblems(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNNonlinearSubproblems(MemorySegment benders) {
        var mh$ = SCIPbendersGetNNonlinearSubproblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNNonlinearSubproblems", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetMasterIsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetMasterIsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetMasterIsNonlinear(SCIP_BENDERS *benders, unsigned int isnonlinear)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetMasterIsNonlinear$descriptor() {
        return SCIPbendersSetMasterIsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetMasterIsNonlinear(SCIP_BENDERS *benders, unsigned int isnonlinear)
     * }
     */
    public static MethodHandle SCIPbendersSetMasterIsNonlinear$handle() {
        return SCIPbendersSetMasterIsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetMasterIsNonlinear(SCIP_BENDERS *benders, unsigned int isnonlinear)
     * }
     */
    public static MemorySegment SCIPbendersSetMasterIsNonlinear$address() {
        return SCIPbendersSetMasterIsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetMasterIsNonlinear(SCIP_BENDERS *benders, unsigned int isnonlinear)
     * }
     */
    public static void SCIPbendersSetMasterIsNonlinear(MemorySegment benders, int isnonlinear) {
        var mh$ = SCIPbendersSetMasterIsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetMasterIsNonlinear", benders, isnonlinear);
            }
            mh$.invokeExact(benders, isnonlinear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersMasterIsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersMasterIsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersMasterIsNonlinear(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersMasterIsNonlinear$descriptor() {
        return SCIPbendersMasterIsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersMasterIsNonlinear(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersMasterIsNonlinear$handle() {
        return SCIPbendersMasterIsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersMasterIsNonlinear(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersMasterIsNonlinear$address() {
        return SCIPbendersMasterIsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersMasterIsNonlinear(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersMasterIsNonlinear(MemorySegment benders) {
        var mh$ = SCIPbendersMasterIsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersMasterIsNonlinear", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersInStrengthenRound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersInStrengthenRound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersInStrengthenRound(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersInStrengthenRound$descriptor() {
        return SCIPbendersInStrengthenRound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersInStrengthenRound(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersInStrengthenRound$handle() {
        return SCIPbendersInStrengthenRound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersInStrengthenRound(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersInStrengthenRound$address() {
        return SCIPbendersInStrengthenRound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersInStrengthenRound(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersInStrengthenRound(MemorySegment benders) {
        var mh$ = SCIPbendersInStrengthenRound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersInStrengthenRound", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSolveSubproblemLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSolveSubproblemLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemLP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, double *objective)
     * }
     */
    public static FunctionDescriptor SCIPbendersSolveSubproblemLP$descriptor() {
        return SCIPbendersSolveSubproblemLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemLP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, double *objective)
     * }
     */
    public static MethodHandle SCIPbendersSolveSubproblemLP$handle() {
        return SCIPbendersSolveSubproblemLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemLP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, double *objective)
     * }
     */
    public static MemorySegment SCIPbendersSolveSubproblemLP$address() {
        return SCIPbendersSolveSubproblemLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemLP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, double *objective)
     * }
     */
    public static int SCIPbendersSolveSubproblemLP(MemorySegment scip, MemorySegment benders, int probnumber, MemorySegment solvestatus, MemorySegment objective) {
        var mh$ = SCIPbendersSolveSubproblemLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSolveSubproblemLP", scip, benders, probnumber, solvestatus, objective);
            }
            return (int)mh$.invokeExact(scip, benders, probnumber, solvestatus, objective);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSolveSubproblemCIP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSolveSubproblemCIP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemCIP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, unsigned int solvecip)
     * }
     */
    public static FunctionDescriptor SCIPbendersSolveSubproblemCIP$descriptor() {
        return SCIPbendersSolveSubproblemCIP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemCIP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, unsigned int solvecip)
     * }
     */
    public static MethodHandle SCIPbendersSolveSubproblemCIP$handle() {
        return SCIPbendersSolveSubproblemCIP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemCIP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, unsigned int solvecip)
     * }
     */
    public static MemorySegment SCIPbendersSolveSubproblemCIP$address() {
        return SCIPbendersSolveSubproblemCIP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbendersSolveSubproblemCIP(SCIP *scip, SCIP_BENDERS *benders, int probnumber, SCIP_STATUS *solvestatus, unsigned int solvecip)
     * }
     */
    public static int SCIPbendersSolveSubproblemCIP(MemorySegment scip, MemorySegment benders, int probnumber, MemorySegment solvestatus, int solvecip) {
        var mh$ = SCIPbendersSolveSubproblemCIP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSolveSubproblemCIP", scip, benders, probnumber, solvestatus, solvecip);
            }
            return (int)mh$.invokeExact(scip, benders, probnumber, solvestatus, solvecip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetNTransferredCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetNTransferredCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbendersGetNTransferredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetNTransferredCuts$descriptor() {
        return SCIPbendersGetNTransferredCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbendersGetNTransferredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPbendersGetNTransferredCuts$handle() {
        return SCIPbendersGetNTransferredCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbendersGetNTransferredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPbendersGetNTransferredCuts$address() {
        return SCIPbendersGetNTransferredCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbendersGetNTransferredCuts(SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPbendersGetNTransferredCuts(MemorySegment benders) {
        var mh$ = SCIPbendersGetNTransferredCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetNTransferredCuts", benders);
            }
            return (int)mh$.invokeExact(benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersUpdateSubproblemLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersUpdateSubproblemLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersUpdateSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber, double lowerbound)
     * }
     */
    public static FunctionDescriptor SCIPbendersUpdateSubproblemLowerbound$descriptor() {
        return SCIPbendersUpdateSubproblemLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersUpdateSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber, double lowerbound)
     * }
     */
    public static MethodHandle SCIPbendersUpdateSubproblemLowerbound$handle() {
        return SCIPbendersUpdateSubproblemLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersUpdateSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber, double lowerbound)
     * }
     */
    public static MemorySegment SCIPbendersUpdateSubproblemLowerbound$address() {
        return SCIPbendersUpdateSubproblemLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersUpdateSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber, double lowerbound)
     * }
     */
    public static void SCIPbendersUpdateSubproblemLowerbound(MemorySegment benders, int probnumber, double lowerbound) {
        var mh$ = SCIPbendersUpdateSubproblemLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersUpdateSubproblemLowerbound", benders, probnumber, lowerbound);
            }
            mh$.invokeExact(benders, probnumber, lowerbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersGetSubproblemLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersGetSubproblemLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersGetSubproblemLowerbound$descriptor() {
        return SCIPbendersGetSubproblemLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersGetSubproblemLowerbound$handle() {
        return SCIPbendersGetSubproblemLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersGetSubproblemLowerbound$address() {
        return SCIPbendersGetSubproblemLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbendersGetSubproblemLowerbound(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static double SCIPbendersGetSubproblemLowerbound(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersGetSubproblemLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersGetSubproblemLowerbound", benders, probnumber);
            }
            return (double)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSetSubproblemIsIndependent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSetSubproblemIsIndependent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber, unsigned int isindep)
     * }
     */
    public static FunctionDescriptor SCIPbendersSetSubproblemIsIndependent$descriptor() {
        return SCIPbendersSetSubproblemIsIndependent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber, unsigned int isindep)
     * }
     */
    public static MethodHandle SCIPbendersSetSubproblemIsIndependent$handle() {
        return SCIPbendersSetSubproblemIsIndependent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber, unsigned int isindep)
     * }
     */
    public static MemorySegment SCIPbendersSetSubproblemIsIndependent$address() {
        return SCIPbendersSetSubproblemIsIndependent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbendersSetSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber, unsigned int isindep)
     * }
     */
    public static void SCIPbendersSetSubproblemIsIndependent(MemorySegment benders, int probnumber, int isindep) {
        var mh$ = SCIPbendersSetSubproblemIsIndependent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSetSubproblemIsIndependent", benders, probnumber, isindep);
            }
            mh$.invokeExact(benders, probnumber, isindep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblemIsIndependent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblemIsIndependent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblemIsIndependent$descriptor() {
        return SCIPbendersSubproblemIsIndependent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblemIsIndependent$handle() {
        return SCIPbendersSubproblemIsIndependent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblemIsIndependent$address() {
        return SCIPbendersSubproblemIsIndependent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsIndependent(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersSubproblemIsIndependent(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblemIsIndependent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblemIsIndependent", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbendersSubproblemIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbendersSubproblemIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsEnabled(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPbendersSubproblemIsEnabled$descriptor() {
        return SCIPbendersSubproblemIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsEnabled(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPbendersSubproblemIsEnabled$handle() {
        return SCIPbendersSubproblemIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsEnabled(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPbendersSubproblemIsEnabled$address() {
        return SCIPbendersSubproblemIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbendersSubproblemIsEnabled(SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPbendersSubproblemIsEnabled(MemorySegment benders, int probnumber) {
        var mh$ = SCIPbendersSubproblemIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbendersSubproblemIsEnabled", benders, probnumber);
            }
            return (int)mh$.invokeExact(benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbenderscutComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutComp$descriptor() {
        return SCIPbenderscutComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbenderscutComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbenderscutComp$handle() {
        return SCIPbenderscutComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbenderscutComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbenderscutComp$address() {
        return SCIPbenderscutComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbenderscutComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbenderscutComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbenderscutComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbenderscutCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutCompName$descriptor() {
        return SCIPbenderscutCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbenderscutCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbenderscutCompName$handle() {
        return SCIPbenderscutCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbenderscutCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbenderscutCompName$address() {
        return SCIPbenderscutCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbenderscutCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbenderscutCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbenderscutCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUTDATA *SCIPbenderscutGetData(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetData$descriptor() {
        return SCIPbenderscutGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUTDATA *SCIPbenderscutGetData(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetData$handle() {
        return SCIPbenderscutGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERSCUTDATA *SCIPbenderscutGetData(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetData$address() {
        return SCIPbenderscutGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERSCUTDATA *SCIPbenderscutGetData(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetData(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetData", benderscut);
            }
            return (MemorySegment)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetData(SCIP_BENDERSCUT *benderscut, SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutSetData$descriptor() {
        return SCIPbenderscutSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetData(SCIP_BENDERSCUT *benderscut, SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MethodHandle SCIPbenderscutSetData$handle() {
        return SCIPbenderscutSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetData(SCIP_BENDERSCUT *benderscut, SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MemorySegment SCIPbenderscutSetData$address() {
        return SCIPbenderscutSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbenderscutSetData(SCIP_BENDERSCUT *benderscut, SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static void SCIPbenderscutSetData(MemorySegment benderscut, MemorySegment benderscutdata) {
        var mh$ = SCIPbenderscutSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutSetData", benderscut, benderscutdata);
            }
            mh$.invokeExact(benderscut, benderscutdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetName(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetName$descriptor() {
        return SCIPbenderscutGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetName(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetName$handle() {
        return SCIPbenderscutGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetName(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetName$address() {
        return SCIPbenderscutGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetName(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetName(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetName", benderscut);
            }
            return (MemorySegment)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetDesc(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetDesc$descriptor() {
        return SCIPbenderscutGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetDesc(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetDesc$handle() {
        return SCIPbenderscutGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetDesc(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetDesc$address() {
        return SCIPbenderscutGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbenderscutGetDesc(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetDesc(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetDesc", benderscut);
            }
            return (MemorySegment)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbenderscutGetPriority(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetPriority$descriptor() {
        return SCIPbenderscutGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbenderscutGetPriority(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetPriority$handle() {
        return SCIPbenderscutGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbenderscutGetPriority(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetPriority$address() {
        return SCIPbenderscutGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbenderscutGetPriority(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static int SCIPbenderscutGetPriority(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetPriority", benderscut);
            }
            return (int)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNCalls(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetNCalls$descriptor() {
        return SCIPbenderscutGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNCalls(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetNCalls$handle() {
        return SCIPbenderscutGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNCalls(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetNCalls$address() {
        return SCIPbenderscutGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNCalls(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static long SCIPbenderscutGetNCalls(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetNCalls", benderscut);
            }
            return (long)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetNFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetNFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNFound(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetNFound$descriptor() {
        return SCIPbenderscutGetNFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNFound(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetNFound$handle() {
        return SCIPbenderscutGetNFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNFound(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetNFound$address() {
        return SCIPbenderscutGetNFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbenderscutGetNFound(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static long SCIPbenderscutGetNFound(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetNFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetNFound", benderscut);
            }
            return (long)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsInitialized(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutIsInitialized$descriptor() {
        return SCIPbenderscutIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsInitialized(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutIsInitialized$handle() {
        return SCIPbenderscutIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsInitialized(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutIsInitialized$address() {
        return SCIPbenderscutIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsInitialized(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static int SCIPbenderscutIsInitialized(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutIsInitialized", benderscut);
            }
            return (int)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetSetupTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetSetupTime$descriptor() {
        return SCIPbenderscutGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetSetupTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetSetupTime$handle() {
        return SCIPbenderscutGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetSetupTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetSetupTime$address() {
        return SCIPbenderscutGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbenderscutGetSetupTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static double SCIPbenderscutGetSetupTime(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetSetupTime", benderscut);
            }
            return (double)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutGetTime$descriptor() {
        return SCIPbenderscutGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutGetTime$handle() {
        return SCIPbenderscutGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbenderscutGetTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutGetTime$address() {
        return SCIPbenderscutGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbenderscutGetTime(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static double SCIPbenderscutGetTime(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutGetTime", benderscut);
            }
            return (double)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutIsLPCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutIsLPCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsLPCut(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutIsLPCut$descriptor() {
        return SCIPbenderscutIsLPCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsLPCut(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MethodHandle SCIPbenderscutIsLPCut$handle() {
        return SCIPbenderscutIsLPCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsLPCut(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static MemorySegment SCIPbenderscutIsLPCut$address() {
        return SCIPbenderscutIsLPCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbenderscutIsLPCut(SCIP_BENDERSCUT *benderscut)
     * }
     */
    public static int SCIPbenderscutIsLPCut(MemorySegment benderscut) {
        var mh$ = SCIPbenderscutIsLPCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutIsLPCut", benderscut);
            }
            return (int)mh$.invokeExact(benderscut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbenderscutSetEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbenderscutSetEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetEnabled(SCIP_BENDERSCUT *benderscut, unsigned int enabled)
     * }
     */
    public static FunctionDescriptor SCIPbenderscutSetEnabled$descriptor() {
        return SCIPbenderscutSetEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetEnabled(SCIP_BENDERSCUT *benderscut, unsigned int enabled)
     * }
     */
    public static MethodHandle SCIPbenderscutSetEnabled$handle() {
        return SCIPbenderscutSetEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbenderscutSetEnabled(SCIP_BENDERSCUT *benderscut, unsigned int enabled)
     * }
     */
    public static MemorySegment SCIPbenderscutSetEnabled$address() {
        return SCIPbenderscutSetEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbenderscutSetEnabled(SCIP_BENDERSCUT *benderscut, unsigned int enabled)
     * }
     */
    public static void SCIPbenderscutSetEnabled(MemorySegment benderscut, int enabled) {
        var mh$ = SCIPbenderscutSetEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbenderscutSetEnabled", benderscut, enabled);
            }
            mh$.invokeExact(benderscut, enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbranchruleComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleComp$descriptor() {
        return SCIPbranchruleComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbranchruleComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbranchruleComp$handle() {
        return SCIPbranchruleComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbranchruleComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbranchruleComp$address() {
        return SCIPbranchruleComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbranchruleComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbranchruleComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbranchruleComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbranchruleCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleCompName$descriptor() {
        return SCIPbranchruleCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbranchruleCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPbranchruleCompName$handle() {
        return SCIPbranchruleCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbranchruleCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPbranchruleCompName$address() {
        return SCIPbranchruleCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbranchruleCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPbranchruleCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPbranchruleCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULEDATA *SCIPbranchruleGetData(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetData$descriptor() {
        return SCIPbranchruleGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULEDATA *SCIPbranchruleGetData(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetData$handle() {
        return SCIPbranchruleGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULEDATA *SCIPbranchruleGetData(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetData$address() {
        return SCIPbranchruleGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BRANCHRULEDATA *SCIPbranchruleGetData(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetData(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetData", branchrule);
            }
            return (MemorySegment)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPbranchruleSetData(SCIP_BRANCHRULE *branchrule, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleSetData$descriptor() {
        return SCIPbranchruleSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPbranchruleSetData(SCIP_BRANCHRULE *branchrule, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MethodHandle SCIPbranchruleSetData$handle() {
        return SCIPbranchruleSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPbranchruleSetData(SCIP_BRANCHRULE *branchrule, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MemorySegment SCIPbranchruleSetData$address() {
        return SCIPbranchruleSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPbranchruleSetData(SCIP_BRANCHRULE *branchrule, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static void SCIPbranchruleSetData(MemorySegment branchrule, MemorySegment branchruledata) {
        var mh$ = SCIPbranchruleSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleSetData", branchrule, branchruledata);
            }
            mh$.invokeExact(branchrule, branchruledata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetName(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetName$descriptor() {
        return SCIPbranchruleGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetName(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetName$handle() {
        return SCIPbranchruleGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetName(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetName$address() {
        return SCIPbranchruleGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetName(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetName(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetName", branchrule);
            }
            return (MemorySegment)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetDesc(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetDesc$descriptor() {
        return SCIPbranchruleGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetDesc(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetDesc$handle() {
        return SCIPbranchruleGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetDesc(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetDesc$address() {
        return SCIPbranchruleGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPbranchruleGetDesc(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetDesc(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetDesc", branchrule);
            }
            return (MemorySegment)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetPriority(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetPriority$descriptor() {
        return SCIPbranchruleGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetPriority(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetPriority$handle() {
        return SCIPbranchruleGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetPriority(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetPriority$address() {
        return SCIPbranchruleGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbranchruleGetPriority(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static int SCIPbranchruleGetPriority(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetPriority", branchrule);
            }
            return (int)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetMaxdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetMaxdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetMaxdepth(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetMaxdepth$descriptor() {
        return SCIPbranchruleGetMaxdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetMaxdepth(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetMaxdepth$handle() {
        return SCIPbranchruleGetMaxdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbranchruleGetMaxdepth(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetMaxdepth$address() {
        return SCIPbranchruleGetMaxdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbranchruleGetMaxdepth(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static int SCIPbranchruleGetMaxdepth(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetMaxdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetMaxdepth", branchrule);
            }
            return (int)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetMaxbounddist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetMaxbounddist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetMaxbounddist(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetMaxbounddist$descriptor() {
        return SCIPbranchruleGetMaxbounddist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetMaxbounddist(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetMaxbounddist$handle() {
        return SCIPbranchruleGetMaxbounddist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetMaxbounddist(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetMaxbounddist$address() {
        return SCIPbranchruleGetMaxbounddist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbranchruleGetMaxbounddist(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static double SCIPbranchruleGetMaxbounddist(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetMaxbounddist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetMaxbounddist", branchrule);
            }
            return (double)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetSetupTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetSetupTime$descriptor() {
        return SCIPbranchruleGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetSetupTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetSetupTime$handle() {
        return SCIPbranchruleGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetSetupTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetSetupTime$address() {
        return SCIPbranchruleGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbranchruleGetSetupTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static double SCIPbranchruleGetSetupTime(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetSetupTime", branchrule);
            }
            return (double)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetTime$descriptor() {
        return SCIPbranchruleGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetTime$handle() {
        return SCIPbranchruleGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbranchruleGetTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetTime$address() {
        return SCIPbranchruleGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbranchruleGetTime(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static double SCIPbranchruleGetTime(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetTime", branchrule);
            }
            return (double)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNLPCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNLPCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNLPCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNLPCalls$descriptor() {
        return SCIPbranchruleGetNLPCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNLPCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNLPCalls$handle() {
        return SCIPbranchruleGetNLPCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNLPCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNLPCalls$address() {
        return SCIPbranchruleGetNLPCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNLPCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNLPCalls(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNLPCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNLPCalls", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNExternCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNExternCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNExternCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNExternCalls$descriptor() {
        return SCIPbranchruleGetNExternCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNExternCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNExternCalls$handle() {
        return SCIPbranchruleGetNExternCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNExternCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNExternCalls$address() {
        return SCIPbranchruleGetNExternCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNExternCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNExternCalls(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNExternCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNExternCalls", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNPseudoCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNPseudoCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNPseudoCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNPseudoCalls$descriptor() {
        return SCIPbranchruleGetNPseudoCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNPseudoCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNPseudoCalls$handle() {
        return SCIPbranchruleGetNPseudoCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNPseudoCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNPseudoCalls$address() {
        return SCIPbranchruleGetNPseudoCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNPseudoCalls(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNPseudoCalls(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNPseudoCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNPseudoCalls", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutoffs(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNCutoffs$descriptor() {
        return SCIPbranchruleGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutoffs(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNCutoffs$handle() {
        return SCIPbranchruleGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutoffs(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNCutoffs$address() {
        return SCIPbranchruleGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutoffs(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNCutoffs(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNCutoffs", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNCutsFound$descriptor() {
        return SCIPbranchruleGetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNCutsFound$handle() {
        return SCIPbranchruleGetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNCutsFound$address() {
        return SCIPbranchruleGetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNCutsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNCutsFound(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNCutsFound", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNConssFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNConssFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNConssFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNConssFound$descriptor() {
        return SCIPbranchruleGetNConssFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNConssFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNConssFound$handle() {
        return SCIPbranchruleGetNConssFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNConssFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNConssFound$address() {
        return SCIPbranchruleGetNConssFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNConssFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNConssFound(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNConssFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNConssFound", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNDomredsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNDomredsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNDomredsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNDomredsFound$descriptor() {
        return SCIPbranchruleGetNDomredsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNDomredsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNDomredsFound$handle() {
        return SCIPbranchruleGetNDomredsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNDomredsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNDomredsFound$address() {
        return SCIPbranchruleGetNDomredsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNDomredsFound(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNDomredsFound(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNDomredsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNDomredsFound", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleGetNChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleGetNChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNChildren(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleGetNChildren$descriptor() {
        return SCIPbranchruleGetNChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNChildren(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleGetNChildren$handle() {
        return SCIPbranchruleGetNChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNChildren(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleGetNChildren$address() {
        return SCIPbranchruleGetNChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPbranchruleGetNChildren(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static long SCIPbranchruleGetNChildren(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleGetNChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleGetNChildren", branchrule);
            }
            return (long)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchruleIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchruleIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbranchruleIsInitialized(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static FunctionDescriptor SCIPbranchruleIsInitialized$descriptor() {
        return SCIPbranchruleIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbranchruleIsInitialized(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MethodHandle SCIPbranchruleIsInitialized$handle() {
        return SCIPbranchruleIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbranchruleIsInitialized(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static MemorySegment SCIPbranchruleIsInitialized$address() {
        return SCIPbranchruleIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbranchruleIsInitialized(SCIP_BRANCHRULE *branchrule)
     * }
     */
    public static int SCIPbranchruleIsInitialized(MemorySegment branchrule) {
        var mh$ = SCIPbranchruleIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchruleIsInitialized", branchrule);
            }
            return (int)mh$.invokeExact(branchrule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrComp$descriptor() {
        return SCIPconflicthdlrComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconflicthdlrComp$handle() {
        return SCIPconflicthdlrComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconflicthdlrComp$address() {
        return SCIPconflicthdlrComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconflicthdlrComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconflicthdlrComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconflicthdlrComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrCompName$descriptor() {
        return SCIPconflicthdlrCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconflicthdlrCompName$handle() {
        return SCIPconflicthdlrCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconflicthdlrCompName$address() {
        return SCIPconflicthdlrCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconflicthdlrCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconflicthdlrCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconflicthdlrCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLRDATA *SCIPconflicthdlrGetData(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetData$descriptor() {
        return SCIPconflicthdlrGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLRDATA *SCIPconflicthdlrGetData(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetData$handle() {
        return SCIPconflicthdlrGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLRDATA *SCIPconflicthdlrGetData(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetData$address() {
        return SCIPconflicthdlrGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLRDATA *SCIPconflicthdlrGetData(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetData(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetData", conflicthdlr);
            }
            return (MemorySegment)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconflicthdlrSetData(SCIP_CONFLICTHDLR *conflicthdlr, SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrSetData$descriptor() {
        return SCIPconflicthdlrSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconflicthdlrSetData(SCIP_CONFLICTHDLR *conflicthdlr, SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MethodHandle SCIPconflicthdlrSetData$handle() {
        return SCIPconflicthdlrSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconflicthdlrSetData(SCIP_CONFLICTHDLR *conflicthdlr, SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MemorySegment SCIPconflicthdlrSetData$address() {
        return SCIPconflicthdlrSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconflicthdlrSetData(SCIP_CONFLICTHDLR *conflicthdlr, SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static void SCIPconflicthdlrSetData(MemorySegment conflicthdlr, MemorySegment conflicthdlrdata) {
        var mh$ = SCIPconflicthdlrSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrSetData", conflicthdlr, conflicthdlrdata);
            }
            mh$.invokeExact(conflicthdlr, conflicthdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetName(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetName$descriptor() {
        return SCIPconflicthdlrGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetName(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetName$handle() {
        return SCIPconflicthdlrGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetName(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetName$address() {
        return SCIPconflicthdlrGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetName(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetName(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetName", conflicthdlr);
            }
            return (MemorySegment)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetDesc(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetDesc$descriptor() {
        return SCIPconflicthdlrGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetDesc(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetDesc$handle() {
        return SCIPconflicthdlrGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetDesc(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetDesc$address() {
        return SCIPconflicthdlrGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPconflicthdlrGetDesc(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetDesc(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetDesc", conflicthdlr);
            }
            return (MemorySegment)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrGetPriority(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetPriority$descriptor() {
        return SCIPconflicthdlrGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrGetPriority(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetPriority$handle() {
        return SCIPconflicthdlrGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconflicthdlrGetPriority(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetPriority$address() {
        return SCIPconflicthdlrGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconflicthdlrGetPriority(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static int SCIPconflicthdlrGetPriority(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetPriority", conflicthdlr);
            }
            return (int)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconflicthdlrIsInitialized(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrIsInitialized$descriptor() {
        return SCIPconflicthdlrIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconflicthdlrIsInitialized(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrIsInitialized$handle() {
        return SCIPconflicthdlrIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconflicthdlrIsInitialized(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrIsInitialized$address() {
        return SCIPconflicthdlrIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconflicthdlrIsInitialized(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static int SCIPconflicthdlrIsInitialized(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrIsInitialized", conflicthdlr);
            }
            return (int)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetSetupTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetSetupTime$descriptor() {
        return SCIPconflicthdlrGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetSetupTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetSetupTime$handle() {
        return SCIPconflicthdlrGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetSetupTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetSetupTime$address() {
        return SCIPconflicthdlrGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetSetupTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static double SCIPconflicthdlrGetSetupTime(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetSetupTime", conflicthdlr);
            }
            return (double)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconflicthdlrGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconflicthdlrGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static FunctionDescriptor SCIPconflicthdlrGetTime$descriptor() {
        return SCIPconflicthdlrGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MethodHandle SCIPconflicthdlrGetTime$handle() {
        return SCIPconflicthdlrGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static MemorySegment SCIPconflicthdlrGetTime$address() {
        return SCIPconflicthdlrGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconflicthdlrGetTime(SCIP_CONFLICTHDLR *conflicthdlr)
     * }
     */
    public static double SCIPconflicthdlrGetTime(MemorySegment conflicthdlr) {
        var mh$ = SCIPconflicthdlrGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconflicthdlrGetTime", conflicthdlr);
            }
            return (double)mh$.invokeExact(conflicthdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrCompSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrCompSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompSepa(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrCompSepa$descriptor() {
        return SCIPconshdlrCompSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompSepa(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconshdlrCompSepa$handle() {
        return SCIPconshdlrCompSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompSepa(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconshdlrCompSepa$address() {
        return SCIPconshdlrCompSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrCompSepa(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconshdlrCompSepa(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconshdlrCompSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrCompSepa", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrCompEnfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrCompEnfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompEnfo(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrCompEnfo$descriptor() {
        return SCIPconshdlrCompEnfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompEnfo(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconshdlrCompEnfo$handle() {
        return SCIPconshdlrCompEnfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompEnfo(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconshdlrCompEnfo$address() {
        return SCIPconshdlrCompEnfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrCompEnfo(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconshdlrCompEnfo(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconshdlrCompEnfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrCompEnfo", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrCompCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrCompCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompCheck(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrCompCheck$descriptor() {
        return SCIPconshdlrCompCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompCheck(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconshdlrCompCheck$handle() {
        return SCIPconshdlrCompCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrCompCheck(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconshdlrCompCheck$address() {
        return SCIPconshdlrCompCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrCompCheck(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconshdlrCompCheck(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconshdlrCompCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrCompCheck", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsCompCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsCompCheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsCompCheck(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPconsCompCheck$descriptor() {
        return SCIPconsCompCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsCompCheck(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPconsCompCheck$handle() {
        return SCIPconsCompCheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsCompCheck(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPconsCompCheck$address() {
        return SCIPconsCompCheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsCompCheck(void *elem1, void *elem2)
     * }
     */
    public static int SCIPconsCompCheck(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPconsCompCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsCompCheck", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetName(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetName$descriptor() {
        return SCIPconshdlrGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetName(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetName$handle() {
        return SCIPconshdlrGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetName(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetName$address() {
        return SCIPconshdlrGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetName(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetName(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetName", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetDesc(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetDesc$descriptor() {
        return SCIPconshdlrGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetDesc(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetDesc$handle() {
        return SCIPconshdlrGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetDesc(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetDesc$address() {
        return SCIPconshdlrGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPconshdlrGetDesc(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetDesc(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetDesc", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSHDLRDATA *SCIPconshdlrGetData(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetData$descriptor() {
        return SCIPconshdlrGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSHDLRDATA *SCIPconshdlrGetData(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetData$handle() {
        return SCIPconshdlrGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSHDLRDATA *SCIPconshdlrGetData(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetData$address() {
        return SCIPconshdlrGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSHDLRDATA *SCIPconshdlrGetData(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetData(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetData", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetData(SCIP_CONSHDLR *conshdlr, SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetData$descriptor() {
        return SCIPconshdlrSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetData(SCIP_CONSHDLR *conshdlr, SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MethodHandle SCIPconshdlrSetData$handle() {
        return SCIPconshdlrSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetData(SCIP_CONSHDLR *conshdlr, SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MemorySegment SCIPconshdlrSetData$address() {
        return SCIPconshdlrSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetData(SCIP_CONSHDLR *conshdlr, SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static void SCIPconshdlrSetData(MemorySegment conshdlr, MemorySegment conshdlrdata) {
        var mh$ = SCIPconshdlrSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetData", conshdlr, conshdlrdata);
            }
            mh$.invokeExact(conshdlr, conshdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetSepa(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetSepa$descriptor() {
        return SCIPconshdlrSetSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetSepa(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static MethodHandle SCIPconshdlrSetSepa$handle() {
        return SCIPconshdlrSetSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetSepa(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static MemorySegment SCIPconshdlrSetSepa$address() {
        return SCIPconshdlrSetSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetSepa(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static void SCIPconshdlrSetSepa(MemorySegment conshdlr, MemorySegment conssepalp, MemorySegment conssepasol, int sepafreq, int sepapriority, int delaysepa) {
        var mh$ = SCIPconshdlrSetSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetSepa", conshdlr, conssepalp, conssepasol, sepafreq, sepapriority, delaysepa);
            }
            mh$.invokeExact(conshdlr, conssepalp, conssepasol, sepafreq, sepapriority, delaysepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetProp(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING timingmask)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetProp$descriptor() {
        return SCIPconshdlrSetProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetProp(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING timingmask)
     * }
     */
    public static MethodHandle SCIPconshdlrSetProp$handle() {
        return SCIPconshdlrSetProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetProp(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING timingmask)
     * }
     */
    public static MemorySegment SCIPconshdlrSetProp$address() {
        return SCIPconshdlrSetProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetProp(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING timingmask)
     * }
     */
    public static void SCIPconshdlrSetProp(MemorySegment conshdlr, MemorySegment consprop, int propfreq, int delayprop, int timingmask) {
        var mh$ = SCIPconshdlrSetProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetProp", conshdlr, consprop, propfreq, delayprop, timingmask);
            }
            mh$.invokeExact(conshdlr, consprop, propfreq, delayprop, timingmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetEnforelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetEnforelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetEnforelax(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetEnforelax$descriptor() {
        return SCIPconshdlrSetEnforelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetEnforelax(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPconshdlrSetEnforelax$handle() {
        return SCIPconshdlrSetEnforelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetEnforelax(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPconshdlrSetEnforelax$address() {
        return SCIPconshdlrSetEnforelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetEnforelax(SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static void SCIPconshdlrSetEnforelax(MemorySegment conshdlr, MemorySegment consenforelax) {
        var mh$ = SCIPconshdlrSetEnforelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetEnforelax", conshdlr, consenforelax);
            }
            mh$.invokeExact(conshdlr, consenforelax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetConss$descriptor() {
        return SCIPconshdlrGetConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetConss$handle() {
        return SCIPconshdlrGetConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetConss$address() {
        return SCIPconshdlrGetConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetConss", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEnfoConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEnfoConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEnfoConss$descriptor() {
        return SCIPconshdlrGetEnfoConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEnfoConss$handle() {
        return SCIPconshdlrGetEnfoConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoConss$address() {
        return SCIPconshdlrGetEnfoConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEnfoConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEnfoConss", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetCheckConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetCheckConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetCheckConss$descriptor() {
        return SCIPconshdlrGetCheckConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetCheckConss$handle() {
        return SCIPconshdlrGetCheckConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetCheckConss$address() {
        return SCIPconshdlrGetCheckConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetCheckConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetCheckConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetCheckConss", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetUpdateConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetUpdateConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetUpdateConss$descriptor() {
        return SCIPconshdlrGetUpdateConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetUpdateConss$handle() {
        return SCIPconshdlrGetUpdateConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetUpdateConss$address() {
        return SCIPconshdlrGetUpdateConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPconshdlrGetUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetUpdateConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetUpdateConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetUpdateConss", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNConss$descriptor() {
        return SCIPconshdlrGetNConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNConss$handle() {
        return SCIPconshdlrGetNConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNConss$address() {
        return SCIPconshdlrGetNConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNEnfoConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNEnfoConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNEnfoConss$descriptor() {
        return SCIPconshdlrGetNEnfoConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNEnfoConss$handle() {
        return SCIPconshdlrGetNEnfoConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNEnfoConss$address() {
        return SCIPconshdlrGetNEnfoConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnfoConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNEnfoConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNEnfoConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNEnfoConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNCheckConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNCheckConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNCheckConss$descriptor() {
        return SCIPconshdlrGetNCheckConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNCheckConss$handle() {
        return SCIPconshdlrGetNCheckConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNCheckConss$address() {
        return SCIPconshdlrGetNCheckConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNCheckConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNCheckConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNCheckConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNCheckConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNActiveConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNActiveConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNActiveConss$descriptor() {
        return SCIPconshdlrGetNActiveConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNActiveConss$handle() {
        return SCIPconshdlrGetNActiveConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNActiveConss$address() {
        return SCIPconshdlrGetNActiveConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNActiveConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNActiveConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNActiveConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNEnabledConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNEnabledConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnabledConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNEnabledConss$descriptor() {
        return SCIPconshdlrGetNEnabledConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnabledConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNEnabledConss$handle() {
        return SCIPconshdlrGetNEnabledConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnabledConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNEnabledConss$address() {
        return SCIPconshdlrGetNEnabledConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNEnabledConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNEnabledConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNEnabledConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNEnabledConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNUpdateConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNUpdateConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNUpdateConss$descriptor() {
        return SCIPconshdlrGetNUpdateConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNUpdateConss$handle() {
        return SCIPconshdlrGetNUpdateConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNUpdateConss$address() {
        return SCIPconshdlrGetNUpdateConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpdateConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNUpdateConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNUpdateConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNUpdateConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSetupTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetSetupTime$descriptor() {
        return SCIPconshdlrGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSetupTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetSetupTime$handle() {
        return SCIPconshdlrGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSetupTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetSetupTime$address() {
        return SCIPconshdlrGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetSetupTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetSetupTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetSetupTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetPresolTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetPresolTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPresolTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetPresolTime$descriptor() {
        return SCIPconshdlrGetPresolTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPresolTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetPresolTime$handle() {
        return SCIPconshdlrGetPresolTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPresolTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetPresolTime$address() {
        return SCIPconshdlrGetPresolTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetPresolTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetPresolTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetPresolTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetPresolTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetSepaTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetSepaTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSepaTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetSepaTime$descriptor() {
        return SCIPconshdlrGetSepaTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSepaTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetSepaTime$handle() {
        return SCIPconshdlrGetSepaTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetSepaTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetSepaTime$address() {
        return SCIPconshdlrGetSepaTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetSepaTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetSepaTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetSepaTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetSepaTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEnfoLPTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEnfoLPTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoLPTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEnfoLPTime$descriptor() {
        return SCIPconshdlrGetEnfoLPTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoLPTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEnfoLPTime$handle() {
        return SCIPconshdlrGetEnfoLPTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoLPTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoLPTime$address() {
        return SCIPconshdlrGetEnfoLPTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoLPTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetEnfoLPTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEnfoLPTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEnfoLPTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEnfoPSTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEnfoPSTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoPSTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEnfoPSTime$descriptor() {
        return SCIPconshdlrGetEnfoPSTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoPSTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEnfoPSTime$handle() {
        return SCIPconshdlrGetEnfoPSTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoPSTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoPSTime$address() {
        return SCIPconshdlrGetEnfoPSTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoPSTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetEnfoPSTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEnfoPSTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEnfoPSTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEnfoRelaxTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEnfoRelaxTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoRelaxTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEnfoRelaxTime$descriptor() {
        return SCIPconshdlrGetEnfoRelaxTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoRelaxTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEnfoRelaxTime$handle() {
        return SCIPconshdlrGetEnfoRelaxTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoRelaxTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoRelaxTime$address() {
        return SCIPconshdlrGetEnfoRelaxTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetEnfoRelaxTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetEnfoRelaxTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEnfoRelaxTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEnfoRelaxTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetPropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetPropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetPropTime$descriptor() {
        return SCIPconshdlrGetPropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetPropTime$handle() {
        return SCIPconshdlrGetPropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetPropTime$address() {
        return SCIPconshdlrGetPropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetPropTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetPropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetPropTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetStrongBranchPropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetStrongBranchPropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetStrongBranchPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetStrongBranchPropTime$descriptor() {
        return SCIPconshdlrGetStrongBranchPropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetStrongBranchPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetStrongBranchPropTime$handle() {
        return SCIPconshdlrGetStrongBranchPropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetStrongBranchPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetStrongBranchPropTime$address() {
        return SCIPconshdlrGetStrongBranchPropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetStrongBranchPropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetStrongBranchPropTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetStrongBranchPropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetStrongBranchPropTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetCheckTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetCheckTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetCheckTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetCheckTime$descriptor() {
        return SCIPconshdlrGetCheckTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetCheckTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetCheckTime$handle() {
        return SCIPconshdlrGetCheckTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetCheckTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetCheckTime$address() {
        return SCIPconshdlrGetCheckTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetCheckTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetCheckTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetCheckTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetCheckTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetRespropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetRespropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetRespropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetRespropTime$descriptor() {
        return SCIPconshdlrGetRespropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetRespropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetRespropTime$handle() {
        return SCIPconshdlrGetRespropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconshdlrGetRespropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetRespropTime$address() {
        return SCIPconshdlrGetRespropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconshdlrGetRespropTime(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static double SCIPconshdlrGetRespropTime(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetRespropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetRespropTime", conshdlr);
            }
            return (double)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNSepaCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNSepaCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNSepaCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNSepaCalls$descriptor() {
        return SCIPconshdlrGetNSepaCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNSepaCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNSepaCalls$handle() {
        return SCIPconshdlrGetNSepaCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNSepaCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNSepaCalls$address() {
        return SCIPconshdlrGetNSepaCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNSepaCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNSepaCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNSepaCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNSepaCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNEnfoLPCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNEnfoLPCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoLPCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNEnfoLPCalls$descriptor() {
        return SCIPconshdlrGetNEnfoLPCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoLPCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNEnfoLPCalls$handle() {
        return SCIPconshdlrGetNEnfoLPCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoLPCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNEnfoLPCalls$address() {
        return SCIPconshdlrGetNEnfoLPCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoLPCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNEnfoLPCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNEnfoLPCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNEnfoLPCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNEnfoPSCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNEnfoPSCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoPSCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNEnfoPSCalls$descriptor() {
        return SCIPconshdlrGetNEnfoPSCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoPSCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNEnfoPSCalls$handle() {
        return SCIPconshdlrGetNEnfoPSCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoPSCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNEnfoPSCalls$address() {
        return SCIPconshdlrGetNEnfoPSCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoPSCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNEnfoPSCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNEnfoPSCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNEnfoPSCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNEnfoRelaxCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNEnfoRelaxCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoRelaxCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNEnfoRelaxCalls$descriptor() {
        return SCIPconshdlrGetNEnfoRelaxCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoRelaxCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNEnfoRelaxCalls$handle() {
        return SCIPconshdlrGetNEnfoRelaxCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoRelaxCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNEnfoRelaxCalls$address() {
        return SCIPconshdlrGetNEnfoRelaxCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNEnfoRelaxCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNEnfoRelaxCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNEnfoRelaxCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNEnfoRelaxCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNPropCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNPropCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNPropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNPropCalls$descriptor() {
        return SCIPconshdlrGetNPropCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNPropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNPropCalls$handle() {
        return SCIPconshdlrGetNPropCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNPropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNPropCalls$address() {
        return SCIPconshdlrGetNPropCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNPropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNPropCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNPropCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNPropCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNCheckCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNCheckCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCheckCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNCheckCalls$descriptor() {
        return SCIPconshdlrGetNCheckCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCheckCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNCheckCalls$handle() {
        return SCIPconshdlrGetNCheckCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCheckCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNCheckCalls$address() {
        return SCIPconshdlrGetNCheckCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCheckCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNCheckCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNCheckCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNCheckCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNRespropCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNRespropCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNRespropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNRespropCalls$descriptor() {
        return SCIPconshdlrGetNRespropCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNRespropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNRespropCalls$handle() {
        return SCIPconshdlrGetNRespropCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNRespropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNRespropCalls$address() {
        return SCIPconshdlrGetNRespropCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNRespropCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNRespropCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNRespropCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNRespropCalls", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutoffs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNCutoffs$descriptor() {
        return SCIPconshdlrGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutoffs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNCutoffs$handle() {
        return SCIPconshdlrGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutoffs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNCutoffs$address() {
        return SCIPconshdlrGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutoffs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNCutoffs(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNCutoffs", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNCutsFound$descriptor() {
        return SCIPconshdlrGetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNCutsFound$handle() {
        return SCIPconshdlrGetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNCutsFound$address() {
        return SCIPconshdlrGetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNCutsFound(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNCutsFound", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNCutsApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNCutsApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsApplied(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNCutsApplied$descriptor() {
        return SCIPconshdlrGetNCutsApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsApplied(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNCutsApplied$handle() {
        return SCIPconshdlrGetNCutsApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsApplied(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNCutsApplied$address() {
        return SCIPconshdlrGetNCutsApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNCutsApplied(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNCutsApplied(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNCutsApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNCutsApplied", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNConssFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNConssFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNConssFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNConssFound$descriptor() {
        return SCIPconshdlrGetNConssFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNConssFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNConssFound$handle() {
        return SCIPconshdlrGetNConssFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNConssFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNConssFound$address() {
        return SCIPconshdlrGetNConssFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNConssFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNConssFound(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNConssFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNConssFound", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNDomredsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNDomredsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNDomredsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNDomredsFound$descriptor() {
        return SCIPconshdlrGetNDomredsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNDomredsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNDomredsFound$handle() {
        return SCIPconshdlrGetNDomredsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNDomredsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNDomredsFound$address() {
        return SCIPconshdlrGetNDomredsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNDomredsFound(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNDomredsFound(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNDomredsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNDomredsFound", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNChildren(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNChildren$descriptor() {
        return SCIPconshdlrGetNChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNChildren(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNChildren$handle() {
        return SCIPconshdlrGetNChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNChildren(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNChildren$address() {
        return SCIPconshdlrGetNChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconshdlrGetNChildren(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPconshdlrGetNChildren(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNChildren", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetMaxNActiveConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetMaxNActiveConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetMaxNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetMaxNActiveConss$descriptor() {
        return SCIPconshdlrGetMaxNActiveConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetMaxNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetMaxNActiveConss$handle() {
        return SCIPconshdlrGetMaxNActiveConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetMaxNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetMaxNActiveConss$address() {
        return SCIPconshdlrGetMaxNActiveConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetMaxNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetMaxNActiveConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetMaxNActiveConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetMaxNActiveConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetStartNActiveConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetStartNActiveConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetStartNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetStartNActiveConss$descriptor() {
        return SCIPconshdlrGetStartNActiveConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetStartNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetStartNActiveConss$handle() {
        return SCIPconshdlrGetStartNActiveConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetStartNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetStartNActiveConss$address() {
        return SCIPconshdlrGetStartNActiveConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetStartNActiveConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetStartNActiveConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetStartNActiveConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetStartNActiveConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNFixedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNFixedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNFixedVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNFixedVars$descriptor() {
        return SCIPconshdlrGetNFixedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNFixedVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNFixedVars$handle() {
        return SCIPconshdlrGetNFixedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNFixedVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNFixedVars$address() {
        return SCIPconshdlrGetNFixedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNFixedVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNFixedVars(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNFixedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNFixedVars", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNAggrVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNAggrVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAggrVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNAggrVars$descriptor() {
        return SCIPconshdlrGetNAggrVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAggrVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNAggrVars$handle() {
        return SCIPconshdlrGetNAggrVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAggrVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNAggrVars$address() {
        return SCIPconshdlrGetNAggrVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAggrVars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNAggrVars(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNAggrVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNAggrVars", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNChgVarTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNChgVarTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgVarTypes(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNChgVarTypes$descriptor() {
        return SCIPconshdlrGetNChgVarTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgVarTypes(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNChgVarTypes$handle() {
        return SCIPconshdlrGetNChgVarTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgVarTypes(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNChgVarTypes$address() {
        return SCIPconshdlrGetNChgVarTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgVarTypes(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNChgVarTypes(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNChgVarTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNChgVarTypes", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNChgBds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNChgBds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgBds(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNChgBds$descriptor() {
        return SCIPconshdlrGetNChgBds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgBds(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNChgBds$handle() {
        return SCIPconshdlrGetNChgBds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgBds(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNChgBds$address() {
        return SCIPconshdlrGetNChgBds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgBds(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNChgBds(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNChgBds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNChgBds", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNAddHoles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNAddHoles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddHoles(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNAddHoles$descriptor() {
        return SCIPconshdlrGetNAddHoles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddHoles(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNAddHoles$handle() {
        return SCIPconshdlrGetNAddHoles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddHoles(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNAddHoles$address() {
        return SCIPconshdlrGetNAddHoles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddHoles(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNAddHoles(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNAddHoles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNAddHoles", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNDelConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNDelConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNDelConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNDelConss$descriptor() {
        return SCIPconshdlrGetNDelConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNDelConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNDelConss$handle() {
        return SCIPconshdlrGetNDelConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNDelConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNDelConss$address() {
        return SCIPconshdlrGetNDelConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNDelConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNDelConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNDelConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNDelConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNAddConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNAddConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNAddConss$descriptor() {
        return SCIPconshdlrGetNAddConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNAddConss$handle() {
        return SCIPconshdlrGetNAddConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNAddConss$address() {
        return SCIPconshdlrGetNAddConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNAddConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNAddConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNAddConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNAddConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNUpgdConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNUpgdConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpgdConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNUpgdConss$descriptor() {
        return SCIPconshdlrGetNUpgdConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpgdConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNUpgdConss$handle() {
        return SCIPconshdlrGetNUpgdConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpgdConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNUpgdConss$address() {
        return SCIPconshdlrGetNUpgdConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNUpgdConss(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNUpgdConss(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNUpgdConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNUpgdConss", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNChgCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNChgCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgCoefs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNChgCoefs$descriptor() {
        return SCIPconshdlrGetNChgCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgCoefs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNChgCoefs$handle() {
        return SCIPconshdlrGetNChgCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgCoefs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNChgCoefs$address() {
        return SCIPconshdlrGetNChgCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgCoefs(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNChgCoefs(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNChgCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNChgCoefs", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNChgSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNChgSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgSides(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNChgSides$descriptor() {
        return SCIPconshdlrGetNChgSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgSides(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNChgSides$handle() {
        return SCIPconshdlrGetNChgSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgSides(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNChgSides$address() {
        return SCIPconshdlrGetNChgSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNChgSides(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNChgSides(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNChgSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNChgSides", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetNPresolCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetNPresolCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNPresolCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetNPresolCalls$descriptor() {
        return SCIPconshdlrGetNPresolCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNPresolCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetNPresolCalls$handle() {
        return SCIPconshdlrGetNPresolCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetNPresolCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetNPresolCalls$address() {
        return SCIPconshdlrGetNPresolCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetNPresolCalls(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetNPresolCalls(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetNPresolCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetNPresolCalls", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetSepaPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetSepaPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetSepaPriority$descriptor() {
        return SCIPconshdlrGetSepaPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetSepaPriority$handle() {
        return SCIPconshdlrGetSepaPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetSepaPriority$address() {
        return SCIPconshdlrGetSepaPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetSepaPriority(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetSepaPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetSepaPriority", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEnfoPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEnfoPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEnfoPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEnfoPriority$descriptor() {
        return SCIPconshdlrGetEnfoPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEnfoPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEnfoPriority$handle() {
        return SCIPconshdlrGetEnfoPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEnfoPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEnfoPriority$address() {
        return SCIPconshdlrGetEnfoPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetEnfoPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetEnfoPriority(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEnfoPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEnfoPriority", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetCheckPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetCheckPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetCheckPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetCheckPriority$descriptor() {
        return SCIPconshdlrGetCheckPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetCheckPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetCheckPriority$handle() {
        return SCIPconshdlrGetCheckPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetCheckPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetCheckPriority$address() {
        return SCIPconshdlrGetCheckPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetCheckPriority(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetCheckPriority(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetCheckPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetCheckPriority", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetSepaFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetSepaFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetSepaFreq$descriptor() {
        return SCIPconshdlrGetSepaFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetSepaFreq$handle() {
        return SCIPconshdlrGetSepaFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetSepaFreq$address() {
        return SCIPconshdlrGetSepaFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetSepaFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetSepaFreq(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetSepaFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetSepaFreq", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetPropFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetPropFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetPropFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetPropFreq$descriptor() {
        return SCIPconshdlrGetPropFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetPropFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetPropFreq$handle() {
        return SCIPconshdlrGetPropFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetPropFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetPropFreq$address() {
        return SCIPconshdlrGetPropFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetPropFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetPropFreq(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetPropFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetPropFreq", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetEagerFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetEagerFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEagerFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetEagerFreq$descriptor() {
        return SCIPconshdlrGetEagerFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEagerFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetEagerFreq$handle() {
        return SCIPconshdlrGetEagerFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconshdlrGetEagerFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetEagerFreq$address() {
        return SCIPconshdlrGetEagerFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconshdlrGetEagerFreq(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetEagerFreq(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetEagerFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetEagerFreq", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrNeedsCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrNeedsCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrNeedsCons(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrNeedsCons$descriptor() {
        return SCIPconshdlrNeedsCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrNeedsCons(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrNeedsCons$handle() {
        return SCIPconshdlrNeedsCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrNeedsCons(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrNeedsCons$address() {
        return SCIPconshdlrNeedsCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrNeedsCons(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrNeedsCons(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrNeedsCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrNeedsCons", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrDoesPresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrDoesPresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrDoesPresolve(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrDoesPresolve$descriptor() {
        return SCIPconshdlrDoesPresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrDoesPresolve(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrDoesPresolve$handle() {
        return SCIPconshdlrDoesPresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrDoesPresolve(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrDoesPresolve$address() {
        return SCIPconshdlrDoesPresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrDoesPresolve(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrDoesPresolve(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrDoesPresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrDoesPresolve", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrIsSeparationDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrIsSeparationDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrIsSeparationDelayed$descriptor() {
        return SCIPconshdlrIsSeparationDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrIsSeparationDelayed$handle() {
        return SCIPconshdlrIsSeparationDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrIsSeparationDelayed$address() {
        return SCIPconshdlrIsSeparationDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrIsSeparationDelayed(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrIsSeparationDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrIsSeparationDelayed", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrIsPropagationDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrIsPropagationDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrIsPropagationDelayed$descriptor() {
        return SCIPconshdlrIsPropagationDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrIsPropagationDelayed$handle() {
        return SCIPconshdlrIsPropagationDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrIsPropagationDelayed$address() {
        return SCIPconshdlrIsPropagationDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrIsPropagationDelayed(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrIsPropagationDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrIsPropagationDelayed", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrWasLPSeparationDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrWasLPSeparationDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasLPSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrWasLPSeparationDelayed$descriptor() {
        return SCIPconshdlrWasLPSeparationDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasLPSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrWasLPSeparationDelayed$handle() {
        return SCIPconshdlrWasLPSeparationDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasLPSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrWasLPSeparationDelayed$address() {
        return SCIPconshdlrWasLPSeparationDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasLPSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrWasLPSeparationDelayed(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrWasLPSeparationDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrWasLPSeparationDelayed", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrWasSolSeparationDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrWasSolSeparationDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasSolSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrWasSolSeparationDelayed$descriptor() {
        return SCIPconshdlrWasSolSeparationDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasSolSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrWasSolSeparationDelayed$handle() {
        return SCIPconshdlrWasSolSeparationDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasSolSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrWasSolSeparationDelayed$address() {
        return SCIPconshdlrWasSolSeparationDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasSolSeparationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrWasSolSeparationDelayed(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrWasSolSeparationDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrWasSolSeparationDelayed", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrWasPropagationDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrWasPropagationDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrWasPropagationDelayed$descriptor() {
        return SCIPconshdlrWasPropagationDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrWasPropagationDelayed$handle() {
        return SCIPconshdlrWasPropagationDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrWasPropagationDelayed$address() {
        return SCIPconshdlrWasPropagationDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrWasPropagationDelayed(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrWasPropagationDelayed(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrWasPropagationDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrWasPropagationDelayed", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsInitialized(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrIsInitialized$descriptor() {
        return SCIPconshdlrIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsInitialized(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrIsInitialized$handle() {
        return SCIPconshdlrIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsInitialized(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrIsInitialized$address() {
        return SCIPconshdlrIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsInitialized(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrIsInitialized(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrIsInitialized", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrIsClonable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrIsClonable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsClonable(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrIsClonable$descriptor() {
        return SCIPconshdlrIsClonable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsClonable(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrIsClonable$handle() {
        return SCIPconshdlrIsClonable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsClonable(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrIsClonable$address() {
        return SCIPconshdlrIsClonable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrIsClonable(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrIsClonable(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrIsClonable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrIsClonable", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetPropTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetPropTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPconshdlrGetPropTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetPropTiming$descriptor() {
        return SCIPconshdlrGetPropTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPconshdlrGetPropTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetPropTiming$handle() {
        return SCIPconshdlrGetPropTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPconshdlrGetPropTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetPropTiming$address() {
        return SCIPconshdlrGetPropTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPconshdlrGetPropTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetPropTiming(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetPropTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetPropTiming", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconssetchgGetAddedConsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconssetchgGetAddedConsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconssetchgGetAddedConsData(SCIP_CONSSETCHG *conssetchg, SCIP_CONS ***conss, int *nconss)
     * }
     */
    public static FunctionDescriptor SCIPconssetchgGetAddedConsData$descriptor() {
        return SCIPconssetchgGetAddedConsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconssetchgGetAddedConsData(SCIP_CONSSETCHG *conssetchg, SCIP_CONS ***conss, int *nconss)
     * }
     */
    public static MethodHandle SCIPconssetchgGetAddedConsData$handle() {
        return SCIPconssetchgGetAddedConsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconssetchgGetAddedConsData(SCIP_CONSSETCHG *conssetchg, SCIP_CONS ***conss, int *nconss)
     * }
     */
    public static MemorySegment SCIPconssetchgGetAddedConsData$address() {
        return SCIPconssetchgGetAddedConsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconssetchgGetAddedConsData(SCIP_CONSSETCHG *conssetchg, SCIP_CONS ***conss, int *nconss)
     * }
     */
    public static void SCIPconssetchgGetAddedConsData(MemorySegment conssetchg, MemorySegment conss, MemorySegment nconss) {
        var mh$ = SCIPconssetchgGetAddedConsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconssetchgGetAddedConsData", conssetchg, conss, nconss);
            }
            mh$.invokeExact(conssetchg, conss, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetPropTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetPropTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPropTiming(SCIP_CONSHDLR *conshdlr, SCIP_PROPTIMING proptiming)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetPropTiming$descriptor() {
        return SCIPconshdlrSetPropTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPropTiming(SCIP_CONSHDLR *conshdlr, SCIP_PROPTIMING proptiming)
     * }
     */
    public static MethodHandle SCIPconshdlrSetPropTiming$handle() {
        return SCIPconshdlrSetPropTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPropTiming(SCIP_CONSHDLR *conshdlr, SCIP_PROPTIMING proptiming)
     * }
     */
    public static MemorySegment SCIPconshdlrSetPropTiming$address() {
        return SCIPconshdlrSetPropTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetPropTiming(SCIP_CONSHDLR *conshdlr, SCIP_PROPTIMING proptiming)
     * }
     */
    public static void SCIPconshdlrSetPropTiming(MemorySegment conshdlr, int proptiming) {
        var mh$ = SCIPconshdlrSetPropTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetPropTiming", conshdlr, proptiming);
            }
            mh$.invokeExact(conshdlr, proptiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrGetPresolTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrGetPresolTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPconshdlrGetPresolTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrGetPresolTiming$descriptor() {
        return SCIPconshdlrGetPresolTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPconshdlrGetPresolTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrGetPresolTiming$handle() {
        return SCIPconshdlrGetPresolTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPconshdlrGetPresolTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrGetPresolTiming$address() {
        return SCIPconshdlrGetPresolTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPconshdlrGetPresolTiming(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrGetPresolTiming(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrGetPresolTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrGetPresolTiming", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSetPresolTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSetPresolTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPresolTiming(SCIP_CONSHDLR *conshdlr, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSetPresolTiming$descriptor() {
        return SCIPconshdlrSetPresolTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPresolTiming(SCIP_CONSHDLR *conshdlr, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MethodHandle SCIPconshdlrSetPresolTiming$handle() {
        return SCIPconshdlrSetPresolTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconshdlrSetPresolTiming(SCIP_CONSHDLR *conshdlr, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MemorySegment SCIPconshdlrSetPresolTiming$address() {
        return SCIPconshdlrSetPresolTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconshdlrSetPresolTiming(SCIP_CONSHDLR *conshdlr, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static void SCIPconshdlrSetPresolTiming(MemorySegment conshdlr, int presoltiming) {
        var mh$ = SCIPconshdlrSetPresolTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSetPresolTiming", conshdlr, presoltiming);
            }
            mh$.invokeExact(conshdlr, presoltiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSupportsPermsymDetection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSupportsPermsymDetection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSupportsPermsymDetection$descriptor() {
        return SCIPconshdlrSupportsPermsymDetection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrSupportsPermsymDetection$handle() {
        return SCIPconshdlrSupportsPermsymDetection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrSupportsPermsymDetection$address() {
        return SCIPconshdlrSupportsPermsymDetection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrSupportsPermsymDetection(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrSupportsPermsymDetection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSupportsPermsymDetection", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconshdlrSupportsSignedPermsymDetection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconshdlrSupportsSignedPermsymDetection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsSignedPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPconshdlrSupportsSignedPermsymDetection$descriptor() {
        return SCIPconshdlrSupportsSignedPermsymDetection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsSignedPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPconshdlrSupportsSignedPermsymDetection$handle() {
        return SCIPconshdlrSupportsSignedPermsymDetection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsSignedPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPconshdlrSupportsSignedPermsymDetection$address() {
        return SCIPconshdlrSupportsSignedPermsymDetection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconshdlrSupportsSignedPermsymDetection(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPconshdlrSupportsSignedPermsymDetection(MemorySegment conshdlr) {
        var mh$ = SCIPconshdlrSupportsSignedPermsymDetection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconshdlrSupportsSignedPermsymDetection", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPconsGetName(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetName$descriptor() {
        return SCIPconsGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPconsGetName(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetName$handle() {
        return SCIPconsGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPconsGetName(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetName$address() {
        return SCIPconsGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPconsGetName(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetName(MemorySegment cons) {
        var mh$ = SCIPconsGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetName", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetPos(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetPos$descriptor() {
        return SCIPconsGetPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetPos(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetPos$handle() {
        return SCIPconsGetPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetPos(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetPos$address() {
        return SCIPconsGetPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetPos(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetPos(MemorySegment cons) {
        var mh$ = SCIPconsGetPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetPos", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetHdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetHdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPconsGetHdlr(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetHdlr$descriptor() {
        return SCIPconsGetHdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPconsGetHdlr(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetHdlr$handle() {
        return SCIPconsGetHdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPconsGetHdlr(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetHdlr$address() {
        return SCIPconsGetHdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPconsGetHdlr(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetHdlr(MemorySegment cons) {
        var mh$ = SCIPconsGetHdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetHdlr", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSDATA *SCIPconsGetData(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetData$descriptor() {
        return SCIPconsGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSDATA *SCIPconsGetData(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetData$handle() {
        return SCIPconsGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSDATA *SCIPconsGetData(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetData$address() {
        return SCIPconsGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSDATA *SCIPconsGetData(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetData(MemorySegment cons) {
        var mh$ = SCIPconsGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetData", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNUses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNUses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNUses(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNUses$descriptor() {
        return SCIPconsGetNUses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNUses(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetNUses$handle() {
        return SCIPconsGetNUses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNUses(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetNUses$address() {
        return SCIPconsGetNUses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNUses(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetNUses(MemorySegment cons) {
        var mh$ = SCIPconsGetNUses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNUses", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetActiveDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetActiveDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetActiveDepth(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetActiveDepth$descriptor() {
        return SCIPconsGetActiveDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetActiveDepth(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetActiveDepth$handle() {
        return SCIPconsGetActiveDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetActiveDepth(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetActiveDepth$address() {
        return SCIPconsGetActiveDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetActiveDepth(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetActiveDepth(MemorySegment cons) {
        var mh$ = SCIPconsGetActiveDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetActiveDepth", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetValidDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetValidDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetValidDepth(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetValidDepth$descriptor() {
        return SCIPconsGetValidDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetValidDepth(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetValidDepth$handle() {
        return SCIPconsGetValidDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetValidDepth(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetValidDepth$address() {
        return SCIPconsGetValidDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetValidDepth(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetValidDepth(MemorySegment cons) {
        var mh$ = SCIPconsGetValidDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetValidDepth", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsActive(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsActive$descriptor() {
        return SCIPconsIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsActive(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsActive$handle() {
        return SCIPconsIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsActive(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsActive$address() {
        return SCIPconsIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsActive(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsActive(MemorySegment cons) {
        var mh$ = SCIPconsIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsActive", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsUpdatedeactivate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsUpdatedeactivate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsUpdatedeactivate(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsUpdatedeactivate$descriptor() {
        return SCIPconsIsUpdatedeactivate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsUpdatedeactivate(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsUpdatedeactivate$handle() {
        return SCIPconsIsUpdatedeactivate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsUpdatedeactivate(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsUpdatedeactivate$address() {
        return SCIPconsIsUpdatedeactivate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsUpdatedeactivate(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsUpdatedeactivate(MemorySegment cons) {
        var mh$ = SCIPconsIsUpdatedeactivate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsUpdatedeactivate", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnabled(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsEnabled$descriptor() {
        return SCIPconsIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnabled(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsEnabled$handle() {
        return SCIPconsIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnabled(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsEnabled$address() {
        return SCIPconsIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnabled(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsEnabled(MemorySegment cons) {
        var mh$ = SCIPconsIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsEnabled", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsSeparationEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsSeparationEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparationEnabled(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsSeparationEnabled$descriptor() {
        return SCIPconsIsSeparationEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparationEnabled(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsSeparationEnabled$handle() {
        return SCIPconsIsSeparationEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparationEnabled(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsSeparationEnabled$address() {
        return SCIPconsIsSeparationEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparationEnabled(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsSeparationEnabled(MemorySegment cons) {
        var mh$ = SCIPconsIsSeparationEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsSeparationEnabled", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsPropagationEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsPropagationEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagationEnabled(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsPropagationEnabled$descriptor() {
        return SCIPconsIsPropagationEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagationEnabled(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsPropagationEnabled$handle() {
        return SCIPconsIsPropagationEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagationEnabled(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsPropagationEnabled$address() {
        return SCIPconsIsPropagationEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagationEnabled(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsPropagationEnabled(MemorySegment cons) {
        var mh$ = SCIPconsIsPropagationEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsPropagationEnabled", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsDeleted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsDeleted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDeleted(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsDeleted$descriptor() {
        return SCIPconsIsDeleted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDeleted(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsDeleted$handle() {
        return SCIPconsIsDeleted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDeleted(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsDeleted$address() {
        return SCIPconsIsDeleted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDeleted(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsDeleted(MemorySegment cons) {
        var mh$ = SCIPconsIsDeleted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsDeleted", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsObsolete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsObsolete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsObsolete(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsObsolete$descriptor() {
        return SCIPconsIsObsolete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsObsolete(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsObsolete$handle() {
        return SCIPconsIsObsolete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsObsolete(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsObsolete$address() {
        return SCIPconsIsObsolete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsObsolete(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsObsolete(MemorySegment cons) {
        var mh$ = SCIPconsIsObsolete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsObsolete", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsConflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsConflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsConflict(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsConflict$descriptor() {
        return SCIPconsIsConflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsConflict(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsConflict$handle() {
        return SCIPconsIsConflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsConflict(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsConflict$address() {
        return SCIPconsIsConflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsConflict(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsConflict(MemorySegment cons) {
        var mh$ = SCIPconsIsConflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsConflict", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPconsGetAge(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetAge$descriptor() {
        return SCIPconsGetAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPconsGetAge(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetAge$handle() {
        return SCIPconsGetAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPconsGetAge(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetAge$address() {
        return SCIPconsGetAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPconsGetAge(SCIP_CONS *cons)
     * }
     */
    public static double SCIPconsGetAge(MemorySegment cons) {
        var mh$ = SCIPconsGetAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetAge", cons);
            }
            return (double)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsInitial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsInitial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInitial(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsInitial$descriptor() {
        return SCIPconsIsInitial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInitial(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsInitial$handle() {
        return SCIPconsIsInitial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInitial(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsInitial$address() {
        return SCIPconsIsInitial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInitial(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsInitial(MemorySegment cons) {
        var mh$ = SCIPconsIsInitial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsInitial", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsSeparated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsSeparated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparated(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsSeparated$descriptor() {
        return SCIPconsIsSeparated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparated(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsSeparated$handle() {
        return SCIPconsIsSeparated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparated(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsSeparated$address() {
        return SCIPconsIsSeparated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsSeparated(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsSeparated(MemorySegment cons) {
        var mh$ = SCIPconsIsSeparated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsSeparated", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsEnforced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsEnforced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnforced(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsEnforced$descriptor() {
        return SCIPconsIsEnforced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnforced(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsEnforced$handle() {
        return SCIPconsIsEnforced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnforced(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsEnforced$address() {
        return SCIPconsIsEnforced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsEnforced(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsEnforced(MemorySegment cons) {
        var mh$ = SCIPconsIsEnforced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsEnforced", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsChecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsChecked(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsChecked$descriptor() {
        return SCIPconsIsChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsChecked(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsChecked$handle() {
        return SCIPconsIsChecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsChecked(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsChecked$address() {
        return SCIPconsIsChecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsChecked(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsChecked(MemorySegment cons) {
        var mh$ = SCIPconsIsChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsChecked", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsMarkedPropagate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsMarkedPropagate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsMarkedPropagate(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsMarkedPropagate$descriptor() {
        return SCIPconsIsMarkedPropagate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsMarkedPropagate(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsMarkedPropagate$handle() {
        return SCIPconsIsMarkedPropagate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsMarkedPropagate(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsMarkedPropagate$address() {
        return SCIPconsIsMarkedPropagate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsMarkedPropagate(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsMarkedPropagate(MemorySegment cons) {
        var mh$ = SCIPconsIsMarkedPropagate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsMarkedPropagate", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsPropagated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsPropagated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagated(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsPropagated$descriptor() {
        return SCIPconsIsPropagated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagated(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsPropagated$handle() {
        return SCIPconsIsPropagated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagated(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsPropagated$address() {
        return SCIPconsIsPropagated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsPropagated(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsPropagated(MemorySegment cons) {
        var mh$ = SCIPconsIsPropagated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsPropagated", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsGlobal(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsGlobal$descriptor() {
        return SCIPconsIsGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsGlobal(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsGlobal$handle() {
        return SCIPconsIsGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsGlobal(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsGlobal$address() {
        return SCIPconsIsGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsGlobal(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsGlobal(MemorySegment cons) {
        var mh$ = SCIPconsIsGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsGlobal", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocal(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLocal$descriptor() {
        return SCIPconsIsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocal(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsLocal$handle() {
        return SCIPconsIsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocal(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsLocal$address() {
        return SCIPconsIsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocal(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsLocal(MemorySegment cons) {
        var mh$ = SCIPconsIsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLocal", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsModifiable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsModifiable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsModifiable(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsModifiable$descriptor() {
        return SCIPconsIsModifiable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsModifiable(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsModifiable$handle() {
        return SCIPconsIsModifiable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsModifiable(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsModifiable$address() {
        return SCIPconsIsModifiable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsModifiable(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsModifiable(MemorySegment cons) {
        var mh$ = SCIPconsIsModifiable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsModifiable", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsDynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsDynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDynamic(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsDynamic$descriptor() {
        return SCIPconsIsDynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDynamic(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsDynamic$handle() {
        return SCIPconsIsDynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDynamic(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsDynamic$address() {
        return SCIPconsIsDynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsDynamic(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsDynamic(MemorySegment cons) {
        var mh$ = SCIPconsIsDynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsDynamic", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsRemovable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsRemovable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsRemovable(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsRemovable$descriptor() {
        return SCIPconsIsRemovable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsRemovable(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsRemovable$handle() {
        return SCIPconsIsRemovable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsRemovable(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsRemovable$address() {
        return SCIPconsIsRemovable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsRemovable(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsRemovable(MemorySegment cons) {
        var mh$ = SCIPconsIsRemovable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsRemovable", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsStickingAtNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsStickingAtNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsStickingAtNode(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsStickingAtNode$descriptor() {
        return SCIPconsIsStickingAtNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsStickingAtNode(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsStickingAtNode$handle() {
        return SCIPconsIsStickingAtNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsStickingAtNode(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsStickingAtNode$address() {
        return SCIPconsIsStickingAtNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsStickingAtNode(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsStickingAtNode(MemorySegment cons) {
        var mh$ = SCIPconsIsStickingAtNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsStickingAtNode", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsInProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsInProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInProb(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsInProb$descriptor() {
        return SCIPconsIsInProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInProb(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsInProb$handle() {
        return SCIPconsIsInProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInProb(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsInProb$address() {
        return SCIPconsIsInProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsInProb(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsInProb(MemorySegment cons) {
        var mh$ = SCIPconsIsInProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsInProb", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsOriginal(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsOriginal$descriptor() {
        return SCIPconsIsOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsOriginal(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsOriginal$handle() {
        return SCIPconsIsOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsOriginal(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsOriginal$address() {
        return SCIPconsIsOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsOriginal(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsOriginal(MemorySegment cons) {
        var mh$ = SCIPconsIsOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsOriginal", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsTransformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsTransformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsTransformed(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsTransformed$descriptor() {
        return SCIPconsIsTransformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsTransformed(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsTransformed$handle() {
        return SCIPconsIsTransformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsTransformed(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsTransformed$address() {
        return SCIPconsIsTransformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsTransformed(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsTransformed(MemorySegment cons) {
        var mh$ = SCIPconsIsTransformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsTransformed", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLockedPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLockedPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedPos(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLockedPos$descriptor() {
        return SCIPconsIsLockedPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedPos(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsLockedPos$handle() {
        return SCIPconsIsLockedPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedPos(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsLockedPos$address() {
        return SCIPconsIsLockedPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedPos(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsLockedPos(MemorySegment cons) {
        var mh$ = SCIPconsIsLockedPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLockedPos", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLockedNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLockedNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedNeg(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLockedNeg$descriptor() {
        return SCIPconsIsLockedNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedNeg(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsLockedNeg$handle() {
        return SCIPconsIsLockedNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedNeg(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsLockedNeg$address() {
        return SCIPconsIsLockedNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedNeg(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsLockedNeg(MemorySegment cons) {
        var mh$ = SCIPconsIsLockedNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLockedNeg", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocked(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLocked$descriptor() {
        return SCIPconsIsLocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocked(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsLocked$handle() {
        return SCIPconsIsLocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocked(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsLocked$address() {
        return SCIPconsIsLocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLocked(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsLocked(MemorySegment cons) {
        var mh$ = SCIPconsIsLocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLocked", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNLocksPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNLocksPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksPos(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNLocksPos$descriptor() {
        return SCIPconsGetNLocksPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksPos(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetNLocksPos$handle() {
        return SCIPconsGetNLocksPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksPos(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetNLocksPos$address() {
        return SCIPconsGetNLocksPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNLocksPos(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetNLocksPos(MemorySegment cons) {
        var mh$ = SCIPconsGetNLocksPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNLocksPos", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNLocksNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNLocksNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksNeg(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNLocksNeg$descriptor() {
        return SCIPconsGetNLocksNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksNeg(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetNLocksNeg$handle() {
        return SCIPconsGetNLocksNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksNeg(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetNLocksNeg$address() {
        return SCIPconsGetNLocksNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNLocksNeg(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetNLocksNeg(MemorySegment cons) {
        var mh$ = SCIPconsGetNLocksNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNLocksNeg", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLockedTypePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLockedTypePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLockedTypePos$descriptor() {
        return SCIPconsIsLockedTypePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPconsIsLockedTypePos$handle() {
        return SCIPconsIsLockedTypePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPconsIsLockedTypePos$address() {
        return SCIPconsIsLockedTypePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPconsIsLockedTypePos(MemorySegment cons, int locktype) {
        var mh$ = SCIPconsIsLockedTypePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLockedTypePos", cons, locktype);
            }
            return (int)mh$.invokeExact(cons, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLockedTypeNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLockedTypeNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLockedTypeNeg$descriptor() {
        return SCIPconsIsLockedTypeNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPconsIsLockedTypeNeg$handle() {
        return SCIPconsIsLockedTypeNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPconsIsLockedTypeNeg$address() {
        return SCIPconsIsLockedTypeNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPconsIsLockedTypeNeg(MemorySegment cons, int locktype) {
        var mh$ = SCIPconsIsLockedTypeNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLockedTypeNeg", cons, locktype);
            }
            return (int)mh$.invokeExact(cons, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsLockedType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsLockedType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedType(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPconsIsLockedType$descriptor() {
        return SCIPconsIsLockedType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedType(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPconsIsLockedType$handle() {
        return SCIPconsIsLockedType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedType(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPconsIsLockedType$address() {
        return SCIPconsIsLockedType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsLockedType(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPconsIsLockedType(MemorySegment cons, int locktype) {
        var mh$ = SCIPconsIsLockedType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsLockedType", cons, locktype);
            }
            return (int)mh$.invokeExact(cons, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNLocksTypePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNLocksTypePos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNLocksTypePos$descriptor() {
        return SCIPconsGetNLocksTypePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPconsGetNLocksTypePos$handle() {
        return SCIPconsGetNLocksTypePos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPconsGetNLocksTypePos$address() {
        return SCIPconsGetNLocksTypePos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypePos(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPconsGetNLocksTypePos(MemorySegment cons, int locktype) {
        var mh$ = SCIPconsGetNLocksTypePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNLocksTypePos", cons, locktype);
            }
            return (int)mh$.invokeExact(cons, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNLocksTypeNeg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNLocksTypeNeg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNLocksTypeNeg$descriptor() {
        return SCIPconsGetNLocksTypeNeg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPconsGetNLocksTypeNeg$handle() {
        return SCIPconsGetNLocksTypeNeg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPconsGetNLocksTypeNeg$address() {
        return SCIPconsGetNLocksTypeNeg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNLocksTypeNeg(SCIP_CONS *cons, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPconsGetNLocksTypeNeg(MemorySegment cons, int locktype) {
        var mh$ = SCIPconsGetNLocksTypeNeg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNLocksTypeNeg", cons, locktype);
            }
            return (int)mh$.invokeExact(cons, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsIsAdded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsIsAdded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsAdded(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsIsAdded$descriptor() {
        return SCIPconsIsAdded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsAdded(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsIsAdded$handle() {
        return SCIPconsIsAdded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPconsIsAdded(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsIsAdded$address() {
        return SCIPconsIsAdded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPconsIsAdded(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsIsAdded(MemorySegment cons) {
        var mh$ = SCIPconsIsAdded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsIsAdded", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsAddUpgradeLocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsAddUpgradeLocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPconsAddUpgradeLocks(SCIP_CONS *cons, int nlocks)
     * }
     */
    public static FunctionDescriptor SCIPconsAddUpgradeLocks$descriptor() {
        return SCIPconsAddUpgradeLocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPconsAddUpgradeLocks(SCIP_CONS *cons, int nlocks)
     * }
     */
    public static MethodHandle SCIPconsAddUpgradeLocks$handle() {
        return SCIPconsAddUpgradeLocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPconsAddUpgradeLocks(SCIP_CONS *cons, int nlocks)
     * }
     */
    public static MemorySegment SCIPconsAddUpgradeLocks$address() {
        return SCIPconsAddUpgradeLocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPconsAddUpgradeLocks(SCIP_CONS *cons, int nlocks)
     * }
     */
    public static void SCIPconsAddUpgradeLocks(MemorySegment cons, int nlocks) {
        var mh$ = SCIPconsAddUpgradeLocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsAddUpgradeLocks", cons, nlocks);
            }
            mh$.invokeExact(cons, nlocks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsGetNUpgradeLocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsGetNUpgradeLocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconsGetNUpgradeLocks(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPconsGetNUpgradeLocks$descriptor() {
        return SCIPconsGetNUpgradeLocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconsGetNUpgradeLocks(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPconsGetNUpgradeLocks$handle() {
        return SCIPconsGetNUpgradeLocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconsGetNUpgradeLocks(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPconsGetNUpgradeLocks$address() {
        return SCIPconsGetNUpgradeLocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconsGetNUpgradeLocks(SCIP_CONS *cons)
     * }
     */
    public static int SCIPconsGetNUpgradeLocks(MemorySegment cons) {
        var mh$ = SCIPconsGetNUpgradeLocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsGetNUpgradeLocks", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinConsStatsCreate(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsCreate$descriptor() {
        return SCIPlinConsStatsCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinConsStatsCreate(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static MethodHandle SCIPlinConsStatsCreate$handle() {
        return SCIPlinConsStatsCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinConsStatsCreate(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static MemorySegment SCIPlinConsStatsCreate$address() {
        return SCIPlinConsStatsCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinConsStatsCreate(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static int SCIPlinConsStatsCreate(MemorySegment scip, MemorySegment linconsstats) {
        var mh$ = SCIPlinConsStatsCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsCreate", scip, linconsstats);
            }
            return (int)mh$.invokeExact(scip, linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsFree(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsFree$descriptor() {
        return SCIPlinConsStatsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsFree(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static MethodHandle SCIPlinConsStatsFree$handle() {
        return SCIPlinConsStatsFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsFree(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static MemorySegment SCIPlinConsStatsFree$address() {
        return SCIPlinConsStatsFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPlinConsStatsFree(SCIP *scip, SCIP_LINCONSSTATS **linconsstats)
     * }
     */
    public static void SCIPlinConsStatsFree(MemorySegment scip, MemorySegment linconsstats) {
        var mh$ = SCIPlinConsStatsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsFree", scip, linconsstats);
            }
            mh$.invokeExact(scip, linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsReset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsReset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsReset(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsReset$descriptor() {
        return SCIPlinConsStatsReset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsReset(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MethodHandle SCIPlinConsStatsReset$handle() {
        return SCIPlinConsStatsReset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsReset(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MemorySegment SCIPlinConsStatsReset$address() {
        return SCIPlinConsStatsReset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPlinConsStatsReset(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static void SCIPlinConsStatsReset(MemorySegment linconsstats) {
        var mh$ = SCIPlinConsStatsReset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsReset", linconsstats);
            }
            mh$.invokeExact(linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsGetTypeCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsGetTypeCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsGetTypeCount$descriptor() {
        return SCIPlinConsStatsGetTypeCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype)
     * }
     */
    public static MethodHandle SCIPlinConsStatsGetTypeCount$handle() {
        return SCIPlinConsStatsGetTypeCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype)
     * }
     */
    public static MemorySegment SCIPlinConsStatsGetTypeCount$address() {
        return SCIPlinConsStatsGetTypeCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype)
     * }
     */
    public static int SCIPlinConsStatsGetTypeCount(MemorySegment linconsstats, int linconstype) {
        var mh$ = SCIPlinConsStatsGetTypeCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsGetTypeCount", linconsstats, linconstype);
            }
            return (int)mh$.invokeExact(linconsstats, linconstype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsGetSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsGetSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetSum(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsGetSum$descriptor() {
        return SCIPlinConsStatsGetSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetSum(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MethodHandle SCIPlinConsStatsGetSum$handle() {
        return SCIPlinConsStatsGetSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetSum(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MemorySegment SCIPlinConsStatsGetSum$address() {
        return SCIPlinConsStatsGetSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPlinConsStatsGetSum(SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static int SCIPlinConsStatsGetSum(MemorySegment linconsstats) {
        var mh$ = SCIPlinConsStatsGetSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsGetSum", linconsstats);
            }
            return (int)mh$.invokeExact(linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinConsStatsIncTypeCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinConsStatsIncTypeCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsIncTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype, int increment)
     * }
     */
    public static FunctionDescriptor SCIPlinConsStatsIncTypeCount$descriptor() {
        return SCIPlinConsStatsIncTypeCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsIncTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype, int increment)
     * }
     */
    public static MethodHandle SCIPlinConsStatsIncTypeCount$handle() {
        return SCIPlinConsStatsIncTypeCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPlinConsStatsIncTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype, int increment)
     * }
     */
    public static MemorySegment SCIPlinConsStatsIncTypeCount$address() {
        return SCIPlinConsStatsIncTypeCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPlinConsStatsIncTypeCount(SCIP_LINCONSSTATS *linconsstats, SCIP_LINCONSTYPE linconstype, int increment)
     * }
     */
    public static void SCIPlinConsStatsIncTypeCount(MemorySegment linconsstats, int linconstype, int increment) {
        var mh$ = SCIPlinConsStatsIncTypeCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinConsStatsIncTypeCount", linconsstats, linconstype, increment);
            }
            mh$.invokeExact(linconsstats, linconstype, increment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintLinConsStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintLinConsStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintLinConsStats(SCIP *scip, FILE *file, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPprintLinConsStats$descriptor() {
        return SCIPprintLinConsStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintLinConsStats(SCIP *scip, FILE *file, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MethodHandle SCIPprintLinConsStats$handle() {
        return SCIPprintLinConsStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintLinConsStats(SCIP *scip, FILE *file, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MemorySegment SCIPprintLinConsStats$address() {
        return SCIPprintLinConsStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintLinConsStats(SCIP *scip, FILE *file, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static void SCIPprintLinConsStats(MemorySegment scip, MemorySegment file, MemorySegment linconsstats) {
        var mh$ = SCIPprintLinConsStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintLinConsStats", scip, file, linconsstats);
            }
            mh$.invokeExact(scip, file, linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutGetRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutGetRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPcutGetRow(SCIP_CUT *cut)
     * }
     */
    public static FunctionDescriptor SCIPcutGetRow$descriptor() {
        return SCIPcutGetRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPcutGetRow(SCIP_CUT *cut)
     * }
     */
    public static MethodHandle SCIPcutGetRow$handle() {
        return SCIPcutGetRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPcutGetRow(SCIP_CUT *cut)
     * }
     */
    public static MemorySegment SCIPcutGetRow$address() {
        return SCIPcutGetRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPcutGetRow(SCIP_CUT *cut)
     * }
     */
    public static MemorySegment SCIPcutGetRow(MemorySegment cut) {
        var mh$ = SCIPcutGetRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutGetRow", cut);
            }
            return (MemorySegment)mh$.invokeExact(cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutGetAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutGetAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcutGetAge(SCIP_CUT *cut)
     * }
     */
    public static FunctionDescriptor SCIPcutGetAge$descriptor() {
        return SCIPcutGetAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcutGetAge(SCIP_CUT *cut)
     * }
     */
    public static MethodHandle SCIPcutGetAge$handle() {
        return SCIPcutGetAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcutGetAge(SCIP_CUT *cut)
     * }
     */
    public static MemorySegment SCIPcutGetAge$address() {
        return SCIPcutGetAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcutGetAge(SCIP_CUT *cut)
     * }
     */
    public static int SCIPcutGetAge(MemorySegment cut) {
        var mh$ = SCIPcutGetAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutGetAge", cut);
            }
            return (int)mh$.invokeExact(cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutGetLPActivityQuot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutGetLPActivityQuot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcutGetLPActivityQuot(SCIP_CUT *cut)
     * }
     */
    public static FunctionDescriptor SCIPcutGetLPActivityQuot$descriptor() {
        return SCIPcutGetLPActivityQuot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcutGetLPActivityQuot(SCIP_CUT *cut)
     * }
     */
    public static MethodHandle SCIPcutGetLPActivityQuot$handle() {
        return SCIPcutGetLPActivityQuot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcutGetLPActivityQuot(SCIP_CUT *cut)
     * }
     */
    public static MemorySegment SCIPcutGetLPActivityQuot$address() {
        return SCIPcutGetLPActivityQuot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcutGetLPActivityQuot(SCIP_CUT *cut)
     * }
     */
    public static double SCIPcutGetLPActivityQuot(MemorySegment cut) {
        var mh$ = SCIPcutGetLPActivityQuot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutGetLPActivityQuot", cut);
            }
            return (double)mh$.invokeExact(cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPcutpoolGetCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetCuts$descriptor() {
        return SCIPcutpoolGetCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPcutpoolGetCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetCuts$handle() {
        return SCIPcutpoolGetCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPcutpoolGetCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetCuts$address() {
        return SCIPcutpoolGetCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUT **SCIPcutpoolGetCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetCuts(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetCuts", cutpool);
            }
            return (MemorySegment)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetNCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetNCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcutpoolGetNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetNCuts$descriptor() {
        return SCIPcutpoolGetNCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcutpoolGetNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetNCuts$handle() {
        return SCIPcutpoolGetNCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcutpoolGetNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetNCuts$address() {
        return SCIPcutpoolGetNCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcutpoolGetNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static int SCIPcutpoolGetNCuts(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetNCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetNCuts", cutpool);
            }
            return (int)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetMaxNCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetMaxNCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetMaxNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetMaxNCuts$descriptor() {
        return SCIPcutpoolGetMaxNCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetMaxNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetMaxNCuts$handle() {
        return SCIPcutpoolGetMaxNCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetMaxNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetMaxNCuts$address() {
        return SCIPcutpoolGetMaxNCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutpoolGetMaxNCuts(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static long SCIPcutpoolGetMaxNCuts(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetMaxNCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetMaxNCuts", cutpool);
            }
            return (long)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcutpoolGetTime(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetTime$descriptor() {
        return SCIPcutpoolGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcutpoolGetTime(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetTime$handle() {
        return SCIPcutpoolGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcutpoolGetTime(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetTime$address() {
        return SCIPcutpoolGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcutpoolGetTime(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static double SCIPcutpoolGetTime(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetTime", cutpool);
            }
            return (double)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetNCalls$descriptor() {
        return SCIPcutpoolGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetNCalls$handle() {
        return SCIPcutpoolGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetNCalls$address() {
        return SCIPcutpoolGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static long SCIPcutpoolGetNCalls(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetNCalls", cutpool);
            }
            return (long)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetNRootCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetNRootCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNRootCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetNRootCalls$descriptor() {
        return SCIPcutpoolGetNRootCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNRootCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetNRootCalls$handle() {
        return SCIPcutpoolGetNRootCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNRootCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetNRootCalls$address() {
        return SCIPcutpoolGetNRootCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNRootCalls(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static long SCIPcutpoolGetNRootCalls(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetNRootCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetNRootCalls", cutpool);
            }
            return (long)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsFound(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetNCutsFound$descriptor() {
        return SCIPcutpoolGetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsFound(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetNCutsFound$handle() {
        return SCIPcutpoolGetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsFound(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetNCutsFound$address() {
        return SCIPcutpoolGetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsFound(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static long SCIPcutpoolGetNCutsFound(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetNCutsFound", cutpool);
            }
            return (long)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutpoolGetNCutsAdded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutpoolGetNCutsAdded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsAdded(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static FunctionDescriptor SCIPcutpoolGetNCutsAdded$descriptor() {
        return SCIPcutpoolGetNCutsAdded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsAdded(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MethodHandle SCIPcutpoolGetNCutsAdded$handle() {
        return SCIPcutpoolGetNCutsAdded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsAdded(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static MemorySegment SCIPcutpoolGetNCutsAdded$address() {
        return SCIPcutpoolGetNCutsAdded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutpoolGetNCutsAdded(SCIP_CUTPOOL *cutpool)
     * }
     */
    public static long SCIPcutpoolGetNCutsAdded(MemorySegment cutpool) {
        var mh$ = SCIPcutpoolGetNCutsAdded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutpoolGetNCutsAdded", cutpool);
            }
            return (long)mh$.invokeExact(cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompCreate(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static FunctionDescriptor SCIPdecompCreate$descriptor() {
        return SCIPdecompCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompCreate(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static MethodHandle SCIPdecompCreate$handle() {
        return SCIPdecompCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompCreate(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static MemorySegment SCIPdecompCreate$address() {
        return SCIPdecompCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompCreate(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static int SCIPdecompCreate(MemorySegment decomp, MemorySegment blkmem, int nblocks, int original, int benderslabels) {
        var mh$ = SCIPdecompCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompCreate", decomp, blkmem, nblocks, original, benderslabels);
            }
            return (int)mh$.invokeExact(decomp, blkmem, nblocks, original, benderslabels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdecompFree(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem)
     * }
     */
    public static FunctionDescriptor SCIPdecompFree$descriptor() {
        return SCIPdecompFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdecompFree(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem)
     * }
     */
    public static MethodHandle SCIPdecompFree$handle() {
        return SCIPdecompFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdecompFree(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem)
     * }
     */
    public static MemorySegment SCIPdecompFree$address() {
        return SCIPdecompFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdecompFree(SCIP_DECOMP **decomp, BMS_BLKMEM *blkmem)
     * }
     */
    public static void SCIPdecompFree(MemorySegment decomp, MemorySegment blkmem) {
        var mh$ = SCIPdecompFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompFree", decomp, blkmem);
            }
            mh$.invokeExact(decomp, blkmem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompIsOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompIsOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompIsOriginal(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompIsOriginal$descriptor() {
        return SCIPdecompIsOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompIsOriginal(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompIsOriginal$handle() {
        return SCIPdecompIsOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompIsOriginal(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompIsOriginal$address() {
        return SCIPdecompIsOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdecompIsOriginal(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompIsOriginal(MemorySegment decomp) {
        var mh$ = SCIPdecompIsOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompIsOriginal", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompSetUseBendersLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompSetUseBendersLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdecompSetUseBendersLabels(SCIP_DECOMP *decomp, unsigned int benderslabels)
     * }
     */
    public static FunctionDescriptor SCIPdecompSetUseBendersLabels$descriptor() {
        return SCIPdecompSetUseBendersLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdecompSetUseBendersLabels(SCIP_DECOMP *decomp, unsigned int benderslabels)
     * }
     */
    public static MethodHandle SCIPdecompSetUseBendersLabels$handle() {
        return SCIPdecompSetUseBendersLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdecompSetUseBendersLabels(SCIP_DECOMP *decomp, unsigned int benderslabels)
     * }
     */
    public static MemorySegment SCIPdecompSetUseBendersLabels$address() {
        return SCIPdecompSetUseBendersLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdecompSetUseBendersLabels(SCIP_DECOMP *decomp, unsigned int benderslabels)
     * }
     */
    public static void SCIPdecompSetUseBendersLabels(MemorySegment decomp, int benderslabels) {
        var mh$ = SCIPdecompSetUseBendersLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompSetUseBendersLabels", decomp, benderslabels);
            }
            mh$.invokeExact(decomp, benderslabels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompUseBendersLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompUseBendersLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompUseBendersLabels(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompUseBendersLabels$descriptor() {
        return SCIPdecompUseBendersLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompUseBendersLabels(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompUseBendersLabels$handle() {
        return SCIPdecompUseBendersLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdecompUseBendersLabels(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompUseBendersLabels$address() {
        return SCIPdecompUseBendersLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdecompUseBendersLabels(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompUseBendersLabels(MemorySegment decomp) {
        var mh$ = SCIPdecompUseBendersLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompUseBendersLabels", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBlocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBlocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlocks(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBlocks$descriptor() {
        return SCIPdecompGetNBlocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlocks(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBlocks$handle() {
        return SCIPdecompGetNBlocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlocks(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBlocks$address() {
        return SCIPdecompGetNBlocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBlocks(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBlocks(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBlocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBlocks", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetAreaScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetAreaScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdecompGetAreaScore(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetAreaScore$descriptor() {
        return SCIPdecompGetAreaScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdecompGetAreaScore(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetAreaScore$handle() {
        return SCIPdecompGetAreaScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdecompGetAreaScore(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetAreaScore$address() {
        return SCIPdecompGetAreaScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdecompGetAreaScore(SCIP_DECOMP *decomp)
     * }
     */
    public static double SCIPdecompGetAreaScore(MemorySegment decomp) {
        var mh$ = SCIPdecompGetAreaScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetAreaScore", decomp);
            }
            return (double)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetModularity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetModularity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdecompGetModularity(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetModularity$descriptor() {
        return SCIPdecompGetModularity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdecompGetModularity(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetModularity$handle() {
        return SCIPdecompGetModularity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdecompGetModularity(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetModularity$address() {
        return SCIPdecompGetModularity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdecompGetModularity(SCIP_DECOMP *decomp)
     * }
     */
    public static double SCIPdecompGetModularity(MemorySegment decomp) {
        var mh$ = SCIPdecompGetModularity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetModularity", decomp);
            }
            return (double)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetVarsSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetVarsSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetVarsSize(SCIP_DECOMP *decomp, int *varssize, int nblocks)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetVarsSize$descriptor() {
        return SCIPdecompGetVarsSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetVarsSize(SCIP_DECOMP *decomp, int *varssize, int nblocks)
     * }
     */
    public static MethodHandle SCIPdecompGetVarsSize$handle() {
        return SCIPdecompGetVarsSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetVarsSize(SCIP_DECOMP *decomp, int *varssize, int nblocks)
     * }
     */
    public static MemorySegment SCIPdecompGetVarsSize$address() {
        return SCIPdecompGetVarsSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetVarsSize(SCIP_DECOMP *decomp, int *varssize, int nblocks)
     * }
     */
    public static int SCIPdecompGetVarsSize(MemorySegment decomp, MemorySegment varssize, int nblocks) {
        var mh$ = SCIPdecompGetVarsSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetVarsSize", decomp, varssize, nblocks);
            }
            return (int)mh$.invokeExact(decomp, varssize, nblocks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetConssSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetConssSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetConssSize(SCIP_DECOMP *decomp, int *consssize, int nblocks)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetConssSize$descriptor() {
        return SCIPdecompGetConssSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetConssSize(SCIP_DECOMP *decomp, int *consssize, int nblocks)
     * }
     */
    public static MethodHandle SCIPdecompGetConssSize$handle() {
        return SCIPdecompGetConssSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetConssSize(SCIP_DECOMP *decomp, int *consssize, int nblocks)
     * }
     */
    public static MemorySegment SCIPdecompGetConssSize$address() {
        return SCIPdecompGetConssSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompGetConssSize(SCIP_DECOMP *decomp, int *consssize, int nblocks)
     * }
     */
    public static int SCIPdecompGetConssSize(MemorySegment decomp, MemorySegment consssize, int nblocks) {
        var mh$ = SCIPdecompGetConssSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetConssSize", decomp, consssize, nblocks);
            }
            return (int)mh$.invokeExact(decomp, consssize, nblocks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBorderVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBorderVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderVars(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBorderVars$descriptor() {
        return SCIPdecompGetNBorderVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderVars(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBorderVars$handle() {
        return SCIPdecompGetNBorderVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderVars(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBorderVars$address() {
        return SCIPdecompGetNBorderVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderVars(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBorderVars(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBorderVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBorderVars", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBorderConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBorderConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderConss(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBorderConss$descriptor() {
        return SCIPdecompGetNBorderConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderConss(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBorderConss$handle() {
        return SCIPdecompGetNBorderConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderConss(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBorderConss$address() {
        return SCIPdecompGetNBorderConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBorderConss(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBorderConss(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBorderConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBorderConss", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBlockGraphEdges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBlockGraphEdges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphEdges(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBlockGraphEdges$descriptor() {
        return SCIPdecompGetNBlockGraphEdges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphEdges(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBlockGraphEdges$handle() {
        return SCIPdecompGetNBlockGraphEdges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphEdges(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBlockGraphEdges$address() {
        return SCIPdecompGetNBlockGraphEdges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphEdges(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBlockGraphEdges(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBlockGraphEdges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBlockGraphEdges", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBlockGraphComponents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBlockGraphComponents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphComponents(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBlockGraphComponents$descriptor() {
        return SCIPdecompGetNBlockGraphComponents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphComponents(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBlockGraphComponents$handle() {
        return SCIPdecompGetNBlockGraphComponents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphComponents(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBlockGraphComponents$address() {
        return SCIPdecompGetNBlockGraphComponents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphComponents(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBlockGraphComponents(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBlockGraphComponents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBlockGraphComponents", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetNBlockGraphArticulations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetNBlockGraphArticulations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphArticulations(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetNBlockGraphArticulations$descriptor() {
        return SCIPdecompGetNBlockGraphArticulations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphArticulations(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetNBlockGraphArticulations$handle() {
        return SCIPdecompGetNBlockGraphArticulations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphArticulations(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetNBlockGraphArticulations$address() {
        return SCIPdecompGetNBlockGraphArticulations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetNBlockGraphArticulations(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetNBlockGraphArticulations(MemorySegment decomp) {
        var mh$ = SCIPdecompGetNBlockGraphArticulations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetNBlockGraphArticulations", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetBlockGraphMaxDegree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetBlockGraphMaxDegree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMaxDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetBlockGraphMaxDegree$descriptor() {
        return SCIPdecompGetBlockGraphMaxDegree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMaxDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetBlockGraphMaxDegree$handle() {
        return SCIPdecompGetBlockGraphMaxDegree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMaxDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetBlockGraphMaxDegree$address() {
        return SCIPdecompGetBlockGraphMaxDegree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMaxDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetBlockGraphMaxDegree(MemorySegment decomp) {
        var mh$ = SCIPdecompGetBlockGraphMaxDegree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetBlockGraphMaxDegree", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetBlockGraphMinDegree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetBlockGraphMinDegree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMinDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetBlockGraphMinDegree$descriptor() {
        return SCIPdecompGetBlockGraphMinDegree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMinDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPdecompGetBlockGraphMinDegree$handle() {
        return SCIPdecompGetBlockGraphMinDegree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMinDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPdecompGetBlockGraphMinDegree$address() {
        return SCIPdecompGetBlockGraphMinDegree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdecompGetBlockGraphMinDegree(SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPdecompGetBlockGraphMinDegree(MemorySegment decomp) {
        var mh$ = SCIPdecompGetBlockGraphMinDegree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetBlockGraphMinDegree", decomp);
            }
            return (int)mh$.invokeExact(decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompSetVarsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompSetVarsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPdecompSetVarsLabels$descriptor() {
        return SCIPdecompSetVarsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static MethodHandle SCIPdecompSetVarsLabels$handle() {
        return SCIPdecompSetVarsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static MemorySegment SCIPdecompSetVarsLabels$address() {
        return SCIPdecompSetVarsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static int SCIPdecompSetVarsLabels(MemorySegment decomp, MemorySegment vars, MemorySegment labels, int nvars) {
        var mh$ = SCIPdecompSetVarsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompSetVarsLabels", decomp, vars, labels, nvars);
            }
            return (int)mh$.invokeExact(decomp, vars, labels, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetVarsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetVarsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdecompGetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetVarsLabels$descriptor() {
        return SCIPdecompGetVarsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdecompGetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static MethodHandle SCIPdecompGetVarsLabels$handle() {
        return SCIPdecompGetVarsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdecompGetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static MemorySegment SCIPdecompGetVarsLabels$address() {
        return SCIPdecompGetVarsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdecompGetVarsLabels(SCIP_DECOMP *decomp, SCIP_VAR **vars, int *labels, int nvars)
     * }
     */
    public static void SCIPdecompGetVarsLabels(MemorySegment decomp, MemorySegment vars, MemorySegment labels, int nvars) {
        var mh$ = SCIPdecompGetVarsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetVarsLabels", decomp, vars, labels, nvars);
            }
            mh$.invokeExact(decomp, vars, labels, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompSetConsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompSetConsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static FunctionDescriptor SCIPdecompSetConsLabels$descriptor() {
        return SCIPdecompSetConsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static MethodHandle SCIPdecompSetConsLabels$handle() {
        return SCIPdecompSetConsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static MemorySegment SCIPdecompSetConsLabels$address() {
        return SCIPdecompSetConsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompSetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static int SCIPdecompSetConsLabels(MemorySegment decomp, MemorySegment conss, MemorySegment labels, int nconss) {
        var mh$ = SCIPdecompSetConsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompSetConsLabels", decomp, conss, labels, nconss);
            }
            return (int)mh$.invokeExact(decomp, conss, labels, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompGetConsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompGetConsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdecompGetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static FunctionDescriptor SCIPdecompGetConsLabels$descriptor() {
        return SCIPdecompGetConsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdecompGetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static MethodHandle SCIPdecompGetConsLabels$handle() {
        return SCIPdecompGetConsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdecompGetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static MemorySegment SCIPdecompGetConsLabels$address() {
        return SCIPdecompGetConsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdecompGetConsLabels(SCIP_DECOMP *decomp, SCIP_CONS **conss, int *labels, int nconss)
     * }
     */
    public static void SCIPdecompGetConsLabels(MemorySegment decomp, MemorySegment conss, MemorySegment labels, int nconss) {
        var mh$ = SCIPdecompGetConsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompGetConsLabels", decomp, conss, labels, nconss);
            }
            mh$.invokeExact(decomp, conss, labels, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompClear(SCIP_DECOMP *decomp, unsigned int clearvarlabels, unsigned int clearconslabels)
     * }
     */
    public static FunctionDescriptor SCIPdecompClear$descriptor() {
        return SCIPdecompClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompClear(SCIP_DECOMP *decomp, unsigned int clearvarlabels, unsigned int clearconslabels)
     * }
     */
    public static MethodHandle SCIPdecompClear$handle() {
        return SCIPdecompClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompClear(SCIP_DECOMP *decomp, unsigned int clearvarlabels, unsigned int clearconslabels)
     * }
     */
    public static MemorySegment SCIPdecompClear$address() {
        return SCIPdecompClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdecompClear(SCIP_DECOMP *decomp, unsigned int clearvarlabels, unsigned int clearconslabels)
     * }
     */
    public static int SCIPdecompClear(MemorySegment decomp, int clearvarlabels, int clearconslabels) {
        var mh$ = SCIPdecompClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompClear", decomp, clearvarlabels, clearconslabels);
            }
            return (int)mh$.invokeExact(decomp, clearvarlabels, clearconslabels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdecompPrintStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdecompPrintStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPdecompPrintStats(SCIP_DECOMP *decomp, char *strbuf)
     * }
     */
    public static FunctionDescriptor SCIPdecompPrintStats$descriptor() {
        return SCIPdecompPrintStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPdecompPrintStats(SCIP_DECOMP *decomp, char *strbuf)
     * }
     */
    public static MethodHandle SCIPdecompPrintStats$handle() {
        return SCIPdecompPrintStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPdecompPrintStats(SCIP_DECOMP *decomp, char *strbuf)
     * }
     */
    public static MemorySegment SCIPdecompPrintStats$address() {
        return SCIPdecompPrintStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPdecompPrintStats(SCIP_DECOMP *decomp, char *strbuf)
     * }
     */
    public static MemorySegment SCIPdecompPrintStats(MemorySegment decomp, MemorySegment strbuf) {
        var mh$ = SCIPdecompPrintStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdecompPrintStats", decomp, strbuf);
            }
            return (MemorySegment)mh$.invokeExact(decomp, strbuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrGetRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrGetRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialoghdlrGetRoot(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrGetRoot$descriptor() {
        return SCIPdialoghdlrGetRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialoghdlrGetRoot(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MethodHandle SCIPdialoghdlrGetRoot$handle() {
        return SCIPdialoghdlrGetRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialoghdlrGetRoot(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MemorySegment SCIPdialoghdlrGetRoot$address() {
        return SCIPdialoghdlrGetRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialoghdlrGetRoot(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MemorySegment SCIPdialoghdlrGetRoot(MemorySegment dialoghdlr) {
        var mh$ = SCIPdialoghdlrGetRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrGetRoot", dialoghdlr);
            }
            return (MemorySegment)mh$.invokeExact(dialoghdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrClearBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrClearBuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdialoghdlrClearBuffer(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrClearBuffer$descriptor() {
        return SCIPdialoghdlrClearBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdialoghdlrClearBuffer(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MethodHandle SCIPdialoghdlrClearBuffer$handle() {
        return SCIPdialoghdlrClearBuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdialoghdlrClearBuffer(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MemorySegment SCIPdialoghdlrClearBuffer$address() {
        return SCIPdialoghdlrClearBuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdialoghdlrClearBuffer(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static void SCIPdialoghdlrClearBuffer(MemorySegment dialoghdlr) {
        var mh$ = SCIPdialoghdlrClearBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrClearBuffer", dialoghdlr);
            }
            mh$.invokeExact(dialoghdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrIsBufferEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrIsBufferEmpty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdialoghdlrIsBufferEmpty(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrIsBufferEmpty$descriptor() {
        return SCIPdialoghdlrIsBufferEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdialoghdlrIsBufferEmpty(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MethodHandle SCIPdialoghdlrIsBufferEmpty$handle() {
        return SCIPdialoghdlrIsBufferEmpty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdialoghdlrIsBufferEmpty(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static MemorySegment SCIPdialoghdlrIsBufferEmpty$address() {
        return SCIPdialoghdlrIsBufferEmpty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdialoghdlrIsBufferEmpty(SCIP_DIALOGHDLR *dialoghdlr)
     * }
     */
    public static int SCIPdialoghdlrIsBufferEmpty(MemorySegment dialoghdlr) {
        var mh$ = SCIPdialoghdlrIsBufferEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrIsBufferEmpty", dialoghdlr);
            }
            return (int)mh$.invokeExact(dialoghdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrGetLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrGetLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetLine(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputline, unsigned int *endoffile)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrGetLine$descriptor() {
        return SCIPdialoghdlrGetLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetLine(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputline, unsigned int *endoffile)
     * }
     */
    public static MethodHandle SCIPdialoghdlrGetLine$handle() {
        return SCIPdialoghdlrGetLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetLine(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputline, unsigned int *endoffile)
     * }
     */
    public static MemorySegment SCIPdialoghdlrGetLine$address() {
        return SCIPdialoghdlrGetLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetLine(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputline, unsigned int *endoffile)
     * }
     */
    public static int SCIPdialoghdlrGetLine(MemorySegment dialoghdlr, MemorySegment dialog, MemorySegment prompt, MemorySegment inputline, MemorySegment endoffile) {
        var mh$ = SCIPdialoghdlrGetLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrGetLine", dialoghdlr, dialog, prompt, inputline, endoffile);
            }
            return (int)mh$.invokeExact(dialoghdlr, dialog, prompt, inputline, endoffile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrGetWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrGetWord");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetWord(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputword, unsigned int *endoffile)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrGetWord$descriptor() {
        return SCIPdialoghdlrGetWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetWord(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputword, unsigned int *endoffile)
     * }
     */
    public static MethodHandle SCIPdialoghdlrGetWord$handle() {
        return SCIPdialoghdlrGetWord.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetWord(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputword, unsigned int *endoffile)
     * }
     */
    public static MemorySegment SCIPdialoghdlrGetWord$address() {
        return SCIPdialoghdlrGetWord.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrGetWord(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *prompt, char **inputword, unsigned int *endoffile)
     * }
     */
    public static int SCIPdialoghdlrGetWord(MemorySegment dialoghdlr, MemorySegment dialog, MemorySegment prompt, MemorySegment inputword, MemorySegment endoffile) {
        var mh$ = SCIPdialoghdlrGetWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrGetWord", dialoghdlr, dialog, prompt, inputword, endoffile);
            }
            return (int)mh$.invokeExact(dialoghdlr, dialog, prompt, inputword, endoffile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrAddInputLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrAddInputLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddInputLine(SCIP_DIALOGHDLR *dialoghdlr, const char *inputline)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrAddInputLine$descriptor() {
        return SCIPdialoghdlrAddInputLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddInputLine(SCIP_DIALOGHDLR *dialoghdlr, const char *inputline)
     * }
     */
    public static MethodHandle SCIPdialoghdlrAddInputLine$handle() {
        return SCIPdialoghdlrAddInputLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddInputLine(SCIP_DIALOGHDLR *dialoghdlr, const char *inputline)
     * }
     */
    public static MemorySegment SCIPdialoghdlrAddInputLine$address() {
        return SCIPdialoghdlrAddInputLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddInputLine(SCIP_DIALOGHDLR *dialoghdlr, const char *inputline)
     * }
     */
    public static int SCIPdialoghdlrAddInputLine(MemorySegment dialoghdlr, MemorySegment inputline) {
        var mh$ = SCIPdialoghdlrAddInputLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrAddInputLine", dialoghdlr, inputline);
            }
            return (int)mh$.invokeExact(dialoghdlr, inputline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialoghdlrAddHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialoghdlrAddHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddHistory(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *command, unsigned int escapecommand)
     * }
     */
    public static FunctionDescriptor SCIPdialoghdlrAddHistory$descriptor() {
        return SCIPdialoghdlrAddHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddHistory(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *command, unsigned int escapecommand)
     * }
     */
    public static MethodHandle SCIPdialoghdlrAddHistory$handle() {
        return SCIPdialoghdlrAddHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddHistory(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *command, unsigned int escapecommand)
     * }
     */
    public static MemorySegment SCIPdialoghdlrAddHistory$address() {
        return SCIPdialoghdlrAddHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialoghdlrAddHistory(SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG *dialog, const char *command, unsigned int escapecommand)
     * }
     */
    public static int SCIPdialoghdlrAddHistory(MemorySegment dialoghdlr, MemorySegment dialog, MemorySegment command, int escapecommand) {
        var mh$ = SCIPdialoghdlrAddHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialoghdlrAddHistory", dialoghdlr, dialog, command, escapecommand);
            }
            return (int)mh$.invokeExact(dialoghdlr, dialog, command, escapecommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogHasEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogHasEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogHasEntry(SCIP_DIALOG *dialog, const char *entryname)
     * }
     */
    public static FunctionDescriptor SCIPdialogHasEntry$descriptor() {
        return SCIPdialogHasEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogHasEntry(SCIP_DIALOG *dialog, const char *entryname)
     * }
     */
    public static MethodHandle SCIPdialogHasEntry$handle() {
        return SCIPdialogHasEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogHasEntry(SCIP_DIALOG *dialog, const char *entryname)
     * }
     */
    public static MemorySegment SCIPdialogHasEntry$address() {
        return SCIPdialogHasEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdialogHasEntry(SCIP_DIALOG *dialog, const char *entryname)
     * }
     */
    public static int SCIPdialogHasEntry(MemorySegment dialog, MemorySegment entryname) {
        var mh$ = SCIPdialogHasEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogHasEntry", dialog, entryname);
            }
            return (int)mh$.invokeExact(dialog, entryname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogFindEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogFindEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdialogFindEntry(SCIP_DIALOG *dialog, const char *entryname, SCIP_DIALOG **subdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogFindEntry$descriptor() {
        return SCIPdialogFindEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdialogFindEntry(SCIP_DIALOG *dialog, const char *entryname, SCIP_DIALOG **subdialog)
     * }
     */
    public static MethodHandle SCIPdialogFindEntry$handle() {
        return SCIPdialogFindEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdialogFindEntry(SCIP_DIALOG *dialog, const char *entryname, SCIP_DIALOG **subdialog)
     * }
     */
    public static MemorySegment SCIPdialogFindEntry$address() {
        return SCIPdialogFindEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdialogFindEntry(SCIP_DIALOG *dialog, const char *entryname, SCIP_DIALOG **subdialog)
     * }
     */
    public static int SCIPdialogFindEntry(MemorySegment dialog, MemorySegment entryname, MemorySegment subdialog) {
        var mh$ = SCIPdialogFindEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogFindEntry", dialog, entryname, subdialog);
            }
            return (int)mh$.invokeExact(dialog, entryname, subdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogDisplayMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogDisplayMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenu(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdialogDisplayMenu$descriptor() {
        return SCIPdialogDisplayMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenu(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdialogDisplayMenu$handle() {
        return SCIPdialogDisplayMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenu(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdialogDisplayMenu$address() {
        return SCIPdialogDisplayMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenu(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static int SCIPdialogDisplayMenu(MemorySegment dialog, MemorySegment scip) {
        var mh$ = SCIPdialogDisplayMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogDisplayMenu", dialog, scip);
            }
            return (int)mh$.invokeExact(dialog, scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogDisplayMenuEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogDisplayMenuEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenuEntry(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdialogDisplayMenuEntry$descriptor() {
        return SCIPdialogDisplayMenuEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenuEntry(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdialogDisplayMenuEntry$handle() {
        return SCIPdialogDisplayMenuEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenuEntry(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdialogDisplayMenuEntry$address() {
        return SCIPdialogDisplayMenuEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayMenuEntry(SCIP_DIALOG *dialog, SCIP *scip)
     * }
     */
    public static int SCIPdialogDisplayMenuEntry(MemorySegment dialog, MemorySegment scip) {
        var mh$ = SCIPdialogDisplayMenuEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogDisplayMenuEntry", dialog, scip);
            }
            return (int)mh$.invokeExact(dialog, scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogDisplayCompletions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogDisplayCompletions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayCompletions(SCIP_DIALOG *dialog, SCIP *scip, const char *entryname)
     * }
     */
    public static FunctionDescriptor SCIPdialogDisplayCompletions$descriptor() {
        return SCIPdialogDisplayCompletions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayCompletions(SCIP_DIALOG *dialog, SCIP *scip, const char *entryname)
     * }
     */
    public static MethodHandle SCIPdialogDisplayCompletions$handle() {
        return SCIPdialogDisplayCompletions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayCompletions(SCIP_DIALOG *dialog, SCIP *scip, const char *entryname)
     * }
     */
    public static MemorySegment SCIPdialogDisplayCompletions$address() {
        return SCIPdialogDisplayCompletions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDisplayCompletions(SCIP_DIALOG *dialog, SCIP *scip, const char *entryname)
     * }
     */
    public static int SCIPdialogDisplayCompletions(MemorySegment dialog, MemorySegment scip, MemorySegment entryname) {
        var mh$ = SCIPdialogDisplayCompletions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogDisplayCompletions", dialog, scip, entryname);
            }
            return (int)mh$.invokeExact(dialog, scip, entryname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdialogGetPath(SCIP_DIALOG *dialog, const char sepchar, char *path)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetPath$descriptor() {
        return SCIPdialogGetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdialogGetPath(SCIP_DIALOG *dialog, const char sepchar, char *path)
     * }
     */
    public static MethodHandle SCIPdialogGetPath$handle() {
        return SCIPdialogGetPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdialogGetPath(SCIP_DIALOG *dialog, const char sepchar, char *path)
     * }
     */
    public static MemorySegment SCIPdialogGetPath$address() {
        return SCIPdialogGetPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdialogGetPath(SCIP_DIALOG *dialog, const char sepchar, char *path)
     * }
     */
    public static void SCIPdialogGetPath(MemorySegment dialog, byte sepchar, MemorySegment path) {
        var mh$ = SCIPdialogGetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetPath", dialog, sepchar, path);
            }
            mh$.invokeExact(dialog, sepchar, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetName(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetName$descriptor() {
        return SCIPdialogGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetName(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetName$handle() {
        return SCIPdialogGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetName(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetName$address() {
        return SCIPdialogGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdialogGetName(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetName(MemorySegment dialog) {
        var mh$ = SCIPdialogGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetName", dialog);
            }
            return (MemorySegment)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetDesc(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetDesc$descriptor() {
        return SCIPdialogGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetDesc(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetDesc$handle() {
        return SCIPdialogGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdialogGetDesc(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetDesc$address() {
        return SCIPdialogGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdialogGetDesc(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetDesc(MemorySegment dialog) {
        var mh$ = SCIPdialogGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetDesc", dialog);
            }
            return (MemorySegment)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogIsSubmenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogIsSubmenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogIsSubmenu(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogIsSubmenu$descriptor() {
        return SCIPdialogIsSubmenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogIsSubmenu(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogIsSubmenu$handle() {
        return SCIPdialogIsSubmenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdialogIsSubmenu(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogIsSubmenu$address() {
        return SCIPdialogIsSubmenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdialogIsSubmenu(SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPdialogIsSubmenu(MemorySegment dialog) {
        var mh$ = SCIPdialogIsSubmenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogIsSubmenu", dialog);
            }
            return (int)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialogGetParent(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetParent$descriptor() {
        return SCIPdialogGetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialogGetParent(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetParent$handle() {
        return SCIPdialogGetParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialogGetParent(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetParent$address() {
        return SCIPdialogGetParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPdialogGetParent(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetParent(MemorySegment dialog) {
        var mh$ = SCIPdialogGetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetParent", dialog);
            }
            return (MemorySegment)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetSubdialogs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetSubdialogs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIALOG **SCIPdialogGetSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetSubdialogs$descriptor() {
        return SCIPdialogGetSubdialogs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIALOG **SCIPdialogGetSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetSubdialogs$handle() {
        return SCIPdialogGetSubdialogs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIALOG **SCIPdialogGetSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetSubdialogs$address() {
        return SCIPdialogGetSubdialogs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIALOG **SCIPdialogGetSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetSubdialogs(MemorySegment dialog) {
        var mh$ = SCIPdialogGetSubdialogs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetSubdialogs", dialog);
            }
            return (MemorySegment)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetNSubdialogs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetNSubdialogs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdialogGetNSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetNSubdialogs$descriptor() {
        return SCIPdialogGetNSubdialogs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdialogGetNSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetNSubdialogs$handle() {
        return SCIPdialogGetNSubdialogs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdialogGetNSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetNSubdialogs$address() {
        return SCIPdialogGetNSubdialogs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdialogGetNSubdialogs(SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPdialogGetNSubdialogs(MemorySegment dialog) {
        var mh$ = SCIPdialogGetNSubdialogs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetNSubdialogs", dialog);
            }
            return (int)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIALOGDATA *SCIPdialogGetData(SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogGetData$descriptor() {
        return SCIPdialogGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIALOGDATA *SCIPdialogGetData(SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogGetData$handle() {
        return SCIPdialogGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIALOGDATA *SCIPdialogGetData(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetData$address() {
        return SCIPdialogGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIALOGDATA *SCIPdialogGetData(SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogGetData(MemorySegment dialog) {
        var mh$ = SCIPdialogGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogGetData", dialog);
            }
            return (MemorySegment)mh$.invokeExact(dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdialogSetData(SCIP_DIALOG *dialog, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static FunctionDescriptor SCIPdialogSetData$descriptor() {
        return SCIPdialogSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdialogSetData(SCIP_DIALOG *dialog, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static MethodHandle SCIPdialogSetData$handle() {
        return SCIPdialogSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdialogSetData(SCIP_DIALOG *dialog, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static MemorySegment SCIPdialogSetData$address() {
        return SCIPdialogSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdialogSetData(SCIP_DIALOG *dialog, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static void SCIPdialogSetData(MemorySegment dialog, MemorySegment dialogdata) {
        var mh$ = SCIPdialogSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogSetData", dialog, dialogdata);
            }
            mh$.invokeExact(dialog, dialogdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogWriteHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogWriteHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogWriteHistory(const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPdialogWriteHistory$descriptor() {
        return SCIPdialogWriteHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogWriteHistory(const char *filename)
     * }
     */
    public static MethodHandle SCIPdialogWriteHistory$handle() {
        return SCIPdialogWriteHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogWriteHistory(const char *filename)
     * }
     */
    public static MemorySegment SCIPdialogWriteHistory$address() {
        return SCIPdialogWriteHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogWriteHistory(const char *filename)
     * }
     */
    public static int SCIPdialogWriteHistory(MemorySegment filename) {
        var mh$ = SCIPdialogWriteHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogWriteHistory", filename);
            }
            return (int)mh$.invokeExact(filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_VERBLEVEL_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_NONE = 0
     * }
     */
    public static int SCIP_VERBLEVEL_NONE() {
        return SCIP_VERBLEVEL_NONE;
    }
    private static final int SCIP_VERBLEVEL_DIALOG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_DIALOG = 1
     * }
     */
    public static int SCIP_VERBLEVEL_DIALOG() {
        return SCIP_VERBLEVEL_DIALOG;
    }
    private static final int SCIP_VERBLEVEL_MINIMAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_MINIMAL = 2
     * }
     */
    public static int SCIP_VERBLEVEL_MINIMAL() {
        return SCIP_VERBLEVEL_MINIMAL;
    }
    private static final int SCIP_VERBLEVEL_NORMAL = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_NORMAL = 3
     * }
     */
    public static int SCIP_VERBLEVEL_NORMAL() {
        return SCIP_VERBLEVEL_NORMAL;
    }
    private static final int SCIP_VERBLEVEL_HIGH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_HIGH = 4
     * }
     */
    public static int SCIP_VERBLEVEL_HIGH() {
        return SCIP_VERBLEVEL_HIGH;
    }
    private static final int SCIP_VERBLEVEL_FULL = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_VerbLevel.SCIP_VERBLEVEL_FULL = 5
     * }
     */
    public static int SCIP_VERBLEVEL_FULL() {
        return SCIP_VERBLEVEL_FULL;
    }

    private static class SCIPdispGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DISPDATA *SCIPdispGetData(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetData$descriptor() {
        return SCIPdispGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DISPDATA *SCIPdispGetData(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetData$handle() {
        return SCIPdispGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DISPDATA *SCIPdispGetData(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetData$address() {
        return SCIPdispGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DISPDATA *SCIPdispGetData(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetData(MemorySegment disp) {
        var mh$ = SCIPdispGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetData", disp);
            }
            return (MemorySegment)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdispSetData(SCIP_DISP *disp, SCIP_DISPDATA *dispdata)
     * }
     */
    public static FunctionDescriptor SCIPdispSetData$descriptor() {
        return SCIPdispSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdispSetData(SCIP_DISP *disp, SCIP_DISPDATA *dispdata)
     * }
     */
    public static MethodHandle SCIPdispSetData$handle() {
        return SCIPdispSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdispSetData(SCIP_DISP *disp, SCIP_DISPDATA *dispdata)
     * }
     */
    public static MemorySegment SCIPdispSetData$address() {
        return SCIPdispSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdispSetData(SCIP_DISP *disp, SCIP_DISPDATA *dispdata)
     * }
     */
    public static void SCIPdispSetData(MemorySegment disp, MemorySegment dispdata) {
        var mh$ = SCIPdispSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispSetData", disp, dispdata);
            }
            mh$.invokeExact(disp, dispdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdispGetName(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetName$descriptor() {
        return SCIPdispGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdispGetName(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetName$handle() {
        return SCIPdispGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdispGetName(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetName$address() {
        return SCIPdispGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdispGetName(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetName(MemorySegment disp) {
        var mh$ = SCIPdispGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetName", disp);
            }
            return (MemorySegment)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdispGetDesc(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetDesc$descriptor() {
        return SCIPdispGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdispGetDesc(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetDesc$handle() {
        return SCIPdispGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdispGetDesc(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetDesc$address() {
        return SCIPdispGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdispGetDesc(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetDesc(MemorySegment disp) {
        var mh$ = SCIPdispGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetDesc", disp);
            }
            return (MemorySegment)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetHeader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdispGetHeader(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetHeader$descriptor() {
        return SCIPdispGetHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdispGetHeader(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetHeader$handle() {
        return SCIPdispGetHeader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdispGetHeader(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetHeader$address() {
        return SCIPdispGetHeader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdispGetHeader(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetHeader(MemorySegment disp) {
        var mh$ = SCIPdispGetHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetHeader", disp);
            }
            return (MemorySegment)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdispGetWidth(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetWidth$descriptor() {
        return SCIPdispGetWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdispGetWidth(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetWidth$handle() {
        return SCIPdispGetWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdispGetWidth(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetWidth$address() {
        return SCIPdispGetWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdispGetWidth(SCIP_DISP *disp)
     * }
     */
    public static int SCIPdispGetWidth(MemorySegment disp) {
        var mh$ = SCIPdispGetWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetWidth", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdispGetPriority(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetPriority$descriptor() {
        return SCIPdispGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdispGetPriority(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetPriority$handle() {
        return SCIPdispGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdispGetPriority(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetPriority$address() {
        return SCIPdispGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdispGetPriority(SCIP_DISP *disp)
     * }
     */
    public static int SCIPdispGetPriority(MemorySegment disp) {
        var mh$ = SCIPdispGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetPriority", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdispGetPosition(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetPosition$descriptor() {
        return SCIPdispGetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdispGetPosition(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetPosition$handle() {
        return SCIPdispGetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdispGetPosition(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetPosition$address() {
        return SCIPdispGetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdispGetPosition(SCIP_DISP *disp)
     * }
     */
    public static int SCIPdispGetPosition(MemorySegment disp) {
        var mh$ = SCIPdispGetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetPosition", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispGetStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispGetStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DISPSTATUS SCIPdispGetStatus(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispGetStatus$descriptor() {
        return SCIPdispGetStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DISPSTATUS SCIPdispGetStatus(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispGetStatus$handle() {
        return SCIPdispGetStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DISPSTATUS SCIPdispGetStatus(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispGetStatus$address() {
        return SCIPdispGetStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DISPSTATUS SCIPdispGetStatus(SCIP_DISP *disp)
     * }
     */
    public static int SCIPdispGetStatus(MemorySegment disp) {
        var mh$ = SCIPdispGetStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispGetStatus", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdispIsInitialized(SCIP_DISP *disp)
     * }
     */
    public static FunctionDescriptor SCIPdispIsInitialized$descriptor() {
        return SCIPdispIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdispIsInitialized(SCIP_DISP *disp)
     * }
     */
    public static MethodHandle SCIPdispIsInitialized$handle() {
        return SCIPdispIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdispIsInitialized(SCIP_DISP *disp)
     * }
     */
    public static MemorySegment SCIPdispIsInitialized$address() {
        return SCIPdispIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdispIsInitialized(SCIP_DISP *disp)
     * }
     */
    public static int SCIPdispIsInitialized(MemorySegment disp) {
        var mh$ = SCIPdispIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispIsInitialized", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispLongint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispLongint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdispLongint(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, long long val, int width)
     * }
     */
    public static FunctionDescriptor SCIPdispLongint$descriptor() {
        return SCIPdispLongint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdispLongint(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, long long val, int width)
     * }
     */
    public static MethodHandle SCIPdispLongint$handle() {
        return SCIPdispLongint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdispLongint(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, long long val, int width)
     * }
     */
    public static MemorySegment SCIPdispLongint$address() {
        return SCIPdispLongint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdispLongint(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, long long val, int width)
     * }
     */
    public static void SCIPdispLongint(MemorySegment messagehdlr, MemorySegment file, long val, int width) {
        var mh$ = SCIPdispLongint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispLongint", messagehdlr, file, val, width);
            }
            mh$.invokeExact(messagehdlr, file, val, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdispInt(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, int val, int width)
     * }
     */
    public static FunctionDescriptor SCIPdispInt$descriptor() {
        return SCIPdispInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdispInt(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, int val, int width)
     * }
     */
    public static MethodHandle SCIPdispInt$handle() {
        return SCIPdispInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdispInt(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, int val, int width)
     * }
     */
    public static MemorySegment SCIPdispInt$address() {
        return SCIPdispInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdispInt(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, int val, int width)
     * }
     */
    public static void SCIPdispInt(MemorySegment messagehdlr, MemorySegment file, int val, int width) {
        var mh$ = SCIPdispInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispInt", messagehdlr, file, val, width);
            }
            mh$.invokeExact(messagehdlr, file, val, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdispTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdispTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdispTime(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, double val, int width)
     * }
     */
    public static FunctionDescriptor SCIPdispTime$descriptor() {
        return SCIPdispTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdispTime(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, double val, int width)
     * }
     */
    public static MethodHandle SCIPdispTime$handle() {
        return SCIPdispTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdispTime(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, double val, int width)
     * }
     */
    public static MemorySegment SCIPdispTime$address() {
        return SCIPdispTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdispTime(SCIP_MESSAGEHDLR *messagehdlr, FILE *file, double val, int width)
     * }
     */
    public static void SCIPdispTime(MemorySegment messagehdlr, MemorySegment file, double val, int width) {
        var mh$ = SCIPdispTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdispTime", messagehdlr, file, val, width);
            }
            mh$.invokeExact(messagehdlr, file, val, width);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPeventhdlrGetName(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrGetName$descriptor() {
        return SCIPeventhdlrGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPeventhdlrGetName(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MethodHandle SCIPeventhdlrGetName$handle() {
        return SCIPeventhdlrGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPeventhdlrGetName(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetName$address() {
        return SCIPeventhdlrGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPeventhdlrGetName(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetName(MemorySegment eventhdlr) {
        var mh$ = SCIPeventhdlrGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrGetName", eventhdlr);
            }
            return (MemorySegment)mh$.invokeExact(eventhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLRDATA *SCIPeventhdlrGetData(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrGetData$descriptor() {
        return SCIPeventhdlrGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLRDATA *SCIPeventhdlrGetData(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MethodHandle SCIPeventhdlrGetData$handle() {
        return SCIPeventhdlrGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLRDATA *SCIPeventhdlrGetData(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetData$address() {
        return SCIPeventhdlrGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EVENTHDLRDATA *SCIPeventhdlrGetData(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetData(MemorySegment eventhdlr) {
        var mh$ = SCIPeventhdlrGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrGetData", eventhdlr);
            }
            return (MemorySegment)mh$.invokeExact(eventhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPeventhdlrSetData(SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrSetData$descriptor() {
        return SCIPeventhdlrSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPeventhdlrSetData(SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MethodHandle SCIPeventhdlrSetData$handle() {
        return SCIPeventhdlrSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPeventhdlrSetData(SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MemorySegment SCIPeventhdlrSetData$address() {
        return SCIPeventhdlrSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPeventhdlrSetData(SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static void SCIPeventhdlrSetData(MemorySegment eventhdlr, MemorySegment eventhdlrdata) {
        var mh$ = SCIPeventhdlrSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrSetData", eventhdlr, eventhdlrdata);
            }
            mh$.invokeExact(eventhdlr, eventhdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPeventhdlrIsInitialized(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrIsInitialized$descriptor() {
        return SCIPeventhdlrIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPeventhdlrIsInitialized(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MethodHandle SCIPeventhdlrIsInitialized$handle() {
        return SCIPeventhdlrIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPeventhdlrIsInitialized(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrIsInitialized$address() {
        return SCIPeventhdlrIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPeventhdlrIsInitialized(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static int SCIPeventhdlrIsInitialized(MemorySegment eventhdlr) {
        var mh$ = SCIPeventhdlrIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrIsInitialized", eventhdlr);
            }
            return (int)mh$.invokeExact(eventhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetSetupTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrGetSetupTime$descriptor() {
        return SCIPeventhdlrGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetSetupTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MethodHandle SCIPeventhdlrGetSetupTime$handle() {
        return SCIPeventhdlrGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetSetupTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetSetupTime$address() {
        return SCIPeventhdlrGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventhdlrGetSetupTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static double SCIPeventhdlrGetSetupTime(MemorySegment eventhdlr) {
        var mh$ = SCIPeventhdlrGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrGetSetupTime", eventhdlr);
            }
            return (double)mh$.invokeExact(eventhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventhdlrGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventhdlrGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static FunctionDescriptor SCIPeventhdlrGetTime$descriptor() {
        return SCIPeventhdlrGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MethodHandle SCIPeventhdlrGetTime$handle() {
        return SCIPeventhdlrGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventhdlrGetTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static MemorySegment SCIPeventhdlrGetTime$address() {
        return SCIPeventhdlrGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventhdlrGetTime(SCIP_EVENTHDLR *eventhdlr)
     * }
     */
    public static double SCIPeventhdlrGetTime(MemorySegment eventhdlr) {
        var mh$ = SCIPeventhdlrGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventhdlrGetTime", eventhdlr);
            }
            return (double)mh$.invokeExact(eventhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EVENTTYPE SCIPeventGetType(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetType$descriptor() {
        return SCIPeventGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EVENTTYPE SCIPeventGetType(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetType$handle() {
        return SCIPeventGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EVENTTYPE SCIPeventGetType(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetType$address() {
        return SCIPeventGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EVENTTYPE SCIPeventGetType(SCIP_EVENT *event)
     * }
     */
    public static long SCIPeventGetType(MemorySegment event) {
        var mh$ = SCIPeventGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetType", event);
            }
            return (long)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPeventGetVar(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetVar$descriptor() {
        return SCIPeventGetVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPeventGetVar(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetVar$handle() {
        return SCIPeventGetVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPeventGetVar(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetVar$address() {
        return SCIPeventGetVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPeventGetVar(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetVar(MemorySegment event) {
        var mh$ = SCIPeventGetVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetVar", event);
            }
            return (MemorySegment)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetOldobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetOldobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetOldobj(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetOldobj$descriptor() {
        return SCIPeventGetOldobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetOldobj(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetOldobj$handle() {
        return SCIPeventGetOldobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetOldobj(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetOldobj$address() {
        return SCIPeventGetOldobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetOldobj(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetOldobj(MemorySegment event) {
        var mh$ = SCIPeventGetOldobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetOldobj", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetNewobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetNewobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetNewobj(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetNewobj$descriptor() {
        return SCIPeventGetNewobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetNewobj(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetNewobj$handle() {
        return SCIPeventGetNewobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetNewobj(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetNewobj$address() {
        return SCIPeventGetNewobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetNewobj(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetNewobj(MemorySegment event) {
        var mh$ = SCIPeventGetNewobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetNewobj", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetOldbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetOldbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetOldbound(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetOldbound$descriptor() {
        return SCIPeventGetOldbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetOldbound(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetOldbound$handle() {
        return SCIPeventGetOldbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetOldbound(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetOldbound$address() {
        return SCIPeventGetOldbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetOldbound(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetOldbound(MemorySegment event) {
        var mh$ = SCIPeventGetOldbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetOldbound", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetNewbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetNewbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetNewbound(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetNewbound$descriptor() {
        return SCIPeventGetNewbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetNewbound(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetNewbound$handle() {
        return SCIPeventGetNewbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetNewbound(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetNewbound$address() {
        return SCIPeventGetNewbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetNewbound(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetNewbound(MemorySegment event) {
        var mh$ = SCIPeventGetNewbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetNewbound", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetOldtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetOldtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetOldtype(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetOldtype$descriptor() {
        return SCIPeventGetOldtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetOldtype(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetOldtype$handle() {
        return SCIPeventGetOldtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetOldtype(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetOldtype$address() {
        return SCIPeventGetOldtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetOldtype(SCIP_EVENT *event)
     * }
     */
    public static int SCIPeventGetOldtype(MemorySegment event) {
        var mh$ = SCIPeventGetOldtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetOldtype", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetNewtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetNewtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetNewtype(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetNewtype$descriptor() {
        return SCIPeventGetNewtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetNewtype(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetNewtype$handle() {
        return SCIPeventGetNewtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetNewtype(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetNewtype$address() {
        return SCIPeventGetNewtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPeventGetNewtype(SCIP_EVENT *event)
     * }
     */
    public static int SCIPeventGetNewtype(MemorySegment event) {
        var mh$ = SCIPeventGetNewtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetNewtype", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPeventGetNode(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetNode$descriptor() {
        return SCIPeventGetNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPeventGetNode(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetNode$handle() {
        return SCIPeventGetNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPeventGetNode(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetNode$address() {
        return SCIPeventGetNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPeventGetNode(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetNode(MemorySegment event) {
        var mh$ = SCIPeventGetNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetNode", event);
            }
            return (MemorySegment)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPeventGetSol(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetSol$descriptor() {
        return SCIPeventGetSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPeventGetSol(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetSol$handle() {
        return SCIPeventGetSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPeventGetSol(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetSol$address() {
        return SCIPeventGetSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL *SCIPeventGetSol(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetSol(MemorySegment event) {
        var mh$ = SCIPeventGetSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetSol", event);
            }
            return (MemorySegment)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetHoleLeft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetHoleLeft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleLeft(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetHoleLeft$descriptor() {
        return SCIPeventGetHoleLeft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleLeft(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetHoleLeft$handle() {
        return SCIPeventGetHoleLeft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleLeft(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetHoleLeft$address() {
        return SCIPeventGetHoleLeft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetHoleLeft(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetHoleLeft(MemorySegment event) {
        var mh$ = SCIPeventGetHoleLeft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetHoleLeft", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetHoleRight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetHoleRight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleRight(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetHoleRight$descriptor() {
        return SCIPeventGetHoleRight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleRight(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetHoleRight$handle() {
        return SCIPeventGetHoleRight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetHoleRight(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetHoleRight$address() {
        return SCIPeventGetHoleRight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetHoleRight(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetHoleRight(MemorySegment event) {
        var mh$ = SCIPeventGetHoleRight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetHoleRight", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPeventGetRow(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRow$descriptor() {
        return SCIPeventGetRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPeventGetRow(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRow$handle() {
        return SCIPeventGetRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPeventGetRow(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRow$address() {
        return SCIPeventGetRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPeventGetRow(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRow(MemorySegment event) {
        var mh$ = SCIPeventGetRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRow", event);
            }
            return (MemorySegment)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowCol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowCol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPeventGetRowCol(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowCol$descriptor() {
        return SCIPeventGetRowCol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPeventGetRowCol(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowCol$handle() {
        return SCIPeventGetRowCol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPeventGetRowCol(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowCol$address() {
        return SCIPeventGetRowCol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COL *SCIPeventGetRowCol(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowCol(MemorySegment event) {
        var mh$ = SCIPeventGetRowCol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowCol", event);
            }
            return (MemorySegment)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowOldCoefVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowOldCoefVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldCoefVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowOldCoefVal$descriptor() {
        return SCIPeventGetRowOldCoefVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldCoefVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowOldCoefVal$handle() {
        return SCIPeventGetRowOldCoefVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldCoefVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowOldCoefVal$address() {
        return SCIPeventGetRowOldCoefVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowOldCoefVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowOldCoefVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowOldCoefVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowOldCoefVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowNewCoefVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowNewCoefVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewCoefVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowNewCoefVal$descriptor() {
        return SCIPeventGetRowNewCoefVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewCoefVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowNewCoefVal$handle() {
        return SCIPeventGetRowNewCoefVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewCoefVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowNewCoefVal$address() {
        return SCIPeventGetRowNewCoefVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowNewCoefVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowNewCoefVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowNewCoefVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowNewCoefVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowOldConstVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowOldConstVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldConstVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowOldConstVal$descriptor() {
        return SCIPeventGetRowOldConstVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldConstVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowOldConstVal$handle() {
        return SCIPeventGetRowOldConstVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldConstVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowOldConstVal$address() {
        return SCIPeventGetRowOldConstVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowOldConstVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowOldConstVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowOldConstVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowOldConstVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowNewConstVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowNewConstVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewConstVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowNewConstVal$descriptor() {
        return SCIPeventGetRowNewConstVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewConstVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowNewConstVal$handle() {
        return SCIPeventGetRowNewConstVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewConstVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowNewConstVal$address() {
        return SCIPeventGetRowNewConstVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowNewConstVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowNewConstVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowNewConstVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowNewConstVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowSide {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowSide");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SIDETYPE SCIPeventGetRowSide(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowSide$descriptor() {
        return SCIPeventGetRowSide.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SIDETYPE SCIPeventGetRowSide(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowSide$handle() {
        return SCIPeventGetRowSide.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SIDETYPE SCIPeventGetRowSide(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowSide$address() {
        return SCIPeventGetRowSide.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SIDETYPE SCIPeventGetRowSide(SCIP_EVENT *event)
     * }
     */
    public static int SCIPeventGetRowSide(MemorySegment event) {
        var mh$ = SCIPeventGetRowSide.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowSide", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowOldSideVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowOldSideVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldSideVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowOldSideVal$descriptor() {
        return SCIPeventGetRowOldSideVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldSideVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowOldSideVal$handle() {
        return SCIPeventGetRowOldSideVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowOldSideVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowOldSideVal$address() {
        return SCIPeventGetRowOldSideVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowOldSideVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowOldSideVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowOldSideVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowOldSideVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPeventGetRowNewSideVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPeventGetRowNewSideVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewSideVal(SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPeventGetRowNewSideVal$descriptor() {
        return SCIPeventGetRowNewSideVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewSideVal(SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPeventGetRowNewSideVal$handle() {
        return SCIPeventGetRowNewSideVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPeventGetRowNewSideVal(SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPeventGetRowNewSideVal$address() {
        return SCIPeventGetRowNewSideVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPeventGetRowNewSideVal(SCIP_EVENT *event)
     * }
     */
    public static double SCIPeventGetRowNewSideVal(MemorySegment event) {
        var mh$ = SCIPeventGetRowNewSideVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPeventGetRowNewSideVal", event);
            }
            return (double)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetCopyFreeHdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetCopyFreeHdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeHdlr(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copyhdlr)(SCIP *, SCIP_EXPRHDLR *), SCIP_RETCODE (*freehdlr)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRHDLRDATA **))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetCopyFreeHdlr$descriptor() {
        return SCIPexprhdlrSetCopyFreeHdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeHdlr(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copyhdlr)(SCIP *, SCIP_EXPRHDLR *), SCIP_RETCODE (*freehdlr)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRHDLRDATA **))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetCopyFreeHdlr$handle() {
        return SCIPexprhdlrSetCopyFreeHdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeHdlr(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copyhdlr)(SCIP *, SCIP_EXPRHDLR *), SCIP_RETCODE (*freehdlr)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRHDLRDATA **))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetCopyFreeHdlr$address() {
        return SCIPexprhdlrSetCopyFreeHdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeHdlr(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copyhdlr)(SCIP *, SCIP_EXPRHDLR *), SCIP_RETCODE (*freehdlr)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRHDLRDATA **))
     * }
     */
    public static void SCIPexprhdlrSetCopyFreeHdlr(MemorySegment exprhdlr, MemorySegment copyhdlr, MemorySegment freehdlr) {
        var mh$ = SCIPexprhdlrSetCopyFreeHdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetCopyFreeHdlr", exprhdlr, copyhdlr, freehdlr);
            }
            mh$.invokeExact(exprhdlr, copyhdlr, freehdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetCopyFreeData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetCopyFreeData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeData(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copydata)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRDATA **, SCIP *, SCIP_EXPR *), SCIP_RETCODE (*freedata)(SCIP *, SCIP_EXPR *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetCopyFreeData$descriptor() {
        return SCIPexprhdlrSetCopyFreeData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeData(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copydata)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRDATA **, SCIP *, SCIP_EXPR *), SCIP_RETCODE (*freedata)(SCIP *, SCIP_EXPR *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetCopyFreeData$handle() {
        return SCIPexprhdlrSetCopyFreeData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeData(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copydata)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRDATA **, SCIP *, SCIP_EXPR *), SCIP_RETCODE (*freedata)(SCIP *, SCIP_EXPR *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetCopyFreeData$address() {
        return SCIPexprhdlrSetCopyFreeData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCopyFreeData(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*copydata)(SCIP *, SCIP_EXPRHDLR *, SCIP_EXPRDATA **, SCIP *, SCIP_EXPR *), SCIP_RETCODE (*freedata)(SCIP *, SCIP_EXPR *))
     * }
     */
    public static void SCIPexprhdlrSetCopyFreeData(MemorySegment exprhdlr, MemorySegment copydata, MemorySegment freedata) {
        var mh$ = SCIPexprhdlrSetCopyFreeData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetCopyFreeData", exprhdlr, copydata, freedata);
            }
            mh$.invokeExact(exprhdlr, copydata, freedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetPrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetPrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetPrint(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*print)(SCIP *, SCIP_EXPR *, SCIP_EXPRITER_STAGE, int, unsigned int, FILE *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetPrint$descriptor() {
        return SCIPexprhdlrSetPrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetPrint(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*print)(SCIP *, SCIP_EXPR *, SCIP_EXPRITER_STAGE, int, unsigned int, FILE *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetPrint$handle() {
        return SCIPexprhdlrSetPrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetPrint(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*print)(SCIP *, SCIP_EXPR *, SCIP_EXPRITER_STAGE, int, unsigned int, FILE *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetPrint$address() {
        return SCIPexprhdlrSetPrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetPrint(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*print)(SCIP *, SCIP_EXPR *, SCIP_EXPRITER_STAGE, int, unsigned int, FILE *))
     * }
     */
    public static void SCIPexprhdlrSetPrint(MemorySegment exprhdlr, MemorySegment print) {
        var mh$ = SCIPexprhdlrSetPrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetPrint", exprhdlr, print);
            }
            mh$.invokeExact(exprhdlr, print);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetParse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetParse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetParse(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*parse)(SCIP *, SCIP_EXPRHDLR *, const char *, const char **, SCIP_EXPR **, unsigned int *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetParse$descriptor() {
        return SCIPexprhdlrSetParse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetParse(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*parse)(SCIP *, SCIP_EXPRHDLR *, const char *, const char **, SCIP_EXPR **, unsigned int *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetParse$handle() {
        return SCIPexprhdlrSetParse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetParse(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*parse)(SCIP *, SCIP_EXPRHDLR *, const char *, const char **, SCIP_EXPR **, unsigned int *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetParse$address() {
        return SCIPexprhdlrSetParse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetParse(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*parse)(SCIP *, SCIP_EXPRHDLR *, const char *, const char **, SCIP_EXPR **, unsigned int *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static void SCIPexprhdlrSetParse(MemorySegment exprhdlr, MemorySegment parse) {
        var mh$ = SCIPexprhdlrSetParse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetParse", exprhdlr, parse);
            }
            mh$.invokeExact(exprhdlr, parse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCurvature(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*curvature)(SCIP *, SCIP_EXPR *, SCIP_EXPRCURV, unsigned int *, SCIP_EXPRCURV *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetCurvature$descriptor() {
        return SCIPexprhdlrSetCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCurvature(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*curvature)(SCIP *, SCIP_EXPR *, SCIP_EXPRCURV, unsigned int *, SCIP_EXPRCURV *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetCurvature$handle() {
        return SCIPexprhdlrSetCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCurvature(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*curvature)(SCIP *, SCIP_EXPR *, SCIP_EXPRCURV, unsigned int *, SCIP_EXPRCURV *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetCurvature$address() {
        return SCIPexprhdlrSetCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCurvature(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*curvature)(SCIP *, SCIP_EXPR *, SCIP_EXPRCURV, unsigned int *, SCIP_EXPRCURV *))
     * }
     */
    public static void SCIPexprhdlrSetCurvature(MemorySegment exprhdlr, MemorySegment curvature) {
        var mh$ = SCIPexprhdlrSetCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetCurvature", exprhdlr, curvature);
            }
            mh$.invokeExact(exprhdlr, curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetMonotonicity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetMonotonicity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetMonotonicity(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*monotonicity)(SCIP *, SCIP_EXPR *, int, SCIP_MONOTONE *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetMonotonicity$descriptor() {
        return SCIPexprhdlrSetMonotonicity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetMonotonicity(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*monotonicity)(SCIP *, SCIP_EXPR *, int, SCIP_MONOTONE *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetMonotonicity$handle() {
        return SCIPexprhdlrSetMonotonicity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetMonotonicity(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*monotonicity)(SCIP *, SCIP_EXPR *, int, SCIP_MONOTONE *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetMonotonicity$address() {
        return SCIPexprhdlrSetMonotonicity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetMonotonicity(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*monotonicity)(SCIP *, SCIP_EXPR *, int, SCIP_MONOTONE *))
     * }
     */
    public static void SCIPexprhdlrSetMonotonicity(MemorySegment exprhdlr, MemorySegment monotonicity) {
        var mh$ = SCIPexprhdlrSetMonotonicity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetMonotonicity", exprhdlr, monotonicity);
            }
            mh$.invokeExact(exprhdlr, monotonicity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetIntegrality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetIntegrality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntegrality(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*integrality)(SCIP *, SCIP_EXPR *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetIntegrality$descriptor() {
        return SCIPexprhdlrSetIntegrality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntegrality(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*integrality)(SCIP *, SCIP_EXPR *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetIntegrality$handle() {
        return SCIPexprhdlrSetIntegrality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntegrality(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*integrality)(SCIP *, SCIP_EXPR *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetIntegrality$address() {
        return SCIPexprhdlrSetIntegrality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntegrality(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*integrality)(SCIP *, SCIP_EXPR *, unsigned int *))
     * }
     */
    public static void SCIPexprhdlrSetIntegrality(MemorySegment exprhdlr, MemorySegment integrality) {
        var mh$ = SCIPexprhdlrSetIntegrality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetIntegrality", exprhdlr, integrality);
            }
            mh$.invokeExact(exprhdlr, integrality);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetHash(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*hash)(SCIP *, SCIP_EXPR *, unsigned int *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetHash$descriptor() {
        return SCIPexprhdlrSetHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetHash(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*hash)(SCIP *, SCIP_EXPR *, unsigned int *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetHash$handle() {
        return SCIPexprhdlrSetHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetHash(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*hash)(SCIP *, SCIP_EXPR *, unsigned int *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetHash$address() {
        return SCIPexprhdlrSetHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetHash(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*hash)(SCIP *, SCIP_EXPR *, unsigned int *, unsigned int *))
     * }
     */
    public static void SCIPexprhdlrSetHash(MemorySegment exprhdlr, MemorySegment hash) {
        var mh$ = SCIPexprhdlrSetHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetHash", exprhdlr, hash);
            }
            mh$.invokeExact(exprhdlr, hash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCompare(SCIP_EXPRHDLR *exprhdlr, int (*compare)(SCIP *, SCIP_EXPR *, SCIP_EXPR *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetCompare$descriptor() {
        return SCIPexprhdlrSetCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCompare(SCIP_EXPRHDLR *exprhdlr, int (*compare)(SCIP *, SCIP_EXPR *, SCIP_EXPR *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetCompare$handle() {
        return SCIPexprhdlrSetCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCompare(SCIP_EXPRHDLR *exprhdlr, int (*compare)(SCIP *, SCIP_EXPR *, SCIP_EXPR *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetCompare$address() {
        return SCIPexprhdlrSetCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetCompare(SCIP_EXPRHDLR *exprhdlr, int (*compare)(SCIP *, SCIP_EXPR *, SCIP_EXPR *))
     * }
     */
    public static void SCIPexprhdlrSetCompare(MemorySegment exprhdlr, MemorySegment compare) {
        var mh$ = SCIPexprhdlrSetCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetCompare", exprhdlr, compare);
            }
            mh$.invokeExact(exprhdlr, compare);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetDiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetDiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetDiff(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*bwdiff)(SCIP *, SCIP_EXPR *, int, double *), SCIP_RETCODE (*fwdiff)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_RETCODE (*bwfwdiff)(SCIP *, SCIP_EXPR *, int, double *, SCIP_SOL *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetDiff$descriptor() {
        return SCIPexprhdlrSetDiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetDiff(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*bwdiff)(SCIP *, SCIP_EXPR *, int, double *), SCIP_RETCODE (*fwdiff)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_RETCODE (*bwfwdiff)(SCIP *, SCIP_EXPR *, int, double *, SCIP_SOL *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetDiff$handle() {
        return SCIPexprhdlrSetDiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetDiff(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*bwdiff)(SCIP *, SCIP_EXPR *, int, double *), SCIP_RETCODE (*fwdiff)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_RETCODE (*bwfwdiff)(SCIP *, SCIP_EXPR *, int, double *, SCIP_SOL *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetDiff$address() {
        return SCIPexprhdlrSetDiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetDiff(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*bwdiff)(SCIP *, SCIP_EXPR *, int, double *), SCIP_RETCODE (*fwdiff)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_RETCODE (*bwfwdiff)(SCIP *, SCIP_EXPR *, int, double *, SCIP_SOL *))
     * }
     */
    public static void SCIPexprhdlrSetDiff(MemorySegment exprhdlr, MemorySegment bwdiff, MemorySegment fwdiff, MemorySegment bwfwdiff) {
        var mh$ = SCIPexprhdlrSetDiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetDiff", exprhdlr, bwdiff, fwdiff, bwfwdiff);
            }
            mh$.invokeExact(exprhdlr, bwdiff, fwdiff, bwfwdiff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetIntEval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetIntEval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntEval(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetIntEval$descriptor() {
        return SCIPexprhdlrSetIntEval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntEval(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetIntEval$handle() {
        return SCIPexprhdlrSetIntEval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntEval(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetIntEval$address() {
        return SCIPexprhdlrSetIntEval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetIntEval(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *))
     * }
     */
    public static void SCIPexprhdlrSetIntEval(MemorySegment exprhdlr, MemorySegment inteval) {
        var mh$ = SCIPexprhdlrSetIntEval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetIntEval", exprhdlr, inteval);
            }
            mh$.invokeExact(exprhdlr, inteval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetSimplify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetSimplify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetSimplify(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*simplify)(SCIP *, SCIP_EXPR *, SCIP_EXPR **, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetSimplify$descriptor() {
        return SCIPexprhdlrSetSimplify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetSimplify(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*simplify)(SCIP *, SCIP_EXPR *, SCIP_EXPR **, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetSimplify$handle() {
        return SCIPexprhdlrSetSimplify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetSimplify(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*simplify)(SCIP *, SCIP_EXPR *, SCIP_EXPR **, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetSimplify$address() {
        return SCIPexprhdlrSetSimplify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetSimplify(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*simplify)(SCIP *, SCIP_EXPR *, SCIP_EXPR **, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *))
     * }
     */
    public static void SCIPexprhdlrSetSimplify(MemorySegment exprhdlr, MemorySegment simplify) {
        var mh$ = SCIPexprhdlrSetSimplify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetSimplify", exprhdlr, simplify);
            }
            mh$.invokeExact(exprhdlr, simplify);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetReverseProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetReverseProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetReverseProp(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL, SCIP_INTERVAL *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetReverseProp$descriptor() {
        return SCIPexprhdlrSetReverseProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetReverseProp(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL, SCIP_INTERVAL *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetReverseProp$handle() {
        return SCIPexprhdlrSetReverseProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetReverseProp(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL, SCIP_INTERVAL *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetReverseProp$address() {
        return SCIPexprhdlrSetReverseProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetReverseProp(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL, SCIP_INTERVAL *, unsigned int *))
     * }
     */
    public static void SCIPexprhdlrSetReverseProp(MemorySegment exprhdlr, MemorySegment reverseprop) {
        var mh$ = SCIPexprhdlrSetReverseProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetReverseProp", exprhdlr, reverseprop);
            }
            mh$.invokeExact(exprhdlr, reverseprop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetEstimate(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*initestimates)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, unsigned int, double **, double *, int *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL *, double *, unsigned int, double, double *, double *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetEstimate$descriptor() {
        return SCIPexprhdlrSetEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetEstimate(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*initestimates)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, unsigned int, double **, double *, int *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL *, double *, unsigned int, double, double *, double *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetEstimate$handle() {
        return SCIPexprhdlrSetEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetEstimate(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*initestimates)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, unsigned int, double **, double *, int *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL *, double *, unsigned int, double, double *, double *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetEstimate$address() {
        return SCIPexprhdlrSetEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetEstimate(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*initestimates)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, unsigned int, double **, double *, int *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_EXPR *, SCIP_INTERVAL *, SCIP_INTERVAL *, double *, unsigned int, double, double *, double *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static void SCIPexprhdlrSetEstimate(MemorySegment exprhdlr, MemorySegment initestimates, MemorySegment estimate) {
        var mh$ = SCIPexprhdlrSetEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetEstimate", exprhdlr, initestimates, estimate);
            }
            mh$.invokeExact(exprhdlr, initestimates, estimate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrSetGetSymdata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrSetGetSymdata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetGetSymdata(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*getsymdata)(SCIP *, SCIP_EXPR *, SYM_EXPRDATA **))
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrSetGetSymdata$descriptor() {
        return SCIPexprhdlrSetGetSymdata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetGetSymdata(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*getsymdata)(SCIP *, SCIP_EXPR *, SYM_EXPRDATA **))
     * }
     */
    public static MethodHandle SCIPexprhdlrSetGetSymdata$handle() {
        return SCIPexprhdlrSetGetSymdata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrSetGetSymdata(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*getsymdata)(SCIP *, SCIP_EXPR *, SYM_EXPRDATA **))
     * }
     */
    public static MemorySegment SCIPexprhdlrSetGetSymdata$address() {
        return SCIPexprhdlrSetGetSymdata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrSetGetSymdata(SCIP_EXPRHDLR *exprhdlr, SCIP_RETCODE (*getsymdata)(SCIP *, SCIP_EXPR *, SYM_EXPRDATA **))
     * }
     */
    public static void SCIPexprhdlrSetGetSymdata(MemorySegment exprhdlr, MemorySegment getsymdata) {
        var mh$ = SCIPexprhdlrSetGetSymdata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrSetGetSymdata", exprhdlr, getsymdata);
            }
            mh$.invokeExact(exprhdlr, getsymdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetName(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetName$descriptor() {
        return SCIPexprhdlrGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetName(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetName$handle() {
        return SCIPexprhdlrGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetName(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetName$address() {
        return SCIPexprhdlrGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetName(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetName(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetName", exprhdlr);
            }
            return (MemorySegment)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetDescription");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetDescription(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetDescription$descriptor() {
        return SCIPexprhdlrGetDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetDescription(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetDescription$handle() {
        return SCIPexprhdlrGetDescription.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetDescription(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetDescription$address() {
        return SCIPexprhdlrGetDescription.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPexprhdlrGetDescription(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetDescription(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetDescription", exprhdlr);
            }
            return (MemorySegment)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetPrecedence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetPrecedence");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetPrecedence(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetPrecedence$descriptor() {
        return SCIPexprhdlrGetPrecedence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetPrecedence(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetPrecedence$handle() {
        return SCIPexprhdlrGetPrecedence.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetPrecedence(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetPrecedence$address() {
        return SCIPexprhdlrGetPrecedence.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetPrecedence(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrGetPrecedence(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetPrecedence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetPrecedence", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLRDATA *SCIPexprhdlrGetData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetData$descriptor() {
        return SCIPexprhdlrGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLRDATA *SCIPexprhdlrGetData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetData$handle() {
        return SCIPexprhdlrGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLRDATA *SCIPexprhdlrGetData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetData$address() {
        return SCIPexprhdlrGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLRDATA *SCIPexprhdlrGetData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetData(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetData", exprhdlr);
            }
            return (MemorySegment)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasPrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasPrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasPrint(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasPrint$descriptor() {
        return SCIPexprhdlrHasPrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasPrint(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasPrint$handle() {
        return SCIPexprhdlrHasPrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasPrint(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasPrint$address() {
        return SCIPexprhdlrHasPrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasPrint(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasPrint(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasPrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasPrint", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasBwdiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasBwdiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasBwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasBwdiff$descriptor() {
        return SCIPexprhdlrHasBwdiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasBwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasBwdiff$handle() {
        return SCIPexprhdlrHasBwdiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasBwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasBwdiff$address() {
        return SCIPexprhdlrHasBwdiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasBwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasBwdiff(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasBwdiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasBwdiff", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasFwdiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasFwdiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasFwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasFwdiff$descriptor() {
        return SCIPexprhdlrHasFwdiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasFwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasFwdiff$handle() {
        return SCIPexprhdlrHasFwdiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasFwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasFwdiff$address() {
        return SCIPexprhdlrHasFwdiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasFwdiff(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasFwdiff(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasFwdiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasFwdiff", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasIntEval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasIntEval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasIntEval(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasIntEval$descriptor() {
        return SCIPexprhdlrHasIntEval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasIntEval(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasIntEval$handle() {
        return SCIPexprhdlrHasIntEval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasIntEval(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasIntEval$address() {
        return SCIPexprhdlrHasIntEval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasIntEval(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasIntEval(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasIntEval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasIntEval", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasEstimate(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasEstimate$descriptor() {
        return SCIPexprhdlrHasEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasEstimate(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasEstimate$handle() {
        return SCIPexprhdlrHasEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasEstimate(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasEstimate$address() {
        return SCIPexprhdlrHasEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasEstimate(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasEstimate(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasEstimate", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasInitEstimates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasInitEstimates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasInitEstimates(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasInitEstimates$descriptor() {
        return SCIPexprhdlrHasInitEstimates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasInitEstimates(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasInitEstimates$handle() {
        return SCIPexprhdlrHasInitEstimates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasInitEstimates(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasInitEstimates$address() {
        return SCIPexprhdlrHasInitEstimates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasInitEstimates(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasInitEstimates(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasInitEstimates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasInitEstimates", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasSimplify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasSimplify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasSimplify(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasSimplify$descriptor() {
        return SCIPexprhdlrHasSimplify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasSimplify(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasSimplify$handle() {
        return SCIPexprhdlrHasSimplify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasSimplify(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasSimplify$address() {
        return SCIPexprhdlrHasSimplify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasSimplify(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasSimplify(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasSimplify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasSimplify", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasCurvature(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasCurvature$descriptor() {
        return SCIPexprhdlrHasCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasCurvature(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasCurvature$handle() {
        return SCIPexprhdlrHasCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasCurvature(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasCurvature$address() {
        return SCIPexprhdlrHasCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasCurvature(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasCurvature(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasCurvature", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasMonotonicity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasMonotonicity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasMonotonicity(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasMonotonicity$descriptor() {
        return SCIPexprhdlrHasMonotonicity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasMonotonicity(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasMonotonicity$handle() {
        return SCIPexprhdlrHasMonotonicity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasMonotonicity(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasMonotonicity$address() {
        return SCIPexprhdlrHasMonotonicity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasMonotonicity(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasMonotonicity(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasMonotonicity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasMonotonicity", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasReverseProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasReverseProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasReverseProp(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasReverseProp$descriptor() {
        return SCIPexprhdlrHasReverseProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasReverseProp(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasReverseProp$handle() {
        return SCIPexprhdlrHasReverseProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasReverseProp(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasReverseProp$address() {
        return SCIPexprhdlrHasReverseProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasReverseProp(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasReverseProp(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasReverseProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasReverseProp", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrHasGetSymData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrHasGetSymData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasGetSymData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrHasGetSymData$descriptor() {
        return SCIPexprhdlrHasGetSymData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasGetSymData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrHasGetSymData$handle() {
        return SCIPexprhdlrHasGetSymData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasGetSymData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrHasGetSymData$address() {
        return SCIPexprhdlrHasGetSymData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrHasGetSymData(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrHasGetSymData(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrHasGetSymData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrHasGetSymData", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPexprhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrComp$descriptor() {
        return SCIPexprhdlrComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPexprhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPexprhdlrComp$handle() {
        return SCIPexprhdlrComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPexprhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPexprhdlrComp$address() {
        return SCIPexprhdlrComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPexprhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPexprhdlrComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPexprhdlrComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNCreated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNCreated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetNCreated(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNCreated$descriptor() {
        return SCIPexprhdlrGetNCreated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetNCreated(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNCreated$handle() {
        return SCIPexprhdlrGetNCreated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetNCreated(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNCreated$address() {
        return SCIPexprhdlrGetNCreated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprhdlrGetNCreated(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static int SCIPexprhdlrGetNCreated(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNCreated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNCreated", exprhdlr);
            }
            return (int)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNIntevalCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNIntevalCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNIntevalCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNIntevalCalls$descriptor() {
        return SCIPexprhdlrGetNIntevalCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNIntevalCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNIntevalCalls$handle() {
        return SCIPexprhdlrGetNIntevalCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNIntevalCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNIntevalCalls$address() {
        return SCIPexprhdlrGetNIntevalCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNIntevalCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNIntevalCalls(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNIntevalCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNIntevalCalls", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetIntevalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetIntevalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetIntevalTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetIntevalTime$descriptor() {
        return SCIPexprhdlrGetIntevalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetIntevalTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetIntevalTime$handle() {
        return SCIPexprhdlrGetIntevalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetIntevalTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetIntevalTime$address() {
        return SCIPexprhdlrGetIntevalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprhdlrGetIntevalTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static double SCIPexprhdlrGetIntevalTime(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetIntevalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetIntevalTime", exprhdlr);
            }
            return (double)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNReversepropCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNReversepropCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNReversepropCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNReversepropCalls$descriptor() {
        return SCIPexprhdlrGetNReversepropCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNReversepropCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNReversepropCalls$handle() {
        return SCIPexprhdlrGetNReversepropCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNReversepropCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNReversepropCalls$address() {
        return SCIPexprhdlrGetNReversepropCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNReversepropCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNReversepropCalls(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNReversepropCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNReversepropCalls", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetReversepropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetReversepropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetReversepropTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetReversepropTime$descriptor() {
        return SCIPexprhdlrGetReversepropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetReversepropTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetReversepropTime$handle() {
        return SCIPexprhdlrGetReversepropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetReversepropTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetReversepropTime$address() {
        return SCIPexprhdlrGetReversepropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprhdlrGetReversepropTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static double SCIPexprhdlrGetReversepropTime(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetReversepropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetReversepropTime", exprhdlr);
            }
            return (double)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNCutoffs(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNCutoffs$descriptor() {
        return SCIPexprhdlrGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNCutoffs(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNCutoffs$handle() {
        return SCIPexprhdlrGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNCutoffs(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNCutoffs$address() {
        return SCIPexprhdlrGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNCutoffs(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNCutoffs(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNCutoffs", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNDomainReductions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNDomainReductions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNDomainReductions(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNDomainReductions$descriptor() {
        return SCIPexprhdlrGetNDomainReductions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNDomainReductions(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNDomainReductions$handle() {
        return SCIPexprhdlrGetNDomainReductions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNDomainReductions(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNDomainReductions$address() {
        return SCIPexprhdlrGetNDomainReductions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNDomainReductions(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNDomainReductions(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNDomainReductions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNDomainReductions", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrIncrementNDomainReductions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrIncrementNDomainReductions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNDomainReductions(SCIP_EXPRHDLR *exprhdlr, int nreductions)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrIncrementNDomainReductions$descriptor() {
        return SCIPexprhdlrIncrementNDomainReductions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNDomainReductions(SCIP_EXPRHDLR *exprhdlr, int nreductions)
     * }
     */
    public static MethodHandle SCIPexprhdlrIncrementNDomainReductions$handle() {
        return SCIPexprhdlrIncrementNDomainReductions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNDomainReductions(SCIP_EXPRHDLR *exprhdlr, int nreductions)
     * }
     */
    public static MemorySegment SCIPexprhdlrIncrementNDomainReductions$address() {
        return SCIPexprhdlrIncrementNDomainReductions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNDomainReductions(SCIP_EXPRHDLR *exprhdlr, int nreductions)
     * }
     */
    public static void SCIPexprhdlrIncrementNDomainReductions(MemorySegment exprhdlr, int nreductions) {
        var mh$ = SCIPexprhdlrIncrementNDomainReductions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrIncrementNDomainReductions", exprhdlr, nreductions);
            }
            mh$.invokeExact(exprhdlr, nreductions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNEstimateCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNEstimateCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNEstimateCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNEstimateCalls$descriptor() {
        return SCIPexprhdlrGetNEstimateCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNEstimateCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNEstimateCalls$handle() {
        return SCIPexprhdlrGetNEstimateCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNEstimateCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNEstimateCalls$address() {
        return SCIPexprhdlrGetNEstimateCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNEstimateCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNEstimateCalls(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNEstimateCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNEstimateCalls", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetEstimateTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetEstimateTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetEstimateTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetEstimateTime$descriptor() {
        return SCIPexprhdlrGetEstimateTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetEstimateTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetEstimateTime$handle() {
        return SCIPexprhdlrGetEstimateTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetEstimateTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetEstimateTime$address() {
        return SCIPexprhdlrGetEstimateTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprhdlrGetEstimateTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static double SCIPexprhdlrGetEstimateTime(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetEstimateTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetEstimateTime", exprhdlr);
            }
            return (double)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNBranchings$descriptor() {
        return SCIPexprhdlrGetNBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNBranchings$handle() {
        return SCIPexprhdlrGetNBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNBranchings$address() {
        return SCIPexprhdlrGetNBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNBranchings(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNBranchings", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrIncrementNBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrIncrementNBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrIncrementNBranchings$descriptor() {
        return SCIPexprhdlrIncrementNBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrIncrementNBranchings$handle() {
        return SCIPexprhdlrIncrementNBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrIncrementNBranchings$address() {
        return SCIPexprhdlrIncrementNBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprhdlrIncrementNBranchings(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static void SCIPexprhdlrIncrementNBranchings(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrIncrementNBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrIncrementNBranchings", exprhdlr);
            }
            mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNSimplifyCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNSimplifyCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifyCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNSimplifyCalls$descriptor() {
        return SCIPexprhdlrGetNSimplifyCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifyCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNSimplifyCalls$handle() {
        return SCIPexprhdlrGetNSimplifyCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifyCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNSimplifyCalls$address() {
        return SCIPexprhdlrGetNSimplifyCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifyCalls(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNSimplifyCalls(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNSimplifyCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNSimplifyCalls", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetSimplifyTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetSimplifyTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetSimplifyTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetSimplifyTime$descriptor() {
        return SCIPexprhdlrGetSimplifyTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetSimplifyTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetSimplifyTime$handle() {
        return SCIPexprhdlrGetSimplifyTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprhdlrGetSimplifyTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetSimplifyTime$address() {
        return SCIPexprhdlrGetSimplifyTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprhdlrGetSimplifyTime(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static double SCIPexprhdlrGetSimplifyTime(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetSimplifyTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetSimplifyTime", exprhdlr);
            }
            return (double)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprhdlrGetNSimplifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprhdlrGetNSimplifications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifications(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static FunctionDescriptor SCIPexprhdlrGetNSimplifications$descriptor() {
        return SCIPexprhdlrGetNSimplifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifications(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MethodHandle SCIPexprhdlrGetNSimplifications$handle() {
        return SCIPexprhdlrGetNSimplifications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifications(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static MemorySegment SCIPexprhdlrGetNSimplifications$address() {
        return SCIPexprhdlrGetNSimplifications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprhdlrGetNSimplifications(SCIP_EXPRHDLR *exprhdlr)
     * }
     */
    public static long SCIPexprhdlrGetNSimplifications(MemorySegment exprhdlr) {
        var mh$ = SCIPexprhdlrGetNSimplifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprhdlrGetNSimplifications", exprhdlr);
            }
            return (long)mh$.invokeExact(exprhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetNUses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetNUses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPexprGetNUses(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetNUses$descriptor() {
        return SCIPexprGetNUses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPexprGetNUses(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetNUses$handle() {
        return SCIPexprGetNUses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPexprGetNUses(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetNUses$address() {
        return SCIPexprGetNUses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPexprGetNUses(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPexprGetNUses(MemorySegment expr) {
        var mh$ = SCIPexprGetNUses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetNUses", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetNChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetNChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPexprGetNChildren(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetNChildren$descriptor() {
        return SCIPexprGetNChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPexprGetNChildren(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetNChildren$handle() {
        return SCIPexprGetNChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPexprGetNChildren(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetNChildren$address() {
        return SCIPexprGetNChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPexprGetNChildren(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPexprGetNChildren(MemorySegment expr) {
        var mh$ = SCIPexprGetNChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetNChildren", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPexprGetChildren(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetChildren$descriptor() {
        return SCIPexprGetChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPexprGetChildren(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetChildren$handle() {
        return SCIPexprGetChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPexprGetChildren(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetChildren$address() {
        return SCIPexprGetChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPexprGetChildren(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetChildren(MemorySegment expr) {
        var mh$ = SCIPexprGetChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetChildren", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetHdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetHdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPexprGetHdlr(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetHdlr$descriptor() {
        return SCIPexprGetHdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPexprGetHdlr(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetHdlr$handle() {
        return SCIPexprGetHdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPexprGetHdlr(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetHdlr$address() {
        return SCIPexprGetHdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPexprGetHdlr(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetHdlr(MemorySegment expr) {
        var mh$ = SCIPexprGetHdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetHdlr", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRDATA *SCIPexprGetData(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetData$descriptor() {
        return SCIPexprGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRDATA *SCIPexprGetData(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetData$handle() {
        return SCIPexprGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRDATA *SCIPexprGetData(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetData$address() {
        return SCIPexprGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRDATA *SCIPexprGetData(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetData(MemorySegment expr) {
        var mh$ = SCIPexprGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetData", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprSetData(SCIP_EXPR *expr, SCIP_EXPRDATA *exprdata)
     * }
     */
    public static FunctionDescriptor SCIPexprSetData$descriptor() {
        return SCIPexprSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprSetData(SCIP_EXPR *expr, SCIP_EXPRDATA *exprdata)
     * }
     */
    public static MethodHandle SCIPexprSetData$handle() {
        return SCIPexprSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprSetData(SCIP_EXPR *expr, SCIP_EXPRDATA *exprdata)
     * }
     */
    public static MemorySegment SCIPexprSetData$address() {
        return SCIPexprSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprSetData(SCIP_EXPR *expr, SCIP_EXPRDATA *exprdata)
     * }
     */
    public static void SCIPexprSetData(MemorySegment expr, MemorySegment exprdata) {
        var mh$ = SCIPexprSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprSetData", expr, exprdata);
            }
            mh$.invokeExact(expr, exprdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetOwnerData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetOwnerData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR_OWNERDATA *SCIPexprGetOwnerData(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetOwnerData$descriptor() {
        return SCIPexprGetOwnerData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR_OWNERDATA *SCIPexprGetOwnerData(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetOwnerData$handle() {
        return SCIPexprGetOwnerData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR_OWNERDATA *SCIPexprGetOwnerData(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetOwnerData$address() {
        return SCIPexprGetOwnerData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR_OWNERDATA *SCIPexprGetOwnerData(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetOwnerData(MemorySegment expr) {
        var mh$ = SCIPexprGetOwnerData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetOwnerData", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetEvalValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetEvalValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprGetEvalValue(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetEvalValue$descriptor() {
        return SCIPexprGetEvalValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprGetEvalValue(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetEvalValue$handle() {
        return SCIPexprGetEvalValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprGetEvalValue(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetEvalValue$address() {
        return SCIPexprGetEvalValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprGetEvalValue(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPexprGetEvalValue(MemorySegment expr) {
        var mh$ = SCIPexprGetEvalValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetEvalValue", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetEvalTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetEvalTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprGetEvalTag(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetEvalTag$descriptor() {
        return SCIPexprGetEvalTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprGetEvalTag(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetEvalTag$handle() {
        return SCIPexprGetEvalTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprGetEvalTag(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetEvalTag$address() {
        return SCIPexprGetEvalTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprGetEvalTag(SCIP_EXPR *expr)
     * }
     */
    public static long SCIPexprGetEvalTag(MemorySegment expr) {
        var mh$ = SCIPexprGetEvalTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetEvalTag", expr);
            }
            return (long)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetDerivative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetDerivative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprGetDerivative(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetDerivative$descriptor() {
        return SCIPexprGetDerivative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprGetDerivative(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetDerivative$handle() {
        return SCIPexprGetDerivative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprGetDerivative(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetDerivative$address() {
        return SCIPexprGetDerivative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprGetDerivative(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPexprGetDerivative(MemorySegment expr) {
        var mh$ = SCIPexprGetDerivative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetDerivative", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetDot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetDot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprGetDot(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetDot$descriptor() {
        return SCIPexprGetDot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprGetDot(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetDot$handle() {
        return SCIPexprGetDot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprGetDot(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetDot$address() {
        return SCIPexprGetDot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprGetDot(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPexprGetDot(MemorySegment expr) {
        var mh$ = SCIPexprGetDot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetDot", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetBardot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetBardot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPexprGetBardot(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetBardot$descriptor() {
        return SCIPexprGetBardot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPexprGetBardot(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetBardot$handle() {
        return SCIPexprGetBardot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPexprGetBardot(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetBardot$address() {
        return SCIPexprGetBardot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPexprGetBardot(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPexprGetBardot(MemorySegment expr) {
        var mh$ = SCIPexprGetBardot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetBardot", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetDiffTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetDiffTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprGetDiffTag(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetDiffTag$descriptor() {
        return SCIPexprGetDiffTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprGetDiffTag(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetDiffTag$handle() {
        return SCIPexprGetDiffTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprGetDiffTag(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetDiffTag$address() {
        return SCIPexprGetDiffTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprGetDiffTag(SCIP_EXPR *expr)
     * }
     */
    public static long SCIPexprGetDiffTag(MemorySegment expr) {
        var mh$ = SCIPexprGetDiffTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetDiffTag", expr);
            }
            return (long)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_Interval.layout(),
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPexprGetActivity(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetActivity$descriptor() {
        return SCIPexprGetActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPexprGetActivity(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetActivity$handle() {
        return SCIPexprGetActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPexprGetActivity(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetActivity$address() {
        return SCIPexprGetActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPexprGetActivity(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetActivity(SegmentAllocator allocator, MemorySegment expr) {
        var mh$ = SCIPexprGetActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetActivity", allocator, expr);
            }
            return (MemorySegment)mh$.invokeExact(allocator, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetActivityTag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetActivityTag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPexprGetActivityTag(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetActivityTag$descriptor() {
        return SCIPexprGetActivityTag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPexprGetActivityTag(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetActivityTag$handle() {
        return SCIPexprGetActivityTag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPexprGetActivityTag(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetActivityTag$address() {
        return SCIPexprGetActivityTag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPexprGetActivityTag(SCIP_EXPR *expr)
     * }
     */
    public static long SCIPexprGetActivityTag(MemorySegment expr) {
        var mh$ = SCIPexprGetActivityTag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetActivityTag", expr);
            }
            return (long)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprSetActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprSetActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprSetActivity(SCIP_EXPR *expr, SCIP_INTERVAL activity, long long activitytag)
     * }
     */
    public static FunctionDescriptor SCIPexprSetActivity$descriptor() {
        return SCIPexprSetActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprSetActivity(SCIP_EXPR *expr, SCIP_INTERVAL activity, long long activitytag)
     * }
     */
    public static MethodHandle SCIPexprSetActivity$handle() {
        return SCIPexprSetActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprSetActivity(SCIP_EXPR *expr, SCIP_INTERVAL activity, long long activitytag)
     * }
     */
    public static MemorySegment SCIPexprSetActivity$address() {
        return SCIPexprSetActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprSetActivity(SCIP_EXPR *expr, SCIP_INTERVAL activity, long long activitytag)
     * }
     */
    public static void SCIPexprSetActivity(MemorySegment expr, MemorySegment activity, long activitytag) {
        var mh$ = SCIPexprSetActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprSetActivity", expr, activity, activitytag);
            }
            mh$.invokeExact(expr, activity, activitytag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprGetCurvature(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetCurvature$descriptor() {
        return SCIPexprGetCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprGetCurvature(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprGetCurvature$handle() {
        return SCIPexprGetCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprGetCurvature(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprGetCurvature$address() {
        return SCIPexprGetCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprGetCurvature(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPexprGetCurvature(MemorySegment expr) {
        var mh$ = SCIPexprGetCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetCurvature", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprSetCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprSetCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprSetCurvature(SCIP_EXPR *expr, SCIP_EXPRCURV curvature)
     * }
     */
    public static FunctionDescriptor SCIPexprSetCurvature$descriptor() {
        return SCIPexprSetCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprSetCurvature(SCIP_EXPR *expr, SCIP_EXPRCURV curvature)
     * }
     */
    public static MethodHandle SCIPexprSetCurvature$handle() {
        return SCIPexprSetCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprSetCurvature(SCIP_EXPR *expr, SCIP_EXPRCURV curvature)
     * }
     */
    public static MemorySegment SCIPexprSetCurvature$address() {
        return SCIPexprSetCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprSetCurvature(SCIP_EXPR *expr, SCIP_EXPRCURV curvature)
     * }
     */
    public static void SCIPexprSetCurvature(MemorySegment expr, int curvature) {
        var mh$ = SCIPexprSetCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprSetCurvature", expr, curvature);
            }
            mh$.invokeExact(expr, curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprIsIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprIsIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprIsIntegral(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprIsIntegral$descriptor() {
        return SCIPexprIsIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprIsIntegral(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprIsIntegral$handle() {
        return SCIPexprIsIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprIsIntegral(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprIsIntegral$address() {
        return SCIPexprIsIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprIsIntegral(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPexprIsIntegral(MemorySegment expr) {
        var mh$ = SCIPexprIsIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprIsIntegral", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprSetIntegrality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprSetIntegrality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprSetIntegrality(SCIP_EXPR *expr, unsigned int isintegral)
     * }
     */
    public static FunctionDescriptor SCIPexprSetIntegrality$descriptor() {
        return SCIPexprSetIntegrality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprSetIntegrality(SCIP_EXPR *expr, unsigned int isintegral)
     * }
     */
    public static MethodHandle SCIPexprSetIntegrality$handle() {
        return SCIPexprSetIntegrality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprSetIntegrality(SCIP_EXPR *expr, unsigned int isintegral)
     * }
     */
    public static MemorySegment SCIPexprSetIntegrality$address() {
        return SCIPexprSetIntegrality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprSetIntegrality(SCIP_EXPR *expr, unsigned int isintegral)
     * }
     */
    public static void SCIPexprSetIntegrality(MemorySegment expr, int isintegral) {
        var mh$ = SCIPexprSetIntegrality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprSetIntegrality", expr, isintegral);
            }
            mh$.invokeExact(expr, isintegral);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetQuadraticData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetQuadraticData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticData(SCIP_EXPR *expr, double *constant, int *nlinexprs, SCIP_EXPR ***linexprs, double **lincoefs, int *nquadexprs, int *nbilinexprs, double **eigenvalues, double **eigenvectors)
     * }
     */
    public static FunctionDescriptor SCIPexprGetQuadraticData$descriptor() {
        return SCIPexprGetQuadraticData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticData(SCIP_EXPR *expr, double *constant, int *nlinexprs, SCIP_EXPR ***linexprs, double **lincoefs, int *nquadexprs, int *nbilinexprs, double **eigenvalues, double **eigenvectors)
     * }
     */
    public static MethodHandle SCIPexprGetQuadraticData$handle() {
        return SCIPexprGetQuadraticData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticData(SCIP_EXPR *expr, double *constant, int *nlinexprs, SCIP_EXPR ***linexprs, double **lincoefs, int *nquadexprs, int *nbilinexprs, double **eigenvalues, double **eigenvectors)
     * }
     */
    public static MemorySegment SCIPexprGetQuadraticData$address() {
        return SCIPexprGetQuadraticData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticData(SCIP_EXPR *expr, double *constant, int *nlinexprs, SCIP_EXPR ***linexprs, double **lincoefs, int *nquadexprs, int *nbilinexprs, double **eigenvalues, double **eigenvectors)
     * }
     */
    public static void SCIPexprGetQuadraticData(MemorySegment expr, MemorySegment constant, MemorySegment nlinexprs, MemorySegment linexprs, MemorySegment lincoefs, MemorySegment nquadexprs, MemorySegment nbilinexprs, MemorySegment eigenvalues, MemorySegment eigenvectors) {
        var mh$ = SCIPexprGetQuadraticData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetQuadraticData", expr, constant, nlinexprs, linexprs, lincoefs, nquadexprs, nbilinexprs, eigenvalues, eigenvectors);
            }
            mh$.invokeExact(expr, constant, nlinexprs, linexprs, lincoefs, nquadexprs, nbilinexprs, eigenvalues, eigenvectors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetQuadraticQuadTerm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetQuadraticQuadTerm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticQuadTerm(SCIP_EXPR *quadexpr, int termidx, SCIP_EXPR **expr, double *lincoef, double *sqrcoef, int *nadjbilin, int **adjbilin, SCIP_EXPR **sqrexpr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetQuadraticQuadTerm$descriptor() {
        return SCIPexprGetQuadraticQuadTerm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticQuadTerm(SCIP_EXPR *quadexpr, int termidx, SCIP_EXPR **expr, double *lincoef, double *sqrcoef, int *nadjbilin, int **adjbilin, SCIP_EXPR **sqrexpr)
     * }
     */
    public static MethodHandle SCIPexprGetQuadraticQuadTerm$handle() {
        return SCIPexprGetQuadraticQuadTerm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticQuadTerm(SCIP_EXPR *quadexpr, int termidx, SCIP_EXPR **expr, double *lincoef, double *sqrcoef, int *nadjbilin, int **adjbilin, SCIP_EXPR **sqrexpr)
     * }
     */
    public static MemorySegment SCIPexprGetQuadraticQuadTerm$address() {
        return SCIPexprGetQuadraticQuadTerm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticQuadTerm(SCIP_EXPR *quadexpr, int termidx, SCIP_EXPR **expr, double *lincoef, double *sqrcoef, int *nadjbilin, int **adjbilin, SCIP_EXPR **sqrexpr)
     * }
     */
    public static void SCIPexprGetQuadraticQuadTerm(MemorySegment quadexpr, int termidx, MemorySegment expr, MemorySegment lincoef, MemorySegment sqrcoef, MemorySegment nadjbilin, MemorySegment adjbilin, MemorySegment sqrexpr) {
        var mh$ = SCIPexprGetQuadraticQuadTerm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetQuadraticQuadTerm", quadexpr, termidx, expr, lincoef, sqrcoef, nadjbilin, adjbilin, sqrexpr);
            }
            mh$.invokeExact(quadexpr, termidx, expr, lincoef, sqrcoef, nadjbilin, adjbilin, sqrexpr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprGetQuadraticBilinTerm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprGetQuadraticBilinTerm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticBilinTerm(SCIP_EXPR *expr, int termidx, SCIP_EXPR **expr1, SCIP_EXPR **expr2, double *coef, int *pos2, SCIP_EXPR **prodexpr)
     * }
     */
    public static FunctionDescriptor SCIPexprGetQuadraticBilinTerm$descriptor() {
        return SCIPexprGetQuadraticBilinTerm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticBilinTerm(SCIP_EXPR *expr, int termidx, SCIP_EXPR **expr1, SCIP_EXPR **expr2, double *coef, int *pos2, SCIP_EXPR **prodexpr)
     * }
     */
    public static MethodHandle SCIPexprGetQuadraticBilinTerm$handle() {
        return SCIPexprGetQuadraticBilinTerm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticBilinTerm(SCIP_EXPR *expr, int termidx, SCIP_EXPR **expr1, SCIP_EXPR **expr2, double *coef, int *pos2, SCIP_EXPR **prodexpr)
     * }
     */
    public static MemorySegment SCIPexprGetQuadraticBilinTerm$address() {
        return SCIPexprGetQuadraticBilinTerm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexprGetQuadraticBilinTerm(SCIP_EXPR *expr, int termidx, SCIP_EXPR **expr1, SCIP_EXPR **expr2, double *coef, int *pos2, SCIP_EXPR **prodexpr)
     * }
     */
    public static void SCIPexprGetQuadraticBilinTerm(MemorySegment expr, int termidx, MemorySegment expr1, MemorySegment expr2, MemorySegment coef, MemorySegment pos2, MemorySegment prodexpr) {
        var mh$ = SCIPexprGetQuadraticBilinTerm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprGetQuadraticBilinTerm", expr, termidx, expr1, expr2, coef, pos2, prodexpr);
            }
            mh$.invokeExact(expr, termidx, expr1, expr2, coef, pos2, prodexpr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprAreQuadraticExprsVariables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprAreQuadraticExprsVariables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprAreQuadraticExprsVariables(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexprAreQuadraticExprsVariables$descriptor() {
        return SCIPexprAreQuadraticExprsVariables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprAreQuadraticExprsVariables(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexprAreQuadraticExprsVariables$handle() {
        return SCIPexprAreQuadraticExprsVariables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprAreQuadraticExprsVariables(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexprAreQuadraticExprsVariables$address() {
        return SCIPexprAreQuadraticExprsVariables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprAreQuadraticExprsVariables(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPexprAreQuadraticExprsVariables(MemorySegment expr) {
        var mh$ = SCIPexprAreQuadraticExprsVariables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprAreQuadraticExprsVariables", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarExprVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarExprVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarExprVar(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetVarExprVar$descriptor() {
        return SCIPgetVarExprVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarExprVar(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetVarExprVar$handle() {
        return SCIPgetVarExprVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarExprVar(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetVarExprVar$address() {
        return SCIPgetVarExprVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarExprVar(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetVarExprVar(MemorySegment expr) {
        var mh$ = SCIPgetVarExprVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarExprVar", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetValueExprValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetValueExprValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetValueExprValue(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetValueExprValue$descriptor() {
        return SCIPgetValueExprValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetValueExprValue(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetValueExprValue$handle() {
        return SCIPgetValueExprValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetValueExprValue(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetValueExprValue$address() {
        return SCIPgetValueExprValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetValueExprValue(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPgetValueExprValue(MemorySegment expr) {
        var mh$ = SCIPgetValueExprValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetValueExprValue", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCoefsExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCoefsExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetCoefsExprSum(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetCoefsExprSum$descriptor() {
        return SCIPgetCoefsExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetCoefsExprSum(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetCoefsExprSum$handle() {
        return SCIPgetCoefsExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetCoefsExprSum(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetCoefsExprSum$address() {
        return SCIPgetCoefsExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetCoefsExprSum(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetCoefsExprSum(MemorySegment expr) {
        var mh$ = SCIPgetCoefsExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCoefsExprSum", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConstantExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConstantExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetConstantExprSum(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetConstantExprSum$descriptor() {
        return SCIPgetConstantExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetConstantExprSum(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetConstantExprSum$handle() {
        return SCIPgetConstantExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetConstantExprSum(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetConstantExprSum$address() {
        return SCIPgetConstantExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetConstantExprSum(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPgetConstantExprSum(MemorySegment expr) {
        var mh$ = SCIPgetConstantExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConstantExprSum", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCoefExprProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCoefExprProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetCoefExprProduct(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetCoefExprProduct$descriptor() {
        return SCIPgetCoefExprProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetCoefExprProduct(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetCoefExprProduct$handle() {
        return SCIPgetCoefExprProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetCoefExprProduct(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetCoefExprProduct$address() {
        return SCIPgetCoefExprProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetCoefExprProduct(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPgetCoefExprProduct(MemorySegment expr) {
        var mh$ = SCIPgetCoefExprProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCoefExprProduct", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExponentExprPow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExponentExprPow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetExponentExprPow(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExponentExprPow$descriptor() {
        return SCIPgetExponentExprPow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetExponentExprPow(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExponentExprPow$handle() {
        return SCIPgetExponentExprPow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetExponentExprPow(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExponentExprPow$address() {
        return SCIPgetExponentExprPow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetExponentExprPow(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPgetExponentExprPow(MemorySegment expr) {
        var mh$ = SCIPgetExponentExprPow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExponentExprPow", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterIsInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterIsInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsInit(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterIsInit$descriptor() {
        return SCIPexpriterIsInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsInit(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterIsInit$handle() {
        return SCIPexpriterIsInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsInit(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterIsInit$address() {
        return SCIPexpriterIsInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsInit(SCIP_EXPRITER *iterator)
     * }
     */
    public static int SCIPexpriterIsInit(MemorySegment iterator) {
        var mh$ = SCIPexpriterIsInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterIsInit", iterator);
            }
            return (int)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexpriterInit(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_TYPE type, unsigned int allowrevisit)
     * }
     */
    public static FunctionDescriptor SCIPexpriterInit$descriptor() {
        return SCIPexpriterInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexpriterInit(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_TYPE type, unsigned int allowrevisit)
     * }
     */
    public static MethodHandle SCIPexpriterInit$handle() {
        return SCIPexpriterInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexpriterInit(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_TYPE type, unsigned int allowrevisit)
     * }
     */
    public static MemorySegment SCIPexpriterInit$address() {
        return SCIPexpriterInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexpriterInit(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_TYPE type, unsigned int allowrevisit)
     * }
     */
    public static int SCIPexpriterInit(MemorySegment iterator, MemorySegment expr, int type, int allowrevisit) {
        var mh$ = SCIPexpriterInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterInit", iterator, expr, type, allowrevisit);
            }
            return (int)mh$.invokeExact(iterator, expr, type, allowrevisit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterRestartDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterRestartDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterRestartDFS(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexpriterRestartDFS$descriptor() {
        return SCIPexpriterRestartDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterRestartDFS(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexpriterRestartDFS$handle() {
        return SCIPexpriterRestartDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterRestartDFS(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexpriterRestartDFS$address() {
        return SCIPexpriterRestartDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterRestartDFS(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexpriterRestartDFS(MemorySegment iterator, MemorySegment expr) {
        var mh$ = SCIPexpriterRestartDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterRestartDFS", iterator, expr);
            }
            return (MemorySegment)mh$.invokeExact(iterator, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterSetStagesDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterSetStagesDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexpriterSetStagesDFS(SCIP_EXPRITER *iterator, SCIP_EXPRITER_STAGE stopstages)
     * }
     */
    public static FunctionDescriptor SCIPexpriterSetStagesDFS$descriptor() {
        return SCIPexpriterSetStagesDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexpriterSetStagesDFS(SCIP_EXPRITER *iterator, SCIP_EXPRITER_STAGE stopstages)
     * }
     */
    public static MethodHandle SCIPexpriterSetStagesDFS$handle() {
        return SCIPexpriterSetStagesDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexpriterSetStagesDFS(SCIP_EXPRITER *iterator, SCIP_EXPRITER_STAGE stopstages)
     * }
     */
    public static MemorySegment SCIPexpriterSetStagesDFS$address() {
        return SCIPexpriterSetStagesDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexpriterSetStagesDFS(SCIP_EXPRITER *iterator, SCIP_EXPRITER_STAGE stopstages)
     * }
     */
    public static void SCIPexpriterSetStagesDFS(MemorySegment iterator, int stopstages) {
        var mh$ = SCIPexpriterSetStagesDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterSetStagesDFS", iterator, stopstages);
            }
            mh$.invokeExact(iterator, stopstages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetCurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetCurrent(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetCurrent$descriptor() {
        return SCIPexpriterGetCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetCurrent(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetCurrent$handle() {
        return SCIPexpriterGetCurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetCurrent(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetCurrent$address() {
        return SCIPexpriterGetCurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetCurrent(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetCurrent(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetCurrent", iterator);
            }
            return (MemorySegment)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetStageDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetStageDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_STAGE SCIPexpriterGetStageDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetStageDFS$descriptor() {
        return SCIPexpriterGetStageDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_STAGE SCIPexpriterGetStageDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetStageDFS$handle() {
        return SCIPexpriterGetStageDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_STAGE SCIPexpriterGetStageDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetStageDFS$address() {
        return SCIPexpriterGetStageDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRITER_STAGE SCIPexpriterGetStageDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static int SCIPexpriterGetStageDFS(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetStageDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetStageDFS", iterator);
            }
            return (int)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetChildIdxDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetChildIdxDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPexpriterGetChildIdxDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetChildIdxDFS$descriptor() {
        return SCIPexpriterGetChildIdxDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPexpriterGetChildIdxDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetChildIdxDFS$handle() {
        return SCIPexpriterGetChildIdxDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPexpriterGetChildIdxDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetChildIdxDFS$address() {
        return SCIPexpriterGetChildIdxDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPexpriterGetChildIdxDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static int SCIPexpriterGetChildIdxDFS(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetChildIdxDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetChildIdxDFS", iterator);
            }
            return (int)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetChildExprDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetChildExprDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetChildExprDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetChildExprDFS$descriptor() {
        return SCIPexpriterGetChildExprDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetChildExprDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetChildExprDFS$handle() {
        return SCIPexpriterGetChildExprDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetChildExprDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetChildExprDFS$address() {
        return SCIPexpriterGetChildExprDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetChildExprDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetChildExprDFS(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetChildExprDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetChildExprDFS", iterator);
            }
            return (MemorySegment)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetParentDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetParentDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetParentDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetParentDFS$descriptor() {
        return SCIPexpriterGetParentDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetParentDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetParentDFS$handle() {
        return SCIPexpriterGetParentDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetParentDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetParentDFS$address() {
        return SCIPexpriterGetParentDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetParentDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetParentDFS(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetParentDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetParentDFS", iterator);
            }
            return (MemorySegment)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetCurrentUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_EXPRITER_USERDATA.layout(),
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetCurrentUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetCurrentUserData(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetCurrentUserData$descriptor() {
        return SCIPexpriterGetCurrentUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetCurrentUserData(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetCurrentUserData$handle() {
        return SCIPexpriterGetCurrentUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetCurrentUserData(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetCurrentUserData$address() {
        return SCIPexpriterGetCurrentUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetCurrentUserData(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetCurrentUserData(SegmentAllocator allocator, MemorySegment iterator) {
        var mh$ = SCIPexpriterGetCurrentUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetCurrentUserData", allocator, iterator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetChildUserDataDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_EXPRITER_USERDATA.layout(),
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetChildUserDataDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetChildUserDataDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetChildUserDataDFS$descriptor() {
        return SCIPexpriterGetChildUserDataDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetChildUserDataDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetChildUserDataDFS$handle() {
        return SCIPexpriterGetChildUserDataDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetChildUserDataDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetChildUserDataDFS$address() {
        return SCIPexpriterGetChildUserDataDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetChildUserDataDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetChildUserDataDFS(SegmentAllocator allocator, MemorySegment iterator) {
        var mh$ = SCIPexpriterGetChildUserDataDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetChildUserDataDFS", allocator, iterator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetExprUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_EXPRITER_USERDATA.layout(),
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetExprUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetExprUserData$descriptor() {
        return SCIPexpriterGetExprUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPexpriterGetExprUserData$handle() {
        return SCIPexpriterGetExprUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexpriterGetExprUserData$address() {
        return SCIPexpriterGetExprUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRITER_USERDATA SCIPexpriterGetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPexpriterGetExprUserData(SegmentAllocator allocator, MemorySegment iterator, MemorySegment expr) {
        var mh$ = SCIPexpriterGetExprUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetExprUserData", allocator, iterator, expr);
            }
            return (MemorySegment)mh$.invokeExact(allocator, iterator, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterSetCurrentUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            SCIP_EXPRITER_USERDATA.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterSetCurrentUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexpriterSetCurrentUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static FunctionDescriptor SCIPexpriterSetCurrentUserData$descriptor() {
        return SCIPexpriterSetCurrentUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexpriterSetCurrentUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MethodHandle SCIPexpriterSetCurrentUserData$handle() {
        return SCIPexpriterSetCurrentUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexpriterSetCurrentUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MemorySegment SCIPexpriterSetCurrentUserData$address() {
        return SCIPexpriterSetCurrentUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexpriterSetCurrentUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static void SCIPexpriterSetCurrentUserData(MemorySegment iterator, MemorySegment userdata) {
        var mh$ = SCIPexpriterSetCurrentUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterSetCurrentUserData", iterator, userdata);
            }
            mh$.invokeExact(iterator, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterSetExprUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            SCIP_EXPRITER_USERDATA.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterSetExprUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexpriterSetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static FunctionDescriptor SCIPexpriterSetExprUserData$descriptor() {
        return SCIPexpriterSetExprUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexpriterSetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MethodHandle SCIPexpriterSetExprUserData$handle() {
        return SCIPexpriterSetExprUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexpriterSetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MemorySegment SCIPexpriterSetExprUserData$address() {
        return SCIPexpriterSetExprUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexpriterSetExprUserData(SCIP_EXPRITER *iterator, SCIP_EXPR *expr, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static void SCIPexpriterSetExprUserData(MemorySegment iterator, MemorySegment expr, MemorySegment userdata) {
        var mh$ = SCIPexpriterSetExprUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterSetExprUserData", iterator, expr, userdata);
            }
            mh$.invokeExact(iterator, expr, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterSetChildUserData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            SCIP_EXPRITER_USERDATA.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterSetChildUserData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPexpriterSetChildUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static FunctionDescriptor SCIPexpriterSetChildUserData$descriptor() {
        return SCIPexpriterSetChildUserData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPexpriterSetChildUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MethodHandle SCIPexpriterSetChildUserData$handle() {
        return SCIPexpriterSetChildUserData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPexpriterSetChildUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static MemorySegment SCIPexpriterSetChildUserData$address() {
        return SCIPexpriterSetChildUserData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPexpriterSetChildUserData(SCIP_EXPRITER *iterator, SCIP_EXPRITER_USERDATA userdata)
     * }
     */
    public static void SCIPexpriterSetChildUserData(MemorySegment iterator, MemorySegment userdata) {
        var mh$ = SCIPexpriterSetChildUserData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterSetChildUserData", iterator, userdata);
            }
            mh$.invokeExact(iterator, userdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterGetNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterGetNext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetNext(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterGetNext$descriptor() {
        return SCIPexpriterGetNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetNext(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterGetNext$handle() {
        return SCIPexpriterGetNext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetNext(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetNext$address() {
        return SCIPexpriterGetNext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterGetNext(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterGetNext(MemorySegment iterator) {
        var mh$ = SCIPexpriterGetNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterGetNext", iterator);
            }
            return (MemorySegment)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterSkipDFS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterSkipDFS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterSkipDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterSkipDFS$descriptor() {
        return SCIPexpriterSkipDFS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterSkipDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterSkipDFS$handle() {
        return SCIPexpriterSkipDFS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterSkipDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterSkipDFS$address() {
        return SCIPexpriterSkipDFS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPexpriterSkipDFS(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterSkipDFS(MemorySegment iterator) {
        var mh$ = SCIPexpriterSkipDFS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterSkipDFS", iterator);
            }
            return (MemorySegment)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexpriterIsEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexpriterIsEnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsEnd(SCIP_EXPRITER *iterator)
     * }
     */
    public static FunctionDescriptor SCIPexpriterIsEnd$descriptor() {
        return SCIPexpriterIsEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsEnd(SCIP_EXPRITER *iterator)
     * }
     */
    public static MethodHandle SCIPexpriterIsEnd$handle() {
        return SCIPexpriterIsEnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsEnd(SCIP_EXPRITER *iterator)
     * }
     */
    public static MemorySegment SCIPexpriterIsEnd$address() {
        return SCIPexpriterIsEnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexpriterIsEnd(SCIP_EXPRITER *iterator)
     * }
     */
    public static int SCIPexpriterIsEnd(MemorySegment iterator) {
        var mh$ = SCIPexpriterIsEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexpriterIsEnd", iterator);
            }
            return (int)mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvAdd(SCIP_EXPRCURV curv1, SCIP_EXPRCURV curv2)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvAdd$descriptor() {
        return SCIPexprcurvAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvAdd(SCIP_EXPRCURV curv1, SCIP_EXPRCURV curv2)
     * }
     */
    public static MethodHandle SCIPexprcurvAdd$handle() {
        return SCIPexprcurvAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvAdd(SCIP_EXPRCURV curv1, SCIP_EXPRCURV curv2)
     * }
     */
    public static MemorySegment SCIPexprcurvAdd$address() {
        return SCIPexprcurvAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvAdd(SCIP_EXPRCURV curv1, SCIP_EXPRCURV curv2)
     * }
     */
    public static int SCIPexprcurvAdd(int curv1, int curv2) {
        var mh$ = SCIPexprcurvAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvAdd", curv1, curv2);
            }
            return (int)mh$.invokeExact(curv1, curv2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvNegate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvNegate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvNegate(SCIP_EXPRCURV curvature)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvNegate$descriptor() {
        return SCIPexprcurvNegate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvNegate(SCIP_EXPRCURV curvature)
     * }
     */
    public static MethodHandle SCIPexprcurvNegate$handle() {
        return SCIPexprcurvNegate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvNegate(SCIP_EXPRCURV curvature)
     * }
     */
    public static MemorySegment SCIPexprcurvNegate$address() {
        return SCIPexprcurvNegate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvNegate(SCIP_EXPRCURV curvature)
     * }
     */
    public static int SCIPexprcurvNegate(int curvature) {
        var mh$ = SCIPexprcurvNegate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvNegate", curvature);
            }
            return (int)mh$.invokeExact(curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvMultiply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvMultiply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMultiply(double factor, SCIP_EXPRCURV curvature)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvMultiply$descriptor() {
        return SCIPexprcurvMultiply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMultiply(double factor, SCIP_EXPRCURV curvature)
     * }
     */
    public static MethodHandle SCIPexprcurvMultiply$handle() {
        return SCIPexprcurvMultiply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMultiply(double factor, SCIP_EXPRCURV curvature)
     * }
     */
    public static MemorySegment SCIPexprcurvMultiply$address() {
        return SCIPexprcurvMultiply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMultiply(double factor, SCIP_EXPRCURV curvature)
     * }
     */
    public static int SCIPexprcurvMultiply(double factor, int curvature) {
        var mh$ = SCIPexprcurvMultiply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvMultiply", factor, curvature);
            }
            return (int)mh$.invokeExact(factor, curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvPower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            SCIP_Interval.layout(),
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvPower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPower(SCIP_INTERVAL basebounds, SCIP_EXPRCURV basecurv, double exponent)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvPower$descriptor() {
        return SCIPexprcurvPower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPower(SCIP_INTERVAL basebounds, SCIP_EXPRCURV basecurv, double exponent)
     * }
     */
    public static MethodHandle SCIPexprcurvPower$handle() {
        return SCIPexprcurvPower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPower(SCIP_INTERVAL basebounds, SCIP_EXPRCURV basecurv, double exponent)
     * }
     */
    public static MemorySegment SCIPexprcurvPower$address() {
        return SCIPexprcurvPower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPower(SCIP_INTERVAL basebounds, SCIP_EXPRCURV basecurv, double exponent)
     * }
     */
    public static int SCIPexprcurvPower(MemorySegment basebounds, int basecurv, double exponent) {
        var mh$ = SCIPexprcurvPower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvPower", basebounds, basecurv, exponent);
            }
            return (int)mh$.invokeExact(basebounds, basecurv, exponent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvPowerInv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            SCIP_Interval.layout(),
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvPowerInv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPowerInv(SCIP_INTERVAL basebounds, double exponent, SCIP_EXPRCURV powercurv)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvPowerInv$descriptor() {
        return SCIPexprcurvPowerInv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPowerInv(SCIP_INTERVAL basebounds, double exponent, SCIP_EXPRCURV powercurv)
     * }
     */
    public static MethodHandle SCIPexprcurvPowerInv$handle() {
        return SCIPexprcurvPowerInv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPowerInv(SCIP_INTERVAL basebounds, double exponent, SCIP_EXPRCURV powercurv)
     * }
     */
    public static MemorySegment SCIPexprcurvPowerInv$address() {
        return SCIPexprcurvPowerInv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvPowerInv(SCIP_INTERVAL basebounds, double exponent, SCIP_EXPRCURV powercurv)
     * }
     */
    public static int SCIPexprcurvPowerInv(MemorySegment basebounds, double exponent, int powercurv) {
        var mh$ = SCIPexprcurvPowerInv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvPowerInv", basebounds, exponent, powercurv);
            }
            return (int)mh$.invokeExact(basebounds, exponent, powercurv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvMonomial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvMonomial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMonomial(int nfactors, double *exponents, int *factoridxs, SCIP_EXPRCURV *factorcurv, SCIP_INTERVAL *factorbounds)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvMonomial$descriptor() {
        return SCIPexprcurvMonomial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMonomial(int nfactors, double *exponents, int *factoridxs, SCIP_EXPRCURV *factorcurv, SCIP_INTERVAL *factorbounds)
     * }
     */
    public static MethodHandle SCIPexprcurvMonomial$handle() {
        return SCIPexprcurvMonomial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMonomial(int nfactors, double *exponents, int *factoridxs, SCIP_EXPRCURV *factorcurv, SCIP_INTERVAL *factorbounds)
     * }
     */
    public static MemorySegment SCIPexprcurvMonomial$address() {
        return SCIPexprcurvMonomial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPexprcurvMonomial(int nfactors, double *exponents, int *factoridxs, SCIP_EXPRCURV *factorcurv, SCIP_INTERVAL *factorbounds)
     * }
     */
    public static int SCIPexprcurvMonomial(int nfactors, MemorySegment exponents, MemorySegment factoridxs, MemorySegment factorcurv, MemorySegment factorbounds) {
        var mh$ = SCIPexprcurvMonomial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvMonomial", nfactors, exponents, factoridxs, factorcurv, factorbounds);
            }
            return (int)mh$.invokeExact(nfactors, exponents, factoridxs, factorcurv, factorbounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvMonomialInv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvMonomialInv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexprcurvMonomialInv(SCIP_EXPRCURV monomialcurv, int nfactors, double *exponents, SCIP_INTERVAL *factorbounds, SCIP_EXPRCURV *factorcurv)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvMonomialInv$descriptor() {
        return SCIPexprcurvMonomialInv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexprcurvMonomialInv(SCIP_EXPRCURV monomialcurv, int nfactors, double *exponents, SCIP_INTERVAL *factorbounds, SCIP_EXPRCURV *factorcurv)
     * }
     */
    public static MethodHandle SCIPexprcurvMonomialInv$handle() {
        return SCIPexprcurvMonomialInv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexprcurvMonomialInv(SCIP_EXPRCURV monomialcurv, int nfactors, double *exponents, SCIP_INTERVAL *factorbounds, SCIP_EXPRCURV *factorcurv)
     * }
     */
    public static MemorySegment SCIPexprcurvMonomialInv$address() {
        return SCIPexprcurvMonomialInv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexprcurvMonomialInv(SCIP_EXPRCURV monomialcurv, int nfactors, double *exponents, SCIP_INTERVAL *factorbounds, SCIP_EXPRCURV *factorcurv)
     * }
     */
    public static int SCIPexprcurvMonomialInv(int monomialcurv, int nfactors, MemorySegment exponents, MemorySegment factorbounds, MemorySegment factorcurv) {
        var mh$ = SCIPexprcurvMonomialInv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvMonomialInv", monomialcurv, nfactors, exponents, factorbounds, factorcurv);
            }
            return (int)mh$.invokeExact(monomialcurv, nfactors, exponents, factorbounds, factorcurv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexprcurvGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexprcurvGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPexprcurvGetName(SCIP_EXPRCURV curv)
     * }
     */
    public static FunctionDescriptor SCIPexprcurvGetName$descriptor() {
        return SCIPexprcurvGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPexprcurvGetName(SCIP_EXPRCURV curv)
     * }
     */
    public static MethodHandle SCIPexprcurvGetName$handle() {
        return SCIPexprcurvGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPexprcurvGetName(SCIP_EXPRCURV curv)
     * }
     */
    public static MemorySegment SCIPexprcurvGetName$address() {
        return SCIPexprcurvGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPexprcurvGetName(SCIP_EXPRCURV curv)
     * }
     */
    public static MemorySegment SCIPexprcurvGetName(int curv) {
        var mh$ = SCIPexprcurvGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexprcurvGetName", curv);
            }
            return (MemorySegment)mh$.invokeExact(curv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfopen(const char *path, const char *mode)
     * }
     */
    public static FunctionDescriptor SCIPfopen$descriptor() {
        return SCIPfopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfopen(const char *path, const char *mode)
     * }
     */
    public static MethodHandle SCIPfopen$handle() {
        return SCIPfopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfopen(const char *path, const char *mode)
     * }
     */
    public static MemorySegment SCIPfopen$address() {
        return SCIPfopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfopen(const char *path, const char *mode)
     * }
     */
    public static MemorySegment SCIPfopen(MemorySegment path, MemorySegment mode) {
        var mh$ = SCIPfopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfopen", path, mode);
            }
            return (MemorySegment)mh$.invokeExact(path, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfdopen(int fildes, const char *mode)
     * }
     */
    public static FunctionDescriptor SCIPfdopen$descriptor() {
        return SCIPfdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfdopen(int fildes, const char *mode)
     * }
     */
    public static MethodHandle SCIPfdopen$handle() {
        return SCIPfdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfdopen(int fildes, const char *mode)
     * }
     */
    public static MemorySegment SCIPfdopen$address() {
        return SCIPfdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_FILE *SCIPfdopen(int fildes, const char *mode)
     * }
     */
    public static MemorySegment SCIPfdopen(int fildes, MemorySegment mode) {
        var mh$ = SCIPfdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfdopen", fildes, mode);
            }
            return (MemorySegment)mh$.invokeExact(fildes, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t SCIPfread(void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfread$descriptor() {
        return SCIPfread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t SCIPfread(void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfread$handle() {
        return SCIPfread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t SCIPfread(void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfread$address() {
        return SCIPfread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t SCIPfread(void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static long SCIPfread(MemorySegment ptr, long size, long nmemb, MemorySegment stream) {
        var mh$ = SCIPfread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfread", ptr, size, nmemb, stream);
            }
            return (long)mh$.invokeExact(ptr, size, nmemb, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t SCIPfwrite(const void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfwrite$descriptor() {
        return SCIPfwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t SCIPfwrite(const void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfwrite$handle() {
        return SCIPfwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t SCIPfwrite(const void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfwrite$address() {
        return SCIPfwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t SCIPfwrite(const void *ptr, size_t size, size_t nmemb, SCIP_FILE *stream)
     * }
     */
    public static long SCIPfwrite(MemorySegment ptr, long size, long nmemb, MemorySegment stream) {
        var mh$ = SCIPfwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfwrite", ptr, size, nmemb, stream);
            }
            return (long)mh$.invokeExact(ptr, size, nmemb, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int SCIPfprintf(SCIP_FILE *stream, const char *format, ...)
     * }
     */
    public static class SCIPfprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                scip_h.C_INT,
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPfprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int SCIPfprintf(SCIP_FILE *stream, const char *format, ...)
         * }
         */
        public static SCIPfprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPfprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment stream, MemorySegment format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPfprintf", stream, format, x2);
                }
                return (int)spreader.invokeExact(stream, format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class SCIPfputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfputc(int c, SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfputc$descriptor() {
        return SCIPfputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfputc(int c, SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfputc$handle() {
        return SCIPfputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfputc(int c, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfputc$address() {
        return SCIPfputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfputc(int c, SCIP_FILE *stream)
     * }
     */
    public static int SCIPfputc(int c, MemorySegment stream) {
        var mh$ = SCIPfputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfputc", c, stream);
            }
            return (int)mh$.invokeExact(c, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfputs(const char *s, SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfputs$descriptor() {
        return SCIPfputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfputs(const char *s, SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfputs$handle() {
        return SCIPfputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfputs(const char *s, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfputs$address() {
        return SCIPfputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfputs(const char *s, SCIP_FILE *stream)
     * }
     */
    public static int SCIPfputs(MemorySegment s, MemorySegment stream) {
        var mh$ = SCIPfputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfputs", s, stream);
            }
            return (int)mh$.invokeExact(s, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfgetc(SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfgetc$descriptor() {
        return SCIPfgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfgetc(SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfgetc$handle() {
        return SCIPfgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfgetc(SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfgetc$address() {
        return SCIPfgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfgetc(SCIP_FILE *stream)
     * }
     */
    public static int SCIPfgetc(MemorySegment stream) {
        var mh$ = SCIPfgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfgetc", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPfgets(char *s, int size, SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfgets$descriptor() {
        return SCIPfgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPfgets(char *s, int size, SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfgets$handle() {
        return SCIPfgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPfgets(char *s, int size, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfgets$address() {
        return SCIPfgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPfgets(char *s, int size, SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfgets(MemorySegment s, int size, MemorySegment stream) {
        var mh$ = SCIPfgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfgets", s, size, stream);
            }
            return (MemorySegment)mh$.invokeExact(s, size, stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfflush(SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfflush$descriptor() {
        return SCIPfflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfflush(SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfflush$handle() {
        return SCIPfflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfflush(SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfflush$address() {
        return SCIPfflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfflush(SCIP_FILE *stream)
     * }
     */
    public static int SCIPfflush(MemorySegment stream) {
        var mh$ = SCIPfflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfflush", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_LONG,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfseek(SCIP_FILE *stream, long offset, int whence)
     * }
     */
    public static FunctionDescriptor SCIPfseek$descriptor() {
        return SCIPfseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfseek(SCIP_FILE *stream, long offset, int whence)
     * }
     */
    public static MethodHandle SCIPfseek$handle() {
        return SCIPfseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfseek(SCIP_FILE *stream, long offset, int whence)
     * }
     */
    public static MemorySegment SCIPfseek$address() {
        return SCIPfseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfseek(SCIP_FILE *stream, long offset, int whence)
     * }
     */
    public static int SCIPfseek(MemorySegment stream, long offset, int whence) {
        var mh$ = SCIPfseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfseek", stream, offset, whence);
            }
            return (int)mh$.invokeExact(stream, offset, whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPrewind(SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPrewind$descriptor() {
        return SCIPrewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPrewind(SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPrewind$handle() {
        return SCIPrewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPrewind(SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPrewind$address() {
        return SCIPrewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPrewind(SCIP_FILE *stream)
     * }
     */
    public static void SCIPrewind(MemorySegment stream) {
        var mh$ = SCIPrewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrewind", stream);
            }
            mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long SCIPftell(SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPftell$descriptor() {
        return SCIPftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long SCIPftell(SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPftell$handle() {
        return SCIPftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long SCIPftell(SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPftell$address() {
        return SCIPftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long SCIPftell(SCIP_FILE *stream)
     * }
     */
    public static long SCIPftell(MemorySegment stream) {
        var mh$ = SCIPftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPftell", stream);
            }
            return (long)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfeof(SCIP_FILE *stream)
     * }
     */
    public static FunctionDescriptor SCIPfeof$descriptor() {
        return SCIPfeof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfeof(SCIP_FILE *stream)
     * }
     */
    public static MethodHandle SCIPfeof$handle() {
        return SCIPfeof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfeof(SCIP_FILE *stream)
     * }
     */
    public static MemorySegment SCIPfeof$address() {
        return SCIPfeof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfeof(SCIP_FILE *stream)
     * }
     */
    public static int SCIPfeof(MemorySegment stream) {
        var mh$ = SCIPfeof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeof", stream);
            }
            return (int)mh$.invokeExact(stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPfclose(SCIP_FILE *fp)
     * }
     */
    public static FunctionDescriptor SCIPfclose$descriptor() {
        return SCIPfclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPfclose(SCIP_FILE *fp)
     * }
     */
    public static MethodHandle SCIPfclose$handle() {
        return SCIPfclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPfclose(SCIP_FILE *fp)
     * }
     */
    public static MemorySegment SCIPfclose$address() {
        return SCIPfclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPfclose(SCIP_FILE *fp)
     * }
     */
    public static int SCIPfclose(MemorySegment fp) {
        var mh$ = SCIPfclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfclose", fp);
            }
            return (int)mh$.invokeExact(fp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPheurComp$descriptor() {
        return SCIPheurComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPheurComp$handle() {
        return SCIPheurComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPheurComp$address() {
        return SCIPheurComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPheurComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPheurComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurCompPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurCompPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurCompPriority(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPheurCompPriority$descriptor() {
        return SCIPheurCompPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurCompPriority(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPheurCompPriority$handle() {
        return SCIPheurCompPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurCompPriority(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPheurCompPriority$address() {
        return SCIPheurCompPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurCompPriority(void *elem1, void *elem2)
     * }
     */
    public static int SCIPheurCompPriority(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPheurCompPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurCompPriority", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPheurCompName$descriptor() {
        return SCIPheurCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPheurCompName$handle() {
        return SCIPheurCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPheurCompName$address() {
        return SCIPheurCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPheurCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPheurCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEURDATA *SCIPheurGetData(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetData$descriptor() {
        return SCIPheurGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEURDATA *SCIPheurGetData(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetData$handle() {
        return SCIPheurGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEURDATA *SCIPheurGetData(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetData$address() {
        return SCIPheurGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEURDATA *SCIPheurGetData(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetData(MemorySegment heur) {
        var mh$ = SCIPheurGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetData", heur);
            }
            return (MemorySegment)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPheurSetData(SCIP_HEUR *heur, SCIP_HEURDATA *heurdata)
     * }
     */
    public static FunctionDescriptor SCIPheurSetData$descriptor() {
        return SCIPheurSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPheurSetData(SCIP_HEUR *heur, SCIP_HEURDATA *heurdata)
     * }
     */
    public static MethodHandle SCIPheurSetData$handle() {
        return SCIPheurSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPheurSetData(SCIP_HEUR *heur, SCIP_HEURDATA *heurdata)
     * }
     */
    public static MemorySegment SCIPheurSetData$address() {
        return SCIPheurSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPheurSetData(SCIP_HEUR *heur, SCIP_HEURDATA *heurdata)
     * }
     */
    public static void SCIPheurSetData(MemorySegment heur, MemorySegment heurdata) {
        var mh$ = SCIPheurSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurSetData", heur, heurdata);
            }
            mh$.invokeExact(heur, heurdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPheurGetName(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetName$descriptor() {
        return SCIPheurGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPheurGetName(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetName$handle() {
        return SCIPheurGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPheurGetName(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetName$address() {
        return SCIPheurGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPheurGetName(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetName(MemorySegment heur) {
        var mh$ = SCIPheurGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetName", heur);
            }
            return (MemorySegment)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPheurGetDesc(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetDesc$descriptor() {
        return SCIPheurGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPheurGetDesc(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetDesc$handle() {
        return SCIPheurGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPheurGetDesc(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetDesc$address() {
        return SCIPheurGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPheurGetDesc(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetDesc(MemorySegment heur) {
        var mh$ = SCIPheurGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetDesc", heur);
            }
            return (MemorySegment)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetDispchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetDispchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char SCIPheurGetDispchar(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetDispchar$descriptor() {
        return SCIPheurGetDispchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char SCIPheurGetDispchar(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetDispchar$handle() {
        return SCIPheurGetDispchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char SCIPheurGetDispchar(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetDispchar$address() {
        return SCIPheurGetDispchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char SCIPheurGetDispchar(SCIP_HEUR *heur)
     * }
     */
    public static byte SCIPheurGetDispchar(MemorySegment heur) {
        var mh$ = SCIPheurGetDispchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetDispchar", heur);
            }
            return (byte)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetTimingmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetTimingmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEURTIMING SCIPheurGetTimingmask(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetTimingmask$descriptor() {
        return SCIPheurGetTimingmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEURTIMING SCIPheurGetTimingmask(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetTimingmask$handle() {
        return SCIPheurGetTimingmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEURTIMING SCIPheurGetTimingmask(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetTimingmask$address() {
        return SCIPheurGetTimingmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEURTIMING SCIPheurGetTimingmask(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetTimingmask(MemorySegment heur) {
        var mh$ = SCIPheurGetTimingmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetTimingmask", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurSetTimingmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurSetTimingmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPheurSetTimingmask(SCIP_HEUR *heur, SCIP_HEURTIMING timingmask)
     * }
     */
    public static FunctionDescriptor SCIPheurSetTimingmask$descriptor() {
        return SCIPheurSetTimingmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPheurSetTimingmask(SCIP_HEUR *heur, SCIP_HEURTIMING timingmask)
     * }
     */
    public static MethodHandle SCIPheurSetTimingmask$handle() {
        return SCIPheurSetTimingmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPheurSetTimingmask(SCIP_HEUR *heur, SCIP_HEURTIMING timingmask)
     * }
     */
    public static MemorySegment SCIPheurSetTimingmask$address() {
        return SCIPheurSetTimingmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPheurSetTimingmask(SCIP_HEUR *heur, SCIP_HEURTIMING timingmask)
     * }
     */
    public static void SCIPheurSetTimingmask(MemorySegment heur, int timingmask) {
        var mh$ = SCIPheurSetTimingmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurSetTimingmask", heur, timingmask);
            }
            mh$.invokeExact(heur, timingmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurUsesSubscip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurUsesSubscip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPheurUsesSubscip(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurUsesSubscip$descriptor() {
        return SCIPheurUsesSubscip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPheurUsesSubscip(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurUsesSubscip$handle() {
        return SCIPheurUsesSubscip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPheurUsesSubscip(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurUsesSubscip$address() {
        return SCIPheurUsesSubscip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPheurUsesSubscip(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurUsesSubscip(MemorySegment heur) {
        var mh$ = SCIPheurUsesSubscip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurUsesSubscip", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurGetPriority(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetPriority$descriptor() {
        return SCIPheurGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurGetPriority(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetPriority$handle() {
        return SCIPheurGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurGetPriority(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetPriority$address() {
        return SCIPheurGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurGetPriority(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetPriority(MemorySegment heur) {
        var mh$ = SCIPheurGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetPriority", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurGetFreq(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetFreq$descriptor() {
        return SCIPheurGetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurGetFreq(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetFreq$handle() {
        return SCIPheurGetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurGetFreq(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetFreq$address() {
        return SCIPheurGetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurGetFreq(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetFreq(MemorySegment heur) {
        var mh$ = SCIPheurGetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetFreq", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurSetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurSetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPheurSetFreq(SCIP_HEUR *heur, int freq)
     * }
     */
    public static FunctionDescriptor SCIPheurSetFreq$descriptor() {
        return SCIPheurSetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPheurSetFreq(SCIP_HEUR *heur, int freq)
     * }
     */
    public static MethodHandle SCIPheurSetFreq$handle() {
        return SCIPheurSetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPheurSetFreq(SCIP_HEUR *heur, int freq)
     * }
     */
    public static MemorySegment SCIPheurSetFreq$address() {
        return SCIPheurSetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPheurSetFreq(SCIP_HEUR *heur, int freq)
     * }
     */
    public static void SCIPheurSetFreq(MemorySegment heur, int freq) {
        var mh$ = SCIPheurSetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurSetFreq", heur, freq);
            }
            mh$.invokeExact(heur, freq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetFreqofs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetFreqofs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurGetFreqofs(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetFreqofs$descriptor() {
        return SCIPheurGetFreqofs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurGetFreqofs(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetFreqofs$handle() {
        return SCIPheurGetFreqofs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurGetFreqofs(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetFreqofs$address() {
        return SCIPheurGetFreqofs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurGetFreqofs(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetFreqofs(MemorySegment heur) {
        var mh$ = SCIPheurGetFreqofs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetFreqofs", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetMaxdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetMaxdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurGetMaxdepth(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetMaxdepth$descriptor() {
        return SCIPheurGetMaxdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurGetMaxdepth(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetMaxdepth$handle() {
        return SCIPheurGetMaxdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurGetMaxdepth(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetMaxdepth$address() {
        return SCIPheurGetMaxdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurGetMaxdepth(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetMaxdepth(MemorySegment heur) {
        var mh$ = SCIPheurGetMaxdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetMaxdepth", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPheurGetNCalls(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetNCalls$descriptor() {
        return SCIPheurGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPheurGetNCalls(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetNCalls$handle() {
        return SCIPheurGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPheurGetNCalls(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetNCalls$address() {
        return SCIPheurGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPheurGetNCalls(SCIP_HEUR *heur)
     * }
     */
    public static long SCIPheurGetNCalls(MemorySegment heur) {
        var mh$ = SCIPheurGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetNCalls", heur);
            }
            return (long)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetNSolsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetNSolsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPheurGetNSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetNSolsFound$descriptor() {
        return SCIPheurGetNSolsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPheurGetNSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetNSolsFound$handle() {
        return SCIPheurGetNSolsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPheurGetNSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetNSolsFound$address() {
        return SCIPheurGetNSolsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPheurGetNSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static long SCIPheurGetNSolsFound(MemorySegment heur) {
        var mh$ = SCIPheurGetNSolsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetNSolsFound", heur);
            }
            return (long)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetNBestSolsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetNBestSolsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPheurGetNBestSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetNBestSolsFound$descriptor() {
        return SCIPheurGetNBestSolsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPheurGetNBestSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetNBestSolsFound$handle() {
        return SCIPheurGetNBestSolsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPheurGetNBestSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetNBestSolsFound$address() {
        return SCIPheurGetNBestSolsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPheurGetNBestSolsFound(SCIP_HEUR *heur)
     * }
     */
    public static long SCIPheurGetNBestSolsFound(MemorySegment heur) {
        var mh$ = SCIPheurGetNBestSolsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetNBestSolsFound", heur);
            }
            return (long)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPheurIsInitialized(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurIsInitialized$descriptor() {
        return SCIPheurIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPheurIsInitialized(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurIsInitialized$handle() {
        return SCIPheurIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPheurIsInitialized(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurIsInitialized$address() {
        return SCIPheurIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPheurIsInitialized(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurIsInitialized(MemorySegment heur) {
        var mh$ = SCIPheurIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurIsInitialized", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPheurGetSetupTime(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetSetupTime$descriptor() {
        return SCIPheurGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPheurGetSetupTime(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetSetupTime$handle() {
        return SCIPheurGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPheurGetSetupTime(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetSetupTime$address() {
        return SCIPheurGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPheurGetSetupTime(SCIP_HEUR *heur)
     * }
     */
    public static double SCIPheurGetSetupTime(MemorySegment heur) {
        var mh$ = SCIPheurGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetSetupTime", heur);
            }
            return (double)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPheurGetTime(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetTime$descriptor() {
        return SCIPheurGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPheurGetTime(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetTime$handle() {
        return SCIPheurGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPheurGetTime(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetTime$address() {
        return SCIPheurGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPheurGetTime(SCIP_HEUR *heur)
     * }
     */
    public static double SCIPheurGetTime(MemorySegment heur) {
        var mh$ = SCIPheurGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetTime", heur);
            }
            return (double)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetDivesets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetDivesets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIVESET **SCIPheurGetDivesets(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetDivesets$descriptor() {
        return SCIPheurGetDivesets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIVESET **SCIPheurGetDivesets(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetDivesets$handle() {
        return SCIPheurGetDivesets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIVESET **SCIPheurGetDivesets(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetDivesets$address() {
        return SCIPheurGetDivesets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIVESET **SCIPheurGetDivesets(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetDivesets(MemorySegment heur) {
        var mh$ = SCIPheurGetDivesets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetDivesets", heur);
            }
            return (MemorySegment)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurGetNDivesets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurGetNDivesets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPheurGetNDivesets(SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPheurGetNDivesets$descriptor() {
        return SCIPheurGetNDivesets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPheurGetNDivesets(SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPheurGetNDivesets$handle() {
        return SCIPheurGetNDivesets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPheurGetNDivesets(SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPheurGetNDivesets$address() {
        return SCIPheurGetNDivesets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPheurGetNDivesets(SCIP_HEUR *heur)
     * }
     */
    public static int SCIPheurGetNDivesets(MemorySegment heur) {
        var mh$ = SCIPheurGetNDivesets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurGetNDivesets", heur);
            }
            return (int)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPdivesetGetHeur(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetHeur$descriptor() {
        return SCIPdivesetGetHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPdivesetGetHeur(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetHeur$handle() {
        return SCIPdivesetGetHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPdivesetGetHeur(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetHeur$address() {
        return SCIPdivesetGetHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPdivesetGetHeur(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetHeur(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetHeur", diveset);
            }
            return (MemorySegment)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetWorkSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetWorkSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPdivesetGetWorkSolution(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetWorkSolution$descriptor() {
        return SCIPdivesetGetWorkSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPdivesetGetWorkSolution(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetWorkSolution$handle() {
        return SCIPdivesetGetWorkSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPdivesetGetWorkSolution(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetWorkSolution$address() {
        return SCIPdivesetGetWorkSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL *SCIPdivesetGetWorkSolution(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetWorkSolution(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetWorkSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetWorkSolution", diveset);
            }
            return (MemorySegment)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetSetWorkSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetSetWorkSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdivesetSetWorkSolution(SCIP_DIVESET *diveset, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPdivesetSetWorkSolution$descriptor() {
        return SCIPdivesetSetWorkSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdivesetSetWorkSolution(SCIP_DIVESET *diveset, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPdivesetSetWorkSolution$handle() {
        return SCIPdivesetSetWorkSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdivesetSetWorkSolution(SCIP_DIVESET *diveset, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPdivesetSetWorkSolution$address() {
        return SCIPdivesetSetWorkSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdivesetSetWorkSolution(SCIP_DIVESET *diveset, SCIP_SOL *sol)
     * }
     */
    public static void SCIPdivesetSetWorkSolution(MemorySegment diveset, MemorySegment sol) {
        var mh$ = SCIPdivesetSetWorkSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetSetWorkSolution", diveset, sol);
            }
            mh$.invokeExact(diveset, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPdivesetGetName(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetName$descriptor() {
        return SCIPdivesetGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPdivesetGetName(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetName$handle() {
        return SCIPdivesetGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPdivesetGetName(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetName$address() {
        return SCIPdivesetGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPdivesetGetName(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetName(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetName", diveset);
            }
            return (MemorySegment)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMinRelDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMinRelDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMinRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMinRelDepth$descriptor() {
        return SCIPdivesetGetMinRelDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMinRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetMinRelDepth$handle() {
        return SCIPdivesetGetMinRelDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMinRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetMinRelDepth$address() {
        return SCIPdivesetGetMinRelDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetMinRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetMinRelDepth(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetMinRelDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMinRelDepth", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMaxRelDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMaxRelDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMaxRelDepth$descriptor() {
        return SCIPdivesetGetMaxRelDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetMaxRelDepth$handle() {
        return SCIPdivesetGetMaxRelDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetMaxRelDepth$address() {
        return SCIPdivesetGetMaxRelDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxRelDepth(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetMaxRelDepth(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetMaxRelDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMaxRelDepth", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetSolSuccess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetSolSuccess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetSolSuccess(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetSolSuccess$descriptor() {
        return SCIPdivesetGetSolSuccess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetSolSuccess(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetSolSuccess$handle() {
        return SCIPdivesetGetSolSuccess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetSolSuccess(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetSolSuccess$address() {
        return SCIPdivesetGetSolSuccess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetSolSuccess(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetSolSuccess(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetSolSuccess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetSolSuccess", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNCalls$descriptor() {
        return SCIPdivesetGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNCalls$handle() {
        return SCIPdivesetGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNCalls$address() {
        return SCIPdivesetGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetNCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetNCalls(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNCalls", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNSolutionCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNSolutionCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNSolutionCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNSolutionCalls$descriptor() {
        return SCIPdivesetGetNSolutionCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNSolutionCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNSolutionCalls$handle() {
        return SCIPdivesetGetNSolutionCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetNSolutionCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNSolutionCalls$address() {
        return SCIPdivesetGetNSolutionCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetNSolutionCalls(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetNSolutionCalls(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNSolutionCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNSolutionCalls", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMinDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMinDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMinDepth$descriptor() {
        return SCIPdivesetGetMinDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetMinDepth$handle() {
        return SCIPdivesetGetMinDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetMinDepth$address() {
        return SCIPdivesetGetMinDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetMinDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetMinDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetMinDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMinDepth", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMaxDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMaxDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMaxDepth$descriptor() {
        return SCIPdivesetGetMaxDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetMaxDepth$handle() {
        return SCIPdivesetGetMaxDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetMaxDepth$address() {
        return SCIPdivesetGetMaxDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetMaxDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetMaxDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMaxDepth", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetAvgDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetAvgDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetAvgDepth$descriptor() {
        return SCIPdivesetGetAvgDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetAvgDepth$handle() {
        return SCIPdivesetGetAvgDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetAvgDepth$address() {
        return SCIPdivesetGetAvgDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static double SCIPdivesetGetAvgDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetAvgDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetAvgDepth", diveset, divecontext);
            }
            return (double)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMinSolutionDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMinSolutionDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMinSolutionDepth$descriptor() {
        return SCIPdivesetGetMinSolutionDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetMinSolutionDepth$handle() {
        return SCIPdivesetGetMinSolutionDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMinSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetMinSolutionDepth$address() {
        return SCIPdivesetGetMinSolutionDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetMinSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetMinSolutionDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetMinSolutionDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMinSolutionDepth", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMaxSolutionDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMaxSolutionDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMaxSolutionDepth$descriptor() {
        return SCIPdivesetGetMaxSolutionDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetMaxSolutionDepth$handle() {
        return SCIPdivesetGetMaxSolutionDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetMaxSolutionDepth$address() {
        return SCIPdivesetGetMaxSolutionDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPdivesetGetMaxSolutionDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetMaxSolutionDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMaxSolutionDepth", diveset, divecontext);
            }
            return (int)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetAvgSolutionDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetAvgSolutionDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetAvgSolutionDepth$descriptor() {
        return SCIPdivesetGetAvgSolutionDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetAvgSolutionDepth$handle() {
        return SCIPdivesetGetAvgSolutionDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetAvgSolutionDepth$address() {
        return SCIPdivesetGetAvgSolutionDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgSolutionDepth(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static double SCIPdivesetGetAvgSolutionDepth(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetAvgSolutionDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetAvgSolutionDepth", diveset, divecontext);
            }
            return (double)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNLPIterations(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNLPIterations$descriptor() {
        return SCIPdivesetGetNLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNLPIterations(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNLPIterations$handle() {
        return SCIPdivesetGetNLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNLPIterations(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNLPIterations$address() {
        return SCIPdivesetGetNLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetNLPIterations(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetNLPIterations(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNLPIterations", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNProbingNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNProbingNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNProbingNodes(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNProbingNodes$descriptor() {
        return SCIPdivesetGetNProbingNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNProbingNodes(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNProbingNodes$handle() {
        return SCIPdivesetGetNProbingNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNProbingNodes(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNProbingNodes$address() {
        return SCIPdivesetGetNProbingNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetNProbingNodes(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetNProbingNodes(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNProbingNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNProbingNodes", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNBacktracks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNBacktracks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNBacktracks(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNBacktracks$descriptor() {
        return SCIPdivesetGetNBacktracks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNBacktracks(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNBacktracks$handle() {
        return SCIPdivesetGetNBacktracks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNBacktracks(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNBacktracks$address() {
        return SCIPdivesetGetNBacktracks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetNBacktracks(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetNBacktracks(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNBacktracks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNBacktracks", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNConflicts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNConflicts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNConflicts(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNConflicts$descriptor() {
        return SCIPdivesetGetNConflicts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNConflicts(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNConflicts$handle() {
        return SCIPdivesetGetNConflicts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNConflicts(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNConflicts$address() {
        return SCIPdivesetGetNConflicts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetNConflicts(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetNConflicts(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNConflicts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNConflicts", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetNSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetNSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNSols(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetNSols$descriptor() {
        return SCIPdivesetGetNSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNSols(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPdivesetGetNSols$handle() {
        return SCIPdivesetGetNSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPdivesetGetNSols(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPdivesetGetNSols$address() {
        return SCIPdivesetGetNSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPdivesetGetNSols(SCIP_DIVESET *diveset, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static long SCIPdivesetGetNSols(MemorySegment diveset, int divecontext) {
        var mh$ = SCIPdivesetGetNSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetNSols", diveset, divecontext);
            }
            return (long)mh$.invokeExact(diveset, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMaxLPIterQuot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMaxLPIterQuot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxLPIterQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMaxLPIterQuot$descriptor() {
        return SCIPdivesetGetMaxLPIterQuot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxLPIterQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetMaxLPIterQuot$handle() {
        return SCIPdivesetGetMaxLPIterQuot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxLPIterQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetMaxLPIterQuot$address() {
        return SCIPdivesetGetMaxLPIterQuot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetMaxLPIterQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetMaxLPIterQuot(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetMaxLPIterQuot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMaxLPIterQuot", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetMaxLPIterOffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetMaxLPIterOffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxLPIterOffset(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetMaxLPIterOffset$descriptor() {
        return SCIPdivesetGetMaxLPIterOffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxLPIterOffset(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetMaxLPIterOffset$handle() {
        return SCIPdivesetGetMaxLPIterOffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxLPIterOffset(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetMaxLPIterOffset$address() {
        return SCIPdivesetGetMaxLPIterOffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetMaxLPIterOffset(SCIP_DIVESET *diveset)
     * }
     */
    public static int SCIPdivesetGetMaxLPIterOffset(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetMaxLPIterOffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetMaxLPIterOffset", diveset);
            }
            return (int)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetUbQuotNoSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetUbQuotNoSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetUbQuotNoSol$descriptor() {
        return SCIPdivesetGetUbQuotNoSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetUbQuotNoSol$handle() {
        return SCIPdivesetGetUbQuotNoSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetUbQuotNoSol$address() {
        return SCIPdivesetGetUbQuotNoSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetUbQuotNoSol(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetUbQuotNoSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetUbQuotNoSol", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetAvgQuotNoSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetAvgQuotNoSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetAvgQuotNoSol$descriptor() {
        return SCIPdivesetGetAvgQuotNoSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetAvgQuotNoSol$handle() {
        return SCIPdivesetGetAvgQuotNoSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetAvgQuotNoSol$address() {
        return SCIPdivesetGetAvgQuotNoSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuotNoSol(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetAvgQuotNoSol(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetAvgQuotNoSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetAvgQuotNoSol", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetUbQuot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetUbQuot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetUbQuot$descriptor() {
        return SCIPdivesetGetUbQuot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetUbQuot$handle() {
        return SCIPdivesetGetUbQuot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetUbQuot$address() {
        return SCIPdivesetGetUbQuot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetUbQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetUbQuot(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetUbQuot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetUbQuot", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetAvgQuot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetAvgQuot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetAvgQuot$descriptor() {
        return SCIPdivesetGetAvgQuot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetAvgQuot$handle() {
        return SCIPdivesetGetAvgQuot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetAvgQuot$address() {
        return SCIPdivesetGetAvgQuot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetAvgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetAvgQuot(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetAvgQuot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetAvgQuot", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetUseBacktrack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetUseBacktrack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseBacktrack(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetUseBacktrack$descriptor() {
        return SCIPdivesetUseBacktrack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseBacktrack(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetUseBacktrack$handle() {
        return SCIPdivesetUseBacktrack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseBacktrack(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetUseBacktrack$address() {
        return SCIPdivesetUseBacktrack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseBacktrack(SCIP_DIVESET *diveset)
     * }
     */
    public static int SCIPdivesetUseBacktrack(MemorySegment diveset) {
        var mh$ = SCIPdivesetUseBacktrack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetUseBacktrack", diveset);
            }
            return (int)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetLPSolveFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetLPSolveFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdivesetGetLPSolveFreq(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetLPSolveFreq$descriptor() {
        return SCIPdivesetGetLPSolveFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdivesetGetLPSolveFreq(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetLPSolveFreq$handle() {
        return SCIPdivesetGetLPSolveFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdivesetGetLPSolveFreq(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetLPSolveFreq$address() {
        return SCIPdivesetGetLPSolveFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdivesetGetLPSolveFreq(SCIP_DIVESET *diveset)
     * }
     */
    public static int SCIPdivesetGetLPSolveFreq(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetLPSolveFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetLPSolveFreq", diveset);
            }
            return (int)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetLPResolveDomChgQuot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetLPResolveDomChgQuot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdivesetGetLPResolveDomChgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetLPResolveDomChgQuot$descriptor() {
        return SCIPdivesetGetLPResolveDomChgQuot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdivesetGetLPResolveDomChgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetLPResolveDomChgQuot$handle() {
        return SCIPdivesetGetLPResolveDomChgQuot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdivesetGetLPResolveDomChgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetLPResolveDomChgQuot$address() {
        return SCIPdivesetGetLPResolveDomChgQuot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdivesetGetLPResolveDomChgQuot(SCIP_DIVESET *diveset)
     * }
     */
    public static double SCIPdivesetGetLPResolveDomChgQuot(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetLPResolveDomChgQuot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetLPResolveDomChgQuot", diveset);
            }
            return (double)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetUseOnlyLPBranchcands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetUseOnlyLPBranchcands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseOnlyLPBranchcands(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetUseOnlyLPBranchcands$descriptor() {
        return SCIPdivesetUseOnlyLPBranchcands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseOnlyLPBranchcands(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetUseOnlyLPBranchcands$handle() {
        return SCIPdivesetUseOnlyLPBranchcands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseOnlyLPBranchcands(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetUseOnlyLPBranchcands$address() {
        return SCIPdivesetUseOnlyLPBranchcands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdivesetUseOnlyLPBranchcands(SCIP_DIVESET *diveset)
     * }
     */
    public static int SCIPdivesetUseOnlyLPBranchcands(MemorySegment diveset) {
        var mh$ = SCIPdivesetUseOnlyLPBranchcands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetUseOnlyLPBranchcands", diveset);
            }
            return (int)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetSupportsType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetSupportsType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetSupportsType(SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype)
     * }
     */
    public static FunctionDescriptor SCIPdivesetSupportsType$descriptor() {
        return SCIPdivesetSupportsType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetSupportsType(SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype)
     * }
     */
    public static MethodHandle SCIPdivesetSupportsType$handle() {
        return SCIPdivesetSupportsType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetSupportsType(SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype)
     * }
     */
    public static MemorySegment SCIPdivesetSupportsType$address() {
        return SCIPdivesetSupportsType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdivesetSupportsType(SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype)
     * }
     */
    public static int SCIPdivesetSupportsType(MemorySegment diveset, int divetype) {
        var mh$ = SCIPdivesetSupportsType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetSupportsType", diveset, divetype);
            }
            return (int)mh$.invokeExact(diveset, divetype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetGetRandnumgen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetGetRandnumgen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPdivesetGetRandnumgen(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetGetRandnumgen$descriptor() {
        return SCIPdivesetGetRandnumgen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPdivesetGetRandnumgen(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetGetRandnumgen$handle() {
        return SCIPdivesetGetRandnumgen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPdivesetGetRandnumgen(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetRandnumgen$address() {
        return SCIPdivesetGetRandnumgen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RANDNUMGEN *SCIPdivesetGetRandnumgen(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetGetRandnumgen(MemorySegment diveset) {
        var mh$ = SCIPdivesetGetRandnumgen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetGetRandnumgen", diveset);
            }
            return (MemorySegment)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdivesetIsPublic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdivesetIsPublic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetIsPublic(SCIP_DIVESET *diveset)
     * }
     */
    public static FunctionDescriptor SCIPdivesetIsPublic$descriptor() {
        return SCIPdivesetIsPublic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetIsPublic(SCIP_DIVESET *diveset)
     * }
     */
    public static MethodHandle SCIPdivesetIsPublic$handle() {
        return SCIPdivesetIsPublic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdivesetIsPublic(SCIP_DIVESET *diveset)
     * }
     */
    public static MemorySegment SCIPdivesetIsPublic$address() {
        return SCIPdivesetIsPublic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdivesetIsPublic(SCIP_DIVESET *diveset)
     * }
     */
    public static int SCIPdivesetIsPublic(MemorySegment diveset) {
        var mh$ = SCIPdivesetIsPublic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdivesetIsPublic", diveset);
            }
            return (int)mh$.invokeExact(diveset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvariablegraphBreadthFirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvariablegraphBreadthFirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariablegraphBreadthFirst(SCIP *scip, SCIP_VGRAPH *vargraph, SCIP_VAR **startvars, int nstartvars, int *distances, int maxdistance, int maxvars, int maxbinintvars)
     * }
     */
    public static FunctionDescriptor SCIPvariablegraphBreadthFirst$descriptor() {
        return SCIPvariablegraphBreadthFirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariablegraphBreadthFirst(SCIP *scip, SCIP_VGRAPH *vargraph, SCIP_VAR **startvars, int nstartvars, int *distances, int maxdistance, int maxvars, int maxbinintvars)
     * }
     */
    public static MethodHandle SCIPvariablegraphBreadthFirst$handle() {
        return SCIPvariablegraphBreadthFirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariablegraphBreadthFirst(SCIP *scip, SCIP_VGRAPH *vargraph, SCIP_VAR **startvars, int nstartvars, int *distances, int maxdistance, int maxvars, int maxbinintvars)
     * }
     */
    public static MemorySegment SCIPvariablegraphBreadthFirst$address() {
        return SCIPvariablegraphBreadthFirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariablegraphBreadthFirst(SCIP *scip, SCIP_VGRAPH *vargraph, SCIP_VAR **startvars, int nstartvars, int *distances, int maxdistance, int maxvars, int maxbinintvars)
     * }
     */
    public static int SCIPvariablegraphBreadthFirst(MemorySegment scip, MemorySegment vargraph, MemorySegment startvars, int nstartvars, MemorySegment distances, int maxdistance, int maxvars, int maxbinintvars) {
        var mh$ = SCIPvariablegraphBreadthFirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvariablegraphBreadthFirst", scip, vargraph, startvars, nstartvars, distances, maxdistance, maxvars, maxbinintvars);
            }
            return (int)mh$.invokeExact(scip, vargraph, startvars, nstartvars, distances, maxdistance, maxvars, maxbinintvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvariableGraphCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvariableGraphCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariableGraphCreate(SCIP *scip, SCIP_VGRAPH **vargraph, unsigned int relaxdenseconss, double relaxdensity, int *nrelaxedconstraints)
     * }
     */
    public static FunctionDescriptor SCIPvariableGraphCreate$descriptor() {
        return SCIPvariableGraphCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariableGraphCreate(SCIP *scip, SCIP_VGRAPH **vargraph, unsigned int relaxdenseconss, double relaxdensity, int *nrelaxedconstraints)
     * }
     */
    public static MethodHandle SCIPvariableGraphCreate$handle() {
        return SCIPvariableGraphCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariableGraphCreate(SCIP *scip, SCIP_VGRAPH **vargraph, unsigned int relaxdenseconss, double relaxdensity, int *nrelaxedconstraints)
     * }
     */
    public static MemorySegment SCIPvariableGraphCreate$address() {
        return SCIPvariableGraphCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvariableGraphCreate(SCIP *scip, SCIP_VGRAPH **vargraph, unsigned int relaxdenseconss, double relaxdensity, int *nrelaxedconstraints)
     * }
     */
    public static int SCIPvariableGraphCreate(MemorySegment scip, MemorySegment vargraph, int relaxdenseconss, double relaxdensity, MemorySegment nrelaxedconstraints) {
        var mh$ = SCIPvariableGraphCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvariableGraphCreate", scip, vargraph, relaxdenseconss, relaxdensity, nrelaxedconstraints);
            }
            return (int)mh$.invokeExact(scip, vargraph, relaxdenseconss, relaxdensity, nrelaxedconstraints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvariableGraphFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvariableGraphFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvariableGraphFree(SCIP *scip, SCIP_VGRAPH **vargraph)
     * }
     */
    public static FunctionDescriptor SCIPvariableGraphFree$descriptor() {
        return SCIPvariableGraphFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvariableGraphFree(SCIP *scip, SCIP_VGRAPH **vargraph)
     * }
     */
    public static MethodHandle SCIPvariableGraphFree$handle() {
        return SCIPvariableGraphFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvariableGraphFree(SCIP *scip, SCIP_VGRAPH **vargraph)
     * }
     */
    public static MemorySegment SCIPvariableGraphFree$address() {
        return SCIPvariableGraphFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvariableGraphFree(SCIP *scip, SCIP_VGRAPH **vargraph)
     * }
     */
    public static void SCIPvariableGraphFree(MemorySegment scip, MemorySegment vargraph) {
        var mh$ = SCIPvariableGraphFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvariableGraphFree", scip, vargraph);
            }
            mh$.invokeExact(scip, vargraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomprComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPcomprComp$descriptor() {
        return SCIPcomprComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomprComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPcomprComp$handle() {
        return SCIPcomprComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomprComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPcomprComp$address() {
        return SCIPcomprComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomprComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPcomprComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPcomprComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomprCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPcomprCompName$descriptor() {
        return SCIPcomprCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomprCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPcomprCompName$handle() {
        return SCIPcomprCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomprCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPcomprCompName$address() {
        return SCIPcomprCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomprCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPcomprCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPcomprCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COMPRDATA *SCIPcomprGetData(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetData$descriptor() {
        return SCIPcomprGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COMPRDATA *SCIPcomprGetData(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetData$handle() {
        return SCIPcomprGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COMPRDATA *SCIPcomprGetData(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetData$address() {
        return SCIPcomprGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COMPRDATA *SCIPcomprGetData(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetData(MemorySegment compr) {
        var mh$ = SCIPcomprGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetData", compr);
            }
            return (MemorySegment)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomprSetData(SCIP_COMPR *compr, SCIP_COMPRDATA *comprdata)
     * }
     */
    public static FunctionDescriptor SCIPcomprSetData$descriptor() {
        return SCIPcomprSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomprSetData(SCIP_COMPR *compr, SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MethodHandle SCIPcomprSetData$handle() {
        return SCIPcomprSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomprSetData(SCIP_COMPR *compr, SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MemorySegment SCIPcomprSetData$address() {
        return SCIPcomprSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomprSetData(SCIP_COMPR *compr, SCIP_COMPRDATA *comprdata)
     * }
     */
    public static void SCIPcomprSetData(MemorySegment compr, MemorySegment comprdata) {
        var mh$ = SCIPcomprSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprSetData", compr, comprdata);
            }
            mh$.invokeExact(compr, comprdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetName(SCIP_COMPR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetName$descriptor() {
        return SCIPcomprGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetName(SCIP_COMPR *heur)
     * }
     */
    public static MethodHandle SCIPcomprGetName$handle() {
        return SCIPcomprGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetName(SCIP_COMPR *heur)
     * }
     */
    public static MemorySegment SCIPcomprGetName$address() {
        return SCIPcomprGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcomprGetName(SCIP_COMPR *heur)
     * }
     */
    public static MemorySegment SCIPcomprGetName(MemorySegment heur) {
        var mh$ = SCIPcomprGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetName", heur);
            }
            return (MemorySegment)mh$.invokeExact(heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetDesc(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetDesc$descriptor() {
        return SCIPcomprGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetDesc(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetDesc$handle() {
        return SCIPcomprGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcomprGetDesc(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetDesc$address() {
        return SCIPcomprGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcomprGetDesc(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetDesc(MemorySegment compr) {
        var mh$ = SCIPcomprGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetDesc", compr);
            }
            return (MemorySegment)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomprGetPriority(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetPriority$descriptor() {
        return SCIPcomprGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomprGetPriority(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetPriority$handle() {
        return SCIPcomprGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomprGetPriority(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetPriority$address() {
        return SCIPcomprGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomprGetPriority(SCIP_COMPR *compr)
     * }
     */
    public static int SCIPcomprGetPriority(MemorySegment compr) {
        var mh$ = SCIPcomprGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetPriority", compr);
            }
            return (int)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetMinNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetMinNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomprGetMinNodes(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetMinNodes$descriptor() {
        return SCIPcomprGetMinNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomprGetMinNodes(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetMinNodes$handle() {
        return SCIPcomprGetMinNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomprGetMinNodes(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetMinNodes$address() {
        return SCIPcomprGetMinNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomprGetMinNodes(SCIP_COMPR *compr)
     * }
     */
    public static int SCIPcomprGetMinNodes(MemorySegment compr) {
        var mh$ = SCIPcomprGetMinNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetMinNodes", compr);
            }
            return (int)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNCalls(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetNCalls$descriptor() {
        return SCIPcomprGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNCalls(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetNCalls$handle() {
        return SCIPcomprGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNCalls(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetNCalls$address() {
        return SCIPcomprGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcomprGetNCalls(SCIP_COMPR *compr)
     * }
     */
    public static long SCIPcomprGetNCalls(MemorySegment compr) {
        var mh$ = SCIPcomprGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetNCalls", compr);
            }
            return (long)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetNFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetNFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNFound(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetNFound$descriptor() {
        return SCIPcomprGetNFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNFound(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetNFound$handle() {
        return SCIPcomprGetNFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcomprGetNFound(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetNFound$address() {
        return SCIPcomprGetNFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcomprGetNFound(SCIP_COMPR *compr)
     * }
     */
    public static long SCIPcomprGetNFound(MemorySegment compr) {
        var mh$ = SCIPcomprGetNFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetNFound", compr);
            }
            return (long)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcomprIsInitialized(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprIsInitialized$descriptor() {
        return SCIPcomprIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcomprIsInitialized(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprIsInitialized$handle() {
        return SCIPcomprIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcomprIsInitialized(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprIsInitialized$address() {
        return SCIPcomprIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcomprIsInitialized(SCIP_COMPR *compr)
     * }
     */
    public static int SCIPcomprIsInitialized(MemorySegment compr) {
        var mh$ = SCIPcomprIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprIsInitialized", compr);
            }
            return (int)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomprGetSetupTime(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetSetupTime$descriptor() {
        return SCIPcomprGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomprGetSetupTime(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetSetupTime$handle() {
        return SCIPcomprGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomprGetSetupTime(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetSetupTime$address() {
        return SCIPcomprGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomprGetSetupTime(SCIP_COMPR *compr)
     * }
     */
    public static double SCIPcomprGetSetupTime(MemorySegment compr) {
        var mh$ = SCIPcomprGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetSetupTime", compr);
            }
            return (double)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomprGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomprGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomprGetTime(SCIP_COMPR *compr)
     * }
     */
    public static FunctionDescriptor SCIPcomprGetTime$descriptor() {
        return SCIPcomprGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomprGetTime(SCIP_COMPR *compr)
     * }
     */
    public static MethodHandle SCIPcomprGetTime$handle() {
        return SCIPcomprGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomprGetTime(SCIP_COMPR *compr)
     * }
     */
    public static MemorySegment SCIPcomprGetTime$address() {
        return SCIPcomprGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomprGetTime(SCIP_COMPR *compr)
     * }
     */
    public static double SCIPcomprGetTime(MemorySegment compr) {
        var mh$ = SCIPcomprGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomprGetTime", compr);
            }
            return (double)mh$.invokeExact(compr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhistoryGetVSIDS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhistoryGetVSIDS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPhistoryGetVSIDS(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPhistoryGetVSIDS$descriptor() {
        return SCIPhistoryGetVSIDS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPhistoryGetVSIDS(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPhistoryGetVSIDS$handle() {
        return SCIPhistoryGetVSIDS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPhistoryGetVSIDS(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPhistoryGetVSIDS$address() {
        return SCIPhistoryGetVSIDS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPhistoryGetVSIDS(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPhistoryGetVSIDS(MemorySegment history, int dir) {
        var mh$ = SCIPhistoryGetVSIDS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhistoryGetVSIDS", history, dir);
            }
            return (double)mh$.invokeExact(history, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhistoryGetAvgConflictlength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhistoryGetAvgConflictlength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPhistoryGetAvgConflictlength(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPhistoryGetAvgConflictlength$descriptor() {
        return SCIPhistoryGetAvgConflictlength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPhistoryGetAvgConflictlength(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPhistoryGetAvgConflictlength$handle() {
        return SCIPhistoryGetAvgConflictlength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPhistoryGetAvgConflictlength(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPhistoryGetAvgConflictlength$address() {
        return SCIPhistoryGetAvgConflictlength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPhistoryGetAvgConflictlength(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPhistoryGetAvgConflictlength(MemorySegment history, int dir) {
        var mh$ = SCIPhistoryGetAvgConflictlength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhistoryGetAvgConflictlength", history, dir);
            }
            return (double)mh$.invokeExact(history, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhistoryGetCutoffSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhistoryGetCutoffSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPhistoryGetCutoffSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPhistoryGetCutoffSum$descriptor() {
        return SCIPhistoryGetCutoffSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPhistoryGetCutoffSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPhistoryGetCutoffSum$handle() {
        return SCIPhistoryGetCutoffSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPhistoryGetCutoffSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPhistoryGetCutoffSum$address() {
        return SCIPhistoryGetCutoffSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPhistoryGetCutoffSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPhistoryGetCutoffSum(MemorySegment history, int dir) {
        var mh$ = SCIPhistoryGetCutoffSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhistoryGetCutoffSum", history, dir);
            }
            return (double)mh$.invokeExact(history, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhistoryGetInferenceSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhistoryGetInferenceSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPhistoryGetInferenceSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPhistoryGetInferenceSum$descriptor() {
        return SCIPhistoryGetInferenceSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPhistoryGetInferenceSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPhistoryGetInferenceSum$handle() {
        return SCIPhistoryGetInferenceSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPhistoryGetInferenceSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPhistoryGetInferenceSum$address() {
        return SCIPhistoryGetInferenceSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPhistoryGetInferenceSum(SCIP_HISTORY *history, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPhistoryGetInferenceSum(MemorySegment history, int dir) {
        var mh$ = SCIPhistoryGetInferenceSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhistoryGetInferenceSum", history, dir);
            }
            return (double)mh$.invokeExact(history, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvaluehistoryGetNValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvaluehistoryGetNValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvaluehistoryGetNValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static FunctionDescriptor SCIPvaluehistoryGetNValues$descriptor() {
        return SCIPvaluehistoryGetNValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvaluehistoryGetNValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MethodHandle SCIPvaluehistoryGetNValues$handle() {
        return SCIPvaluehistoryGetNValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvaluehistoryGetNValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MemorySegment SCIPvaluehistoryGetNValues$address() {
        return SCIPvaluehistoryGetNValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvaluehistoryGetNValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static int SCIPvaluehistoryGetNValues(MemorySegment valuehistory) {
        var mh$ = SCIPvaluehistoryGetNValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvaluehistoryGetNValues", valuehistory);
            }
            return (int)mh$.invokeExact(valuehistory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvaluehistoryGetHistories {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvaluehistoryGetHistories");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HISTORY **SCIPvaluehistoryGetHistories(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static FunctionDescriptor SCIPvaluehistoryGetHistories$descriptor() {
        return SCIPvaluehistoryGetHistories.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HISTORY **SCIPvaluehistoryGetHistories(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MethodHandle SCIPvaluehistoryGetHistories$handle() {
        return SCIPvaluehistoryGetHistories.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HISTORY **SCIPvaluehistoryGetHistories(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MemorySegment SCIPvaluehistoryGetHistories$address() {
        return SCIPvaluehistoryGetHistories.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HISTORY **SCIPvaluehistoryGetHistories(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MemorySegment SCIPvaluehistoryGetHistories(MemorySegment valuehistory) {
        var mh$ = SCIPvaluehistoryGetHistories.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvaluehistoryGetHistories", valuehistory);
            }
            return (MemorySegment)mh$.invokeExact(valuehistory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvaluehistoryGetValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvaluehistoryGetValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvaluehistoryGetValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static FunctionDescriptor SCIPvaluehistoryGetValues$descriptor() {
        return SCIPvaluehistoryGetValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvaluehistoryGetValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MethodHandle SCIPvaluehistoryGetValues$handle() {
        return SCIPvaluehistoryGetValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvaluehistoryGetValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MemorySegment SCIPvaluehistoryGetValues$address() {
        return SCIPvaluehistoryGetValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvaluehistoryGetValues(SCIP_VALUEHISTORY *valuehistory)
     * }
     */
    public static MemorySegment SCIPvaluehistoryGetValues(MemorySegment valuehistory) {
        var mh$ = SCIPvaluehistoryGetValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvaluehistoryGetValues", valuehistory);
            }
            return (MemorySegment)mh$.invokeExact(valuehistory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueSearchVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueSearchVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcliqueSearchVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static FunctionDescriptor SCIPcliqueSearchVar$descriptor() {
        return SCIPcliqueSearchVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcliqueSearchVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static MethodHandle SCIPcliqueSearchVar$handle() {
        return SCIPcliqueSearchVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcliqueSearchVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static MemorySegment SCIPcliqueSearchVar$address() {
        return SCIPcliqueSearchVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcliqueSearchVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static int SCIPcliqueSearchVar(MemorySegment clique, MemorySegment var_, int value) {
        var mh$ = SCIPcliqueSearchVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueSearchVar", clique, var_, value);
            }
            return (int)mh$.invokeExact(clique, var_, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueHasVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueHasVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueHasVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static FunctionDescriptor SCIPcliqueHasVar$descriptor() {
        return SCIPcliqueHasVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueHasVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static MethodHandle SCIPcliqueHasVar$handle() {
        return SCIPcliqueHasVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueHasVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static MemorySegment SCIPcliqueHasVar$address() {
        return SCIPcliqueHasVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcliqueHasVar(SCIP_CLIQUE *clique, SCIP_VAR *var, unsigned int value)
     * }
     */
    public static int SCIPcliqueHasVar(MemorySegment clique, MemorySegment var_, int value) {
        var mh$ = SCIPcliqueHasVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueHasVar", clique, var_, value);
            }
            return (int)mh$.invokeExact(clique, var_, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueGetNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueGetNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcliqueGetNVars(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueGetNVars$descriptor() {
        return SCIPcliqueGetNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcliqueGetNVars(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueGetNVars$handle() {
        return SCIPcliqueGetNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcliqueGetNVars(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetNVars$address() {
        return SCIPcliqueGetNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcliqueGetNVars(SCIP_CLIQUE *clique)
     * }
     */
    public static int SCIPcliqueGetNVars(MemorySegment clique) {
        var mh$ = SCIPcliqueGetNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueGetNVars", clique);
            }
            return (int)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueGetVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueGetVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPcliqueGetVars(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueGetVars$descriptor() {
        return SCIPcliqueGetVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPcliqueGetVars(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueGetVars$handle() {
        return SCIPcliqueGetVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPcliqueGetVars(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetVars$address() {
        return SCIPcliqueGetVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPcliqueGetVars(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetVars(MemorySegment clique) {
        var mh$ = SCIPcliqueGetVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueGetVars", clique);
            }
            return (MemorySegment)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueGetValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueGetValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int *SCIPcliqueGetValues(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueGetValues$descriptor() {
        return SCIPcliqueGetValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int *SCIPcliqueGetValues(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueGetValues$handle() {
        return SCIPcliqueGetValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int *SCIPcliqueGetValues(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetValues$address() {
        return SCIPcliqueGetValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int *SCIPcliqueGetValues(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetValues(MemorySegment clique) {
        var mh$ = SCIPcliqueGetValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueGetValues", clique);
            }
            return (MemorySegment)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueGetId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueGetId");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueGetId(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueGetId$descriptor() {
        return SCIPcliqueGetId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueGetId(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueGetId$handle() {
        return SCIPcliqueGetId.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueGetId(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetId$address() {
        return SCIPcliqueGetId.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcliqueGetId(SCIP_CLIQUE *clique)
     * }
     */
    public static int SCIPcliqueGetId(MemorySegment clique) {
        var mh$ = SCIPcliqueGetId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueGetId", clique);
            }
            return (int)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueGetIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueGetIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcliqueGetIndex(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueGetIndex$descriptor() {
        return SCIPcliqueGetIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcliqueGetIndex(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueGetIndex$handle() {
        return SCIPcliqueGetIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcliqueGetIndex(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueGetIndex$address() {
        return SCIPcliqueGetIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcliqueGetIndex(SCIP_CLIQUE *clique)
     * }
     */
    public static int SCIPcliqueGetIndex(MemorySegment clique) {
        var mh$ = SCIPcliqueGetIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueGetIndex", clique);
            }
            return (int)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueIsCleanedUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueIsCleanedUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsCleanedUp(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueIsCleanedUp$descriptor() {
        return SCIPcliqueIsCleanedUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsCleanedUp(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueIsCleanedUp$handle() {
        return SCIPcliqueIsCleanedUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsCleanedUp(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueIsCleanedUp$address() {
        return SCIPcliqueIsCleanedUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsCleanedUp(SCIP_CLIQUE *clique)
     * }
     */
    public static int SCIPcliqueIsCleanedUp(MemorySegment clique) {
        var mh$ = SCIPcliqueIsCleanedUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueIsCleanedUp", clique);
            }
            return (int)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcliqueIsEquation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcliqueIsEquation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsEquation(SCIP_CLIQUE *clique)
     * }
     */
    public static FunctionDescriptor SCIPcliqueIsEquation$descriptor() {
        return SCIPcliqueIsEquation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsEquation(SCIP_CLIQUE *clique)
     * }
     */
    public static MethodHandle SCIPcliqueIsEquation$handle() {
        return SCIPcliqueIsEquation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsEquation(SCIP_CLIQUE *clique)
     * }
     */
    public static MemorySegment SCIPcliqueIsEquation$address() {
        return SCIPcliqueIsEquation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcliqueIsEquation(SCIP_CLIQUE *clique)
     * }
     */
    public static int SCIPcliqueIsEquation(MemorySegment clique) {
        var mh$ = SCIPcliqueIsEquation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcliqueIsEquation", clique);
            }
            return (int)mh$.invokeExact(clique);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_OBJSEN_MAXIMIZE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ObjSen.SCIP_OBJSEN_MAXIMIZE = -1
     * }
     */
    public static int SCIP_OBJSEN_MAXIMIZE() {
        return SCIP_OBJSEN_MAXIMIZE;
    }
    private static final int SCIP_OBJSEN_MINIMIZE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_ObjSen.SCIP_OBJSEN_MINIMIZE = 1
     * }
     */
    public static int SCIP_OBJSEN_MINIMIZE() {
        return SCIP_OBJSEN_MINIMIZE;
    }
    private static final int SCIP_LPPAR_FROMSCRATCH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_FROMSCRATCH = 0
     * }
     */
    public static int SCIP_LPPAR_FROMSCRATCH() {
        return SCIP_LPPAR_FROMSCRATCH;
    }
    private static final int SCIP_LPPAR_FASTMIP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_FASTMIP = 1
     * }
     */
    public static int SCIP_LPPAR_FASTMIP() {
        return SCIP_LPPAR_FASTMIP;
    }
    private static final int SCIP_LPPAR_SCALING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_SCALING = 2
     * }
     */
    public static int SCIP_LPPAR_SCALING() {
        return SCIP_LPPAR_SCALING;
    }
    private static final int SCIP_LPPAR_PRESOLVING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_PRESOLVING = 3
     * }
     */
    public static int SCIP_LPPAR_PRESOLVING() {
        return SCIP_LPPAR_PRESOLVING;
    }
    private static final int SCIP_LPPAR_PRICING = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_PRICING = 4
     * }
     */
    public static int SCIP_LPPAR_PRICING() {
        return SCIP_LPPAR_PRICING;
    }
    private static final int SCIP_LPPAR_LPINFO = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_LPINFO = 5
     * }
     */
    public static int SCIP_LPPAR_LPINFO() {
        return SCIP_LPPAR_LPINFO;
    }
    private static final int SCIP_LPPAR_FEASTOL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_FEASTOL = 6
     * }
     */
    public static int SCIP_LPPAR_FEASTOL() {
        return SCIP_LPPAR_FEASTOL;
    }
    private static final int SCIP_LPPAR_DUALFEASTOL = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LPParam.SCIP_LPPAR_DUALFEASTOL = 7
     * }
     */
    public static int SCIP_LPPAR_DUALFEASTOL() {
        return SCIP_LPPAR_DUALFEASTOL;
    }
}

