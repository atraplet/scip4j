// Generated by jextract

package com.ustermetrics.scip4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class scip_h_3 extends scip_h_4 {

    scip_h_3() {
        // Should not be called directly
    }

    private static class SCIPdisjointsetClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisjointsetClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdisjointsetClear(SCIP_DISJOINTSET *djset)
     * }
     */
    public static FunctionDescriptor SCIPdisjointsetClear$descriptor() {
        return SCIPdisjointsetClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdisjointsetClear(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MethodHandle SCIPdisjointsetClear$handle() {
        return SCIPdisjointsetClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdisjointsetClear(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MemorySegment SCIPdisjointsetClear$address() {
        return SCIPdisjointsetClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdisjointsetClear(SCIP_DISJOINTSET *djset)
     * }
     */
    public static void SCIPdisjointsetClear(MemorySegment djset) {
        var mh$ = SCIPdisjointsetClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisjointsetClear", djset);
            }
            mh$.invokeExact(djset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisjointsetFind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisjointsetFind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdisjointsetFind(SCIP_DISJOINTSET *djset, int element)
     * }
     */
    public static FunctionDescriptor SCIPdisjointsetFind$descriptor() {
        return SCIPdisjointsetFind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdisjointsetFind(SCIP_DISJOINTSET *djset, int element)
     * }
     */
    public static MethodHandle SCIPdisjointsetFind$handle() {
        return SCIPdisjointsetFind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdisjointsetFind(SCIP_DISJOINTSET *djset, int element)
     * }
     */
    public static MemorySegment SCIPdisjointsetFind$address() {
        return SCIPdisjointsetFind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdisjointsetFind(SCIP_DISJOINTSET *djset, int element)
     * }
     */
    public static int SCIPdisjointsetFind(MemorySegment djset, int element) {
        var mh$ = SCIPdisjointsetFind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisjointsetFind", djset, element);
            }
            return (int)mh$.invokeExact(djset, element);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisjointsetUnion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisjointsetUnion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdisjointsetUnion(SCIP_DISJOINTSET *djset, int p, int q, unsigned int forcerepofp)
     * }
     */
    public static FunctionDescriptor SCIPdisjointsetUnion$descriptor() {
        return SCIPdisjointsetUnion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdisjointsetUnion(SCIP_DISJOINTSET *djset, int p, int q, unsigned int forcerepofp)
     * }
     */
    public static MethodHandle SCIPdisjointsetUnion$handle() {
        return SCIPdisjointsetUnion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdisjointsetUnion(SCIP_DISJOINTSET *djset, int p, int q, unsigned int forcerepofp)
     * }
     */
    public static MemorySegment SCIPdisjointsetUnion$address() {
        return SCIPdisjointsetUnion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdisjointsetUnion(SCIP_DISJOINTSET *djset, int p, int q, unsigned int forcerepofp)
     * }
     */
    public static void SCIPdisjointsetUnion(MemorySegment djset, int p, int q, int forcerepofp) {
        var mh$ = SCIPdisjointsetUnion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisjointsetUnion", djset, p, q, forcerepofp);
            }
            mh$.invokeExact(djset, p, q, forcerepofp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisjointsetGetComponentCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisjointsetGetComponentCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetComponentCount(SCIP_DISJOINTSET *djset)
     * }
     */
    public static FunctionDescriptor SCIPdisjointsetGetComponentCount$descriptor() {
        return SCIPdisjointsetGetComponentCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetComponentCount(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MethodHandle SCIPdisjointsetGetComponentCount$handle() {
        return SCIPdisjointsetGetComponentCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetComponentCount(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MemorySegment SCIPdisjointsetGetComponentCount$address() {
        return SCIPdisjointsetGetComponentCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdisjointsetGetComponentCount(SCIP_DISJOINTSET *djset)
     * }
     */
    public static int SCIPdisjointsetGetComponentCount(MemorySegment djset) {
        var mh$ = SCIPdisjointsetGetComponentCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisjointsetGetComponentCount", djset);
            }
            return (int)mh$.invokeExact(djset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisjointsetGetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisjointsetGetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetSize(SCIP_DISJOINTSET *djset)
     * }
     */
    public static FunctionDescriptor SCIPdisjointsetGetSize$descriptor() {
        return SCIPdisjointsetGetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetSize(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MethodHandle SCIPdisjointsetGetSize$handle() {
        return SCIPdisjointsetGetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdisjointsetGetSize(SCIP_DISJOINTSET *djset)
     * }
     */
    public static MemorySegment SCIPdisjointsetGetSize$address() {
        return SCIPdisjointsetGetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdisjointsetGetSize(SCIP_DISJOINTSET *djset)
     * }
     */
    public static int SCIPdisjointsetGetSize(MemorySegment djset) {
        var mh$ = SCIPdisjointsetGetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisjointsetGetSize", djset);
            }
            return (int)mh$.invokeExact(djset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcMachineEpsilon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcMachineEpsilon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcMachineEpsilon()
     * }
     */
    public static FunctionDescriptor SCIPcalcMachineEpsilon$descriptor() {
        return SCIPcalcMachineEpsilon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcMachineEpsilon()
     * }
     */
    public static MethodHandle SCIPcalcMachineEpsilon$handle() {
        return SCIPcalcMachineEpsilon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcMachineEpsilon()
     * }
     */
    public static MemorySegment SCIPcalcMachineEpsilon$address() {
        return SCIPcalcMachineEpsilon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcMachineEpsilon()
     * }
     */
    public static double SCIPcalcMachineEpsilon() {
        var mh$ = SCIPcalcMachineEpsilon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcMachineEpsilon");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnextafter(double from, double to)
     * }
     */
    public static FunctionDescriptor SCIPnextafter$descriptor() {
        return SCIPnextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnextafter(double from, double to)
     * }
     */
    public static MethodHandle SCIPnextafter$handle() {
        return SCIPnextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnextafter(double from, double to)
     * }
     */
    public static MemorySegment SCIPnextafter$address() {
        return SCIPnextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnextafter(double from, double to)
     * }
     */
    public static double SCIPnextafter(double from, double to) {
        var mh$ = SCIPnextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnextafter", from, to);
            }
            return (double)mh$.invokeExact(from, to);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcGreComDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcGreComDiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcalcGreComDiv(long long val1, long long val2)
     * }
     */
    public static FunctionDescriptor SCIPcalcGreComDiv$descriptor() {
        return SCIPcalcGreComDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcalcGreComDiv(long long val1, long long val2)
     * }
     */
    public static MethodHandle SCIPcalcGreComDiv$handle() {
        return SCIPcalcGreComDiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcalcGreComDiv(long long val1, long long val2)
     * }
     */
    public static MemorySegment SCIPcalcGreComDiv$address() {
        return SCIPcalcGreComDiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcalcGreComDiv(long long val1, long long val2)
     * }
     */
    public static long SCIPcalcGreComDiv(long val1, long val2) {
        var mh$ = SCIPcalcGreComDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcGreComDiv", val1, val2);
            }
            return (long)mh$.invokeExact(val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcSmaComMul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcSmaComMul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcalcSmaComMul(long long val1, long long val2)
     * }
     */
    public static FunctionDescriptor SCIPcalcSmaComMul$descriptor() {
        return SCIPcalcSmaComMul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcalcSmaComMul(long long val1, long long val2)
     * }
     */
    public static MethodHandle SCIPcalcSmaComMul$handle() {
        return SCIPcalcSmaComMul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcalcSmaComMul(long long val1, long long val2)
     * }
     */
    public static MemorySegment SCIPcalcSmaComMul$address() {
        return SCIPcalcSmaComMul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcalcSmaComMul(long long val1, long long val2)
     * }
     */
    public static long SCIPcalcSmaComMul(long val1, long val2) {
        var mh$ = SCIPcalcSmaComMul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcSmaComMul", val1, val2);
            }
            return (long)mh$.invokeExact(val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcBinomCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcBinomCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcalcBinomCoef(int n, int m)
     * }
     */
    public static FunctionDescriptor SCIPcalcBinomCoef$descriptor() {
        return SCIPcalcBinomCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcalcBinomCoef(int n, int m)
     * }
     */
    public static MethodHandle SCIPcalcBinomCoef$handle() {
        return SCIPcalcBinomCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcalcBinomCoef(int n, int m)
     * }
     */
    public static MemorySegment SCIPcalcBinomCoef$address() {
        return SCIPcalcBinomCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcalcBinomCoef(int n, int m)
     * }
     */
    public static long SCIPcalcBinomCoef(int n, int m) {
        var mh$ = SCIPcalcBinomCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcBinomCoef", n, m);
            }
            return (long)mh$.invokeExact(n, m);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcFibHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcFibHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcalcFibHash(double v)
     * }
     */
    public static FunctionDescriptor SCIPcalcFibHash$descriptor() {
        return SCIPcalcFibHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcalcFibHash(double v)
     * }
     */
    public static MethodHandle SCIPcalcFibHash$handle() {
        return SCIPcalcFibHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcalcFibHash(double v)
     * }
     */
    public static MemorySegment SCIPcalcFibHash$address() {
        return SCIPcalcFibHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcalcFibHash(double v)
     * }
     */
    public static int SCIPcalcFibHash(double v) {
        var mh$ = SCIPcalcFibHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcFibHash", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrealToRational {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrealToRational");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPrealToRational(double val, double mindelta, double maxdelta, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static FunctionDescriptor SCIPrealToRational$descriptor() {
        return SCIPrealToRational.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPrealToRational(double val, double mindelta, double maxdelta, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static MethodHandle SCIPrealToRational$handle() {
        return SCIPrealToRational.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPrealToRational(double val, double mindelta, double maxdelta, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static MemorySegment SCIPrealToRational$address() {
        return SCIPrealToRational.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPrealToRational(double val, double mindelta, double maxdelta, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static int SCIPrealToRational(double val, double mindelta, double maxdelta, long maxdnom, MemorySegment nominator, MemorySegment denominator) {
        var mh$ = SCIPrealToRational.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrealToRational", val, mindelta, maxdelta, maxdnom, nominator, denominator);
            }
            return (int)mh$.invokeExact(val, mindelta, maxdelta, maxdnom, nominator, denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcIntegralScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcIntegralScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcIntegralScalar(double *vals, int nvals, double mindelta, double maxdelta, long long maxdnom, double maxscale, double *intscalar, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcIntegralScalar$descriptor() {
        return SCIPcalcIntegralScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcIntegralScalar(double *vals, int nvals, double mindelta, double maxdelta, long long maxdnom, double maxscale, double *intscalar, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcIntegralScalar$handle() {
        return SCIPcalcIntegralScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcIntegralScalar(double *vals, int nvals, double mindelta, double maxdelta, long long maxdnom, double maxscale, double *intscalar, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcIntegralScalar$address() {
        return SCIPcalcIntegralScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcIntegralScalar(double *vals, int nvals, double mindelta, double maxdelta, long long maxdnom, double maxscale, double *intscalar, unsigned int *success)
     * }
     */
    public static int SCIPcalcIntegralScalar(MemorySegment vals, int nvals, double mindelta, double maxdelta, long maxdnom, double maxscale, MemorySegment intscalar, MemorySegment success) {
        var mh$ = SCIPcalcIntegralScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcIntegralScalar", vals, nvals, mindelta, maxdelta, maxdnom, maxscale, intscalar, success);
            }
            return (int)mh$.invokeExact(vals, nvals, mindelta, maxdelta, maxdnom, maxscale, intscalar, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindSimpleRational {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindSimpleRational");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPfindSimpleRational(double lb, double ub, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static FunctionDescriptor SCIPfindSimpleRational$descriptor() {
        return SCIPfindSimpleRational.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPfindSimpleRational(double lb, double ub, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static MethodHandle SCIPfindSimpleRational$handle() {
        return SCIPfindSimpleRational.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPfindSimpleRational(double lb, double ub, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static MemorySegment SCIPfindSimpleRational$address() {
        return SCIPfindSimpleRational.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPfindSimpleRational(double lb, double ub, long long maxdnom, long long *nominator, long long *denominator)
     * }
     */
    public static int SCIPfindSimpleRational(double lb, double ub, long maxdnom, MemorySegment nominator, MemorySegment denominator) {
        var mh$ = SCIPfindSimpleRational.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindSimpleRational", lb, ub, maxdnom, nominator, denominator);
            }
            return (int)mh$.invokeExact(lb, ub, maxdnom, nominator, denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectSimpleValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectSimpleValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPselectSimpleValue(double lb, double ub, long long maxdnom)
     * }
     */
    public static FunctionDescriptor SCIPselectSimpleValue$descriptor() {
        return SCIPselectSimpleValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPselectSimpleValue(double lb, double ub, long long maxdnom)
     * }
     */
    public static MethodHandle SCIPselectSimpleValue$handle() {
        return SCIPselectSimpleValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPselectSimpleValue(double lb, double ub, long long maxdnom)
     * }
     */
    public static MemorySegment SCIPselectSimpleValue$address() {
        return SCIPselectSimpleValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPselectSimpleValue(double lb, double ub, long long maxdnom)
     * }
     */
    public static double SCIPselectSimpleValue(double lb, double ub, long maxdnom) {
        var mh$ = SCIPselectSimpleValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectSimpleValue", lb, ub, maxdnom);
            }
            return (double)mh$.invokeExact(lb, ub, maxdnom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcRootNewton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcRootNewton");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcRootNewton(double (*function)(double, double *, int), double (*derivative)(double, double *, int), double *params, int nparams, double x, double eps, int k)
     * }
     */
    public static FunctionDescriptor SCIPcalcRootNewton$descriptor() {
        return SCIPcalcRootNewton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcRootNewton(double (*function)(double, double *, int), double (*derivative)(double, double *, int), double *params, int nparams, double x, double eps, int k)
     * }
     */
    public static MethodHandle SCIPcalcRootNewton$handle() {
        return SCIPcalcRootNewton.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcRootNewton(double (*function)(double, double *, int), double (*derivative)(double, double *, int), double *params, int nparams, double x, double eps, int k)
     * }
     */
    public static MemorySegment SCIPcalcRootNewton$address() {
        return SCIPcalcRootNewton.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcRootNewton(double (*function)(double, double *, int), double (*derivative)(double, double *, int), double *params, int nparams, double x, double eps, int k)
     * }
     */
    public static double SCIPcalcRootNewton(MemorySegment function, MemorySegment derivative, MemorySegment params, int nparams, double x, double eps, int k) {
        var mh$ = SCIPcalcRootNewton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcRootNewton", function, derivative, params, nparams, x, eps, k);
            }
            return (double)mh$.invokeExact(function, derivative, params, nparams, x, eps, k);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelDiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelDiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrelDiff(double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPrelDiff$descriptor() {
        return SCIPrelDiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrelDiff(double val1, double val2)
     * }
     */
    public static MethodHandle SCIPrelDiff$handle() {
        return SCIPrelDiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrelDiff(double val1, double val2)
     * }
     */
    public static MemorySegment SCIPrelDiff$address() {
        return SCIPrelDiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrelDiff(double val1, double val2)
     * }
     */
    public static double SCIPrelDiff(double val1, double val2) {
        var mh$ = SCIPrelDiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelDiff", val1, val2);
            }
            return (double)mh$.invokeExact(val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeGap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeGap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomputeGap(double eps, double inf, double primalbound, double dualbound)
     * }
     */
    public static FunctionDescriptor SCIPcomputeGap$descriptor() {
        return SCIPcomputeGap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomputeGap(double eps, double inf, double primalbound, double dualbound)
     * }
     */
    public static MethodHandle SCIPcomputeGap$handle() {
        return SCIPcomputeGap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomputeGap(double eps, double inf, double primalbound, double dualbound)
     * }
     */
    public static MemorySegment SCIPcomputeGap$address() {
        return SCIPcomputeGap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomputeGap(double eps, double inf, double primalbound, double dualbound)
     * }
     */
    public static double SCIPcomputeGap(double eps, double inf, double primalbound, double dualbound) {
        var mh$ = SCIPcomputeGap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeGap", eps, inf, primalbound, dualbound);
            }
            return (double)mh$.invokeExact(eps, inf, primalbound, dualbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRandomInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRandomInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetRandomInt(int minrandval, int maxrandval, unsigned int *seedp)
     * }
     */
    public static FunctionDescriptor SCIPgetRandomInt$descriptor() {
        return SCIPgetRandomInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetRandomInt(int minrandval, int maxrandval, unsigned int *seedp)
     * }
     */
    public static MethodHandle SCIPgetRandomInt$handle() {
        return SCIPgetRandomInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetRandomInt(int minrandval, int maxrandval, unsigned int *seedp)
     * }
     */
    public static MemorySegment SCIPgetRandomInt$address() {
        return SCIPgetRandomInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetRandomInt(int minrandval, int maxrandval, unsigned int *seedp)
     * }
     */
    public static int SCIPgetRandomInt(int minrandval, int maxrandval, MemorySegment seedp) {
        var mh$ = SCIPgetRandomInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRandomInt", minrandval, maxrandval, seedp);
            }
            return (int)mh$.invokeExact(minrandval, maxrandval, seedp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrandomGetInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrandomGetInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPrandomGetInt(SCIP_RANDNUMGEN *randgen, int minrandval, int maxrandval)
     * }
     */
    public static FunctionDescriptor SCIPrandomGetInt$descriptor() {
        return SCIPrandomGetInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPrandomGetInt(SCIP_RANDNUMGEN *randgen, int minrandval, int maxrandval)
     * }
     */
    public static MethodHandle SCIPrandomGetInt$handle() {
        return SCIPrandomGetInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPrandomGetInt(SCIP_RANDNUMGEN *randgen, int minrandval, int maxrandval)
     * }
     */
    public static MemorySegment SCIPrandomGetInt$address() {
        return SCIPrandomGetInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPrandomGetInt(SCIP_RANDNUMGEN *randgen, int minrandval, int maxrandval)
     * }
     */
    public static int SCIPrandomGetInt(MemorySegment randgen, int minrandval, int maxrandval) {
        var mh$ = SCIPrandomGetInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrandomGetInt", randgen, minrandval, maxrandval);
            }
            return (int)mh$.invokeExact(randgen, minrandval, maxrandval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrandomGetSubset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrandomGetSubset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrandomGetSubset(SCIP_RANDNUMGEN *randgen, void **set, int nelems, void **subset, int nsubelems)
     * }
     */
    public static FunctionDescriptor SCIPrandomGetSubset$descriptor() {
        return SCIPrandomGetSubset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrandomGetSubset(SCIP_RANDNUMGEN *randgen, void **set, int nelems, void **subset, int nsubelems)
     * }
     */
    public static MethodHandle SCIPrandomGetSubset$handle() {
        return SCIPrandomGetSubset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrandomGetSubset(SCIP_RANDNUMGEN *randgen, void **set, int nelems, void **subset, int nsubelems)
     * }
     */
    public static MemorySegment SCIPrandomGetSubset$address() {
        return SCIPrandomGetSubset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrandomGetSubset(SCIP_RANDNUMGEN *randgen, void **set, int nelems, void **subset, int nsubelems)
     * }
     */
    public static int SCIPrandomGetSubset(MemorySegment randgen, MemorySegment set, int nelems, MemorySegment subset, int nsubelems) {
        var mh$ = SCIPrandomGetSubset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrandomGetSubset", randgen, set, nelems, subset, nsubelems);
            }
            return (int)mh$.invokeExact(randgen, set, nelems, subset, nsubelems);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrandomGetReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrandomGetReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrandomGetReal(SCIP_RANDNUMGEN *randgen, double minrandval, double maxrandval)
     * }
     */
    public static FunctionDescriptor SCIPrandomGetReal$descriptor() {
        return SCIPrandomGetReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrandomGetReal(SCIP_RANDNUMGEN *randgen, double minrandval, double maxrandval)
     * }
     */
    public static MethodHandle SCIPrandomGetReal$handle() {
        return SCIPrandomGetReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrandomGetReal(SCIP_RANDNUMGEN *randgen, double minrandval, double maxrandval)
     * }
     */
    public static MemorySegment SCIPrandomGetReal$address() {
        return SCIPrandomGetReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrandomGetReal(SCIP_RANDNUMGEN *randgen, double minrandval, double maxrandval)
     * }
     */
    public static double SCIPrandomGetReal(MemorySegment randgen, double minrandval, double maxrandval) {
        var mh$ = SCIPrandomGetReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrandomGetReal", randgen, minrandval, maxrandval);
            }
            return (double)mh$.invokeExact(randgen, minrandval, maxrandval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRandomReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRandomReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRandomReal(double minrandval, double maxrandval, unsigned int *seedp)
     * }
     */
    public static FunctionDescriptor SCIPgetRandomReal$descriptor() {
        return SCIPgetRandomReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRandomReal(double minrandval, double maxrandval, unsigned int *seedp)
     * }
     */
    public static MethodHandle SCIPgetRandomReal$handle() {
        return SCIPgetRandomReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRandomReal(double minrandval, double maxrandval, unsigned int *seedp)
     * }
     */
    public static MemorySegment SCIPgetRandomReal$address() {
        return SCIPgetRandomReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRandomReal(double minrandval, double maxrandval, unsigned int *seedp)
     * }
     */
    public static double SCIPgetRandomReal(double minrandval, double maxrandval, MemorySegment seedp) {
        var mh$ = SCIPgetRandomReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRandomReal", minrandval, maxrandval, seedp);
            }
            return (double)mh$.invokeExact(minrandval, maxrandval, seedp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRandomSubset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRandomSubset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRandomSubset(void **set, int nelems, void **subset, int nsubelems, unsigned int randseed)
     * }
     */
    public static FunctionDescriptor SCIPgetRandomSubset$descriptor() {
        return SCIPgetRandomSubset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRandomSubset(void **set, int nelems, void **subset, int nsubelems, unsigned int randseed)
     * }
     */
    public static MethodHandle SCIPgetRandomSubset$handle() {
        return SCIPgetRandomSubset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRandomSubset(void **set, int nelems, void **subset, int nsubelems, unsigned int randseed)
     * }
     */
    public static MemorySegment SCIPgetRandomSubset$address() {
        return SCIPgetRandomSubset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRandomSubset(void **set, int nelems, void **subset, int nsubelems, unsigned int randseed)
     * }
     */
    public static int SCIPgetRandomSubset(MemorySegment set, int nelems, MemorySegment subset, int nsubelems, int randseed) {
        var mh$ = SCIPgetRandomSubset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRandomSubset", set, nelems, subset, nsubelems, randseed);
            }
            return (int)mh$.invokeExact(set, nelems, subset, nsubelems, randseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPswapInts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPswapInts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPswapInts(int *value1, int *value2)
     * }
     */
    public static FunctionDescriptor SCIPswapInts$descriptor() {
        return SCIPswapInts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPswapInts(int *value1, int *value2)
     * }
     */
    public static MethodHandle SCIPswapInts$handle() {
        return SCIPswapInts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPswapInts(int *value1, int *value2)
     * }
     */
    public static MemorySegment SCIPswapInts$address() {
        return SCIPswapInts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPswapInts(int *value1, int *value2)
     * }
     */
    public static void SCIPswapInts(MemorySegment value1, MemorySegment value2) {
        var mh$ = SCIPswapInts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPswapInts", value1, value2);
            }
            mh$.invokeExact(value1, value2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPswapReals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPswapReals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPswapReals(double *value1, double *value2)
     * }
     */
    public static FunctionDescriptor SCIPswapReals$descriptor() {
        return SCIPswapReals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPswapReals(double *value1, double *value2)
     * }
     */
    public static MethodHandle SCIPswapReals$handle() {
        return SCIPswapReals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPswapReals(double *value1, double *value2)
     * }
     */
    public static MemorySegment SCIPswapReals$address() {
        return SCIPswapReals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPswapReals(double *value1, double *value2)
     * }
     */
    public static void SCIPswapReals(MemorySegment value1, MemorySegment value2) {
        var mh$ = SCIPswapReals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPswapReals", value1, value2);
            }
            mh$.invokeExact(value1, value2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPswapPointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPswapPointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPswapPointers(void **pointer1, void **pointer2)
     * }
     */
    public static FunctionDescriptor SCIPswapPointers$descriptor() {
        return SCIPswapPointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPswapPointers(void **pointer1, void **pointer2)
     * }
     */
    public static MethodHandle SCIPswapPointers$handle() {
        return SCIPswapPointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPswapPointers(void **pointer1, void **pointer2)
     * }
     */
    public static MemorySegment SCIPswapPointers$address() {
        return SCIPswapPointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPswapPointers(void **pointer1, void **pointer2)
     * }
     */
    public static void SCIPswapPointers(MemorySegment pointer1, MemorySegment pointer2) {
        var mh$ = SCIPswapPointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPswapPointers", pointer1, pointer2);
            }
            mh$.invokeExact(pointer1, pointer2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpermuteIntArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpermuteIntArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpermuteIntArray(int *array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static FunctionDescriptor SCIPpermuteIntArray$descriptor() {
        return SCIPpermuteIntArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpermuteIntArray(int *array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static MethodHandle SCIPpermuteIntArray$handle() {
        return SCIPpermuteIntArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpermuteIntArray(int *array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static MemorySegment SCIPpermuteIntArray$address() {
        return SCIPpermuteIntArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpermuteIntArray(int *array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static void SCIPpermuteIntArray(MemorySegment array, int begin, int end, MemorySegment randseed) {
        var mh$ = SCIPpermuteIntArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpermuteIntArray", array, begin, end, randseed);
            }
            mh$.invokeExact(array, begin, end, randseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrandomPermuteIntArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrandomPermuteIntArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteIntArray(SCIP_RANDNUMGEN *randgen, int *array, int begin, int end)
     * }
     */
    public static FunctionDescriptor SCIPrandomPermuteIntArray$descriptor() {
        return SCIPrandomPermuteIntArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteIntArray(SCIP_RANDNUMGEN *randgen, int *array, int begin, int end)
     * }
     */
    public static MethodHandle SCIPrandomPermuteIntArray$handle() {
        return SCIPrandomPermuteIntArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteIntArray(SCIP_RANDNUMGEN *randgen, int *array, int begin, int end)
     * }
     */
    public static MemorySegment SCIPrandomPermuteIntArray$address() {
        return SCIPrandomPermuteIntArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPrandomPermuteIntArray(SCIP_RANDNUMGEN *randgen, int *array, int begin, int end)
     * }
     */
    public static void SCIPrandomPermuteIntArray(MemorySegment randgen, MemorySegment array, int begin, int end) {
        var mh$ = SCIPrandomPermuteIntArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrandomPermuteIntArray", randgen, array, begin, end);
            }
            mh$.invokeExact(randgen, array, begin, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrandomPermuteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrandomPermuteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteArray(SCIP_RANDNUMGEN *randgen, void **array, int begin, int end)
     * }
     */
    public static FunctionDescriptor SCIPrandomPermuteArray$descriptor() {
        return SCIPrandomPermuteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteArray(SCIP_RANDNUMGEN *randgen, void **array, int begin, int end)
     * }
     */
    public static MethodHandle SCIPrandomPermuteArray$handle() {
        return SCIPrandomPermuteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPrandomPermuteArray(SCIP_RANDNUMGEN *randgen, void **array, int begin, int end)
     * }
     */
    public static MemorySegment SCIPrandomPermuteArray$address() {
        return SCIPrandomPermuteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPrandomPermuteArray(SCIP_RANDNUMGEN *randgen, void **array, int begin, int end)
     * }
     */
    public static void SCIPrandomPermuteArray(MemorySegment randgen, MemorySegment array, int begin, int end) {
        var mh$ = SCIPrandomPermuteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrandomPermuteArray", randgen, array, begin, end);
            }
            mh$.invokeExact(randgen, array, begin, end);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpermuteArray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpermuteArray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpermuteArray(void **array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static FunctionDescriptor SCIPpermuteArray$descriptor() {
        return SCIPpermuteArray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpermuteArray(void **array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static MethodHandle SCIPpermuteArray$handle() {
        return SCIPpermuteArray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpermuteArray(void **array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static MemorySegment SCIPpermuteArray$address() {
        return SCIPpermuteArray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpermuteArray(void **array, int begin, int end, unsigned int *randseed)
     * }
     */
    public static void SCIPpermuteArray(MemorySegment array, int begin, int end, MemorySegment randseed) {
        var mh$ = SCIPpermuteArray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpermuteArray", array, begin, end, randseed);
            }
            mh$.invokeExact(array, begin, end, randseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeArraysIntersection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeArraysIntersection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysIntersection(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static FunctionDescriptor SCIPcomputeArraysIntersection$descriptor() {
        return SCIPcomputeArraysIntersection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysIntersection(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static MethodHandle SCIPcomputeArraysIntersection$handle() {
        return SCIPcomputeArraysIntersection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysIntersection(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static MemorySegment SCIPcomputeArraysIntersection$address() {
        return SCIPcomputeArraysIntersection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysIntersection(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static int SCIPcomputeArraysIntersection(MemorySegment array1, int narray1, MemorySegment array2, int narray2, MemorySegment intersectarray, MemorySegment nintersectarray) {
        var mh$ = SCIPcomputeArraysIntersection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeArraysIntersection", array1, narray1, array2, narray2, intersectarray, nintersectarray);
            }
            return (int)mh$.invokeExact(array1, narray1, array2, narray2, intersectarray, nintersectarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeArraysIntersectionInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeArraysIntersectionInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionInt(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static FunctionDescriptor SCIPcomputeArraysIntersectionInt$descriptor() {
        return SCIPcomputeArraysIntersectionInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionInt(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static MethodHandle SCIPcomputeArraysIntersectionInt$handle() {
        return SCIPcomputeArraysIntersectionInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionInt(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static MemorySegment SCIPcomputeArraysIntersectionInt$address() {
        return SCIPcomputeArraysIntersectionInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionInt(int *array1, int narray1, int *array2, int narray2, int *intersectarray, int *nintersectarray)
     * }
     */
    public static void SCIPcomputeArraysIntersectionInt(MemorySegment array1, int narray1, MemorySegment array2, int narray2, MemorySegment intersectarray, MemorySegment nintersectarray) {
        var mh$ = SCIPcomputeArraysIntersectionInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeArraysIntersectionInt", array1, narray1, array2, narray2, intersectarray, nintersectarray);
            }
            mh$.invokeExact(array1, narray1, array2, narray2, intersectarray, nintersectarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeArraysIntersectionPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeArraysIntersectionPtr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionPtr(void **array1, int narray1, void **array2, int narray2, int (*ptrcomp)(void *, void *), void **intersectarray, int *nintersectarray)
     * }
     */
    public static FunctionDescriptor SCIPcomputeArraysIntersectionPtr$descriptor() {
        return SCIPcomputeArraysIntersectionPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionPtr(void **array1, int narray1, void **array2, int narray2, int (*ptrcomp)(void *, void *), void **intersectarray, int *nintersectarray)
     * }
     */
    public static MethodHandle SCIPcomputeArraysIntersectionPtr$handle() {
        return SCIPcomputeArraysIntersectionPtr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionPtr(void **array1, int narray1, void **array2, int narray2, int (*ptrcomp)(void *, void *), void **intersectarray, int *nintersectarray)
     * }
     */
    public static MemorySegment SCIPcomputeArraysIntersectionPtr$address() {
        return SCIPcomputeArraysIntersectionPtr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomputeArraysIntersectionPtr(void **array1, int narray1, void **array2, int narray2, int (*ptrcomp)(void *, void *), void **intersectarray, int *nintersectarray)
     * }
     */
    public static void SCIPcomputeArraysIntersectionPtr(MemorySegment array1, int narray1, MemorySegment array2, int narray2, MemorySegment ptrcomp, MemorySegment intersectarray, MemorySegment nintersectarray) {
        var mh$ = SCIPcomputeArraysIntersectionPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeArraysIntersectionPtr", array1, narray1, array2, narray2, ptrcomp, intersectarray, nintersectarray);
            }
            mh$.invokeExact(array1, narray1, array2, narray2, ptrcomp, intersectarray, nintersectarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeArraysSetminus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeArraysSetminus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysSetminus(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static FunctionDescriptor SCIPcomputeArraysSetminus$descriptor() {
        return SCIPcomputeArraysSetminus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysSetminus(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static MethodHandle SCIPcomputeArraysSetminus$handle() {
        return SCIPcomputeArraysSetminus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysSetminus(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static MemorySegment SCIPcomputeArraysSetminus$address() {
        return SCIPcomputeArraysSetminus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeArraysSetminus(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static int SCIPcomputeArraysSetminus(MemorySegment array1, int narray1, MemorySegment array2, int narray2, MemorySegment setminusarray, MemorySegment nsetminusarray) {
        var mh$ = SCIPcomputeArraysSetminus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeArraysSetminus", array1, narray1, array2, narray2, setminusarray, nsetminusarray);
            }
            return (int)mh$.invokeExact(array1, narray1, array2, narray2, setminusarray, nsetminusarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeArraysSetminusInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeArraysSetminusInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysSetminusInt(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static FunctionDescriptor SCIPcomputeArraysSetminusInt$descriptor() {
        return SCIPcomputeArraysSetminusInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysSetminusInt(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static MethodHandle SCIPcomputeArraysSetminusInt$handle() {
        return SCIPcomputeArraysSetminusInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomputeArraysSetminusInt(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static MemorySegment SCIPcomputeArraysSetminusInt$address() {
        return SCIPcomputeArraysSetminusInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomputeArraysSetminusInt(int *array1, int narray1, int *array2, int narray2, int *setminusarray, int *nsetminusarray)
     * }
     */
    public static void SCIPcomputeArraysSetminusInt(MemorySegment array1, int narray1, MemorySegment array2, int narray2, MemorySegment setminusarray, MemorySegment nsetminusarray) {
        var mh$ = SCIPcomputeArraysSetminusInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeArraysSetminusInt", array1, narray1, array2, narray2, setminusarray, nsetminusarray);
            }
            mh$.invokeExact(array1, narray1, array2, narray2, setminusarray, nsetminusarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmemccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmemccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPmemccpy(char *dest, const char *src, char stop, unsigned int cnt)
     * }
     */
    public static FunctionDescriptor SCIPmemccpy$descriptor() {
        return SCIPmemccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPmemccpy(char *dest, const char *src, char stop, unsigned int cnt)
     * }
     */
    public static MethodHandle SCIPmemccpy$handle() {
        return SCIPmemccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPmemccpy(char *dest, const char *src, char stop, unsigned int cnt)
     * }
     */
    public static MemorySegment SCIPmemccpy$address() {
        return SCIPmemccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPmemccpy(char *dest, const char *src, char stop, unsigned int cnt)
     * }
     */
    public static int SCIPmemccpy(MemorySegment dest, MemorySegment src, byte stop, int cnt) {
        var mh$ = SCIPmemccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmemccpy", dest, src, stop, cnt);
            }
            return (int)mh$.invokeExact(dest, src, stop, cnt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintSysError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintSysError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintSysError(const char *message)
     * }
     */
    public static FunctionDescriptor SCIPprintSysError$descriptor() {
        return SCIPprintSysError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintSysError(const char *message)
     * }
     */
    public static MethodHandle SCIPprintSysError$handle() {
        return SCIPprintSysError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintSysError(const char *message)
     * }
     */
    public static MemorySegment SCIPprintSysError$address() {
        return SCIPprintSysError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintSysError(const char *message)
     * }
     */
    public static void SCIPprintSysError(MemorySegment message) {
        var mh$ = SCIPprintSysError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintSysError", message);
            }
            mh$.invokeExact(message);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstrtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPstrtok(char *s, const char *delim, char **ptrptr)
     * }
     */
    public static FunctionDescriptor SCIPstrtok$descriptor() {
        return SCIPstrtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPstrtok(char *s, const char *delim, char **ptrptr)
     * }
     */
    public static MethodHandle SCIPstrtok$handle() {
        return SCIPstrtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPstrtok(char *s, const char *delim, char **ptrptr)
     * }
     */
    public static MemorySegment SCIPstrtok$address() {
        return SCIPstrtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPstrtok(char *s, const char *delim, char **ptrptr)
     * }
     */
    public static MemorySegment SCIPstrtok(MemorySegment s, MemorySegment delim, MemorySegment ptrptr) {
        var mh$ = SCIPstrtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrtok", s, delim, ptrptr);
            }
            return (MemorySegment)mh$.invokeExact(s, delim, ptrptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPescapeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPescapeString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPescapeString(char *t, int bufsize, const char *s)
     * }
     */
    public static FunctionDescriptor SCIPescapeString$descriptor() {
        return SCIPescapeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPescapeString(char *t, int bufsize, const char *s)
     * }
     */
    public static MethodHandle SCIPescapeString$handle() {
        return SCIPescapeString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPescapeString(char *t, int bufsize, const char *s)
     * }
     */
    public static MemorySegment SCIPescapeString$address() {
        return SCIPescapeString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPescapeString(char *t, int bufsize, const char *s)
     * }
     */
    public static void SCIPescapeString(MemorySegment t, int bufsize, MemorySegment s) {
        var mh$ = SCIPescapeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPescapeString", t, bufsize, s);
            }
            mh$.invokeExact(t, bufsize, s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPskipSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPskipSpace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPskipSpace(char **s)
     * }
     */
    public static FunctionDescriptor SCIPskipSpace$descriptor() {
        return SCIPskipSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPskipSpace(char **s)
     * }
     */
    public static MethodHandle SCIPskipSpace$handle() {
        return SCIPskipSpace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPskipSpace(char **s)
     * }
     */
    public static MemorySegment SCIPskipSpace$address() {
        return SCIPskipSpace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPskipSpace(char **s)
     * }
     */
    public static int SCIPskipSpace(MemorySegment s) {
        var mh$ = SCIPskipSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPskipSpace", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int SCIPsnprintf(char *t, int len, const char *s, ...)
     * }
     */
    public static class SCIPsnprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                scip_h.C_INT,
                scip_h.C_POINTER,
                scip_h.C_INT,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsnprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPsnprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int SCIPsnprintf(char *t, int len, const char *s, ...)
         * }
         */
        public static SCIPsnprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPsnprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment t, int len, MemorySegment s, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPsnprintf", t, len, s, x3);
                }
                return (int)spreader.invokeExact(t, len, s, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class SCIPstrncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPstrncpy(char *t, const char *s, int size)
     * }
     */
    public static FunctionDescriptor SCIPstrncpy$descriptor() {
        return SCIPstrncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPstrncpy(char *t, const char *s, int size)
     * }
     */
    public static MethodHandle SCIPstrncpy$handle() {
        return SCIPstrncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPstrncpy(char *t, const char *s, int size)
     * }
     */
    public static MemorySegment SCIPstrncpy$address() {
        return SCIPstrncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPstrncpy(char *t, const char *s, int size)
     * }
     */
    public static int SCIPstrncpy(MemorySegment t, MemorySegment s, int size) {
        var mh$ = SCIPstrncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrncpy", t, s, size);
            }
            return (int)mh$.invokeExact(t, s, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstrToIntValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrToIntValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToIntValue(const char *str, int *value, char **endptr)
     * }
     */
    public static FunctionDescriptor SCIPstrToIntValue$descriptor() {
        return SCIPstrToIntValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToIntValue(const char *str, int *value, char **endptr)
     * }
     */
    public static MethodHandle SCIPstrToIntValue$handle() {
        return SCIPstrToIntValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToIntValue(const char *str, int *value, char **endptr)
     * }
     */
    public static MemorySegment SCIPstrToIntValue$address() {
        return SCIPstrToIntValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPstrToIntValue(const char *str, int *value, char **endptr)
     * }
     */
    public static int SCIPstrToIntValue(MemorySegment str, MemorySegment value, MemorySegment endptr) {
        var mh$ = SCIPstrToIntValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrToIntValue", str, value, endptr);
            }
            return (int)mh$.invokeExact(str, value, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstrToRealValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrToRealValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToRealValue(const char *str, double *value, char **endptr)
     * }
     */
    public static FunctionDescriptor SCIPstrToRealValue$descriptor() {
        return SCIPstrToRealValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToRealValue(const char *str, double *value, char **endptr)
     * }
     */
    public static MethodHandle SCIPstrToRealValue$handle() {
        return SCIPstrToRealValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPstrToRealValue(const char *str, double *value, char **endptr)
     * }
     */
    public static MemorySegment SCIPstrToRealValue$address() {
        return SCIPstrToRealValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPstrToRealValue(const char *str, double *value, char **endptr)
     * }
     */
    public static int SCIPstrToRealValue(MemorySegment str, MemorySegment value, MemorySegment endptr) {
        var mh$ = SCIPstrToRealValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrToRealValue", str, value, endptr);
            }
            return (int)mh$.invokeExact(str, value, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstrCopySection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_CHAR,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrCopySection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPstrCopySection(const char *str, char startchar, char endchar, char *token, int size, char **endptr)
     * }
     */
    public static FunctionDescriptor SCIPstrCopySection$descriptor() {
        return SCIPstrCopySection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPstrCopySection(const char *str, char startchar, char endchar, char *token, int size, char **endptr)
     * }
     */
    public static MethodHandle SCIPstrCopySection$handle() {
        return SCIPstrCopySection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPstrCopySection(const char *str, char startchar, char endchar, char *token, int size, char **endptr)
     * }
     */
    public static MemorySegment SCIPstrCopySection$address() {
        return SCIPstrCopySection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPstrCopySection(const char *str, char startchar, char endchar, char *token, int size, char **endptr)
     * }
     */
    public static void SCIPstrCopySection(MemorySegment str, byte startchar, byte endchar, MemorySegment token, int size, MemorySegment endptr) {
        var mh$ = SCIPstrCopySection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrCopySection", str, startchar, endchar, token, size, endptr);
            }
            mh$.invokeExact(str, startchar, endchar, token, size, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstrAtStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstrAtStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPstrAtStart(const char *s, const char *t, size_t tlen)
     * }
     */
    public static FunctionDescriptor SCIPstrAtStart$descriptor() {
        return SCIPstrAtStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPstrAtStart(const char *s, const char *t, size_t tlen)
     * }
     */
    public static MethodHandle SCIPstrAtStart$handle() {
        return SCIPstrAtStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPstrAtStart(const char *s, const char *t, size_t tlen)
     * }
     */
    public static MemorySegment SCIPstrAtStart$address() {
        return SCIPstrAtStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPstrAtStart(const char *s, const char *t, size_t tlen)
     * }
     */
    public static int SCIPstrAtStart(MemorySegment s, MemorySegment t, long tlen) {
        var mh$ = SCIPstrAtStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstrAtStart", s, t, tlen);
            }
            return (int)mh$.invokeExact(s, t, tlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfileExists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfileExists");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPfileExists(const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPfileExists$descriptor() {
        return SCIPfileExists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPfileExists(const char *filename)
     * }
     */
    public static MethodHandle SCIPfileExists$handle() {
        return SCIPfileExists.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPfileExists(const char *filename)
     * }
     */
    public static MemorySegment SCIPfileExists$address() {
        return SCIPfileExists.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPfileExists(const char *filename)
     * }
     */
    public static int SCIPfileExists(MemorySegment filename) {
        var mh$ = SCIPfileExists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfileExists", filename);
            }
            return (int)mh$.invokeExact(filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsplitFilename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsplitFilename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsplitFilename(char *filename, char **path, char **name, char **extension, char **compression)
     * }
     */
    public static FunctionDescriptor SCIPsplitFilename$descriptor() {
        return SCIPsplitFilename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsplitFilename(char *filename, char **path, char **name, char **extension, char **compression)
     * }
     */
    public static MethodHandle SCIPsplitFilename$handle() {
        return SCIPsplitFilename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsplitFilename(char *filename, char **path, char **name, char **extension, char **compression)
     * }
     */
    public static MemorySegment SCIPsplitFilename$address() {
        return SCIPsplitFilename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsplitFilename(char *filename, char **path, char **name, char **extension, char **compression)
     * }
     */
    public static void SCIPsplitFilename(MemorySegment filename, MemorySegment path, MemorySegment name, MemorySegment extension, MemorySegment compression) {
        var mh$ = SCIPsplitFilename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsplitFilename", filename, path, name, extension, compression);
            }
            mh$.invokeExact(filename, path, name, extension, compression);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetName(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetName$descriptor() {
        return SCIPnodeselGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetName(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetName$handle() {
        return SCIPnodeselGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetName(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetName$address() {
        return SCIPnodeselGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnodeselGetName(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetName(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetName", nodesel);
            }
            return (MemorySegment)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetDesc(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetDesc$descriptor() {
        return SCIPnodeselGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetDesc(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetDesc$handle() {
        return SCIPnodeselGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnodeselGetDesc(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetDesc$address() {
        return SCIPnodeselGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnodeselGetDesc(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetDesc(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetDesc", nodesel);
            }
            return (MemorySegment)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetStdPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetStdPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnodeselGetStdPriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetStdPriority$descriptor() {
        return SCIPnodeselGetStdPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnodeselGetStdPriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetStdPriority$handle() {
        return SCIPnodeselGetStdPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnodeselGetStdPriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetStdPriority$address() {
        return SCIPnodeselGetStdPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnodeselGetStdPriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static int SCIPnodeselGetStdPriority(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetStdPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetStdPriority", nodesel);
            }
            return (int)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetMemsavePriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetMemsavePriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnodeselGetMemsavePriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetMemsavePriority$descriptor() {
        return SCIPnodeselGetMemsavePriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnodeselGetMemsavePriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetMemsavePriority$handle() {
        return SCIPnodeselGetMemsavePriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnodeselGetMemsavePriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetMemsavePriority$address() {
        return SCIPnodeselGetMemsavePriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnodeselGetMemsavePriority(SCIP_NODESEL *nodesel)
     * }
     */
    public static int SCIPnodeselGetMemsavePriority(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetMemsavePriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetMemsavePriority", nodesel);
            }
            return (int)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODESELDATA *SCIPnodeselGetData(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetData$descriptor() {
        return SCIPnodeselGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODESELDATA *SCIPnodeselGetData(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetData$handle() {
        return SCIPnodeselGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODESELDATA *SCIPnodeselGetData(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetData$address() {
        return SCIPnodeselGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODESELDATA *SCIPnodeselGetData(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetData(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetData", nodesel);
            }
            return (MemorySegment)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeselSetData(SCIP_NODESEL *nodesel, SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static FunctionDescriptor SCIPnodeselSetData$descriptor() {
        return SCIPnodeselSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeselSetData(SCIP_NODESEL *nodesel, SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MethodHandle SCIPnodeselSetData$handle() {
        return SCIPnodeselSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeselSetData(SCIP_NODESEL *nodesel, SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MemorySegment SCIPnodeselSetData$address() {
        return SCIPnodeselSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeselSetData(SCIP_NODESEL *nodesel, SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static void SCIPnodeselSetData(MemorySegment nodesel, MemorySegment nodeseldata) {
        var mh$ = SCIPnodeselSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselSetData", nodesel, nodeseldata);
            }
            mh$.invokeExact(nodesel, nodeseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeselIsInitialized(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselIsInitialized$descriptor() {
        return SCIPnodeselIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeselIsInitialized(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselIsInitialized$handle() {
        return SCIPnodeselIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeselIsInitialized(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselIsInitialized$address() {
        return SCIPnodeselIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnodeselIsInitialized(SCIP_NODESEL *nodesel)
     * }
     */
    public static int SCIPnodeselIsInitialized(MemorySegment nodesel) {
        var mh$ = SCIPnodeselIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselIsInitialized", nodesel);
            }
            return (int)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnodeselGetSetupTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetSetupTime$descriptor() {
        return SCIPnodeselGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnodeselGetSetupTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetSetupTime$handle() {
        return SCIPnodeselGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnodeselGetSetupTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetSetupTime$address() {
        return SCIPnodeselGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnodeselGetSetupTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static double SCIPnodeselGetSetupTime(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetSetupTime", nodesel);
            }
            return (double)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeselGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeselGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnodeselGetTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static FunctionDescriptor SCIPnodeselGetTime$descriptor() {
        return SCIPnodeselGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnodeselGetTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static MethodHandle SCIPnodeselGetTime$handle() {
        return SCIPnodeselGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnodeselGetTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static MemorySegment SCIPnodeselGetTime$address() {
        return SCIPnodeselGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnodeselGetTime(SCIP_NODESEL *nodesel)
     * }
     */
    public static double SCIPnodeselGetTime(MemorySegment nodesel) {
        var mh$ = SCIPnodeselGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeselGetTime", nodesel);
            }
            return (double)mh$.invokeExact(nodesel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PARAMTYPE SCIPparamGetType(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetType$descriptor() {
        return SCIPparamGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PARAMTYPE SCIPparamGetType(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetType$handle() {
        return SCIPparamGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PARAMTYPE SCIPparamGetType(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetType$address() {
        return SCIPparamGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PARAMTYPE SCIPparamGetType(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetType(MemorySegment param) {
        var mh$ = SCIPparamGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetType", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPparamGetName(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetName$descriptor() {
        return SCIPparamGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPparamGetName(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetName$handle() {
        return SCIPparamGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPparamGetName(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetName$address() {
        return SCIPparamGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPparamGetName(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetName(MemorySegment param) {
        var mh$ = SCIPparamGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetName", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPparamGetDesc(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetDesc$descriptor() {
        return SCIPparamGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPparamGetDesc(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetDesc$handle() {
        return SCIPparamGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPparamGetDesc(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetDesc$address() {
        return SCIPparamGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPparamGetDesc(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetDesc(MemorySegment param) {
        var mh$ = SCIPparamGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetDesc", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PARAMDATA *SCIPparamGetData(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetData$descriptor() {
        return SCIPparamGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PARAMDATA *SCIPparamGetData(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetData$handle() {
        return SCIPparamGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PARAMDATA *SCIPparamGetData(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetData$address() {
        return SCIPparamGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PARAMDATA *SCIPparamGetData(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetData(MemorySegment param) {
        var mh$ = SCIPparamGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetData", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamIsAdvanced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamIsAdvanced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsAdvanced(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamIsAdvanced$descriptor() {
        return SCIPparamIsAdvanced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsAdvanced(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamIsAdvanced$handle() {
        return SCIPparamIsAdvanced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsAdvanced(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamIsAdvanced$address() {
        return SCIPparamIsAdvanced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparamIsAdvanced(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamIsAdvanced(MemorySegment param) {
        var mh$ = SCIPparamIsAdvanced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamIsAdvanced", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamIsFixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamIsFixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsFixed(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamIsFixed$descriptor() {
        return SCIPparamIsFixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsFixed(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamIsFixed$handle() {
        return SCIPparamIsFixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsFixed(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamIsFixed$address() {
        return SCIPparamIsFixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparamIsFixed(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamIsFixed(MemorySegment param) {
        var mh$ = SCIPparamIsFixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamIsFixed", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamSetFixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamSetFixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPparamSetFixed(SCIP_PARAM *param, unsigned int fixed)
     * }
     */
    public static FunctionDescriptor SCIPparamSetFixed$descriptor() {
        return SCIPparamSetFixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPparamSetFixed(SCIP_PARAM *param, unsigned int fixed)
     * }
     */
    public static MethodHandle SCIPparamSetFixed$handle() {
        return SCIPparamSetFixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPparamSetFixed(SCIP_PARAM *param, unsigned int fixed)
     * }
     */
    public static MemorySegment SCIPparamSetFixed$address() {
        return SCIPparamSetFixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPparamSetFixed(SCIP_PARAM *param, unsigned int fixed)
     * }
     */
    public static void SCIPparamSetFixed(MemorySegment param, int fixed) {
        var mh$ = SCIPparamSetFixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamSetFixed", param, fixed);
            }
            mh$.invokeExact(param, fixed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBool(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetBool$descriptor() {
        return SCIPparamGetBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBool(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetBool$handle() {
        return SCIPparamGetBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBool(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetBool$address() {
        return SCIPparamGetBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBool(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetBool(MemorySegment param) {
        var mh$ = SCIPparamGetBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetBool", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetBoolDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetBoolDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBoolDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetBoolDefault$descriptor() {
        return SCIPparamGetBoolDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBoolDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetBoolDefault$handle() {
        return SCIPparamGetBoolDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBoolDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetBoolDefault$address() {
        return SCIPparamGetBoolDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparamGetBoolDefault(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetBoolDefault(MemorySegment param) {
        var mh$ = SCIPparamGetBoolDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetBoolDefault", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPparamGetInt(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetInt$descriptor() {
        return SCIPparamGetInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPparamGetInt(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetInt$handle() {
        return SCIPparamGetInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPparamGetInt(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetInt$address() {
        return SCIPparamGetInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPparamGetInt(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetInt(MemorySegment param) {
        var mh$ = SCIPparamGetInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetInt", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetIntMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetIntMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMin(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetIntMin$descriptor() {
        return SCIPparamGetIntMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMin(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetIntMin$handle() {
        return SCIPparamGetIntMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMin(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetIntMin$address() {
        return SCIPparamGetIntMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPparamGetIntMin(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetIntMin(MemorySegment param) {
        var mh$ = SCIPparamGetIntMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetIntMin", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetIntMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetIntMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMax(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetIntMax$descriptor() {
        return SCIPparamGetIntMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMax(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetIntMax$handle() {
        return SCIPparamGetIntMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPparamGetIntMax(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetIntMax$address() {
        return SCIPparamGetIntMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPparamGetIntMax(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetIntMax(MemorySegment param) {
        var mh$ = SCIPparamGetIntMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetIntMax", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetIntDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetIntDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPparamGetIntDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetIntDefault$descriptor() {
        return SCIPparamGetIntDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPparamGetIntDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetIntDefault$handle() {
        return SCIPparamGetIntDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPparamGetIntDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetIntDefault$address() {
        return SCIPparamGetIntDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPparamGetIntDefault(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamGetIntDefault(MemorySegment param) {
        var mh$ = SCIPparamGetIntDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetIntDefault", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetLongint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetLongint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongint(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetLongint$descriptor() {
        return SCIPparamGetLongint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongint(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetLongint$handle() {
        return SCIPparamGetLongint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongint(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetLongint$address() {
        return SCIPparamGetLongint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPparamGetLongint(SCIP_PARAM *param)
     * }
     */
    public static long SCIPparamGetLongint(MemorySegment param) {
        var mh$ = SCIPparamGetLongint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetLongint", param);
            }
            return (long)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetLongintMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetLongintMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMin(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetLongintMin$descriptor() {
        return SCIPparamGetLongintMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMin(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetLongintMin$handle() {
        return SCIPparamGetLongintMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMin(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetLongintMin$address() {
        return SCIPparamGetLongintMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMin(SCIP_PARAM *param)
     * }
     */
    public static long SCIPparamGetLongintMin(MemorySegment param) {
        var mh$ = SCIPparamGetLongintMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetLongintMin", param);
            }
            return (long)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetLongintMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetLongintMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMax(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetLongintMax$descriptor() {
        return SCIPparamGetLongintMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMax(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetLongintMax$handle() {
        return SCIPparamGetLongintMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMax(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetLongintMax$address() {
        return SCIPparamGetLongintMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPparamGetLongintMax(SCIP_PARAM *param)
     * }
     */
    public static long SCIPparamGetLongintMax(MemorySegment param) {
        var mh$ = SCIPparamGetLongintMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetLongintMax", param);
            }
            return (long)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetLongintDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetLongintDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetLongintDefault$descriptor() {
        return SCIPparamGetLongintDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetLongintDefault$handle() {
        return SCIPparamGetLongintDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPparamGetLongintDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetLongintDefault$address() {
        return SCIPparamGetLongintDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPparamGetLongintDefault(SCIP_PARAM *param)
     * }
     */
    public static long SCIPparamGetLongintDefault(MemorySegment param) {
        var mh$ = SCIPparamGetLongintDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetLongintDefault", param);
            }
            return (long)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPparamGetReal(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetReal$descriptor() {
        return SCIPparamGetReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPparamGetReal(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetReal$handle() {
        return SCIPparamGetReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPparamGetReal(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetReal$address() {
        return SCIPparamGetReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPparamGetReal(SCIP_PARAM *param)
     * }
     */
    public static double SCIPparamGetReal(MemorySegment param) {
        var mh$ = SCIPparamGetReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetReal", param);
            }
            return (double)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetRealMin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetRealMin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMin(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetRealMin$descriptor() {
        return SCIPparamGetRealMin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMin(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetRealMin$handle() {
        return SCIPparamGetRealMin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMin(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetRealMin$address() {
        return SCIPparamGetRealMin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPparamGetRealMin(SCIP_PARAM *param)
     * }
     */
    public static double SCIPparamGetRealMin(MemorySegment param) {
        var mh$ = SCIPparamGetRealMin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetRealMin", param);
            }
            return (double)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetRealMax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetRealMax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMax(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetRealMax$descriptor() {
        return SCIPparamGetRealMax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMax(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetRealMax$handle() {
        return SCIPparamGetRealMax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPparamGetRealMax(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetRealMax$address() {
        return SCIPparamGetRealMax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPparamGetRealMax(SCIP_PARAM *param)
     * }
     */
    public static double SCIPparamGetRealMax(MemorySegment param) {
        var mh$ = SCIPparamGetRealMax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetRealMax", param);
            }
            return (double)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetRealDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetRealDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPparamGetRealDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetRealDefault$descriptor() {
        return SCIPparamGetRealDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPparamGetRealDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetRealDefault$handle() {
        return SCIPparamGetRealDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPparamGetRealDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetRealDefault$address() {
        return SCIPparamGetRealDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPparamGetRealDefault(SCIP_PARAM *param)
     * }
     */
    public static double SCIPparamGetRealDefault(MemorySegment param) {
        var mh$ = SCIPparamGetRealDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetRealDefault", param);
            }
            return (double)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetChar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char SCIPparamGetChar(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetChar$descriptor() {
        return SCIPparamGetChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char SCIPparamGetChar(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetChar$handle() {
        return SCIPparamGetChar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char SCIPparamGetChar(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetChar$address() {
        return SCIPparamGetChar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char SCIPparamGetChar(SCIP_PARAM *param)
     * }
     */
    public static byte SCIPparamGetChar(MemorySegment param) {
        var mh$ = SCIPparamGetChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetChar", param);
            }
            return (byte)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetCharAllowedValues {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetCharAllowedValues");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPparamGetCharAllowedValues(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetCharAllowedValues$descriptor() {
        return SCIPparamGetCharAllowedValues.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPparamGetCharAllowedValues(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetCharAllowedValues$handle() {
        return SCIPparamGetCharAllowedValues.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPparamGetCharAllowedValues(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetCharAllowedValues$address() {
        return SCIPparamGetCharAllowedValues.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPparamGetCharAllowedValues(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetCharAllowedValues(MemorySegment param) {
        var mh$ = SCIPparamGetCharAllowedValues.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetCharAllowedValues", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetCharDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetCharDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char SCIPparamGetCharDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetCharDefault$descriptor() {
        return SCIPparamGetCharDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char SCIPparamGetCharDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetCharDefault$handle() {
        return SCIPparamGetCharDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char SCIPparamGetCharDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetCharDefault$address() {
        return SCIPparamGetCharDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char SCIPparamGetCharDefault(SCIP_PARAM *param)
     * }
     */
    public static byte SCIPparamGetCharDefault(MemorySegment param) {
        var mh$ = SCIPparamGetCharDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetCharDefault", param);
            }
            return (byte)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPparamGetString(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetString$descriptor() {
        return SCIPparamGetString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPparamGetString(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetString$handle() {
        return SCIPparamGetString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPparamGetString(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetString$address() {
        return SCIPparamGetString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPparamGetString(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetString(MemorySegment param) {
        var mh$ = SCIPparamGetString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetString", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamGetStringDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamGetStringDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPparamGetStringDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamGetStringDefault$descriptor() {
        return SCIPparamGetStringDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPparamGetStringDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamGetStringDefault$handle() {
        return SCIPparamGetStringDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPparamGetStringDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetStringDefault$address() {
        return SCIPparamGetStringDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPparamGetStringDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamGetStringDefault(MemorySegment param) {
        var mh$ = SCIPparamGetStringDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamGetStringDefault", param);
            }
            return (MemorySegment)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparamIsDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparamIsDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsDefault(SCIP_PARAM *param)
     * }
     */
    public static FunctionDescriptor SCIPparamIsDefault$descriptor() {
        return SCIPparamIsDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsDefault(SCIP_PARAM *param)
     * }
     */
    public static MethodHandle SCIPparamIsDefault$handle() {
        return SCIPparamIsDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparamIsDefault(SCIP_PARAM *param)
     * }
     */
    public static MemorySegment SCIPparamIsDefault$address() {
        return SCIPparamIsDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparamIsDefault(SCIP_PARAM *param)
     * }
     */
    public static int SCIPparamIsDefault(MemorySegment param) {
        var mh$ = SCIPparamIsDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparamIsDefault", param);
            }
            return (int)mh$.invokeExact(param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpresolComp$descriptor() {
        return SCIPpresolComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpresolComp$handle() {
        return SCIPpresolComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpresolComp$address() {
        return SCIPpresolComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpresolComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpresolComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpresolCompName$descriptor() {
        return SCIPpresolCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpresolCompName$handle() {
        return SCIPpresolCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpresolCompName$address() {
        return SCIPpresolCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpresolCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpresolCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOLDATA *SCIPpresolGetData(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetData$descriptor() {
        return SCIPpresolGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOLDATA *SCIPpresolGetData(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetData$handle() {
        return SCIPpresolGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOLDATA *SCIPpresolGetData(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetData$address() {
        return SCIPpresolGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOLDATA *SCIPpresolGetData(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetData(MemorySegment presol) {
        var mh$ = SCIPpresolGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetData", presol);
            }
            return (MemorySegment)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpresolSetData(SCIP_PRESOL *presol, SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static FunctionDescriptor SCIPpresolSetData$descriptor() {
        return SCIPpresolSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpresolSetData(SCIP_PRESOL *presol, SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MethodHandle SCIPpresolSetData$handle() {
        return SCIPpresolSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpresolSetData(SCIP_PRESOL *presol, SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MemorySegment SCIPpresolSetData$address() {
        return SCIPpresolSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpresolSetData(SCIP_PRESOL *presol, SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static void SCIPpresolSetData(MemorySegment presol, MemorySegment presoldata) {
        var mh$ = SCIPpresolSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolSetData", presol, presoldata);
            }
            mh$.invokeExact(presol, presoldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetName(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetName$descriptor() {
        return SCIPpresolGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetName(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetName$handle() {
        return SCIPpresolGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetName(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetName$address() {
        return SCIPpresolGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpresolGetName(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetName(MemorySegment presol) {
        var mh$ = SCIPpresolGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetName", presol);
            }
            return (MemorySegment)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetDesc(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetDesc$descriptor() {
        return SCIPpresolGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetDesc(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetDesc$handle() {
        return SCIPpresolGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpresolGetDesc(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetDesc$address() {
        return SCIPpresolGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpresolGetDesc(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetDesc(MemorySegment presol) {
        var mh$ = SCIPpresolGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetDesc", presol);
            }
            return (MemorySegment)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetPriority(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetPriority$descriptor() {
        return SCIPpresolGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetPriority(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetPriority$handle() {
        return SCIPpresolGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetPriority(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetPriority$address() {
        return SCIPpresolGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetPriority(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetPriority(MemorySegment presol) {
        var mh$ = SCIPpresolGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetPriority", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetMaxrounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetMaxrounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetMaxrounds(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetMaxrounds$descriptor() {
        return SCIPpresolGetMaxrounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetMaxrounds(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetMaxrounds$handle() {
        return SCIPpresolGetMaxrounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetMaxrounds(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetMaxrounds$address() {
        return SCIPpresolGetMaxrounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetMaxrounds(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetMaxrounds(MemorySegment presol) {
        var mh$ = SCIPpresolGetMaxrounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetMaxrounds", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpresolGetTiming(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetTiming$descriptor() {
        return SCIPpresolGetTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpresolGetTiming(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetTiming$handle() {
        return SCIPpresolGetTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpresolGetTiming(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetTiming$address() {
        return SCIPpresolGetTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpresolGetTiming(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetTiming(MemorySegment presol) {
        var mh$ = SCIPpresolGetTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetTiming", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolSetTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolSetTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpresolSetTiming(SCIP_PRESOL *presol, SCIP_PRESOLTIMING timing)
     * }
     */
    public static FunctionDescriptor SCIPpresolSetTiming$descriptor() {
        return SCIPpresolSetTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpresolSetTiming(SCIP_PRESOL *presol, SCIP_PRESOLTIMING timing)
     * }
     */
    public static MethodHandle SCIPpresolSetTiming$handle() {
        return SCIPpresolSetTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpresolSetTiming(SCIP_PRESOL *presol, SCIP_PRESOLTIMING timing)
     * }
     */
    public static MemorySegment SCIPpresolSetTiming$address() {
        return SCIPpresolSetTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpresolSetTiming(SCIP_PRESOL *presol, SCIP_PRESOLTIMING timing)
     * }
     */
    public static void SCIPpresolSetTiming(MemorySegment presol, int timing) {
        var mh$ = SCIPpresolSetTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolSetTiming", presol, timing);
            }
            mh$.invokeExact(presol, timing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpresolIsInitialized(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolIsInitialized$descriptor() {
        return SCIPpresolIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpresolIsInitialized(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolIsInitialized$handle() {
        return SCIPpresolIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpresolIsInitialized(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolIsInitialized$address() {
        return SCIPpresolIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpresolIsInitialized(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolIsInitialized(MemorySegment presol) {
        var mh$ = SCIPpresolIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolIsInitialized", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpresolGetSetupTime(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetSetupTime$descriptor() {
        return SCIPpresolGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpresolGetSetupTime(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetSetupTime$handle() {
        return SCIPpresolGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpresolGetSetupTime(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetSetupTime$address() {
        return SCIPpresolGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpresolGetSetupTime(SCIP_PRESOL *presol)
     * }
     */
    public static double SCIPpresolGetSetupTime(MemorySegment presol) {
        var mh$ = SCIPpresolGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetSetupTime", presol);
            }
            return (double)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpresolGetTime(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetTime$descriptor() {
        return SCIPpresolGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpresolGetTime(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetTime$handle() {
        return SCIPpresolGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpresolGetTime(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetTime$address() {
        return SCIPpresolGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpresolGetTime(SCIP_PRESOL *presol)
     * }
     */
    public static double SCIPpresolGetTime(MemorySegment presol) {
        var mh$ = SCIPpresolGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetTime", presol);
            }
            return (double)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNFixedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNFixedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNFixedVars(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNFixedVars$descriptor() {
        return SCIPpresolGetNFixedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNFixedVars(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNFixedVars$handle() {
        return SCIPpresolGetNFixedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNFixedVars(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNFixedVars$address() {
        return SCIPpresolGetNFixedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNFixedVars(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNFixedVars(MemorySegment presol) {
        var mh$ = SCIPpresolGetNFixedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNFixedVars", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNAggrVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNAggrVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAggrVars(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNAggrVars$descriptor() {
        return SCIPpresolGetNAggrVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAggrVars(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNAggrVars$handle() {
        return SCIPpresolGetNAggrVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAggrVars(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNAggrVars$address() {
        return SCIPpresolGetNAggrVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNAggrVars(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNAggrVars(MemorySegment presol) {
        var mh$ = SCIPpresolGetNAggrVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNAggrVars", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNChgVarTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNChgVarTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgVarTypes(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNChgVarTypes$descriptor() {
        return SCIPpresolGetNChgVarTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgVarTypes(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNChgVarTypes$handle() {
        return SCIPpresolGetNChgVarTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgVarTypes(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNChgVarTypes$address() {
        return SCIPpresolGetNChgVarTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNChgVarTypes(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNChgVarTypes(MemorySegment presol) {
        var mh$ = SCIPpresolGetNChgVarTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNChgVarTypes", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNChgBds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNChgBds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgBds(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNChgBds$descriptor() {
        return SCIPpresolGetNChgBds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgBds(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNChgBds$handle() {
        return SCIPpresolGetNChgBds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgBds(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNChgBds$address() {
        return SCIPpresolGetNChgBds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNChgBds(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNChgBds(MemorySegment presol) {
        var mh$ = SCIPpresolGetNChgBds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNChgBds", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNAddHoles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNAddHoles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddHoles(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNAddHoles$descriptor() {
        return SCIPpresolGetNAddHoles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddHoles(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNAddHoles$handle() {
        return SCIPpresolGetNAddHoles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddHoles(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNAddHoles$address() {
        return SCIPpresolGetNAddHoles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNAddHoles(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNAddHoles(MemorySegment presol) {
        var mh$ = SCIPpresolGetNAddHoles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNAddHoles", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNDelConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNDelConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNDelConss(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNDelConss$descriptor() {
        return SCIPpresolGetNDelConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNDelConss(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNDelConss$handle() {
        return SCIPpresolGetNDelConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNDelConss(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNDelConss$address() {
        return SCIPpresolGetNDelConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNDelConss(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNDelConss(MemorySegment presol) {
        var mh$ = SCIPpresolGetNDelConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNDelConss", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNAddConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNAddConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddConss(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNAddConss$descriptor() {
        return SCIPpresolGetNAddConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddConss(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNAddConss$handle() {
        return SCIPpresolGetNAddConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNAddConss(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNAddConss$address() {
        return SCIPpresolGetNAddConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNAddConss(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNAddConss(MemorySegment presol) {
        var mh$ = SCIPpresolGetNAddConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNAddConss", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNUpgdConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNUpgdConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNUpgdConss(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNUpgdConss$descriptor() {
        return SCIPpresolGetNUpgdConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNUpgdConss(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNUpgdConss$handle() {
        return SCIPpresolGetNUpgdConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNUpgdConss(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNUpgdConss$address() {
        return SCIPpresolGetNUpgdConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNUpgdConss(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNUpgdConss(MemorySegment presol) {
        var mh$ = SCIPpresolGetNUpgdConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNUpgdConss", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNChgCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNChgCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgCoefs(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNChgCoefs$descriptor() {
        return SCIPpresolGetNChgCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgCoefs(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNChgCoefs$handle() {
        return SCIPpresolGetNChgCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgCoefs(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNChgCoefs$address() {
        return SCIPpresolGetNChgCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNChgCoefs(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNChgCoefs(MemorySegment presol) {
        var mh$ = SCIPpresolGetNChgCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNChgCoefs", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNChgSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNChgSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgSides(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNChgSides$descriptor() {
        return SCIPpresolGetNChgSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgSides(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNChgSides$handle() {
        return SCIPpresolGetNChgSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNChgSides(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNChgSides$address() {
        return SCIPpresolGetNChgSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNChgSides(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNChgSides(MemorySegment presol) {
        var mh$ = SCIPpresolGetNChgSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNChgSides", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpresolGetNCalls(SCIP_PRESOL *presol)
     * }
     */
    public static FunctionDescriptor SCIPpresolGetNCalls$descriptor() {
        return SCIPpresolGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpresolGetNCalls(SCIP_PRESOL *presol)
     * }
     */
    public static MethodHandle SCIPpresolGetNCalls$handle() {
        return SCIPpresolGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpresolGetNCalls(SCIP_PRESOL *presol)
     * }
     */
    public static MemorySegment SCIPpresolGetNCalls$address() {
        return SCIPpresolGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpresolGetNCalls(SCIP_PRESOL *presol)
     * }
     */
    public static int SCIPpresolGetNCalls(MemorySegment presol) {
        var mh$ = SCIPpresolGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolGetNCalls", presol);
            }
            return (int)mh$.invokeExact(presol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpricerComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpricerComp$descriptor() {
        return SCIPpricerComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpricerComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpricerComp$handle() {
        return SCIPpricerComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpricerComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpricerComp$address() {
        return SCIPpricerComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpricerComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpricerComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpricerComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpricerCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpricerCompName$descriptor() {
        return SCIPpricerCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpricerCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpricerCompName$handle() {
        return SCIPpricerCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpricerCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpricerCompName$address() {
        return SCIPpricerCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpricerCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpricerCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpricerCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRICERDATA *SCIPpricerGetData(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetData$descriptor() {
        return SCIPpricerGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRICERDATA *SCIPpricerGetData(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetData$handle() {
        return SCIPpricerGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRICERDATA *SCIPpricerGetData(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetData$address() {
        return SCIPpricerGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRICERDATA *SCIPpricerGetData(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetData(MemorySegment pricer) {
        var mh$ = SCIPpricerGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetData", pricer);
            }
            return (MemorySegment)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpricerSetData(SCIP_PRICER *pricer, SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static FunctionDescriptor SCIPpricerSetData$descriptor() {
        return SCIPpricerSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpricerSetData(SCIP_PRICER *pricer, SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MethodHandle SCIPpricerSetData$handle() {
        return SCIPpricerSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpricerSetData(SCIP_PRICER *pricer, SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MemorySegment SCIPpricerSetData$address() {
        return SCIPpricerSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpricerSetData(SCIP_PRICER *pricer, SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static void SCIPpricerSetData(MemorySegment pricer, MemorySegment pricerdata) {
        var mh$ = SCIPpricerSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerSetData", pricer, pricerdata);
            }
            mh$.invokeExact(pricer, pricerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetName(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetName$descriptor() {
        return SCIPpricerGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetName(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetName$handle() {
        return SCIPpricerGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetName(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetName$address() {
        return SCIPpricerGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpricerGetName(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetName(MemorySegment pricer) {
        var mh$ = SCIPpricerGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetName", pricer);
            }
            return (MemorySegment)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetDesc(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetDesc$descriptor() {
        return SCIPpricerGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetDesc(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetDesc$handle() {
        return SCIPpricerGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpricerGetDesc(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetDesc$address() {
        return SCIPpricerGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpricerGetDesc(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetDesc(MemorySegment pricer) {
        var mh$ = SCIPpricerGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetDesc", pricer);
            }
            return (MemorySegment)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpricerGetPriority(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetPriority$descriptor() {
        return SCIPpricerGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpricerGetPriority(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetPriority$handle() {
        return SCIPpricerGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpricerGetPriority(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetPriority$address() {
        return SCIPpricerGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpricerGetPriority(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerGetPriority(MemorySegment pricer) {
        var mh$ = SCIPpricerGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetPriority", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpricerGetNCalls(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetNCalls$descriptor() {
        return SCIPpricerGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpricerGetNCalls(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetNCalls$handle() {
        return SCIPpricerGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpricerGetNCalls(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetNCalls$address() {
        return SCIPpricerGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpricerGetNCalls(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerGetNCalls(MemorySegment pricer) {
        var mh$ = SCIPpricerGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetNCalls", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetNVarsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetNVarsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpricerGetNVarsFound(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetNVarsFound$descriptor() {
        return SCIPpricerGetNVarsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpricerGetNVarsFound(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetNVarsFound$handle() {
        return SCIPpricerGetNVarsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpricerGetNVarsFound(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetNVarsFound$address() {
        return SCIPpricerGetNVarsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpricerGetNVarsFound(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerGetNVarsFound(MemorySegment pricer) {
        var mh$ = SCIPpricerGetNVarsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetNVarsFound", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpricerGetSetupTime(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetSetupTime$descriptor() {
        return SCIPpricerGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpricerGetSetupTime(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetSetupTime$handle() {
        return SCIPpricerGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpricerGetSetupTime(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetSetupTime$address() {
        return SCIPpricerGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpricerGetSetupTime(SCIP_PRICER *pricer)
     * }
     */
    public static double SCIPpricerGetSetupTime(MemorySegment pricer) {
        var mh$ = SCIPpricerGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetSetupTime", pricer);
            }
            return (double)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpricerGetTime(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerGetTime$descriptor() {
        return SCIPpricerGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpricerGetTime(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerGetTime$handle() {
        return SCIPpricerGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpricerGetTime(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerGetTime$address() {
        return SCIPpricerGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpricerGetTime(SCIP_PRICER *pricer)
     * }
     */
    public static double SCIPpricerGetTime(MemorySegment pricer) {
        var mh$ = SCIPpricerGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerGetTime", pricer);
            }
            return (double)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsActive(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerIsActive$descriptor() {
        return SCIPpricerIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsActive(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerIsActive$handle() {
        return SCIPpricerIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsActive(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerIsActive$address() {
        return SCIPpricerIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsActive(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerIsActive(MemorySegment pricer) {
        var mh$ = SCIPpricerIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerIsActive", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerIsDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerIsDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsDelayed(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerIsDelayed$descriptor() {
        return SCIPpricerIsDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsDelayed(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerIsDelayed$handle() {
        return SCIPpricerIsDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsDelayed(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerIsDelayed$address() {
        return SCIPpricerIsDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsDelayed(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerIsDelayed(MemorySegment pricer) {
        var mh$ = SCIPpricerIsDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerIsDelayed", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpricerIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpricerIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsInitialized(SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPpricerIsInitialized$descriptor() {
        return SCIPpricerIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsInitialized(SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPpricerIsInitialized$handle() {
        return SCIPpricerIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsInitialized(SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPpricerIsInitialized$address() {
        return SCIPpricerIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpricerIsInitialized(SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPpricerIsInitialized(MemorySegment pricer) {
        var mh$ = SCIPpricerIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpricerIsInitialized", pricer);
            }
            return (int)mh$.invokeExact(pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_READERDATA *SCIPreaderGetData(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderGetData$descriptor() {
        return SCIPreaderGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_READERDATA *SCIPreaderGetData(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderGetData$handle() {
        return SCIPreaderGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_READERDATA *SCIPreaderGetData(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetData$address() {
        return SCIPreaderGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_READERDATA *SCIPreaderGetData(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetData(MemorySegment reader) {
        var mh$ = SCIPreaderGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderGetData", reader);
            }
            return (MemorySegment)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPreaderSetData(SCIP_READER *reader, SCIP_READERDATA *readerdata)
     * }
     */
    public static FunctionDescriptor SCIPreaderSetData$descriptor() {
        return SCIPreaderSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPreaderSetData(SCIP_READER *reader, SCIP_READERDATA *readerdata)
     * }
     */
    public static MethodHandle SCIPreaderSetData$handle() {
        return SCIPreaderSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPreaderSetData(SCIP_READER *reader, SCIP_READERDATA *readerdata)
     * }
     */
    public static MemorySegment SCIPreaderSetData$address() {
        return SCIPreaderSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPreaderSetData(SCIP_READER *reader, SCIP_READERDATA *readerdata)
     * }
     */
    public static void SCIPreaderSetData(MemorySegment reader, MemorySegment readerdata) {
        var mh$ = SCIPreaderSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderSetData", reader, readerdata);
            }
            mh$.invokeExact(reader, readerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetName(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderGetName$descriptor() {
        return SCIPreaderGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetName(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderGetName$handle() {
        return SCIPreaderGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetName(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetName$address() {
        return SCIPreaderGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPreaderGetName(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetName(MemorySegment reader) {
        var mh$ = SCIPreaderGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderGetName", reader);
            }
            return (MemorySegment)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetDesc(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderGetDesc$descriptor() {
        return SCIPreaderGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetDesc(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderGetDesc$handle() {
        return SCIPreaderGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetDesc(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetDesc$address() {
        return SCIPreaderGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPreaderGetDesc(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetDesc(MemorySegment reader) {
        var mh$ = SCIPreaderGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderGetDesc", reader);
            }
            return (MemorySegment)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderGetExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderGetExtension");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetExtension(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderGetExtension$descriptor() {
        return SCIPreaderGetExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetExtension(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderGetExtension$handle() {
        return SCIPreaderGetExtension.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPreaderGetExtension(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetExtension$address() {
        return SCIPreaderGetExtension.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPreaderGetExtension(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderGetExtension(MemorySegment reader) {
        var mh$ = SCIPreaderGetExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderGetExtension", reader);
            }
            return (MemorySegment)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderCanRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderCanRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanRead(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderCanRead$descriptor() {
        return SCIPreaderCanRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanRead(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderCanRead$handle() {
        return SCIPreaderCanRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanRead(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderCanRead$address() {
        return SCIPreaderCanRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanRead(SCIP_READER *reader)
     * }
     */
    public static int SCIPreaderCanRead(MemorySegment reader) {
        var mh$ = SCIPreaderCanRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderCanRead", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreaderCanWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreaderCanWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanWrite(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPreaderCanWrite$descriptor() {
        return SCIPreaderCanWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanWrite(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPreaderCanWrite$handle() {
        return SCIPreaderCanWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanWrite(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPreaderCanWrite$address() {
        return SCIPreaderCanWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPreaderCanWrite(SCIP_READER *reader)
     * }
     */
    public static int SCIPreaderCanWrite(MemorySegment reader) {
        var mh$ = SCIPreaderCanWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreaderCanWrite", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPrelaxComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPrelaxComp$descriptor() {
        return SCIPrelaxComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPrelaxComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPrelaxComp$handle() {
        return SCIPrelaxComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPrelaxComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPrelaxComp$address() {
        return SCIPrelaxComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPrelaxComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPrelaxComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPrelaxComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPrelaxCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPrelaxCompName$descriptor() {
        return SCIPrelaxCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPrelaxCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPrelaxCompName$handle() {
        return SCIPrelaxCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPrelaxCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPrelaxCompName$address() {
        return SCIPrelaxCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPrelaxCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPrelaxCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPrelaxCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RELAXDATA *SCIPrelaxGetData(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetData$descriptor() {
        return SCIPrelaxGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RELAXDATA *SCIPrelaxGetData(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetData$handle() {
        return SCIPrelaxGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RELAXDATA *SCIPrelaxGetData(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetData$address() {
        return SCIPrelaxGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RELAXDATA *SCIPrelaxGetData(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetData(MemorySegment relax) {
        var mh$ = SCIPrelaxGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetData", relax);
            }
            return (MemorySegment)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPrelaxSetData(SCIP_RELAX *relax, SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static FunctionDescriptor SCIPrelaxSetData$descriptor() {
        return SCIPrelaxSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPrelaxSetData(SCIP_RELAX *relax, SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MethodHandle SCIPrelaxSetData$handle() {
        return SCIPrelaxSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPrelaxSetData(SCIP_RELAX *relax, SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MemorySegment SCIPrelaxSetData$address() {
        return SCIPrelaxSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPrelaxSetData(SCIP_RELAX *relax, SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static void SCIPrelaxSetData(MemorySegment relax, MemorySegment relaxdata) {
        var mh$ = SCIPrelaxSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxSetData", relax, relaxdata);
            }
            mh$.invokeExact(relax, relaxdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetName(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetName$descriptor() {
        return SCIPrelaxGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetName(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetName$handle() {
        return SCIPrelaxGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetName(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetName$address() {
        return SCIPrelaxGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPrelaxGetName(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetName(MemorySegment relax) {
        var mh$ = SCIPrelaxGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetName", relax);
            }
            return (MemorySegment)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetDesc(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetDesc$descriptor() {
        return SCIPrelaxGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetDesc(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetDesc$handle() {
        return SCIPrelaxGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPrelaxGetDesc(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetDesc$address() {
        return SCIPrelaxGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPrelaxGetDesc(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetDesc(MemorySegment relax) {
        var mh$ = SCIPrelaxGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetDesc", relax);
            }
            return (MemorySegment)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPrelaxGetPriority(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetPriority$descriptor() {
        return SCIPrelaxGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPrelaxGetPriority(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetPriority$handle() {
        return SCIPrelaxGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPrelaxGetPriority(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetPriority$address() {
        return SCIPrelaxGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPrelaxGetPriority(SCIP_RELAX *relax)
     * }
     */
    public static int SCIPrelaxGetPriority(MemorySegment relax) {
        var mh$ = SCIPrelaxGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetPriority", relax);
            }
            return (int)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPrelaxGetFreq(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetFreq$descriptor() {
        return SCIPrelaxGetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPrelaxGetFreq(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetFreq$handle() {
        return SCIPrelaxGetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPrelaxGetFreq(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetFreq$address() {
        return SCIPrelaxGetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPrelaxGetFreq(SCIP_RELAX *relax)
     * }
     */
    public static int SCIPrelaxGetFreq(MemorySegment relax) {
        var mh$ = SCIPrelaxGetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetFreq", relax);
            }
            return (int)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrelaxGetSetupTime(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetSetupTime$descriptor() {
        return SCIPrelaxGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrelaxGetSetupTime(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetSetupTime$handle() {
        return SCIPrelaxGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrelaxGetSetupTime(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetSetupTime$address() {
        return SCIPrelaxGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrelaxGetSetupTime(SCIP_RELAX *relax)
     * }
     */
    public static double SCIPrelaxGetSetupTime(MemorySegment relax) {
        var mh$ = SCIPrelaxGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetSetupTime", relax);
            }
            return (double)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrelaxGetTime(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetTime$descriptor() {
        return SCIPrelaxGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrelaxGetTime(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetTime$handle() {
        return SCIPrelaxGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrelaxGetTime(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetTime$address() {
        return SCIPrelaxGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrelaxGetTime(SCIP_RELAX *relax)
     * }
     */
    public static double SCIPrelaxGetTime(MemorySegment relax) {
        var mh$ = SCIPrelaxGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetTime", relax);
            }
            return (double)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCalls(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNCalls$descriptor() {
        return SCIPrelaxGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCalls(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNCalls$handle() {
        return SCIPrelaxGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCalls(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNCalls$address() {
        return SCIPrelaxGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCalls(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNCalls(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNCalls", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCutoffs(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNCutoffs$descriptor() {
        return SCIPrelaxGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCutoffs(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNCutoffs$handle() {
        return SCIPrelaxGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCutoffs(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNCutoffs$address() {
        return SCIPrelaxGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNCutoffs(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNCutoffs(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNCutoffs", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNImprovedLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNImprovedLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNImprovedLowerbound(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNImprovedLowerbound$descriptor() {
        return SCIPrelaxGetNImprovedLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNImprovedLowerbound(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNImprovedLowerbound$handle() {
        return SCIPrelaxGetNImprovedLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNImprovedLowerbound(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNImprovedLowerbound$address() {
        return SCIPrelaxGetNImprovedLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNImprovedLowerbound(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNImprovedLowerbound(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNImprovedLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNImprovedLowerbound", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetImprovedLowerboundTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetImprovedLowerboundTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrelaxGetImprovedLowerboundTime(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetImprovedLowerboundTime$descriptor() {
        return SCIPrelaxGetImprovedLowerboundTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrelaxGetImprovedLowerboundTime(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetImprovedLowerboundTime$handle() {
        return SCIPrelaxGetImprovedLowerboundTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrelaxGetImprovedLowerboundTime(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetImprovedLowerboundTime$address() {
        return SCIPrelaxGetImprovedLowerboundTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrelaxGetImprovedLowerboundTime(SCIP_RELAX *relax)
     * }
     */
    public static double SCIPrelaxGetImprovedLowerboundTime(MemorySegment relax) {
        var mh$ = SCIPrelaxGetImprovedLowerboundTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetImprovedLowerboundTime", relax);
            }
            return (double)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNAddedConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNAddedConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNAddedConss(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNAddedConss$descriptor() {
        return SCIPrelaxGetNAddedConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNAddedConss(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNAddedConss$handle() {
        return SCIPrelaxGetNAddedConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNAddedConss(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNAddedConss$address() {
        return SCIPrelaxGetNAddedConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNAddedConss(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNAddedConss(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNAddedConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNAddedConss", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNReducedDomains {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNReducedDomains");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNReducedDomains(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNReducedDomains$descriptor() {
        return SCIPrelaxGetNReducedDomains.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNReducedDomains(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNReducedDomains$handle() {
        return SCIPrelaxGetNReducedDomains.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNReducedDomains(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNReducedDomains$address() {
        return SCIPrelaxGetNReducedDomains.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNReducedDomains(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNReducedDomains(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNReducedDomains.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNReducedDomains", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxGetNSeparatedCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxGetNSeparatedCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNSeparatedCuts(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxGetNSeparatedCuts$descriptor() {
        return SCIPrelaxGetNSeparatedCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNSeparatedCuts(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxGetNSeparatedCuts$handle() {
        return SCIPrelaxGetNSeparatedCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPrelaxGetNSeparatedCuts(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxGetNSeparatedCuts$address() {
        return SCIPrelaxGetNSeparatedCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPrelaxGetNSeparatedCuts(SCIP_RELAX *relax)
     * }
     */
    public static long SCIPrelaxGetNSeparatedCuts(MemorySegment relax) {
        var mh$ = SCIPrelaxGetNSeparatedCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxGetNSeparatedCuts", relax);
            }
            return (long)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPrelaxIsInitialized(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxIsInitialized$descriptor() {
        return SCIPrelaxIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPrelaxIsInitialized(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxIsInitialized$handle() {
        return SCIPrelaxIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPrelaxIsInitialized(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxIsInitialized$address() {
        return SCIPrelaxIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPrelaxIsInitialized(SCIP_RELAX *relax)
     * }
     */
    public static int SCIPrelaxIsInitialized(MemorySegment relax) {
        var mh$ = SCIPrelaxIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxIsInitialized", relax);
            }
            return (int)mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxMarkUnsolved {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxMarkUnsolved");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPrelaxMarkUnsolved(SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPrelaxMarkUnsolved$descriptor() {
        return SCIPrelaxMarkUnsolved.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPrelaxMarkUnsolved(SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPrelaxMarkUnsolved$handle() {
        return SCIPrelaxMarkUnsolved.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPrelaxMarkUnsolved(SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPrelaxMarkUnsolved$address() {
        return SCIPrelaxMarkUnsolved.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPrelaxMarkUnsolved(SCIP_RELAX *relax)
     * }
     */
    public static void SCIPrelaxMarkUnsolved(MemorySegment relax) {
        var mh$ = SCIPrelaxMarkUnsolved.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxMarkUnsolved", relax);
            }
            mh$.invokeExact(relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNVars(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetNVars$descriptor() {
        return SCIPreoptnodeGetNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNVars(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetNVars$handle() {
        return SCIPreoptnodeGetNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNVars(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetNVars$address() {
        return SCIPreoptnodeGetNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNVars(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static int SCIPreoptnodeGetNVars(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetNVars", reoptnode);
            }
            return (int)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetNConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetNConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNConss(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetNConss$descriptor() {
        return SCIPreoptnodeGetNConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNConss(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetNConss$handle() {
        return SCIPreoptnodeGetNConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNConss(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetNConss$address() {
        return SCIPreoptnodeGetNConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNConss(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static int SCIPreoptnodeGetNConss(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetNConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetNConss", reoptnode);
            }
            return (int)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetNDualBoundChgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetNDualBoundChgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNDualBoundChgs(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetNDualBoundChgs$descriptor() {
        return SCIPreoptnodeGetNDualBoundChgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNDualBoundChgs(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetNDualBoundChgs$handle() {
        return SCIPreoptnodeGetNDualBoundChgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNDualBoundChgs(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetNDualBoundChgs$address() {
        return SCIPreoptnodeGetNDualBoundChgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNDualBoundChgs(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static int SCIPreoptnodeGetNDualBoundChgs(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetNDualBoundChgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetNDualBoundChgs", reoptnode);
            }
            return (int)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetNChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetNChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNChildren(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetNChildren$descriptor() {
        return SCIPreoptnodeGetNChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNChildren(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetNChildren$handle() {
        return SCIPreoptnodeGetNChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNChildren(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetNChildren$address() {
        return SCIPreoptnodeGetNChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptnodeGetNChildren(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static int SCIPreoptnodeGetNChildren(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetNChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetNChildren", reoptnode);
            }
            return (int)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPreoptnodeGetLowerbound(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetLowerbound$descriptor() {
        return SCIPreoptnodeGetLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPreoptnodeGetLowerbound(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetLowerbound$handle() {
        return SCIPreoptnodeGetLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPreoptnodeGetLowerbound(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetLowerbound$address() {
        return SCIPreoptnodeGetLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPreoptnodeGetLowerbound(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static double SCIPreoptnodeGetLowerbound(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetLowerbound", reoptnode);
            }
            return (double)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPreoptnodeGetType(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetType$descriptor() {
        return SCIPreoptnodeGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPreoptnodeGetType(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetType$handle() {
        return SCIPreoptnodeGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPreoptnodeGetType(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetType$address() {
        return SCIPreoptnodeGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPreoptnodeGetType(SCIP_REOPTNODE *reoptnode)
     * }
     */
    public static int SCIPreoptnodeGetType(MemorySegment reoptnode) {
        var mh$ = SCIPreoptnodeGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetType", reoptnode);
            }
            return (int)mh$.invokeExact(reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetSplitCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetSplitCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetSplitCons(SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, REOPT_CONSTYPE *constype, int conssize, int *nvars)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetSplitCons$descriptor() {
        return SCIPreoptnodeGetSplitCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetSplitCons(SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, REOPT_CONSTYPE *constype, int conssize, int *nvars)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetSplitCons$handle() {
        return SCIPreoptnodeGetSplitCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetSplitCons(SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, REOPT_CONSTYPE *constype, int conssize, int *nvars)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetSplitCons$address() {
        return SCIPreoptnodeGetSplitCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPreoptnodeGetSplitCons(SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, REOPT_CONSTYPE *constype, int conssize, int *nvars)
     * }
     */
    public static void SCIPreoptnodeGetSplitCons(MemorySegment reoptnode, MemorySegment vars, MemorySegment vals, MemorySegment constype, int conssize, MemorySegment nvars) {
        var mh$ = SCIPreoptnodeGetSplitCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetSplitCons", reoptnode, vars, vals, constype, conssize, nvars);
            }
            mh$.invokeExact(reoptnode, vars, vals, constype, conssize, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeGetConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeGetConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetConss(SCIP_REOPTNODE *reoptnode, SCIP_VAR ***vars, double **bounds, SCIP_BOUNDTYPE **boundtypes, int mem, int *nconss, int *nvars)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeGetConss$descriptor() {
        return SCIPreoptnodeGetConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetConss(SCIP_REOPTNODE *reoptnode, SCIP_VAR ***vars, double **bounds, SCIP_BOUNDTYPE **boundtypes, int mem, int *nconss, int *nvars)
     * }
     */
    public static MethodHandle SCIPreoptnodeGetConss$handle() {
        return SCIPreoptnodeGetConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPreoptnodeGetConss(SCIP_REOPTNODE *reoptnode, SCIP_VAR ***vars, double **bounds, SCIP_BOUNDTYPE **boundtypes, int mem, int *nconss, int *nvars)
     * }
     */
    public static MemorySegment SCIPreoptnodeGetConss$address() {
        return SCIPreoptnodeGetConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPreoptnodeGetConss(SCIP_REOPTNODE *reoptnode, SCIP_VAR ***vars, double **bounds, SCIP_BOUNDTYPE **boundtypes, int mem, int *nconss, int *nvars)
     * }
     */
    public static void SCIPreoptnodeGetConss(MemorySegment reoptnode, MemorySegment vars, MemorySegment bounds, MemorySegment boundtypes, int mem, MemorySegment nconss, MemorySegment nvars) {
        var mh$ = SCIPreoptnodeGetConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeGetConss", reoptnode, vars, bounds, boundtypes, mem, nconss, nvars);
            }
            mh$.invokeExact(reoptnode, vars, bounds, boundtypes, mem, nconss, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptnodeSetParentID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptnodeSetParentID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPreoptnodeSetParentID(SCIP_REOPTNODE *reoptnode, unsigned int parentid)
     * }
     */
    public static FunctionDescriptor SCIPreoptnodeSetParentID$descriptor() {
        return SCIPreoptnodeSetParentID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPreoptnodeSetParentID(SCIP_REOPTNODE *reoptnode, unsigned int parentid)
     * }
     */
    public static MethodHandle SCIPreoptnodeSetParentID$handle() {
        return SCIPreoptnodeSetParentID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPreoptnodeSetParentID(SCIP_REOPTNODE *reoptnode, unsigned int parentid)
     * }
     */
    public static MemorySegment SCIPreoptnodeSetParentID$address() {
        return SCIPreoptnodeSetParentID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPreoptnodeSetParentID(SCIP_REOPTNODE *reoptnode, unsigned int parentid)
     * }
     */
    public static void SCIPreoptnodeSetParentID(MemorySegment reoptnode, int parentid) {
        var mh$ = SCIPreoptnodeSetParentID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptnodeSetParentID", reoptnode, parentid);
            }
            mh$.invokeExact(reoptnode, parentid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNRestartsGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNRestartsGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsGlobal(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNRestartsGlobal$descriptor() {
        return SCIPreoptGetNRestartsGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsGlobal(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNRestartsGlobal$handle() {
        return SCIPreoptGetNRestartsGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsGlobal(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNRestartsGlobal$address() {
        return SCIPreoptGetNRestartsGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsGlobal(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNRestartsGlobal(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNRestartsGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNRestartsGlobal", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNRestartsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNRestartsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNRestartsLocal$descriptor() {
        return SCIPreoptGetNRestartsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNRestartsLocal$handle() {
        return SCIPreoptGetNRestartsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNRestartsLocal$address() {
        return SCIPreoptGetNRestartsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNRestartsLocal(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNRestartsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNRestartsLocal", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNTotalRestartsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNTotalRestartsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNTotalRestartsLocal$descriptor() {
        return SCIPreoptGetNTotalRestartsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNTotalRestartsLocal$handle() {
        return SCIPreoptGetNTotalRestartsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNTotalRestartsLocal$address() {
        return SCIPreoptGetNTotalRestartsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalRestartsLocal(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNTotalRestartsLocal(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNTotalRestartsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNTotalRestartsLocal", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetFirstRestarts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetFirstRestarts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetFirstRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetFirstRestarts$descriptor() {
        return SCIPreoptGetFirstRestarts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetFirstRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetFirstRestarts$handle() {
        return SCIPreoptGetFirstRestarts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetFirstRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetFirstRestarts$address() {
        return SCIPreoptGetFirstRestarts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetFirstRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetFirstRestarts(MemorySegment reopt) {
        var mh$ = SCIPreoptGetFirstRestarts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetFirstRestarts", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetLastRestarts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetLastRestarts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetLastRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetLastRestarts$descriptor() {
        return SCIPreoptGetLastRestarts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetLastRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetLastRestarts$handle() {
        return SCIPreoptGetLastRestarts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetLastRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetLastRestarts$address() {
        return SCIPreoptGetLastRestarts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetLastRestarts(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetLastRestarts(MemorySegment reopt) {
        var mh$ = SCIPreoptGetLastRestarts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetLastRestarts", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNFeasNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNFeasNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNFeasNodes$descriptor() {
        return SCIPreoptGetNFeasNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNFeasNodes$handle() {
        return SCIPreoptGetNFeasNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNFeasNodes$address() {
        return SCIPreoptGetNFeasNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNFeasNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNFeasNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNFeasNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNTotalFeasNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNTotalFeasNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNTotalFeasNodes$descriptor() {
        return SCIPreoptGetNTotalFeasNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNTotalFeasNodes$handle() {
        return SCIPreoptGetNTotalFeasNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNTotalFeasNodes$address() {
        return SCIPreoptGetNTotalFeasNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalFeasNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNTotalFeasNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNTotalFeasNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNTotalFeasNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNPrunedNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNPrunedNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNPrunedNodes$descriptor() {
        return SCIPreoptGetNPrunedNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNPrunedNodes$handle() {
        return SCIPreoptGetNPrunedNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNPrunedNodes$address() {
        return SCIPreoptGetNPrunedNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNPrunedNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNPrunedNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNPrunedNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNTotalPrunedNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNTotalPrunedNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNTotalPrunedNodes$descriptor() {
        return SCIPreoptGetNTotalPrunedNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNTotalPrunedNodes$handle() {
        return SCIPreoptGetNTotalPrunedNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNTotalPrunedNodes$address() {
        return SCIPreoptGetNTotalPrunedNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalPrunedNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNTotalPrunedNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNTotalPrunedNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNTotalPrunedNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNCutoffReoptnodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNCutoffReoptnodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNCutoffReoptnodes$descriptor() {
        return SCIPreoptGetNCutoffReoptnodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNCutoffReoptnodes$handle() {
        return SCIPreoptGetNCutoffReoptnodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNCutoffReoptnodes$address() {
        return SCIPreoptGetNCutoffReoptnodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNCutoffReoptnodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNCutoffReoptnodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNCutoffReoptnodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNTotalCutoffReoptnodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNTotalCutoffReoptnodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNTotalCutoffReoptnodes$descriptor() {
        return SCIPreoptGetNTotalCutoffReoptnodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNTotalCutoffReoptnodes$handle() {
        return SCIPreoptGetNTotalCutoffReoptnodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNTotalCutoffReoptnodes$address() {
        return SCIPreoptGetNTotalCutoffReoptnodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalCutoffReoptnodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNTotalCutoffReoptnodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNTotalCutoffReoptnodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNTotalCutoffReoptnodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNInfNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNInfNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNInfNodes$descriptor() {
        return SCIPreoptGetNInfNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNInfNodes$handle() {
        return SCIPreoptGetNInfNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNInfNodes$address() {
        return SCIPreoptGetNInfNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNInfNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNInfNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNInfNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptGetNTotalInfNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptGetNTotalInfNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static FunctionDescriptor SCIPreoptGetNTotalInfNodes$descriptor() {
        return SCIPreoptGetNTotalInfNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MethodHandle SCIPreoptGetNTotalInfNodes$handle() {
        return SCIPreoptGetNTotalInfNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static MemorySegment SCIPreoptGetNTotalInfNodes$address() {
        return SCIPreoptGetNTotalInfNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptGetNTotalInfNodes(SCIP_REOPT *reopt)
     * }
     */
    public static int SCIPreoptGetNTotalInfNodes(MemorySegment reopt) {
        var mh$ = SCIPreoptGetNTotalInfNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptGetNTotalInfNodes", reopt);
            }
            return (int)mh$.invokeExact(reopt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsepaComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPsepaComp$descriptor() {
        return SCIPsepaComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsepaComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPsepaComp$handle() {
        return SCIPsepaComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsepaComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPsepaComp$address() {
        return SCIPsepaComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsepaComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPsepaComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPsepaComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsepaCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPsepaCompName$descriptor() {
        return SCIPsepaCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsepaCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPsepaCompName$handle() {
        return SCIPsepaCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsepaCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPsepaCompName$address() {
        return SCIPsepaCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsepaCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPsepaCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPsepaCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SEPADATA *SCIPsepaGetData(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetData$descriptor() {
        return SCIPsepaGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SEPADATA *SCIPsepaGetData(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetData$handle() {
        return SCIPsepaGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SEPADATA *SCIPsepaGetData(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetData$address() {
        return SCIPsepaGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SEPADATA *SCIPsepaGetData(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetData(MemorySegment sepa) {
        var mh$ = SCIPsepaGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetData", sepa);
            }
            return (MemorySegment)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsepaSetData(SCIP_SEPA *sepa, SCIP_SEPADATA *sepadata)
     * }
     */
    public static FunctionDescriptor SCIPsepaSetData$descriptor() {
        return SCIPsepaSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsepaSetData(SCIP_SEPA *sepa, SCIP_SEPADATA *sepadata)
     * }
     */
    public static MethodHandle SCIPsepaSetData$handle() {
        return SCIPsepaSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsepaSetData(SCIP_SEPA *sepa, SCIP_SEPADATA *sepadata)
     * }
     */
    public static MemorySegment SCIPsepaSetData$address() {
        return SCIPsepaSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsepaSetData(SCIP_SEPA *sepa, SCIP_SEPADATA *sepadata)
     * }
     */
    public static void SCIPsepaSetData(MemorySegment sepa, MemorySegment sepadata) {
        var mh$ = SCIPsepaSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaSetData", sepa, sepadata);
            }
            mh$.invokeExact(sepa, sepadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetName(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetName$descriptor() {
        return SCIPsepaGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetName(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetName$handle() {
        return SCIPsepaGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetName(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetName$address() {
        return SCIPsepaGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPsepaGetName(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetName(MemorySegment sepa) {
        var mh$ = SCIPsepaGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetName", sepa);
            }
            return (MemorySegment)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetDesc(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetDesc$descriptor() {
        return SCIPsepaGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetDesc(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetDesc$handle() {
        return SCIPsepaGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPsepaGetDesc(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetDesc$address() {
        return SCIPsepaGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPsepaGetDesc(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetDesc(MemorySegment sepa) {
        var mh$ = SCIPsepaGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetDesc", sepa);
            }
            return (MemorySegment)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsepaGetPriority(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetPriority$descriptor() {
        return SCIPsepaGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsepaGetPriority(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetPriority$handle() {
        return SCIPsepaGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsepaGetPriority(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetPriority$address() {
        return SCIPsepaGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsepaGetPriority(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaGetPriority(MemorySegment sepa) {
        var mh$ = SCIPsepaGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetPriority", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsepaGetFreq(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetFreq$descriptor() {
        return SCIPsepaGetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsepaGetFreq(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetFreq$handle() {
        return SCIPsepaGetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsepaGetFreq(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetFreq$address() {
        return SCIPsepaGetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsepaGetFreq(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaGetFreq(MemorySegment sepa) {
        var mh$ = SCIPsepaGetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetFreq", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaSetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaSetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsepaSetFreq(SCIP_SEPA *sepa, int freq)
     * }
     */
    public static FunctionDescriptor SCIPsepaSetFreq$descriptor() {
        return SCIPsepaSetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsepaSetFreq(SCIP_SEPA *sepa, int freq)
     * }
     */
    public static MethodHandle SCIPsepaSetFreq$handle() {
        return SCIPsepaSetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsepaSetFreq(SCIP_SEPA *sepa, int freq)
     * }
     */
    public static MemorySegment SCIPsepaSetFreq$address() {
        return SCIPsepaSetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsepaSetFreq(SCIP_SEPA *sepa, int freq)
     * }
     */
    public static void SCIPsepaSetFreq(MemorySegment sepa, int freq) {
        var mh$ = SCIPsepaSetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaSetFreq", sepa, freq);
            }
            mh$.invokeExact(sepa, freq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetMaxbounddist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetMaxbounddist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsepaGetMaxbounddist(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetMaxbounddist$descriptor() {
        return SCIPsepaGetMaxbounddist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsepaGetMaxbounddist(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetMaxbounddist$handle() {
        return SCIPsepaGetMaxbounddist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsepaGetMaxbounddist(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetMaxbounddist$address() {
        return SCIPsepaGetMaxbounddist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsepaGetMaxbounddist(SCIP_SEPA *sepa)
     * }
     */
    public static double SCIPsepaGetMaxbounddist(MemorySegment sepa) {
        var mh$ = SCIPsepaGetMaxbounddist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetMaxbounddist", sepa);
            }
            return (double)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaUsesSubscip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaUsesSubscip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaUsesSubscip(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaUsesSubscip$descriptor() {
        return SCIPsepaUsesSubscip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaUsesSubscip(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaUsesSubscip$handle() {
        return SCIPsepaUsesSubscip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaUsesSubscip(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaUsesSubscip$address() {
        return SCIPsepaUsesSubscip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaUsesSubscip(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaUsesSubscip(MemorySegment sepa) {
        var mh$ = SCIPsepaUsesSubscip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaUsesSubscip", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsepaGetSetupTime(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetSetupTime$descriptor() {
        return SCIPsepaGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsepaGetSetupTime(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetSetupTime$handle() {
        return SCIPsepaGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsepaGetSetupTime(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetSetupTime$address() {
        return SCIPsepaGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsepaGetSetupTime(SCIP_SEPA *sepa)
     * }
     */
    public static double SCIPsepaGetSetupTime(MemorySegment sepa) {
        var mh$ = SCIPsepaGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetSetupTime", sepa);
            }
            return (double)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsepaGetTime(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetTime$descriptor() {
        return SCIPsepaGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsepaGetTime(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetTime$handle() {
        return SCIPsepaGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsepaGetTime(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetTime$address() {
        return SCIPsepaGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsepaGetTime(SCIP_SEPA *sepa)
     * }
     */
    public static double SCIPsepaGetTime(MemorySegment sepa) {
        var mh$ = SCIPsepaGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetTime", sepa);
            }
            return (double)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCalls(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCalls$descriptor() {
        return SCIPsepaGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCalls(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCalls$handle() {
        return SCIPsepaGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCalls(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCalls$address() {
        return SCIPsepaGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCalls(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCalls(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCalls", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNRootCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNRootCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNRootCalls(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNRootCalls$descriptor() {
        return SCIPsepaGetNRootCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNRootCalls(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNRootCalls$handle() {
        return SCIPsepaGetNRootCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNRootCalls(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNRootCalls$address() {
        return SCIPsepaGetNRootCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNRootCalls(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNRootCalls(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNRootCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNRootCalls", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCallsAtNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCallsAtNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsepaGetNCallsAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCallsAtNode$descriptor() {
        return SCIPsepaGetNCallsAtNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsepaGetNCallsAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCallsAtNode$handle() {
        return SCIPsepaGetNCallsAtNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsepaGetNCallsAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCallsAtNode$address() {
        return SCIPsepaGetNCallsAtNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsepaGetNCallsAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaGetNCallsAtNode(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCallsAtNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCallsAtNode", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutoffs(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutoffs$descriptor() {
        return SCIPsepaGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutoffs(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutoffs$handle() {
        return SCIPsepaGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutoffs(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutoffs$address() {
        return SCIPsepaGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutoffs(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutoffs(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutoffs", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFound(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsFound$descriptor() {
        return SCIPsepaGetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFound(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsFound$handle() {
        return SCIPsepaGetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFound(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsFound$address() {
        return SCIPsepaGetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFound(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsFound(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsFound", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsAdded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsAdded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAdded(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsAdded$descriptor() {
        return SCIPsepaGetNCutsAdded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAdded(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsAdded$handle() {
        return SCIPsepaGetNCutsAdded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAdded(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsAdded$address() {
        return SCIPsepaGetNCutsAdded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAdded(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsAdded(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsAdded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsAdded", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsAddedViaPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsAddedViaPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsAddedViaPool$descriptor() {
        return SCIPsepaGetNCutsAddedViaPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsAddedViaPool$handle() {
        return SCIPsepaGetNCutsAddedViaPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsAddedViaPool$address() {
        return SCIPsepaGetNCutsAddedViaPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsAddedViaPool(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsAddedViaPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsAddedViaPool", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsAddedDirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsAddedDirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsAddedDirect$descriptor() {
        return SCIPsepaGetNCutsAddedDirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsAddedDirect$handle() {
        return SCIPsepaGetNCutsAddedDirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsAddedDirect$address() {
        return SCIPsepaGetNCutsAddedDirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAddedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsAddedDirect(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsAddedDirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsAddedDirect", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsApplied(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsApplied$descriptor() {
        return SCIPsepaGetNCutsApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsApplied(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsApplied$handle() {
        return SCIPsepaGetNCutsApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsApplied(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsApplied$address() {
        return SCIPsepaGetNCutsApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsApplied(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsApplied(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsApplied", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsAppliedViaPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsAppliedViaPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsAppliedViaPool$descriptor() {
        return SCIPsepaGetNCutsAppliedViaPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsAppliedViaPool$handle() {
        return SCIPsepaGetNCutsAppliedViaPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsAppliedViaPool$address() {
        return SCIPsepaGetNCutsAppliedViaPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedViaPool(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsAppliedViaPool(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsAppliedViaPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsAppliedViaPool", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsAppliedDirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsAppliedDirect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsAppliedDirect$descriptor() {
        return SCIPsepaGetNCutsAppliedDirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsAppliedDirect$handle() {
        return SCIPsepaGetNCutsAppliedDirect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsAppliedDirect$address() {
        return SCIPsepaGetNCutsAppliedDirect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsAppliedDirect(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsAppliedDirect(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsAppliedDirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsAppliedDirect", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNCutsFoundAtNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNCutsFoundAtNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFoundAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNCutsFoundAtNode$descriptor() {
        return SCIPsepaGetNCutsFoundAtNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFoundAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNCutsFoundAtNode$handle() {
        return SCIPsepaGetNCutsFoundAtNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFoundAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNCutsFoundAtNode$address() {
        return SCIPsepaGetNCutsFoundAtNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNCutsFoundAtNode(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNCutsFoundAtNode(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNCutsFoundAtNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNCutsFoundAtNode", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNConssFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNConssFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNConssFound(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNConssFound$descriptor() {
        return SCIPsepaGetNConssFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNConssFound(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNConssFound$handle() {
        return SCIPsepaGetNConssFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNConssFound(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNConssFound$address() {
        return SCIPsepaGetNConssFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNConssFound(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNConssFound(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNConssFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNConssFound", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetNDomredsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetNDomredsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNDomredsFound(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetNDomredsFound$descriptor() {
        return SCIPsepaGetNDomredsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNDomredsFound(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetNDomredsFound$handle() {
        return SCIPsepaGetNDomredsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsepaGetNDomredsFound(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetNDomredsFound$address() {
        return SCIPsepaGetNDomredsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsepaGetNDomredsFound(SCIP_SEPA *sepa)
     * }
     */
    public static long SCIPsepaGetNDomredsFound(MemorySegment sepa) {
        var mh$ = SCIPsepaGetNDomredsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetNDomredsFound", sepa);
            }
            return (long)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaIsDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaIsDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaIsDelayed$descriptor() {
        return SCIPsepaIsDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaIsDelayed$handle() {
        return SCIPsepaIsDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaIsDelayed$address() {
        return SCIPsepaIsDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaIsDelayed(MemorySegment sepa) {
        var mh$ = SCIPsepaIsDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaIsDelayed", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaWasLPDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaWasLPDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasLPDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaWasLPDelayed$descriptor() {
        return SCIPsepaWasLPDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasLPDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaWasLPDelayed$handle() {
        return SCIPsepaWasLPDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasLPDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaWasLPDelayed$address() {
        return SCIPsepaWasLPDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasLPDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaWasLPDelayed(MemorySegment sepa) {
        var mh$ = SCIPsepaWasLPDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaWasLPDelayed", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaWasSolDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaWasSolDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasSolDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaWasSolDelayed$descriptor() {
        return SCIPsepaWasSolDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasSolDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaWasSolDelayed$handle() {
        return SCIPsepaWasSolDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasSolDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaWasSolDelayed$address() {
        return SCIPsepaWasSolDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaWasSolDelayed(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaWasSolDelayed(MemorySegment sepa) {
        var mh$ = SCIPsepaWasSolDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaWasSolDelayed", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsInitialized(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaIsInitialized$descriptor() {
        return SCIPsepaIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsInitialized(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaIsInitialized$handle() {
        return SCIPsepaIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsInitialized(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaIsInitialized$address() {
        return SCIPsepaIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsInitialized(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaIsInitialized(MemorySegment sepa) {
        var mh$ = SCIPsepaIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaIsInitialized", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaIsParentsepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaIsParentsepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaIsParentsepa$descriptor() {
        return SCIPsepaIsParentsepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaIsParentsepa$handle() {
        return SCIPsepaIsParentsepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaIsParentsepa$address() {
        return SCIPsepaIsParentsepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsepaIsParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static int SCIPsepaIsParentsepa(MemorySegment sepa) {
        var mh$ = SCIPsepaIsParentsepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaIsParentsepa", sepa);
            }
            return (int)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepaGetParentsepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepaGetParentsepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPsepaGetParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsepaGetParentsepa$descriptor() {
        return SCIPsepaGetParentsepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPsepaGetParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsepaGetParentsepa$handle() {
        return SCIPsepaGetParentsepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPsepaGetParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetParentsepa$address() {
        return SCIPsepaGetParentsepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPsepaGetParentsepa(SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsepaGetParentsepa(MemorySegment sepa) {
        var mh$ = SCIPsepaGetParentsepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepaGetParentsepa", sepa);
            }
            return (MemorySegment)mh$.invokeExact(sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetName(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetName$descriptor() {
        return SCIPcutselGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetName(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetName$handle() {
        return SCIPcutselGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetName(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetName$address() {
        return SCIPcutselGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcutselGetName(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetName(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetName", cutsel);
            }
            return (MemorySegment)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUTSELDATA *SCIPcutselGetData(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetData$descriptor() {
        return SCIPcutselGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUTSELDATA *SCIPcutselGetData(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetData$handle() {
        return SCIPcutselGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUTSELDATA *SCIPcutselGetData(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetData$address() {
        return SCIPcutselGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUTSELDATA *SCIPcutselGetData(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetData(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetData", cutsel);
            }
            return (MemorySegment)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetDesc(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetDesc$descriptor() {
        return SCIPcutselGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetDesc(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetDesc$handle() {
        return SCIPcutselGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcutselGetDesc(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetDesc$address() {
        return SCIPcutselGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcutselGetDesc(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetDesc(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetDesc", cutsel);
            }
            return (MemorySegment)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcutselGetPriority(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetPriority$descriptor() {
        return SCIPcutselGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcutselGetPriority(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetPriority$handle() {
        return SCIPcutselGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcutselGetPriority(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetPriority$address() {
        return SCIPcutselGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcutselGetPriority(SCIP_CUTSEL *cutsel)
     * }
     */
    public static int SCIPcutselGetPriority(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetPriority", cutsel);
            }
            return (int)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcutselSetData(SCIP_CUTSEL *cutsel, SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static FunctionDescriptor SCIPcutselSetData$descriptor() {
        return SCIPcutselSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcutselSetData(SCIP_CUTSEL *cutsel, SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MethodHandle SCIPcutselSetData$handle() {
        return SCIPcutselSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcutselSetData(SCIP_CUTSEL *cutsel, SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MemorySegment SCIPcutselSetData$address() {
        return SCIPcutselSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcutselSetData(SCIP_CUTSEL *cutsel, SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static void SCIPcutselSetData(MemorySegment cutsel, MemorySegment cutseldata) {
        var mh$ = SCIPcutselSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselSetData", cutsel, cutseldata);
            }
            mh$.invokeExact(cutsel, cutseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcutselIsInitialized(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselIsInitialized$descriptor() {
        return SCIPcutselIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcutselIsInitialized(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselIsInitialized$handle() {
        return SCIPcutselIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcutselIsInitialized(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselIsInitialized$address() {
        return SCIPcutselIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcutselIsInitialized(SCIP_CUTSEL *cutsel)
     * }
     */
    public static int SCIPcutselIsInitialized(MemorySegment cutsel) {
        var mh$ = SCIPcutselIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselIsInitialized", cutsel);
            }
            return (int)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcutselGetSetupTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetSetupTime$descriptor() {
        return SCIPcutselGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcutselGetSetupTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetSetupTime$handle() {
        return SCIPcutselGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcutselGetSetupTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetSetupTime$address() {
        return SCIPcutselGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcutselGetSetupTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static double SCIPcutselGetSetupTime(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetSetupTime", cutsel);
            }
            return (double)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcutselGetTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetTime$descriptor() {
        return SCIPcutselGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcutselGetTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetTime$handle() {
        return SCIPcutselGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcutselGetTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetTime$address() {
        return SCIPcutselGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcutselGetTime(SCIP_CUTSEL *cutsel)
     * }
     */
    public static double SCIPcutselGetTime(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetTime", cutsel);
            }
            return (double)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNCalls$descriptor() {
        return SCIPcutselGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNCalls$handle() {
        return SCIPcutselGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNCalls$address() {
        return SCIPcutselGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNCalls(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNCalls", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNRootCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNRootCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNRootCalls$descriptor() {
        return SCIPcutselGetNRootCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNRootCalls$handle() {
        return SCIPcutselGetNRootCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNRootCalls$address() {
        return SCIPcutselGetNRootCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCalls(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNRootCalls(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNRootCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNRootCalls", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNRootCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNRootCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNRootCuts$descriptor() {
        return SCIPcutselGetNRootCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNRootCuts$handle() {
        return SCIPcutselGetNRootCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNRootCuts$address() {
        return SCIPcutselGetNRootCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNRootCuts(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNRootCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNRootCuts", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNRootForcedCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNRootForcedCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNRootForcedCuts$descriptor() {
        return SCIPcutselGetNRootForcedCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNRootForcedCuts$handle() {
        return SCIPcutselGetNRootForcedCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNRootForcedCuts$address() {
        return SCIPcutselGetNRootForcedCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNRootForcedCuts(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNRootForcedCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNRootForcedCuts", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNRootCutsFiltered {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNRootCutsFiltered");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNRootCutsFiltered$descriptor() {
        return SCIPcutselGetNRootCutsFiltered.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNRootCutsFiltered$handle() {
        return SCIPcutselGetNRootCutsFiltered.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNRootCutsFiltered$address() {
        return SCIPcutselGetNRootCutsFiltered.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNRootCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNRootCutsFiltered(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNRootCutsFiltered.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNRootCutsFiltered", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNLocalCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNLocalCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNLocalCuts$descriptor() {
        return SCIPcutselGetNLocalCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNLocalCuts$handle() {
        return SCIPcutselGetNLocalCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNLocalCuts$address() {
        return SCIPcutselGetNLocalCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNLocalCuts(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNLocalCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNLocalCuts", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNLocalForcedCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNLocalForcedCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNLocalForcedCuts$descriptor() {
        return SCIPcutselGetNLocalForcedCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNLocalForcedCuts$handle() {
        return SCIPcutselGetNLocalForcedCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNLocalForcedCuts$address() {
        return SCIPcutselGetNLocalForcedCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalForcedCuts(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNLocalForcedCuts(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNLocalForcedCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNLocalForcedCuts", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselGetNLocalCutsFiltered {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselGetNLocalCutsFiltered");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static FunctionDescriptor SCIPcutselGetNLocalCutsFiltered$descriptor() {
        return SCIPcutselGetNLocalCutsFiltered.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MethodHandle SCIPcutselGetNLocalCutsFiltered$handle() {
        return SCIPcutselGetNLocalCutsFiltered.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static MemorySegment SCIPcutselGetNLocalCutsFiltered$address() {
        return SCIPcutselGetNLocalCutsFiltered.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPcutselGetNLocalCutsFiltered(SCIP_CUTSEL *cutsel)
     * }
     */
    public static long SCIPcutselGetNLocalCutsFiltered(MemorySegment cutsel) {
        var mh$ = SCIPcutselGetNLocalCutsFiltered.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselGetNLocalCutsFiltered", cutsel);
            }
            return (long)mh$.invokeExact(cutsel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutselComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutselComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcutselComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPcutselComp$descriptor() {
        return SCIPcutselComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcutselComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPcutselComp$handle() {
        return SCIPcutselComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcutselComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPcutselComp$address() {
        return SCIPcutselComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcutselComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPcutselComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPcutselComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutselComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpropComp$descriptor() {
        return SCIPpropComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpropComp$handle() {
        return SCIPpropComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpropComp$address() {
        return SCIPpropComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpropComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpropComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropCompPresol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropCompPresol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropCompPresol(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpropCompPresol$descriptor() {
        return SCIPpropCompPresol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropCompPresol(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpropCompPresol$handle() {
        return SCIPpropCompPresol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropCompPresol(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpropCompPresol$address() {
        return SCIPpropCompPresol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropCompPresol(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpropCompPresol(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpropCompPresol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropCompPresol", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropCompName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropCompName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropCompName(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPpropCompName$descriptor() {
        return SCIPpropCompName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropCompName(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPpropCompName$handle() {
        return SCIPpropCompName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropCompName(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPpropCompName$address() {
        return SCIPpropCompName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropCompName(void *elem1, void *elem2)
     * }
     */
    public static int SCIPpropCompName(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPpropCompName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropCompName", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROPDATA *SCIPpropGetData(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetData$descriptor() {
        return SCIPpropGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROPDATA *SCIPpropGetData(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetData$handle() {
        return SCIPpropGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROPDATA *SCIPpropGetData(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetData$address() {
        return SCIPpropGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROPDATA *SCIPpropGetData(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetData(MemorySegment prop) {
        var mh$ = SCIPpropGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetData", prop);
            }
            return (MemorySegment)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpropSetData(SCIP_PROP *prop, SCIP_PROPDATA *propdata)
     * }
     */
    public static FunctionDescriptor SCIPpropSetData$descriptor() {
        return SCIPpropSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpropSetData(SCIP_PROP *prop, SCIP_PROPDATA *propdata)
     * }
     */
    public static MethodHandle SCIPpropSetData$handle() {
        return SCIPpropSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpropSetData(SCIP_PROP *prop, SCIP_PROPDATA *propdata)
     * }
     */
    public static MemorySegment SCIPpropSetData$address() {
        return SCIPpropSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpropSetData(SCIP_PROP *prop, SCIP_PROPDATA *propdata)
     * }
     */
    public static void SCIPpropSetData(MemorySegment prop, MemorySegment propdata) {
        var mh$ = SCIPpropSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropSetData", prop, propdata);
            }
            mh$.invokeExact(prop, propdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpropGetName(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetName$descriptor() {
        return SCIPpropGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpropGetName(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetName$handle() {
        return SCIPpropGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpropGetName(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetName$address() {
        return SCIPpropGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpropGetName(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetName(MemorySegment prop) {
        var mh$ = SCIPpropGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetName", prop);
            }
            return (MemorySegment)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPpropGetDesc(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetDesc$descriptor() {
        return SCIPpropGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPpropGetDesc(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetDesc$handle() {
        return SCIPpropGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPpropGetDesc(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetDesc$address() {
        return SCIPpropGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPpropGetDesc(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetDesc(MemorySegment prop) {
        var mh$ = SCIPpropGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetDesc", prop);
            }
            return (MemorySegment)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetPriority(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetPriority$descriptor() {
        return SCIPpropGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetPriority(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetPriority$handle() {
        return SCIPpropGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetPriority(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetPriority$address() {
        return SCIPpropGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetPriority(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetPriority(MemorySegment prop) {
        var mh$ = SCIPpropGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetPriority", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetPresolPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetPresolPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetPresolPriority(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetPresolPriority$descriptor() {
        return SCIPpropGetPresolPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetPresolPriority(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetPresolPriority$handle() {
        return SCIPpropGetPresolPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetPresolPriority(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetPresolPriority$address() {
        return SCIPpropGetPresolPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetPresolPriority(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetPresolPriority(MemorySegment prop) {
        var mh$ = SCIPpropGetPresolPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetPresolPriority", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetFreq(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetFreq$descriptor() {
        return SCIPpropGetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetFreq(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetFreq$handle() {
        return SCIPpropGetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetFreq(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetFreq$address() {
        return SCIPpropGetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetFreq(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetFreq(MemorySegment prop) {
        var mh$ = SCIPpropGetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetFreq", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetSetupTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetSetupTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpropGetSetupTime(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetSetupTime$descriptor() {
        return SCIPpropGetSetupTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpropGetSetupTime(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetSetupTime$handle() {
        return SCIPpropGetSetupTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpropGetSetupTime(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetSetupTime$address() {
        return SCIPpropGetSetupTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpropGetSetupTime(SCIP_PROP *prop)
     * }
     */
    public static double SCIPpropGetSetupTime(MemorySegment prop) {
        var mh$ = SCIPpropGetSetupTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetSetupTime", prop);
            }
            return (double)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropSetFreq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropSetFreq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpropSetFreq(SCIP_PROP *prop, int freq)
     * }
     */
    public static FunctionDescriptor SCIPpropSetFreq$descriptor() {
        return SCIPpropSetFreq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpropSetFreq(SCIP_PROP *prop, int freq)
     * }
     */
    public static MethodHandle SCIPpropSetFreq$handle() {
        return SCIPpropSetFreq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpropSetFreq(SCIP_PROP *prop, int freq)
     * }
     */
    public static MemorySegment SCIPpropSetFreq$address() {
        return SCIPpropSetFreq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpropSetFreq(SCIP_PROP *prop, int freq)
     * }
     */
    public static void SCIPpropSetFreq(MemorySegment prop, int freq) {
        var mh$ = SCIPpropSetFreq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropSetFreq", prop, freq);
            }
            mh$.invokeExact(prop, freq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpropGetTime(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetTime$descriptor() {
        return SCIPpropGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpropGetTime(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetTime$handle() {
        return SCIPpropGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpropGetTime(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetTime$address() {
        return SCIPpropGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpropGetTime(SCIP_PROP *prop)
     * }
     */
    public static double SCIPpropGetTime(MemorySegment prop) {
        var mh$ = SCIPpropGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetTime", prop);
            }
            return (double)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetStrongBranchPropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetStrongBranchPropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpropGetStrongBranchPropTime(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetStrongBranchPropTime$descriptor() {
        return SCIPpropGetStrongBranchPropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpropGetStrongBranchPropTime(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetStrongBranchPropTime$handle() {
        return SCIPpropGetStrongBranchPropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpropGetStrongBranchPropTime(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetStrongBranchPropTime$address() {
        return SCIPpropGetStrongBranchPropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpropGetStrongBranchPropTime(SCIP_PROP *prop)
     * }
     */
    public static double SCIPpropGetStrongBranchPropTime(MemorySegment prop) {
        var mh$ = SCIPpropGetStrongBranchPropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetStrongBranchPropTime", prop);
            }
            return (double)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetRespropTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetRespropTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpropGetRespropTime(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetRespropTime$descriptor() {
        return SCIPpropGetRespropTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpropGetRespropTime(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetRespropTime$handle() {
        return SCIPpropGetRespropTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpropGetRespropTime(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetRespropTime$address() {
        return SCIPpropGetRespropTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpropGetRespropTime(SCIP_PROP *prop)
     * }
     */
    public static double SCIPpropGetRespropTime(MemorySegment prop) {
        var mh$ = SCIPpropGetRespropTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetRespropTime", prop);
            }
            return (double)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetPresolTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetPresolTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPpropGetPresolTime(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetPresolTime$descriptor() {
        return SCIPpropGetPresolTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPpropGetPresolTime(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetPresolTime$handle() {
        return SCIPpropGetPresolTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPpropGetPresolTime(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetPresolTime$address() {
        return SCIPpropGetPresolTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPpropGetPresolTime(SCIP_PROP *prop)
     * }
     */
    public static double SCIPpropGetPresolTime(MemorySegment prop) {
        var mh$ = SCIPpropGetPresolTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetPresolTime", prop);
            }
            return (double)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCalls(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNCalls$descriptor() {
        return SCIPpropGetNCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCalls(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNCalls$handle() {
        return SCIPpropGetNCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCalls(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNCalls$address() {
        return SCIPpropGetNCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPpropGetNCalls(SCIP_PROP *prop)
     * }
     */
    public static long SCIPpropGetNCalls(MemorySegment prop) {
        var mh$ = SCIPpropGetNCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNCalls", prop);
            }
            return (long)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNRespropCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNRespropCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPpropGetNRespropCalls(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNRespropCalls$descriptor() {
        return SCIPpropGetNRespropCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPpropGetNRespropCalls(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNRespropCalls$handle() {
        return SCIPpropGetNRespropCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPpropGetNRespropCalls(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNRespropCalls$address() {
        return SCIPpropGetNRespropCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPpropGetNRespropCalls(SCIP_PROP *prop)
     * }
     */
    public static long SCIPpropGetNRespropCalls(MemorySegment prop) {
        var mh$ = SCIPpropGetNRespropCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNRespropCalls", prop);
            }
            return (long)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCutoffs(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNCutoffs$descriptor() {
        return SCIPpropGetNCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCutoffs(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNCutoffs$handle() {
        return SCIPpropGetNCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPpropGetNCutoffs(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNCutoffs$address() {
        return SCIPpropGetNCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPpropGetNCutoffs(SCIP_PROP *prop)
     * }
     */
    public static long SCIPpropGetNCutoffs(MemorySegment prop) {
        var mh$ = SCIPpropGetNCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNCutoffs", prop);
            }
            return (long)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNDomredsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNDomredsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPpropGetNDomredsFound(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNDomredsFound$descriptor() {
        return SCIPpropGetNDomredsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPpropGetNDomredsFound(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNDomredsFound$handle() {
        return SCIPpropGetNDomredsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPpropGetNDomredsFound(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNDomredsFound$address() {
        return SCIPpropGetNDomredsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPpropGetNDomredsFound(SCIP_PROP *prop)
     * }
     */
    public static long SCIPpropGetNDomredsFound(MemorySegment prop) {
        var mh$ = SCIPpropGetNDomredsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNDomredsFound", prop);
            }
            return (long)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropIsDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropIsDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsDelayed(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropIsDelayed$descriptor() {
        return SCIPpropIsDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsDelayed(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropIsDelayed$handle() {
        return SCIPpropIsDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsDelayed(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropIsDelayed$address() {
        return SCIPpropIsDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpropIsDelayed(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropIsDelayed(MemorySegment prop) {
        var mh$ = SCIPpropIsDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropIsDelayed", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropWasDelayed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropWasDelayed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpropWasDelayed(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropWasDelayed$descriptor() {
        return SCIPpropWasDelayed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpropWasDelayed(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropWasDelayed$handle() {
        return SCIPpropWasDelayed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpropWasDelayed(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropWasDelayed$address() {
        return SCIPpropWasDelayed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpropWasDelayed(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropWasDelayed(MemorySegment prop) {
        var mh$ = SCIPpropWasDelayed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropWasDelayed", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsInitialized(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropIsInitialized$descriptor() {
        return SCIPpropIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsInitialized(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropIsInitialized$handle() {
        return SCIPpropIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpropIsInitialized(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropIsInitialized$address() {
        return SCIPpropIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpropIsInitialized(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropIsInitialized(MemorySegment prop) {
        var mh$ = SCIPpropIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropIsInitialized", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNFixedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNFixedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNFixedVars(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNFixedVars$descriptor() {
        return SCIPpropGetNFixedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNFixedVars(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNFixedVars$handle() {
        return SCIPpropGetNFixedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNFixedVars(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNFixedVars$address() {
        return SCIPpropGetNFixedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNFixedVars(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNFixedVars(MemorySegment prop) {
        var mh$ = SCIPpropGetNFixedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNFixedVars", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNAggrVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNAggrVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNAggrVars(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNAggrVars$descriptor() {
        return SCIPpropGetNAggrVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNAggrVars(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNAggrVars$handle() {
        return SCIPpropGetNAggrVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNAggrVars(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNAggrVars$address() {
        return SCIPpropGetNAggrVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNAggrVars(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNAggrVars(MemorySegment prop) {
        var mh$ = SCIPpropGetNAggrVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNAggrVars", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNChgVarTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNChgVarTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgVarTypes(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNChgVarTypes$descriptor() {
        return SCIPpropGetNChgVarTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgVarTypes(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNChgVarTypes$handle() {
        return SCIPpropGetNChgVarTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgVarTypes(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNChgVarTypes$address() {
        return SCIPpropGetNChgVarTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNChgVarTypes(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNChgVarTypes(MemorySegment prop) {
        var mh$ = SCIPpropGetNChgVarTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNChgVarTypes", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNChgBds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNChgBds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgBds(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNChgBds$descriptor() {
        return SCIPpropGetNChgBds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgBds(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNChgBds$handle() {
        return SCIPpropGetNChgBds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgBds(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNChgBds$address() {
        return SCIPpropGetNChgBds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNChgBds(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNChgBds(MemorySegment prop) {
        var mh$ = SCIPpropGetNChgBds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNChgBds", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNAddHoles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNAddHoles");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddHoles(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNAddHoles$descriptor() {
        return SCIPpropGetNAddHoles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddHoles(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNAddHoles$handle() {
        return SCIPpropGetNAddHoles.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddHoles(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNAddHoles$address() {
        return SCIPpropGetNAddHoles.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNAddHoles(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNAddHoles(MemorySegment prop) {
        var mh$ = SCIPpropGetNAddHoles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNAddHoles", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNDelConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNDelConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNDelConss(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNDelConss$descriptor() {
        return SCIPpropGetNDelConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNDelConss(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNDelConss$handle() {
        return SCIPpropGetNDelConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNDelConss(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNDelConss$address() {
        return SCIPpropGetNDelConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNDelConss(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNDelConss(MemorySegment prop) {
        var mh$ = SCIPpropGetNDelConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNDelConss", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNAddConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNAddConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddConss(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNAddConss$descriptor() {
        return SCIPpropGetNAddConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddConss(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNAddConss$handle() {
        return SCIPpropGetNAddConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNAddConss(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNAddConss$address() {
        return SCIPpropGetNAddConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNAddConss(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNAddConss(MemorySegment prop) {
        var mh$ = SCIPpropGetNAddConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNAddConss", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNUpgdConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNUpgdConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNUpgdConss(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNUpgdConss$descriptor() {
        return SCIPpropGetNUpgdConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNUpgdConss(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNUpgdConss$handle() {
        return SCIPpropGetNUpgdConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNUpgdConss(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNUpgdConss$address() {
        return SCIPpropGetNUpgdConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNUpgdConss(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNUpgdConss(MemorySegment prop) {
        var mh$ = SCIPpropGetNUpgdConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNUpgdConss", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNChgCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNChgCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgCoefs(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNChgCoefs$descriptor() {
        return SCIPpropGetNChgCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgCoefs(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNChgCoefs$handle() {
        return SCIPpropGetNChgCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgCoefs(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNChgCoefs$address() {
        return SCIPpropGetNChgCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNChgCoefs(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNChgCoefs(MemorySegment prop) {
        var mh$ = SCIPpropGetNChgCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNChgCoefs", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNChgSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNChgSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgSides(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNChgSides$descriptor() {
        return SCIPpropGetNChgSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgSides(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNChgSides$handle() {
        return SCIPpropGetNChgSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNChgSides(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNChgSides$address() {
        return SCIPpropGetNChgSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNChgSides(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNChgSides(MemorySegment prop) {
        var mh$ = SCIPpropGetNChgSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNChgSides", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetNPresolCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetNPresolCalls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPpropGetNPresolCalls(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetNPresolCalls$descriptor() {
        return SCIPpropGetNPresolCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPpropGetNPresolCalls(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetNPresolCalls$handle() {
        return SCIPpropGetNPresolCalls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPpropGetNPresolCalls(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetNPresolCalls$address() {
        return SCIPpropGetNPresolCalls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPpropGetNPresolCalls(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetNPresolCalls(MemorySegment prop) {
        var mh$ = SCIPpropGetNPresolCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetNPresolCalls", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetTimingmask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetTimingmask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPpropGetTimingmask(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetTimingmask$descriptor() {
        return SCIPpropGetTimingmask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPpropGetTimingmask(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetTimingmask$handle() {
        return SCIPpropGetTimingmask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPpropGetTimingmask(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetTimingmask$address() {
        return SCIPpropGetTimingmask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROPTIMING SCIPpropGetTimingmask(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetTimingmask(MemorySegment prop) {
        var mh$ = SCIPpropGetTimingmask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetTimingmask", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropDoesPresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropDoesPresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpropDoesPresolve(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropDoesPresolve$descriptor() {
        return SCIPpropDoesPresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpropDoesPresolve(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropDoesPresolve$handle() {
        return SCIPpropDoesPresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpropDoesPresolve(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropDoesPresolve$address() {
        return SCIPpropDoesPresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpropDoesPresolve(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropDoesPresolve(MemorySegment prop) {
        var mh$ = SCIPpropDoesPresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropDoesPresolve", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropGetPresolTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropGetPresolTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpropGetPresolTiming(SCIP_PROP *prop)
     * }
     */
    public static FunctionDescriptor SCIPpropGetPresolTiming$descriptor() {
        return SCIPpropGetPresolTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpropGetPresolTiming(SCIP_PROP *prop)
     * }
     */
    public static MethodHandle SCIPpropGetPresolTiming$handle() {
        return SCIPpropGetPresolTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpropGetPresolTiming(SCIP_PROP *prop)
     * }
     */
    public static MemorySegment SCIPpropGetPresolTiming$address() {
        return SCIPpropGetPresolTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOLTIMING SCIPpropGetPresolTiming(SCIP_PROP *prop)
     * }
     */
    public static int SCIPpropGetPresolTiming(MemorySegment prop) {
        var mh$ = SCIPpropGetPresolTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropGetPresolTiming", prop);
            }
            return (int)mh$.invokeExact(prop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropSetPresolTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropSetPresolTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPpropSetPresolTiming(SCIP_PROP *prop, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static FunctionDescriptor SCIPpropSetPresolTiming$descriptor() {
        return SCIPpropSetPresolTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPpropSetPresolTiming(SCIP_PROP *prop, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MethodHandle SCIPpropSetPresolTiming$handle() {
        return SCIPpropSetPresolTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPpropSetPresolTiming(SCIP_PROP *prop, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MemorySegment SCIPpropSetPresolTiming$address() {
        return SCIPpropSetPresolTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPpropSetPresolTiming(SCIP_PROP *prop, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static void SCIPpropSetPresolTiming(MemorySegment prop, int presoltiming) {
        var mh$ = SCIPpropSetPresolTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropSetPresolTiming", prop, presoltiming);
            }
            mh$.invokeExact(prop, presoltiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetOrigin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetOrigin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOLORIGIN SCIPsolGetOrigin(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetOrigin$descriptor() {
        return SCIPsolGetOrigin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOLORIGIN SCIPsolGetOrigin(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetOrigin$handle() {
        return SCIPsolGetOrigin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOLORIGIN SCIPsolGetOrigin(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetOrigin$address() {
        return SCIPsolGetOrigin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOLORIGIN SCIPsolGetOrigin(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolGetOrigin(MemorySegment sol) {
        var mh$ = SCIPsolGetOrigin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetOrigin", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolIsOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolIsOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsOriginal(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolIsOriginal$descriptor() {
        return SCIPsolIsOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsOriginal(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolIsOriginal$handle() {
        return SCIPsolIsOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsOriginal(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolIsOriginal$address() {
        return SCIPsolIsOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsolIsOriginal(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolIsOriginal(MemorySegment sol) {
        var mh$ = SCIPsolIsOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolIsOriginal", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolIsPartial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolIsPartial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsPartial(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolIsPartial$descriptor() {
        return SCIPsolIsPartial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsPartial(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolIsPartial$handle() {
        return SCIPsolIsPartial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsolIsPartial(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolIsPartial$address() {
        return SCIPsolIsPartial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsolIsPartial(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolIsPartial(MemorySegment sol) {
        var mh$ = SCIPsolIsPartial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolIsPartial", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetOrigObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetOrigObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetOrigObj(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetOrigObj$descriptor() {
        return SCIPsolGetOrigObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetOrigObj(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetOrigObj$handle() {
        return SCIPsolGetOrigObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetOrigObj(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetOrigObj$address() {
        return SCIPsolGetOrigObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetOrigObj(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetOrigObj(MemorySegment sol) {
        var mh$ = SCIPsolGetOrigObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetOrigObj", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetTime(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetTime$descriptor() {
        return SCIPsolGetTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetTime(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetTime$handle() {
        return SCIPsolGetTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetTime(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetTime$address() {
        return SCIPsolGetTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetTime(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetTime(MemorySegment sol) {
        var mh$ = SCIPsolGetTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetTime", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetRunnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetRunnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsolGetRunnum(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetRunnum$descriptor() {
        return SCIPsolGetRunnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsolGetRunnum(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetRunnum$handle() {
        return SCIPsolGetRunnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsolGetRunnum(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRunnum$address() {
        return SCIPsolGetRunnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsolGetRunnum(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolGetRunnum(MemorySegment sol) {
        var mh$ = SCIPsolGetRunnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetRunnum", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetNodenum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetNodenum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPsolGetNodenum(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetNodenum$descriptor() {
        return SCIPsolGetNodenum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPsolGetNodenum(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetNodenum$handle() {
        return SCIPsolGetNodenum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPsolGetNodenum(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetNodenum$address() {
        return SCIPsolGetNodenum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPsolGetNodenum(SCIP_SOL *sol)
     * }
     */
    public static long SCIPsolGetNodenum(MemorySegment sol) {
        var mh$ = SCIPsolGetNodenum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetNodenum", sol);
            }
            return (long)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsolGetDepth(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetDepth$descriptor() {
        return SCIPsolGetDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsolGetDepth(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetDepth$handle() {
        return SCIPsolGetDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsolGetDepth(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetDepth$address() {
        return SCIPsolGetDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsolGetDepth(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolGetDepth(MemorySegment sol) {
        var mh$ = SCIPsolGetDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetDepth", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOLTYPE SCIPsolGetType(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetType$descriptor() {
        return SCIPsolGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOLTYPE SCIPsolGetType(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetType$handle() {
        return SCIPsolGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOLTYPE SCIPsolGetType(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetType$address() {
        return SCIPsolGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOLTYPE SCIPsolGetType(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolGetType(MemorySegment sol) {
        var mh$ = SCIPsolGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetType", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPsolGetHeur(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetHeur$descriptor() {
        return SCIPsolGetHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPsolGetHeur(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetHeur$handle() {
        return SCIPsolGetHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPsolGetHeur(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetHeur$address() {
        return SCIPsolGetHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPsolGetHeur(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetHeur(MemorySegment sol) {
        var mh$ = SCIPsolGetHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetHeur", sol);
            }
            return (MemorySegment)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPsolGetRelax(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetRelax$descriptor() {
        return SCIPsolGetRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPsolGetRelax(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetRelax$handle() {
        return SCIPsolGetRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPsolGetRelax(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRelax$address() {
        return SCIPsolGetRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPsolGetRelax(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRelax(MemorySegment sol) {
        var mh$ = SCIPsolGetRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetRelax", sol);
            }
            return (MemorySegment)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolSetHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolSetHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsolSetHeur(SCIP_SOL *sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPsolSetHeur$descriptor() {
        return SCIPsolSetHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsolSetHeur(SCIP_SOL *sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPsolSetHeur$handle() {
        return SCIPsolSetHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsolSetHeur(SCIP_SOL *sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPsolSetHeur$address() {
        return SCIPsolSetHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsolSetHeur(SCIP_SOL *sol, SCIP_HEUR *heur)
     * }
     */
    public static void SCIPsolSetHeur(MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPsolSetHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolSetHeur", sol, heur);
            }
            mh$.invokeExact(sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolSetRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolSetRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsolSetRelax(SCIP_SOL *sol, SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPsolSetRelax$descriptor() {
        return SCIPsolSetRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsolSetRelax(SCIP_SOL *sol, SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPsolSetRelax$handle() {
        return SCIPsolSetRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsolSetRelax(SCIP_SOL *sol, SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPsolSetRelax$address() {
        return SCIPsolSetRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsolSetRelax(SCIP_SOL *sol, SCIP_RELAX *relax)
     * }
     */
    public static void SCIPsolSetRelax(MemorySegment sol, MemorySegment relax) {
        var mh$ = SCIPsolSetRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolSetRelax", sol, relax);
            }
            mh$.invokeExact(sol, relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolSetLPRelaxation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolSetLPRelaxation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsolSetLPRelaxation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolSetLPRelaxation$descriptor() {
        return SCIPsolSetLPRelaxation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsolSetLPRelaxation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolSetLPRelaxation$handle() {
        return SCIPsolSetLPRelaxation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsolSetLPRelaxation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolSetLPRelaxation$address() {
        return SCIPsolSetLPRelaxation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsolSetLPRelaxation(SCIP_SOL *sol)
     * }
     */
    public static void SCIPsolSetLPRelaxation(MemorySegment sol) {
        var mh$ = SCIPsolSetLPRelaxation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolSetLPRelaxation", sol);
            }
            mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolSetStrongbranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolSetStrongbranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsolSetStrongbranching(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolSetStrongbranching$descriptor() {
        return SCIPsolSetStrongbranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsolSetStrongbranching(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolSetStrongbranching$handle() {
        return SCIPsolSetStrongbranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsolSetStrongbranching(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolSetStrongbranching$address() {
        return SCIPsolSetStrongbranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsolSetStrongbranching(SCIP_SOL *sol)
     * }
     */
    public static void SCIPsolSetStrongbranching(MemorySegment sol) {
        var mh$ = SCIPsolSetStrongbranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolSetStrongbranching", sol);
            }
            mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolSetPseudo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolSetPseudo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsolSetPseudo(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolSetPseudo$descriptor() {
        return SCIPsolSetPseudo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsolSetPseudo(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolSetPseudo$handle() {
        return SCIPsolSetPseudo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsolSetPseudo(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolSetPseudo$address() {
        return SCIPsolSetPseudo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsolSetPseudo(SCIP_SOL *sol)
     * }
     */
    public static void SCIPsolSetPseudo(MemorySegment sol) {
        var mh$ = SCIPsolSetPseudo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolSetPseudo", sol);
            }
            mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsolGetIndex(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetIndex$descriptor() {
        return SCIPsolGetIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsolGetIndex(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetIndex$handle() {
        return SCIPsolGetIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsolGetIndex(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetIndex$address() {
        return SCIPsolGetIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsolGetIndex(SCIP_SOL *sol)
     * }
     */
    public static int SCIPsolGetIndex(MemorySegment sol) {
        var mh$ = SCIPsolGetIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetIndex", sol);
            }
            return (int)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetAbsBoundViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetAbsBoundViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetAbsBoundViolation$descriptor() {
        return SCIPsolGetAbsBoundViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetAbsBoundViolation$handle() {
        return SCIPsolGetAbsBoundViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetAbsBoundViolation$address() {
        return SCIPsolGetAbsBoundViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetAbsBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetAbsBoundViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetAbsBoundViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetAbsBoundViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetRelBoundViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetRelBoundViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetRelBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetRelBoundViolation$descriptor() {
        return SCIPsolGetRelBoundViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetRelBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetRelBoundViolation$handle() {
        return SCIPsolGetRelBoundViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetRelBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRelBoundViolation$address() {
        return SCIPsolGetRelBoundViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetRelBoundViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetRelBoundViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetRelBoundViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetRelBoundViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetAbsIntegralityViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetAbsIntegralityViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsIntegralityViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetAbsIntegralityViolation$descriptor() {
        return SCIPsolGetAbsIntegralityViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsIntegralityViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetAbsIntegralityViolation$handle() {
        return SCIPsolGetAbsIntegralityViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsIntegralityViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetAbsIntegralityViolation$address() {
        return SCIPsolGetAbsIntegralityViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetAbsIntegralityViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetAbsIntegralityViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetAbsIntegralityViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetAbsIntegralityViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetAbsLPRowViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetAbsLPRowViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetAbsLPRowViolation$descriptor() {
        return SCIPsolGetAbsLPRowViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetAbsLPRowViolation$handle() {
        return SCIPsolGetAbsLPRowViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetAbsLPRowViolation$address() {
        return SCIPsolGetAbsLPRowViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetAbsLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetAbsLPRowViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetAbsLPRowViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetAbsLPRowViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetRelLPRowViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetRelLPRowViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetRelLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetRelLPRowViolation$descriptor() {
        return SCIPsolGetRelLPRowViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetRelLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetRelLPRowViolation$handle() {
        return SCIPsolGetRelLPRowViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetRelLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRelLPRowViolation$address() {
        return SCIPsolGetRelLPRowViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetRelLPRowViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetRelLPRowViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetRelLPRowViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetRelLPRowViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetAbsConsViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetAbsConsViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsConsViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetAbsConsViolation$descriptor() {
        return SCIPsolGetAbsConsViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsConsViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetAbsConsViolation$handle() {
        return SCIPsolGetAbsConsViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetAbsConsViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetAbsConsViolation$address() {
        return SCIPsolGetAbsConsViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetAbsConsViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetAbsConsViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetAbsConsViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetAbsConsViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolGetRelConsViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolGetRelConsViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsolGetRelConsViolation(SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsolGetRelConsViolation$descriptor() {
        return SCIPsolGetRelConsViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsolGetRelConsViolation(SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsolGetRelConsViolation$handle() {
        return SCIPsolGetRelConsViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsolGetRelConsViolation(SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsolGetRelConsViolation$address() {
        return SCIPsolGetRelConsViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsolGetRelConsViolation(SCIP_SOL *sol)
     * }
     */
    public static double SCIPsolGetRelConsViolation(MemorySegment sol) {
        var mh$ = SCIPsolGetRelConsViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolGetRelConsViolation", sol);
            }
            return (double)mh$.invokeExact(sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_TABLEDATA *SCIPtableGetData(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableGetData$descriptor() {
        return SCIPtableGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_TABLEDATA *SCIPtableGetData(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableGetData$handle() {
        return SCIPtableGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_TABLEDATA *SCIPtableGetData(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetData$address() {
        return SCIPtableGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_TABLEDATA *SCIPtableGetData(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetData(MemorySegment table) {
        var mh$ = SCIPtableGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableGetData", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPtableSetData(SCIP_TABLE *table, SCIP_TABLEDATA *tabledata)
     * }
     */
    public static FunctionDescriptor SCIPtableSetData$descriptor() {
        return SCIPtableSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPtableSetData(SCIP_TABLE *table, SCIP_TABLEDATA *tabledata)
     * }
     */
    public static MethodHandle SCIPtableSetData$handle() {
        return SCIPtableSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPtableSetData(SCIP_TABLE *table, SCIP_TABLEDATA *tabledata)
     * }
     */
    public static MemorySegment SCIPtableSetData$address() {
        return SCIPtableSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPtableSetData(SCIP_TABLE *table, SCIP_TABLEDATA *tabledata)
     * }
     */
    public static void SCIPtableSetData(MemorySegment table, MemorySegment tabledata) {
        var mh$ = SCIPtableSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableSetData", table, tabledata);
            }
            mh$.invokeExact(table, tabledata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPtableGetName(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableGetName$descriptor() {
        return SCIPtableGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPtableGetName(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableGetName$handle() {
        return SCIPtableGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPtableGetName(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetName$address() {
        return SCIPtableGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPtableGetName(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetName(MemorySegment table) {
        var mh$ = SCIPtableGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableGetName", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPtableGetDesc(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableGetDesc$descriptor() {
        return SCIPtableGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPtableGetDesc(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableGetDesc$handle() {
        return SCIPtableGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPtableGetDesc(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetDesc$address() {
        return SCIPtableGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPtableGetDesc(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetDesc(MemorySegment table) {
        var mh$ = SCIPtableGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableGetDesc", table);
            }
            return (MemorySegment)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableGetPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableGetPosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtableGetPosition(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableGetPosition$descriptor() {
        return SCIPtableGetPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtableGetPosition(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableGetPosition$handle() {
        return SCIPtableGetPosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtableGetPosition(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetPosition$address() {
        return SCIPtableGetPosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtableGetPosition(SCIP_TABLE *table)
     * }
     */
    public static int SCIPtableGetPosition(MemorySegment table) {
        var mh$ = SCIPtableGetPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableGetPosition", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableGetEarliestStage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableGetEarliestStage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPtableGetEarliestStage(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableGetEarliestStage$descriptor() {
        return SCIPtableGetEarliestStage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPtableGetEarliestStage(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableGetEarliestStage$handle() {
        return SCIPtableGetEarliestStage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPtableGetEarliestStage(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableGetEarliestStage$address() {
        return SCIPtableGetEarliestStage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_STAGE SCIPtableGetEarliestStage(SCIP_TABLE *table)
     * }
     */
    public static int SCIPtableGetEarliestStage(MemorySegment table) {
        var mh$ = SCIPtableGetEarliestStage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableGetEarliestStage", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsActive(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableIsActive$descriptor() {
        return SCIPtableIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsActive(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableIsActive$handle() {
        return SCIPtableIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsActive(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableIsActive$address() {
        return SCIPtableIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPtableIsActive(SCIP_TABLE *table)
     * }
     */
    public static int SCIPtableIsActive(MemorySegment table) {
        var mh$ = SCIPtableIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableIsActive", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtableIsInitialized {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtableIsInitialized");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsInitialized(SCIP_TABLE *table)
     * }
     */
    public static FunctionDescriptor SCIPtableIsInitialized$descriptor() {
        return SCIPtableIsInitialized.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsInitialized(SCIP_TABLE *table)
     * }
     */
    public static MethodHandle SCIPtableIsInitialized$handle() {
        return SCIPtableIsInitialized.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPtableIsInitialized(SCIP_TABLE *table)
     * }
     */
    public static MemorySegment SCIPtableIsInitialized$address() {
        return SCIPtableIsInitialized.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPtableIsInitialized(SCIP_TABLE *table)
     * }
     */
    public static int SCIPtableIsInitialized(MemorySegment table) {
        var mh$ = SCIPtableIsInitialized.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtableIsInitialized", table);
            }
            return (int)mh$.invokeExact(table);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeCompLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeCompLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnodeCompLowerbound(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPnodeCompLowerbound$descriptor() {
        return SCIPnodeCompLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnodeCompLowerbound(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPnodeCompLowerbound$handle() {
        return SCIPnodeCompLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnodeCompLowerbound(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPnodeCompLowerbound$address() {
        return SCIPnodeCompLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnodeCompLowerbound(void *elem1, void *elem2)
     * }
     */
    public static int SCIPnodeCompLowerbound(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPnodeCompLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeCompLowerbound", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetParentBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetParentBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetParentBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetParentBranchings$descriptor() {
        return SCIPnodeGetParentBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetParentBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MethodHandle SCIPnodeGetParentBranchings$handle() {
        return SCIPnodeGetParentBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetParentBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MemorySegment SCIPnodeGetParentBranchings$address() {
        return SCIPnodeGetParentBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetParentBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static void SCIPnodeGetParentBranchings(MemorySegment node, MemorySegment branchvars, MemorySegment branchbounds, MemorySegment boundtypes, MemorySegment nbranchvars, int branchvarssize) {
        var mh$ = SCIPnodeGetParentBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetParentBranchings", node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
            }
            mh$.invokeExact(node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetAncestorBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetAncestorBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetAncestorBranchings$descriptor() {
        return SCIPnodeGetAncestorBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MethodHandle SCIPnodeGetAncestorBranchings$handle() {
        return SCIPnodeGetAncestorBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MemorySegment SCIPnodeGetAncestorBranchings$address() {
        return SCIPnodeGetAncestorBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchings(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static void SCIPnodeGetAncestorBranchings(MemorySegment node, MemorySegment branchvars, MemorySegment branchbounds, MemorySegment boundtypes, MemorySegment nbranchvars, int branchvarssize) {
        var mh$ = SCIPnodeGetAncestorBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetAncestorBranchings", node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
            }
            mh$.invokeExact(node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetAncestorBranchingsPart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetAncestorBranchingsPart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingsPart(SCIP_NODE *node, SCIP_NODE *parent, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetAncestorBranchingsPart$descriptor() {
        return SCIPnodeGetAncestorBranchingsPart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingsPart(SCIP_NODE *node, SCIP_NODE *parent, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MethodHandle SCIPnodeGetAncestorBranchingsPart$handle() {
        return SCIPnodeGetAncestorBranchingsPart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingsPart(SCIP_NODE *node, SCIP_NODE *parent, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static MemorySegment SCIPnodeGetAncestorBranchingsPart$address() {
        return SCIPnodeGetAncestorBranchingsPart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingsPart(SCIP_NODE *node, SCIP_NODE *parent, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize)
     * }
     */
    public static void SCIPnodeGetAncestorBranchingsPart(MemorySegment node, MemorySegment parent, MemorySegment branchvars, MemorySegment branchbounds, MemorySegment boundtypes, MemorySegment nbranchvars, int branchvarssize) {
        var mh$ = SCIPnodeGetAncestorBranchingsPart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetAncestorBranchingsPart", node, parent, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
            }
            mh$.invokeExact(node, parent, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodePrintAncestorBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodePrintAncestorBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnodePrintAncestorBranchings(SCIP_NODE *node, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPnodePrintAncestorBranchings$descriptor() {
        return SCIPnodePrintAncestorBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnodePrintAncestorBranchings(SCIP_NODE *node, FILE *file)
     * }
     */
    public static MethodHandle SCIPnodePrintAncestorBranchings$handle() {
        return SCIPnodePrintAncestorBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnodePrintAncestorBranchings(SCIP_NODE *node, FILE *file)
     * }
     */
    public static MemorySegment SCIPnodePrintAncestorBranchings$address() {
        return SCIPnodePrintAncestorBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnodePrintAncestorBranchings(SCIP_NODE *node, FILE *file)
     * }
     */
    public static int SCIPnodePrintAncestorBranchings(MemorySegment node, MemorySegment file) {
        var mh$ = SCIPnodePrintAncestorBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodePrintAncestorBranchings", node, file);
            }
            return (int)mh$.invokeExact(node, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetAncestorBranchingPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetAncestorBranchingPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingPath(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize, int *nodeswitches, int *nnodes, int nodeswitchsize)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetAncestorBranchingPath$descriptor() {
        return SCIPnodeGetAncestorBranchingPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingPath(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize, int *nodeswitches, int *nnodes, int nodeswitchsize)
     * }
     */
    public static MethodHandle SCIPnodeGetAncestorBranchingPath$handle() {
        return SCIPnodeGetAncestorBranchingPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingPath(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize, int *nodeswitches, int *nnodes, int nodeswitchsize)
     * }
     */
    public static MemorySegment SCIPnodeGetAncestorBranchingPath$address() {
        return SCIPnodeGetAncestorBranchingPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetAncestorBranchingPath(SCIP_NODE *node, SCIP_VAR **branchvars, double *branchbounds, SCIP_BOUNDTYPE *boundtypes, int *nbranchvars, int branchvarssize, int *nodeswitches, int *nnodes, int nodeswitchsize)
     * }
     */
    public static void SCIPnodeGetAncestorBranchingPath(MemorySegment node, MemorySegment branchvars, MemorySegment branchbounds, MemorySegment boundtypes, MemorySegment nbranchvars, int branchvarssize, MemorySegment nodeswitches, MemorySegment nnodes, int nodeswitchsize) {
        var mh$ = SCIPnodeGetAncestorBranchingPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetAncestorBranchingPath", node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize, nodeswitches, nnodes, nodeswitchsize);
            }
            mh$.invokeExact(node, branchvars, branchbounds, boundtypes, nbranchvars, branchvarssize, nodeswitches, nnodes, nodeswitchsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodesSharePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodesSharePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnodesSharePath(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static FunctionDescriptor SCIPnodesSharePath$descriptor() {
        return SCIPnodesSharePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnodesSharePath(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static MethodHandle SCIPnodesSharePath$handle() {
        return SCIPnodesSharePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnodesSharePath(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static MemorySegment SCIPnodesSharePath$address() {
        return SCIPnodesSharePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnodesSharePath(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static int SCIPnodesSharePath(MemorySegment node1, MemorySegment node2) {
        var mh$ = SCIPnodesSharePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodesSharePath", node1, node2);
            }
            return (int)mh$.invokeExact(node1, node2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodesGetCommonAncestor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodesGetCommonAncestor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodesGetCommonAncestor(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static FunctionDescriptor SCIPnodesGetCommonAncestor$descriptor() {
        return SCIPnodesGetCommonAncestor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodesGetCommonAncestor(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static MethodHandle SCIPnodesGetCommonAncestor$handle() {
        return SCIPnodesGetCommonAncestor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodesGetCommonAncestor(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static MemorySegment SCIPnodesGetCommonAncestor$address() {
        return SCIPnodesGetCommonAncestor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodesGetCommonAncestor(SCIP_NODE *node1, SCIP_NODE *node2)
     * }
     */
    public static MemorySegment SCIPnodesGetCommonAncestor(MemorySegment node1, MemorySegment node2) {
        var mh$ = SCIPnodesGetCommonAncestor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodesGetCommonAncestor", node1, node2);
            }
            return (MemorySegment)mh$.invokeExact(node1, node2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODETYPE SCIPnodeGetType(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetType$descriptor() {
        return SCIPnodeGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODETYPE SCIPnodeGetType(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetType$handle() {
        return SCIPnodeGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODETYPE SCIPnodeGetType(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetType$address() {
        return SCIPnodeGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODETYPE SCIPnodeGetType(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeGetType(MemorySegment node) {
        var mh$ = SCIPnodeGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetType", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetNumber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPnodeGetNumber(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetNumber$descriptor() {
        return SCIPnodeGetNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPnodeGetNumber(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetNumber$handle() {
        return SCIPnodeGetNumber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPnodeGetNumber(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetNumber$address() {
        return SCIPnodeGetNumber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPnodeGetNumber(SCIP_NODE *node)
     * }
     */
    public static long SCIPnodeGetNumber(MemorySegment node) {
        var mh$ = SCIPnodeGetNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetNumber", node);
            }
            return (long)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnodeGetDepth(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetDepth$descriptor() {
        return SCIPnodeGetDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnodeGetDepth(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetDepth$handle() {
        return SCIPnodeGetDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnodeGetDepth(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetDepth$address() {
        return SCIPnodeGetDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnodeGetDepth(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeGetDepth(MemorySegment node) {
        var mh$ = SCIPnodeGetDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetDepth", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnodeGetLowerbound(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetLowerbound$descriptor() {
        return SCIPnodeGetLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnodeGetLowerbound(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetLowerbound$handle() {
        return SCIPnodeGetLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnodeGetLowerbound(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetLowerbound$address() {
        return SCIPnodeGetLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnodeGetLowerbound(SCIP_NODE *node)
     * }
     */
    public static double SCIPnodeGetLowerbound(MemorySegment node) {
        var mh$ = SCIPnodeGetLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetLowerbound", node);
            }
            return (double)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnodeGetEstimate(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetEstimate$descriptor() {
        return SCIPnodeGetEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnodeGetEstimate(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetEstimate$handle() {
        return SCIPnodeGetEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnodeGetEstimate(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetEstimate$address() {
        return SCIPnodeGetEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnodeGetEstimate(SCIP_NODE *node)
     * }
     */
    public static double SCIPnodeGetEstimate(MemorySegment node) {
        var mh$ = SCIPnodeGetEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetEstimate", node);
            }
            return (double)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetReopttype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetReopttype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPnodeGetReopttype(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetReopttype$descriptor() {
        return SCIPnodeGetReopttype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPnodeGetReopttype(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetReopttype$handle() {
        return SCIPnodeGetReopttype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPnodeGetReopttype(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetReopttype$address() {
        return SCIPnodeGetReopttype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_REOPTTYPE SCIPnodeGetReopttype(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeGetReopttype(MemorySegment node) {
        var mh$ = SCIPnodeGetReopttype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetReopttype", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetReoptID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetReoptID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeGetReoptID(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetReoptID$descriptor() {
        return SCIPnodeGetReoptID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeGetReoptID(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetReoptID$handle() {
        return SCIPnodeGetReoptID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeGetReoptID(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetReoptID$address() {
        return SCIPnodeGetReoptID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnodeGetReoptID(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeGetReoptID(MemorySegment node) {
        var mh$ = SCIPnodeGetReoptID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetReoptID", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeSetReopttype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeSetReopttype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeSetReopttype(SCIP_NODE *node, SCIP_REOPTTYPE reopttype)
     * }
     */
    public static FunctionDescriptor SCIPnodeSetReopttype$descriptor() {
        return SCIPnodeSetReopttype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeSetReopttype(SCIP_NODE *node, SCIP_REOPTTYPE reopttype)
     * }
     */
    public static MethodHandle SCIPnodeSetReopttype$handle() {
        return SCIPnodeSetReopttype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeSetReopttype(SCIP_NODE *node, SCIP_REOPTTYPE reopttype)
     * }
     */
    public static MemorySegment SCIPnodeSetReopttype$address() {
        return SCIPnodeSetReopttype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeSetReopttype(SCIP_NODE *node, SCIP_REOPTTYPE reopttype)
     * }
     */
    public static void SCIPnodeSetReopttype(MemorySegment node, int reopttype) {
        var mh$ = SCIPnodeSetReopttype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeSetReopttype", node, reopttype);
            }
            mh$.invokeExact(node, reopttype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeSetReoptID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeSetReoptID");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeSetReoptID(SCIP_NODE *node, unsigned int id)
     * }
     */
    public static FunctionDescriptor SCIPnodeSetReoptID$descriptor() {
        return SCIPnodeSetReoptID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeSetReoptID(SCIP_NODE *node, unsigned int id)
     * }
     */
    public static MethodHandle SCIPnodeSetReoptID$handle() {
        return SCIPnodeSetReoptID.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeSetReoptID(SCIP_NODE *node, unsigned int id)
     * }
     */
    public static MemorySegment SCIPnodeSetReoptID$address() {
        return SCIPnodeSetReoptID.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeSetReoptID(SCIP_NODE *node, unsigned int id)
     * }
     */
    public static void SCIPnodeSetReoptID(MemorySegment node, int id) {
        var mh$ = SCIPnodeSetReoptID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeSetReoptID", node, id);
            }
            mh$.invokeExact(node, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetNDomchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetNDomchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetNDomchg(SCIP_NODE *node, int *nbranchings, int *nconsprop, int *nprop)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetNDomchg$descriptor() {
        return SCIPnodeGetNDomchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetNDomchg(SCIP_NODE *node, int *nbranchings, int *nconsprop, int *nprop)
     * }
     */
    public static MethodHandle SCIPnodeGetNDomchg$handle() {
        return SCIPnodeGetNDomchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetNDomchg(SCIP_NODE *node, int *nbranchings, int *nconsprop, int *nprop)
     * }
     */
    public static MemorySegment SCIPnodeGetNDomchg$address() {
        return SCIPnodeGetNDomchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetNDomchg(SCIP_NODE *node, int *nbranchings, int *nconsprop, int *nprop)
     * }
     */
    public static void SCIPnodeGetNDomchg(MemorySegment node, MemorySegment nbranchings, MemorySegment nconsprop, MemorySegment nprop) {
        var mh$ = SCIPnodeGetNDomchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetNDomchg", node, nbranchings, nconsprop, nprop);
            }
            mh$.invokeExact(node, nbranchings, nconsprop, nprop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetDomchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetDomchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DOMCHG *SCIPnodeGetDomchg(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetDomchg$descriptor() {
        return SCIPnodeGetDomchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DOMCHG *SCIPnodeGetDomchg(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetDomchg$handle() {
        return SCIPnodeGetDomchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DOMCHG *SCIPnodeGetDomchg(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetDomchg$address() {
        return SCIPnodeGetDomchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DOMCHG *SCIPnodeGetDomchg(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetDomchg(MemorySegment node) {
        var mh$ = SCIPnodeGetDomchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetDomchg", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodeGetParent(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetParent$descriptor() {
        return SCIPnodeGetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodeGetParent(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetParent$handle() {
        return SCIPnodeGetParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodeGetParent(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetParent$address() {
        return SCIPnodeGetParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPnodeGetParent(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetParent(MemorySegment node) {
        var mh$ = SCIPnodeGetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetParent", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetAddedConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetAddedConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnodeGetAddedConss(SCIP_NODE *node, SCIP_CONS **addedconss, int *naddedconss, int addedconsssize)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetAddedConss$descriptor() {
        return SCIPnodeGetAddedConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnodeGetAddedConss(SCIP_NODE *node, SCIP_CONS **addedconss, int *naddedconss, int addedconsssize)
     * }
     */
    public static MethodHandle SCIPnodeGetAddedConss$handle() {
        return SCIPnodeGetAddedConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnodeGetAddedConss(SCIP_NODE *node, SCIP_CONS **addedconss, int *naddedconss, int addedconsssize)
     * }
     */
    public static MemorySegment SCIPnodeGetAddedConss$address() {
        return SCIPnodeGetAddedConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnodeGetAddedConss(SCIP_NODE *node, SCIP_CONS **addedconss, int *naddedconss, int addedconsssize)
     * }
     */
    public static void SCIPnodeGetAddedConss(MemorySegment node, MemorySegment addedconss, MemorySegment naddedconss, int addedconsssize) {
        var mh$ = SCIPnodeGetAddedConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetAddedConss", node, addedconss, naddedconss, addedconsssize);
            }
            mh$.invokeExact(node, addedconss, naddedconss, addedconsssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetNAddedConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetNAddedConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnodeGetNAddedConss(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetNAddedConss$descriptor() {
        return SCIPnodeGetNAddedConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnodeGetNAddedConss(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetNAddedConss$handle() {
        return SCIPnodeGetNAddedConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnodeGetNAddedConss(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetNAddedConss$address() {
        return SCIPnodeGetNAddedConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnodeGetNAddedConss(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeGetNAddedConss(MemorySegment node) {
        var mh$ = SCIPnodeGetNAddedConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetNAddedConss", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsActive(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeIsActive$descriptor() {
        return SCIPnodeIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsActive(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeIsActive$handle() {
        return SCIPnodeIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsActive(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeIsActive$address() {
        return SCIPnodeIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsActive(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeIsActive(MemorySegment node) {
        var mh$ = SCIPnodeIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeIsActive", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeIsPropagatedAgain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeIsPropagatedAgain");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsPropagatedAgain(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeIsPropagatedAgain$descriptor() {
        return SCIPnodeIsPropagatedAgain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsPropagatedAgain(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeIsPropagatedAgain$handle() {
        return SCIPnodeIsPropagatedAgain.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsPropagatedAgain(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeIsPropagatedAgain$address() {
        return SCIPnodeIsPropagatedAgain.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnodeIsPropagatedAgain(SCIP_NODE *node)
     * }
     */
    public static int SCIPnodeIsPropagatedAgain(MemorySegment node) {
        var mh$ = SCIPnodeIsPropagatedAgain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeIsPropagatedAgain", node);
            }
            return (int)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetConssetchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetConssetchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSSETCHG *SCIPnodeGetConssetchg(SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetConssetchg$descriptor() {
        return SCIPnodeGetConssetchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSSETCHG *SCIPnodeGetConssetchg(SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPnodeGetConssetchg$handle() {
        return SCIPnodeGetConssetchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSSETCHG *SCIPnodeGetConssetchg(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetConssetchg$address() {
        return SCIPnodeGetConssetchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSSETCHG *SCIPnodeGetConssetchg(SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPnodeGetConssetchg(MemorySegment node) {
        var mh$ = SCIPnodeGetConssetchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetConssetchg", node);
            }
            return (MemorySegment)mh$.invokeExact(node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLocksDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLocksDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDown(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLocksDown$descriptor() {
        return SCIPvarGetNLocksDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDown(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNLocksDown$handle() {
        return SCIPvarGetNLocksDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDown(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNLocksDown$address() {
        return SCIPvarGetNLocksDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDown(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNLocksDown(MemorySegment var_) {
        var mh$ = SCIPvarGetNLocksDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLocksDown", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLocksUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLocksUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUp(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLocksUp$descriptor() {
        return SCIPvarGetNLocksUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUp(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNLocksUp$handle() {
        return SCIPvarGetNLocksUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUp(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNLocksUp$address() {
        return SCIPvarGetNLocksUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUp(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNLocksUp(MemorySegment var_) {
        var mh$ = SCIPvarGetNLocksUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLocksUp", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLocksUpType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLocksUpType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUpType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLocksUpType$descriptor() {
        return SCIPvarGetNLocksUpType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUpType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPvarGetNLocksUpType$handle() {
        return SCIPvarGetNLocksUpType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUpType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPvarGetNLocksUpType$address() {
        return SCIPvarGetNLocksUpType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNLocksUpType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPvarGetNLocksUpType(MemorySegment var_, int locktype) {
        var mh$ = SCIPvarGetNLocksUpType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLocksUpType", var_, locktype);
            }
            return (int)mh$.invokeExact(var_, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLocksDownType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLocksDownType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDownType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLocksDownType$descriptor() {
        return SCIPvarGetNLocksDownType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDownType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MethodHandle SCIPvarGetNLocksDownType$handle() {
        return SCIPvarGetNLocksDownType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDownType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static MemorySegment SCIPvarGetNLocksDownType$address() {
        return SCIPvarGetNLocksDownType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNLocksDownType(SCIP_VAR *var, SCIP_LOCKTYPE locktype)
     * }
     */
    public static int SCIPvarGetNLocksDownType(MemorySegment var_, int locktype) {
        var mh$ = SCIPvarGetNLocksDownType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLocksDownType", var_, locktype);
            }
            return (int)mh$.invokeExact(var_, locktype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMayRoundDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMayRoundDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundDown(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMayRoundDown$descriptor() {
        return SCIPvarMayRoundDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundDown(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMayRoundDown$handle() {
        return SCIPvarMayRoundDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundDown(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMayRoundDown$address() {
        return SCIPvarMayRoundDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundDown(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarMayRoundDown(MemorySegment var_) {
        var mh$ = SCIPvarMayRoundDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMayRoundDown", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMayRoundUp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMayRoundUp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundUp(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMayRoundUp$descriptor() {
        return SCIPvarMayRoundUp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundUp(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMayRoundUp$handle() {
        return SCIPvarMayRoundUp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundUp(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMayRoundUp$address() {
        return SCIPvarMayRoundUp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarMayRoundUp(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarMayRoundUp(MemorySegment var_) {
        var mh$ = SCIPvarMayRoundUp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMayRoundUp", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarCompareActiveAndNegated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarCompareActiveAndNegated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarCompareActiveAndNegated(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static FunctionDescriptor SCIPvarCompareActiveAndNegated$descriptor() {
        return SCIPvarCompareActiveAndNegated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarCompareActiveAndNegated(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MethodHandle SCIPvarCompareActiveAndNegated$handle() {
        return SCIPvarCompareActiveAndNegated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarCompareActiveAndNegated(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MemorySegment SCIPvarCompareActiveAndNegated$address() {
        return SCIPvarCompareActiveAndNegated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarCompareActiveAndNegated(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static int SCIPvarCompareActiveAndNegated(MemorySegment var1, MemorySegment var2) {
        var mh$ = SCIPvarCompareActiveAndNegated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarCompareActiveAndNegated", var1, var2);
            }
            return (int)mh$.invokeExact(var1, var2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarCompActiveAndNegated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarCompActiveAndNegated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarCompActiveAndNegated(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPvarCompActiveAndNegated$descriptor() {
        return SCIPvarCompActiveAndNegated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarCompActiveAndNegated(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPvarCompActiveAndNegated$handle() {
        return SCIPvarCompActiveAndNegated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarCompActiveAndNegated(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPvarCompActiveAndNegated$address() {
        return SCIPvarCompActiveAndNegated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarCompActiveAndNegated(void *elem1, void *elem2)
     * }
     */
    public static int SCIPvarCompActiveAndNegated(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPvarCompActiveAndNegated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarCompActiveAndNegated", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarCompare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarCompare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarCompare(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static FunctionDescriptor SCIPvarCompare$descriptor() {
        return SCIPvarCompare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarCompare(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MethodHandle SCIPvarCompare$handle() {
        return SCIPvarCompare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarCompare(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MemorySegment SCIPvarCompare$address() {
        return SCIPvarCompare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarCompare(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static int SCIPvarCompare(MemorySegment var1, MemorySegment var2) {
        var mh$ = SCIPvarCompare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarCompare", var1, var2);
            }
            return (int)mh$.invokeExact(var1, var2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPvarComp$descriptor() {
        return SCIPvarComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPvarComp$handle() {
        return SCIPvarComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPvarComp$address() {
        return SCIPvarComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPvarComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPvarComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarCompObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarCompObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarCompObj(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPvarCompObj$descriptor() {
        return SCIPvarCompObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarCompObj(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPvarCompObj$handle() {
        return SCIPvarCompObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarCompObj(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPvarCompObj$address() {
        return SCIPvarCompObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarCompObj(void *elem1, void *elem2)
     * }
     */
    public static int SCIPvarCompObj(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPvarCompObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarCompObj", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetHashkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetHashkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPvarGetHashkey(void *userptr, void *elem)
     * }
     */
    public static FunctionDescriptor SCIPvarGetHashkey$descriptor() {
        return SCIPvarGetHashkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPvarGetHashkey(void *userptr, void *elem)
     * }
     */
    public static MethodHandle SCIPvarGetHashkey$handle() {
        return SCIPvarGetHashkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPvarGetHashkey(void *userptr, void *elem)
     * }
     */
    public static MemorySegment SCIPvarGetHashkey$address() {
        return SCIPvarGetHashkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPvarGetHashkey(void *userptr, void *elem)
     * }
     */
    public static MemorySegment SCIPvarGetHashkey(MemorySegment userptr, MemorySegment elem) {
        var mh$ = SCIPvarGetHashkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetHashkey", userptr, elem);
            }
            return (MemorySegment)mh$.invokeExact(userptr, elem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsHashkeyEq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsHashkeyEq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsHashkeyEq(void *userptr, void *key1, void *key2)
     * }
     */
    public static FunctionDescriptor SCIPvarIsHashkeyEq$descriptor() {
        return SCIPvarIsHashkeyEq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsHashkeyEq(void *userptr, void *key1, void *key2)
     * }
     */
    public static MethodHandle SCIPvarIsHashkeyEq$handle() {
        return SCIPvarIsHashkeyEq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsHashkeyEq(void *userptr, void *key1, void *key2)
     * }
     */
    public static MemorySegment SCIPvarIsHashkeyEq$address() {
        return SCIPvarIsHashkeyEq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsHashkeyEq(void *userptr, void *key1, void *key2)
     * }
     */
    public static int SCIPvarIsHashkeyEq(MemorySegment userptr, MemorySegment key1, MemorySegment key2) {
        var mh$ = SCIPvarIsHashkeyEq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsHashkeyEq", userptr, key1, key2);
            }
            return (int)mh$.invokeExact(userptr, key1, key2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetHashkeyVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetHashkeyVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t SCIPvarGetHashkeyVal(void *userptr, void *key)
     * }
     */
    public static FunctionDescriptor SCIPvarGetHashkeyVal$descriptor() {
        return SCIPvarGetHashkeyVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t SCIPvarGetHashkeyVal(void *userptr, void *key)
     * }
     */
    public static MethodHandle SCIPvarGetHashkeyVal$handle() {
        return SCIPvarGetHashkeyVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t SCIPvarGetHashkeyVal(void *userptr, void *key)
     * }
     */
    public static MemorySegment SCIPvarGetHashkeyVal$address() {
        return SCIPvarGetHashkeyVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t SCIPvarGetHashkeyVal(void *userptr, void *key)
     * }
     */
    public static long SCIPvarGetHashkeyVal(MemorySegment userptr, MemorySegment key) {
        var mh$ = SCIPvarGetHashkeyVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetHashkeyVal", userptr, key);
            }
            return (long)mh$.invokeExact(userptr, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarsGetProbvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarsGetProbvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarsGetProbvar(SCIP_VAR **vars, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPvarsGetProbvar$descriptor() {
        return SCIPvarsGetProbvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarsGetProbvar(SCIP_VAR **vars, int nvars)
     * }
     */
    public static MethodHandle SCIPvarsGetProbvar$handle() {
        return SCIPvarsGetProbvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarsGetProbvar(SCIP_VAR **vars, int nvars)
     * }
     */
    public static MemorySegment SCIPvarsGetProbvar$address() {
        return SCIPvarsGetProbvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarsGetProbvar(SCIP_VAR **vars, int nvars)
     * }
     */
    public static void SCIPvarsGetProbvar(MemorySegment vars, int nvars) {
        var mh$ = SCIPvarsGetProbvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarsGetProbvar", vars, nvars);
            }
            mh$.invokeExact(vars, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetProbvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetProbvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetProbvar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetProbvar$descriptor() {
        return SCIPvarGetProbvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetProbvar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetProbvar$handle() {
        return SCIPvarGetProbvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetProbvar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetProbvar$address() {
        return SCIPvarGetProbvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetProbvar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetProbvar(MemorySegment var_) {
        var mh$ = SCIPvarGetProbvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetProbvar", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarsGetProbvarBinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarsGetProbvarBinary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarsGetProbvarBinary(SCIP_VAR ***vars, unsigned int **negatedarr, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPvarsGetProbvarBinary$descriptor() {
        return SCIPvarsGetProbvarBinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarsGetProbvarBinary(SCIP_VAR ***vars, unsigned int **negatedarr, int nvars)
     * }
     */
    public static MethodHandle SCIPvarsGetProbvarBinary$handle() {
        return SCIPvarsGetProbvarBinary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarsGetProbvarBinary(SCIP_VAR ***vars, unsigned int **negatedarr, int nvars)
     * }
     */
    public static MemorySegment SCIPvarsGetProbvarBinary$address() {
        return SCIPvarsGetProbvarBinary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarsGetProbvarBinary(SCIP_VAR ***vars, unsigned int **negatedarr, int nvars)
     * }
     */
    public static int SCIPvarsGetProbvarBinary(MemorySegment vars, MemorySegment negatedarr, int nvars) {
        var mh$ = SCIPvarsGetProbvarBinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarsGetProbvarBinary", vars, negatedarr, nvars);
            }
            return (int)mh$.invokeExact(vars, negatedarr, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetProbvarBinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetProbvarBinary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBinary(SCIP_VAR **var, unsigned int *negated)
     * }
     */
    public static FunctionDescriptor SCIPvarGetProbvarBinary$descriptor() {
        return SCIPvarGetProbvarBinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBinary(SCIP_VAR **var, unsigned int *negated)
     * }
     */
    public static MethodHandle SCIPvarGetProbvarBinary$handle() {
        return SCIPvarGetProbvarBinary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBinary(SCIP_VAR **var, unsigned int *negated)
     * }
     */
    public static MemorySegment SCIPvarGetProbvarBinary$address() {
        return SCIPvarGetProbvarBinary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBinary(SCIP_VAR **var, unsigned int *negated)
     * }
     */
    public static int SCIPvarGetProbvarBinary(MemorySegment var_, MemorySegment negated) {
        var mh$ = SCIPvarGetProbvarBinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetProbvarBinary", var_, negated);
            }
            return (int)mh$.invokeExact(var_, negated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetProbvarBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetProbvarBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBound(SCIP_VAR **var, double *bound, SCIP_BOUNDTYPE *boundtype)
     * }
     */
    public static FunctionDescriptor SCIPvarGetProbvarBound$descriptor() {
        return SCIPvarGetProbvarBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBound(SCIP_VAR **var, double *bound, SCIP_BOUNDTYPE *boundtype)
     * }
     */
    public static MethodHandle SCIPvarGetProbvarBound$handle() {
        return SCIPvarGetProbvarBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBound(SCIP_VAR **var, double *bound, SCIP_BOUNDTYPE *boundtype)
     * }
     */
    public static MemorySegment SCIPvarGetProbvarBound$address() {
        return SCIPvarGetProbvarBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarBound(SCIP_VAR **var, double *bound, SCIP_BOUNDTYPE *boundtype)
     * }
     */
    public static int SCIPvarGetProbvarBound(MemorySegment var_, MemorySegment bound, MemorySegment boundtype) {
        var mh$ = SCIPvarGetProbvarBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetProbvarBound", var_, bound, boundtype);
            }
            return (int)mh$.invokeExact(var_, bound, boundtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetProbvarHole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetProbvarHole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarHole(SCIP_VAR **var, double *left, double *right)
     * }
     */
    public static FunctionDescriptor SCIPvarGetProbvarHole$descriptor() {
        return SCIPvarGetProbvarHole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarHole(SCIP_VAR **var, double *left, double *right)
     * }
     */
    public static MethodHandle SCIPvarGetProbvarHole$handle() {
        return SCIPvarGetProbvarHole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarHole(SCIP_VAR **var, double *left, double *right)
     * }
     */
    public static MemorySegment SCIPvarGetProbvarHole$address() {
        return SCIPvarGetProbvarHole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetProbvarHole(SCIP_VAR **var, double *left, double *right)
     * }
     */
    public static int SCIPvarGetProbvarHole(MemorySegment var_, MemorySegment left, MemorySegment right) {
        var mh$ = SCIPvarGetProbvarHole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetProbvarHole", var_, left, right);
            }
            return (int)mh$.invokeExact(var_, left, right);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetOrigvarSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetOrigvarSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetOrigvarSum(SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static FunctionDescriptor SCIPvarGetOrigvarSum$descriptor() {
        return SCIPvarGetOrigvarSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetOrigvarSum(SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static MethodHandle SCIPvarGetOrigvarSum$handle() {
        return SCIPvarGetOrigvarSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetOrigvarSum(SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static MemorySegment SCIPvarGetOrigvarSum$address() {
        return SCIPvarGetOrigvarSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetOrigvarSum(SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static int SCIPvarGetOrigvarSum(MemorySegment var_, MemorySegment scalar, MemorySegment constant) {
        var mh$ = SCIPvarGetOrigvarSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetOrigvarSum", var_, scalar, constant);
            }
            return (int)mh$.invokeExact(var_, scalar, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsTransformedOrigvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsTransformedOrigvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformedOrigvar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsTransformedOrigvar$descriptor() {
        return SCIPvarIsTransformedOrigvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformedOrigvar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsTransformedOrigvar$handle() {
        return SCIPvarIsTransformedOrigvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformedOrigvar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsTransformedOrigvar$address() {
        return SCIPvarIsTransformedOrigvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformedOrigvar(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsTransformedOrigvar(MemorySegment var_) {
        var mh$ = SCIPvarIsTransformedOrigvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsTransformedOrigvar", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNBranchings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNBranchings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchings(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNBranchings$descriptor() {
        return SCIPvarGetNBranchings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchings(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetNBranchings$handle() {
        return SCIPvarGetNBranchings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchings(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetNBranchings$address() {
        return SCIPvarGetNBranchings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchings(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static long SCIPvarGetNBranchings(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetNBranchings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNBranchings", var_, dir);
            }
            return (long)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNBranchingsCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNBranchingsCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchingsCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNBranchingsCurrentRun$descriptor() {
        return SCIPvarGetNBranchingsCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchingsCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetNBranchingsCurrentRun$handle() {
        return SCIPvarGetNBranchingsCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchingsCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetNBranchingsCurrentRun$address() {
        return SCIPvarGetNBranchingsCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPvarGetNBranchingsCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static long SCIPvarGetNBranchingsCurrentRun(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetNBranchingsCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNBranchingsCurrentRun", var_, dir);
            }
            return (long)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetInferenceSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetInferenceSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetInferenceSum$descriptor() {
        return SCIPvarGetInferenceSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetInferenceSum$handle() {
        return SCIPvarGetInferenceSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetInferenceSum$address() {
        return SCIPvarGetInferenceSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetInferenceSum(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetInferenceSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetInferenceSum", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetInferenceSumCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetInferenceSumCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetInferenceSumCurrentRun$descriptor() {
        return SCIPvarGetInferenceSumCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetInferenceSumCurrentRun$handle() {
        return SCIPvarGetInferenceSumCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetInferenceSumCurrentRun$address() {
        return SCIPvarGetInferenceSumCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetInferenceSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetInferenceSumCurrentRun(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetInferenceSumCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetInferenceSumCurrentRun", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetCutoffSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetCutoffSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetCutoffSum$descriptor() {
        return SCIPvarGetCutoffSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetCutoffSum$handle() {
        return SCIPvarGetCutoffSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetCutoffSum$address() {
        return SCIPvarGetCutoffSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSum(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetCutoffSum(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetCutoffSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetCutoffSum", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetCutoffSumCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetCutoffSumCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetCutoffSumCurrentRun$descriptor() {
        return SCIPvarGetCutoffSumCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetCutoffSumCurrentRun$handle() {
        return SCIPvarGetCutoffSumCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetCutoffSumCurrentRun$address() {
        return SCIPvarGetCutoffSumCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetCutoffSumCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetCutoffSumCurrentRun(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetCutoffSumCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetCutoffSumCurrentRun", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAvgBranchdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAvgBranchdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepth(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAvgBranchdepth$descriptor() {
        return SCIPvarGetAvgBranchdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepth(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetAvgBranchdepth$handle() {
        return SCIPvarGetAvgBranchdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepth(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetAvgBranchdepth$address() {
        return SCIPvarGetAvgBranchdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepth(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetAvgBranchdepth(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetAvgBranchdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAvgBranchdepth", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAvgBranchdepthCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAvgBranchdepthCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepthCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAvgBranchdepthCurrentRun$descriptor() {
        return SCIPvarGetAvgBranchdepthCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepthCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPvarGetAvgBranchdepthCurrentRun$handle() {
        return SCIPvarGetAvgBranchdepthCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepthCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPvarGetAvgBranchdepthCurrentRun$address() {
        return SCIPvarGetAvgBranchdepthCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetAvgBranchdepthCurrentRun(SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPvarGetAvgBranchdepthCurrentRun(MemorySegment var_, int dir) {
        var mh$ = SCIPvarGetAvgBranchdepthCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAvgBranchdepthCurrentRun", var_, dir);
            }
            return (double)mh$.invokeExact(var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarHasImplic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarHasImplic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype)
     * }
     */
    public static FunctionDescriptor SCIPvarHasImplic$descriptor() {
        return SCIPvarHasImplic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype)
     * }
     */
    public static MethodHandle SCIPvarHasImplic$handle() {
        return SCIPvarHasImplic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype)
     * }
     */
    public static MemorySegment SCIPvarHasImplic$address() {
        return SCIPvarHasImplic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarHasImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype)
     * }
     */
    public static int SCIPvarHasImplic(MemorySegment var_, int varfixing, MemorySegment implvar, int impltype) {
        var mh$ = SCIPvarHasImplic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarHasImplic", var_, varfixing, implvar, impltype);
            }
            return (int)mh$.invokeExact(var_, varfixing, implvar, impltype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarHasBinaryImplic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarHasBinaryImplic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasBinaryImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, unsigned int implvarfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarHasBinaryImplic$descriptor() {
        return SCIPvarHasBinaryImplic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasBinaryImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, unsigned int implvarfixing)
     * }
     */
    public static MethodHandle SCIPvarHasBinaryImplic$handle() {
        return SCIPvarHasBinaryImplic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarHasBinaryImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, unsigned int implvarfixing)
     * }
     */
    public static MemorySegment SCIPvarHasBinaryImplic$address() {
        return SCIPvarHasBinaryImplic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarHasBinaryImplic(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, unsigned int implvarfixing)
     * }
     */
    public static int SCIPvarHasBinaryImplic(MemorySegment var_, int varfixing, MemorySegment implvar, int implvarfixing) {
        var mh$ = SCIPvarHasBinaryImplic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarHasBinaryImplic", var_, varfixing, implvar, implvarfixing);
            }
            return (int)mh$.invokeExact(var_, varfixing, implvar, implvarfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetImplicVarBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetImplicVarBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarGetImplicVarBounds(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, double *lb, double *ub)
     * }
     */
    public static FunctionDescriptor SCIPvarGetImplicVarBounds$descriptor() {
        return SCIPvarGetImplicVarBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarGetImplicVarBounds(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, double *lb, double *ub)
     * }
     */
    public static MethodHandle SCIPvarGetImplicVarBounds$handle() {
        return SCIPvarGetImplicVarBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarGetImplicVarBounds(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, double *lb, double *ub)
     * }
     */
    public static MemorySegment SCIPvarGetImplicVarBounds$address() {
        return SCIPvarGetImplicVarBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarGetImplicVarBounds(SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, double *lb, double *ub)
     * }
     */
    public static void SCIPvarGetImplicVarBounds(MemorySegment var_, int varfixing, MemorySegment implvar, MemorySegment lb, MemorySegment ub) {
        var mh$ = SCIPvarGetImplicVarBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetImplicVarBounds", var_, varfixing, implvar, lb, ub);
            }
            mh$.invokeExact(var_, varfixing, implvar, lb, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarsHaveCommonClique {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarsHaveCommonClique");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarsHaveCommonClique(SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static FunctionDescriptor SCIPvarsHaveCommonClique$descriptor() {
        return SCIPvarsHaveCommonClique.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarsHaveCommonClique(SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static MethodHandle SCIPvarsHaveCommonClique$handle() {
        return SCIPvarsHaveCommonClique.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarsHaveCommonClique(SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static MemorySegment SCIPvarsHaveCommonClique$address() {
        return SCIPvarsHaveCommonClique.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarsHaveCommonClique(SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static int SCIPvarsHaveCommonClique(MemorySegment var1, int value1, MemorySegment var2, int value2, int regardimplics) {
        var mh$ = SCIPvarsHaveCommonClique.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarsHaveCommonClique", var1, value1, var2, value2, regardimplics);
            }
            return (int)mh$.invokeExact(var1, value1, var2, value2, regardimplics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAggregatedObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAggregatedObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetAggregatedObj(SCIP_VAR *var, double *aggrobj)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAggregatedObj$descriptor() {
        return SCIPvarGetAggregatedObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetAggregatedObj(SCIP_VAR *var, double *aggrobj)
     * }
     */
    public static MethodHandle SCIPvarGetAggregatedObj$handle() {
        return SCIPvarGetAggregatedObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetAggregatedObj(SCIP_VAR *var, double *aggrobj)
     * }
     */
    public static MemorySegment SCIPvarGetAggregatedObj$address() {
        return SCIPvarGetAggregatedObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarGetAggregatedObj(SCIP_VAR *var, double *aggrobj)
     * }
     */
    public static int SCIPvarGetAggregatedObj(MemorySegment var_, MemorySegment aggrobj) {
        var mh$ = SCIPvarGetAggregatedObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAggregatedObj", var_, aggrobj);
            }
            return (int)mh$.invokeExact(var_, aggrobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetInitial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetInitial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetInitial(SCIP_VAR *var, unsigned int initial)
     * }
     */
    public static FunctionDescriptor SCIPvarSetInitial$descriptor() {
        return SCIPvarSetInitial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetInitial(SCIP_VAR *var, unsigned int initial)
     * }
     */
    public static MethodHandle SCIPvarSetInitial$handle() {
        return SCIPvarSetInitial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetInitial(SCIP_VAR *var, unsigned int initial)
     * }
     */
    public static MemorySegment SCIPvarSetInitial$address() {
        return SCIPvarSetInitial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetInitial(SCIP_VAR *var, unsigned int initial)
     * }
     */
    public static int SCIPvarSetInitial(MemorySegment var_, int initial) {
        var mh$ = SCIPvarSetInitial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetInitial", var_, initial);
            }
            return (int)mh$.invokeExact(var_, initial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetRemovable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetRemovable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetRemovable(SCIP_VAR *var, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPvarSetRemovable$descriptor() {
        return SCIPvarSetRemovable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetRemovable(SCIP_VAR *var, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPvarSetRemovable$handle() {
        return SCIPvarSetRemovable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetRemovable(SCIP_VAR *var, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPvarSetRemovable$address() {
        return SCIPvarSetRemovable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvarSetRemovable(SCIP_VAR *var, unsigned int removable)
     * }
     */
    public static int SCIPvarSetRemovable(MemorySegment var_, int removable) {
        var mh$ = SCIPvarSetRemovable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetRemovable", var_, removable);
            }
            return (int)mh$.invokeExact(var_, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPvarGetName(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetName$descriptor() {
        return SCIPvarGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPvarGetName(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetName$handle() {
        return SCIPvarGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPvarGetName(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetName$address() {
        return SCIPvarGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPvarGetName(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetName(MemorySegment var_) {
        var mh$ = SCIPvarGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetName", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNUses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNUses");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNUses(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNUses$descriptor() {
        return SCIPvarGetNUses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNUses(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNUses$handle() {
        return SCIPvarGetNUses.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNUses(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNUses$address() {
        return SCIPvarGetNUses.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNUses(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNUses(MemorySegment var_) {
        var mh$ = SCIPvarGetNUses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNUses", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VARDATA *SCIPvarGetData(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetData$descriptor() {
        return SCIPvarGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VARDATA *SCIPvarGetData(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetData$handle() {
        return SCIPvarGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VARDATA *SCIPvarGetData(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetData$address() {
        return SCIPvarGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VARDATA *SCIPvarGetData(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetData(MemorySegment var_) {
        var mh$ = SCIPvarGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetData", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetData(SCIP_VAR *var, SCIP_VARDATA *vardata)
     * }
     */
    public static FunctionDescriptor SCIPvarSetData$descriptor() {
        return SCIPvarSetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetData(SCIP_VAR *var, SCIP_VARDATA *vardata)
     * }
     */
    public static MethodHandle SCIPvarSetData$handle() {
        return SCIPvarSetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetData(SCIP_VAR *var, SCIP_VARDATA *vardata)
     * }
     */
    public static MemorySegment SCIPvarSetData$address() {
        return SCIPvarSetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetData(SCIP_VAR *var, SCIP_VARDATA *vardata)
     * }
     */
    public static void SCIPvarSetData(MemorySegment var_, MemorySegment vardata) {
        var mh$ = SCIPvarSetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetData", var_, vardata);
            }
            mh$.invokeExact(var_, vardata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetDelorigData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetDelorigData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetDelorigData(SCIP_VAR *var, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static FunctionDescriptor SCIPvarSetDelorigData$descriptor() {
        return SCIPvarSetDelorigData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetDelorigData(SCIP_VAR *var, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MethodHandle SCIPvarSetDelorigData$handle() {
        return SCIPvarSetDelorigData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetDelorigData(SCIP_VAR *var, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MemorySegment SCIPvarSetDelorigData$address() {
        return SCIPvarSetDelorigData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetDelorigData(SCIP_VAR *var, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static void SCIPvarSetDelorigData(MemorySegment var_, MemorySegment vardelorig) {
        var mh$ = SCIPvarSetDelorigData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetDelorigData", var_, vardelorig);
            }
            mh$.invokeExact(var_, vardelorig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetTransData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetTransData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetTransData(SCIP_VAR *var, SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static FunctionDescriptor SCIPvarSetTransData$descriptor() {
        return SCIPvarSetTransData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetTransData(SCIP_VAR *var, SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MethodHandle SCIPvarSetTransData$handle() {
        return SCIPvarSetTransData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetTransData(SCIP_VAR *var, SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MemorySegment SCIPvarSetTransData$address() {
        return SCIPvarSetTransData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetTransData(SCIP_VAR *var, SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static void SCIPvarSetTransData(MemorySegment var_, MemorySegment vartrans) {
        var mh$ = SCIPvarSetTransData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetTransData", var_, vartrans);
            }
            mh$.invokeExact(var_, vartrans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetDeltransData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetDeltransData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetDeltransData(SCIP_VAR *var, SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static FunctionDescriptor SCIPvarSetDeltransData$descriptor() {
        return SCIPvarSetDeltransData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetDeltransData(SCIP_VAR *var, SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MethodHandle SCIPvarSetDeltransData$handle() {
        return SCIPvarSetDeltransData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetDeltransData(SCIP_VAR *var, SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static MemorySegment SCIPvarSetDeltransData$address() {
        return SCIPvarSetDeltransData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetDeltransData(SCIP_VAR *var, SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **))
     * }
     */
    public static void SCIPvarSetDeltransData(MemorySegment var_, MemorySegment vardeltrans) {
        var mh$ = SCIPvarSetDeltransData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetDeltransData", var_, vardeltrans);
            }
            mh$.invokeExact(var_, vardeltrans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetCopyData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetCopyData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetCopyData(SCIP_VAR *var, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPvarSetCopyData$descriptor() {
        return SCIPvarSetCopyData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetCopyData(SCIP_VAR *var, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPvarSetCopyData$handle() {
        return SCIPvarSetCopyData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetCopyData(SCIP_VAR *var, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPvarSetCopyData$address() {
        return SCIPvarSetCopyData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetCopyData(SCIP_VAR *var, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *))
     * }
     */
    public static void SCIPvarSetCopyData(MemorySegment var_, MemorySegment varcopy) {
        var mh$ = SCIPvarSetCopyData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetCopyData", var_, varcopy);
            }
            mh$.invokeExact(var_, varcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VARSTATUS SCIPvarGetStatus(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetStatus$descriptor() {
        return SCIPvarGetStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VARSTATUS SCIPvarGetStatus(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetStatus$handle() {
        return SCIPvarGetStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VARSTATUS SCIPvarGetStatus(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetStatus$address() {
        return SCIPvarGetStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VARSTATUS SCIPvarGetStatus(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetStatus(MemorySegment var_) {
        var mh$ = SCIPvarGetStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetStatus", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsOriginal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsOriginal$descriptor() {
        return SCIPvarIsOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsOriginal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsOriginal$handle() {
        return SCIPvarIsOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsOriginal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsOriginal$address() {
        return SCIPvarIsOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsOriginal(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsOriginal(MemorySegment var_) {
        var mh$ = SCIPvarIsOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsOriginal", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsTransformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsTransformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformed(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsTransformed$descriptor() {
        return SCIPvarIsTransformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformed(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsTransformed$handle() {
        return SCIPvarIsTransformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformed(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsTransformed$address() {
        return SCIPvarIsTransformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsTransformed(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsTransformed(MemorySegment var_) {
        var mh$ = SCIPvarIsTransformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsTransformed", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsNegated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsNegated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsNegated(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsNegated$descriptor() {
        return SCIPvarIsNegated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsNegated(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsNegated$handle() {
        return SCIPvarIsNegated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsNegated(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsNegated$address() {
        return SCIPvarIsNegated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsNegated(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsNegated(MemorySegment var_) {
        var mh$ = SCIPvarIsNegated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsNegated", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPvarGetType(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetType$descriptor() {
        return SCIPvarGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPvarGetType(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetType$handle() {
        return SCIPvarGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPvarGetType(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetType$address() {
        return SCIPvarGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VARTYPE SCIPvarGetType(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetType(MemorySegment var_) {
        var mh$ = SCIPvarGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetType", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsBinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsBinary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsBinary(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsBinary$descriptor() {
        return SCIPvarIsBinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsBinary(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsBinary$handle() {
        return SCIPvarIsBinary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsBinary(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsBinary$address() {
        return SCIPvarIsBinary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsBinary(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsBinary(MemorySegment var_) {
        var mh$ = SCIPvarIsBinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsBinary", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsIntegral(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsIntegral$descriptor() {
        return SCIPvarIsIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsIntegral(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsIntegral$handle() {
        return SCIPvarIsIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsIntegral(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsIntegral$address() {
        return SCIPvarIsIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsIntegral(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsIntegral(MemorySegment var_) {
        var mh$ = SCIPvarIsIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsIntegral", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsInitial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsInitial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInitial(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsInitial$descriptor() {
        return SCIPvarIsInitial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInitial(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsInitial$handle() {
        return SCIPvarIsInitial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInitial(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsInitial$address() {
        return SCIPvarIsInitial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInitial(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsInitial(MemorySegment var_) {
        var mh$ = SCIPvarIsInitial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsInitial", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsRemovable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsRemovable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRemovable(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsRemovable$descriptor() {
        return SCIPvarIsRemovable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRemovable(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsRemovable$handle() {
        return SCIPvarIsRemovable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRemovable(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsRemovable$address() {
        return SCIPvarIsRemovable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRemovable(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsRemovable(MemorySegment var_) {
        var mh$ = SCIPvarIsRemovable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsRemovable", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsDeleted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsDeleted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeleted(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsDeleted$descriptor() {
        return SCIPvarIsDeleted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeleted(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsDeleted$handle() {
        return SCIPvarIsDeleted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeleted(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsDeleted$address() {
        return SCIPvarIsDeleted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeleted(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsDeleted(MemorySegment var_) {
        var mh$ = SCIPvarIsDeleted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsDeleted", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMarkDeletable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMarkDeletable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeletable(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMarkDeletable$descriptor() {
        return SCIPvarMarkDeletable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeletable(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMarkDeletable$handle() {
        return SCIPvarMarkDeletable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeletable(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMarkDeletable$address() {
        return SCIPvarMarkDeletable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarMarkDeletable(SCIP_VAR *var)
     * }
     */
    public static void SCIPvarMarkDeletable(MemorySegment var_) {
        var mh$ = SCIPvarMarkDeletable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMarkDeletable", var_);
            }
            mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMarkNotDeletable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMarkNotDeletable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarMarkNotDeletable(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMarkNotDeletable$descriptor() {
        return SCIPvarMarkNotDeletable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarMarkNotDeletable(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMarkNotDeletable$handle() {
        return SCIPvarMarkNotDeletable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarMarkNotDeletable(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMarkNotDeletable$address() {
        return SCIPvarMarkNotDeletable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarMarkNotDeletable(SCIP_VAR *var)
     * }
     */
    public static void SCIPvarMarkNotDeletable(MemorySegment var_) {
        var mh$ = SCIPvarMarkNotDeletable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMarkNotDeletable", var_);
            }
            mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsDeletable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsDeletable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeletable(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsDeletable$descriptor() {
        return SCIPvarIsDeletable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeletable(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsDeletable$handle() {
        return SCIPvarIsDeletable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeletable(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsDeletable$address() {
        return SCIPvarIsDeletable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsDeletable(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsDeletable(MemorySegment var_) {
        var mh$ = SCIPvarIsDeletable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsDeletable", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMarkDeleteGlobalStructures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMarkDeleteGlobalStructures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeleteGlobalStructures(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMarkDeleteGlobalStructures$descriptor() {
        return SCIPvarMarkDeleteGlobalStructures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeleteGlobalStructures(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMarkDeleteGlobalStructures$handle() {
        return SCIPvarMarkDeleteGlobalStructures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarMarkDeleteGlobalStructures(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMarkDeleteGlobalStructures$address() {
        return SCIPvarMarkDeleteGlobalStructures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarMarkDeleteGlobalStructures(SCIP_VAR *var)
     * }
     */
    public static void SCIPvarMarkDeleteGlobalStructures(MemorySegment var_) {
        var mh$ = SCIPvarMarkDeleteGlobalStructures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMarkDeleteGlobalStructures", var_);
            }
            mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsActive(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsActive$descriptor() {
        return SCIPvarIsActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsActive(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsActive$handle() {
        return SCIPvarIsActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsActive(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsActive$address() {
        return SCIPvarIsActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsActive(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsActive(MemorySegment var_) {
        var mh$ = SCIPvarIsActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsActive", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetIndex(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetIndex$descriptor() {
        return SCIPvarGetIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetIndex(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetIndex$handle() {
        return SCIPvarGetIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetIndex(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetIndex$address() {
        return SCIPvarGetIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetIndex(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetIndex(MemorySegment var_) {
        var mh$ = SCIPvarGetIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetIndex", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetProbindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetProbindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetProbindex(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetProbindex$descriptor() {
        return SCIPvarGetProbindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetProbindex(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetProbindex$handle() {
        return SCIPvarGetProbindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetProbindex(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetProbindex$address() {
        return SCIPvarGetProbindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetProbindex(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetProbindex(MemorySegment var_) {
        var mh$ = SCIPvarGetProbindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetProbindex", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetTransVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetTransVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetTransVar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetTransVar$descriptor() {
        return SCIPvarGetTransVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetTransVar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetTransVar$handle() {
        return SCIPvarGetTransVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetTransVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetTransVar$address() {
        return SCIPvarGetTransVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetTransVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetTransVar(MemorySegment var_) {
        var mh$ = SCIPvarGetTransVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetTransVar", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetCol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetCol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPvarGetCol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetCol$descriptor() {
        return SCIPvarGetCol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPvarGetCol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetCol$handle() {
        return SCIPvarGetCol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COL *SCIPvarGetCol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetCol$address() {
        return SCIPvarGetCol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COL *SCIPvarGetCol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetCol(MemorySegment var_) {
        var mh$ = SCIPvarGetCol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetCol", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsInLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsInLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInLP(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsInLP$descriptor() {
        return SCIPvarIsInLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInLP(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsInLP$handle() {
        return SCIPvarIsInLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInLP(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsInLP$address() {
        return SCIPvarIsInLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsInLP(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsInLP(MemorySegment var_) {
        var mh$ = SCIPvarIsInLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsInLP", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAggrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAggrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetAggrVar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAggrVar$descriptor() {
        return SCIPvarGetAggrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetAggrVar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetAggrVar$handle() {
        return SCIPvarGetAggrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetAggrVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetAggrVar$address() {
        return SCIPvarGetAggrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetAggrVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetAggrVar(MemorySegment var_) {
        var mh$ = SCIPvarGetAggrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAggrVar", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAggrScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAggrScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrScalar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAggrScalar$descriptor() {
        return SCIPvarGetAggrScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrScalar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetAggrScalar$handle() {
        return SCIPvarGetAggrScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrScalar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetAggrScalar$address() {
        return SCIPvarGetAggrScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetAggrScalar(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetAggrScalar(MemorySegment var_) {
        var mh$ = SCIPvarGetAggrScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAggrScalar", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAggrConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAggrConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrConstant(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAggrConstant$descriptor() {
        return SCIPvarGetAggrConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrConstant(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetAggrConstant$handle() {
        return SCIPvarGetAggrConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetAggrConstant(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetAggrConstant$address() {
        return SCIPvarGetAggrConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetAggrConstant(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetAggrConstant(MemorySegment var_) {
        var mh$ = SCIPvarGetAggrConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAggrConstant", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetMultaggrNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetMultaggrNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetMultaggrNVars(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetMultaggrNVars$descriptor() {
        return SCIPvarGetMultaggrNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetMultaggrNVars(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetMultaggrNVars$handle() {
        return SCIPvarGetMultaggrNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetMultaggrNVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrNVars$address() {
        return SCIPvarGetMultaggrNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetMultaggrNVars(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetMultaggrNVars(MemorySegment var_) {
        var mh$ = SCIPvarGetMultaggrNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetMultaggrNVars", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetMultaggrVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetMultaggrVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetMultaggrVars(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetMultaggrVars$descriptor() {
        return SCIPvarGetMultaggrVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetMultaggrVars(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetMultaggrVars$handle() {
        return SCIPvarGetMultaggrVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetMultaggrVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrVars$address() {
        return SCIPvarGetMultaggrVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetMultaggrVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrVars(MemorySegment var_) {
        var mh$ = SCIPvarGetMultaggrVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetMultaggrVars", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetMultaggrScalars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetMultaggrScalars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetMultaggrScalars(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetMultaggrScalars$descriptor() {
        return SCIPvarGetMultaggrScalars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetMultaggrScalars(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetMultaggrScalars$handle() {
        return SCIPvarGetMultaggrScalars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetMultaggrScalars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrScalars$address() {
        return SCIPvarGetMultaggrScalars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetMultaggrScalars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrScalars(MemorySegment var_) {
        var mh$ = SCIPvarGetMultaggrScalars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetMultaggrScalars", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetMultaggrConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetMultaggrConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetMultaggrConstant(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetMultaggrConstant$descriptor() {
        return SCIPvarGetMultaggrConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetMultaggrConstant(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetMultaggrConstant$handle() {
        return SCIPvarGetMultaggrConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetMultaggrConstant(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetMultaggrConstant$address() {
        return SCIPvarGetMultaggrConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetMultaggrConstant(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetMultaggrConstant(MemorySegment var_) {
        var mh$ = SCIPvarGetMultaggrConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetMultaggrConstant", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNegatedVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNegatedVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegatedVar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNegatedVar$descriptor() {
        return SCIPvarGetNegatedVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegatedVar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNegatedVar$handle() {
        return SCIPvarGetNegatedVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegatedVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNegatedVar$address() {
        return SCIPvarGetNegatedVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegatedVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNegatedVar(MemorySegment var_) {
        var mh$ = SCIPvarGetNegatedVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNegatedVar", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNegationVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNegationVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegationVar(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNegationVar$descriptor() {
        return SCIPvarGetNegationVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegationVar(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNegationVar$handle() {
        return SCIPvarGetNegationVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegationVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNegationVar$address() {
        return SCIPvarGetNegationVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPvarGetNegationVar(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNegationVar(MemorySegment var_) {
        var mh$ = SCIPvarGetNegationVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNegationVar", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNegationConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNegationConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetNegationConstant(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNegationConstant$descriptor() {
        return SCIPvarGetNegationConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetNegationConstant(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNegationConstant$handle() {
        return SCIPvarGetNegationConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetNegationConstant(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNegationConstant$address() {
        return SCIPvarGetNegationConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetNegationConstant(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetNegationConstant(MemorySegment var_) {
        var mh$ = SCIPvarGetNegationConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNegationConstant", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetObj(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetObj$descriptor() {
        return SCIPvarGetObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetObj(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetObj$handle() {
        return SCIPvarGetObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetObj(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetObj$address() {
        return SCIPvarGetObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetObj(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetObj(MemorySegment var_) {
        var mh$ = SCIPvarGetObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetObj", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUnchangedObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUnchangedObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUnchangedObj(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUnchangedObj$descriptor() {
        return SCIPvarGetUnchangedObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUnchangedObj(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetUnchangedObj$handle() {
        return SCIPvarGetUnchangedObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUnchangedObj(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetUnchangedObj$address() {
        return SCIPvarGetUnchangedObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUnchangedObj(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetUnchangedObj(MemorySegment var_) {
        var mh$ = SCIPvarGetUnchangedObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUnchangedObj", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLbOriginal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbOriginal$descriptor() {
        return SCIPvarGetLbOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLbOriginal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLbOriginal$handle() {
        return SCIPvarGetLbOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLbOriginal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLbOriginal$address() {
        return SCIPvarGetLbOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLbOriginal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLbOriginal(MemorySegment var_) {
        var mh$ = SCIPvarGetLbOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbOriginal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUbOriginal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbOriginal$descriptor() {
        return SCIPvarGetUbOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUbOriginal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetUbOriginal$handle() {
        return SCIPvarGetUbOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUbOriginal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetUbOriginal$address() {
        return SCIPvarGetUbOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUbOriginal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetUbOriginal(MemorySegment var_) {
        var mh$ = SCIPvarGetUbOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbOriginal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetHolelistOriginal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetHolelistOriginal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistOriginal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetHolelistOriginal$descriptor() {
        return SCIPvarGetHolelistOriginal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistOriginal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetHolelistOriginal$handle() {
        return SCIPvarGetHolelistOriginal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistOriginal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistOriginal$address() {
        return SCIPvarGetHolelistOriginal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistOriginal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistOriginal(MemorySegment var_) {
        var mh$ = SCIPvarGetHolelistOriginal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetHolelistOriginal", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLbGlobal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbGlobal$descriptor() {
        return SCIPvarGetLbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLbGlobal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLbGlobal$handle() {
        return SCIPvarGetLbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLbGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLbGlobal$address() {
        return SCIPvarGetLbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLbGlobal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLbGlobal(MemorySegment var_) {
        var mh$ = SCIPvarGetLbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbGlobal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUbGlobal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbGlobal$descriptor() {
        return SCIPvarGetUbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUbGlobal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetUbGlobal$handle() {
        return SCIPvarGetUbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUbGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetUbGlobal$address() {
        return SCIPvarGetUbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUbGlobal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetUbGlobal(MemorySegment var_) {
        var mh$ = SCIPvarGetUbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbGlobal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetHolelistGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetHolelistGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistGlobal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetHolelistGlobal$descriptor() {
        return SCIPvarGetHolelistGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistGlobal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetHolelistGlobal$handle() {
        return SCIPvarGetHolelistGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistGlobal$address() {
        return SCIPvarGetHolelistGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistGlobal(MemorySegment var_) {
        var mh$ = SCIPvarGetHolelistGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetHolelistGlobal", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestBoundGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestBoundGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestBoundGlobal$descriptor() {
        return SCIPvarGetBestBoundGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestBoundGlobal$handle() {
        return SCIPvarGetBestBoundGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestBoundGlobal$address() {
        return SCIPvarGetBestBoundGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBestBoundGlobal(MemorySegment var_) {
        var mh$ = SCIPvarGetBestBoundGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestBoundGlobal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetWorstBoundGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetWorstBoundGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetWorstBoundGlobal$descriptor() {
        return SCIPvarGetWorstBoundGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetWorstBoundGlobal$handle() {
        return SCIPvarGetWorstBoundGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetWorstBoundGlobal$address() {
        return SCIPvarGetWorstBoundGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundGlobal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetWorstBoundGlobal(MemorySegment var_) {
        var mh$ = SCIPvarGetWorstBoundGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetWorstBoundGlobal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLocal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbLocal$descriptor() {
        return SCIPvarGetLbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLocal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLbLocal$handle() {
        return SCIPvarGetLbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLbLocal$address() {
        return SCIPvarGetLbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLbLocal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLbLocal(MemorySegment var_) {
        var mh$ = SCIPvarGetLbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbLocal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLocal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbLocal$descriptor() {
        return SCIPvarGetUbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLocal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetUbLocal$handle() {
        return SCIPvarGetUbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetUbLocal$address() {
        return SCIPvarGetUbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUbLocal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetUbLocal(MemorySegment var_) {
        var mh$ = SCIPvarGetUbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbLocal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetHolelistLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetHolelistLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistLocal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetHolelistLocal$descriptor() {
        return SCIPvarGetHolelistLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistLocal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetHolelistLocal$handle() {
        return SCIPvarGetHolelistLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistLocal$address() {
        return SCIPvarGetHolelistLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPvarGetHolelistLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetHolelistLocal(MemorySegment var_) {
        var mh$ = SCIPvarGetHolelistLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetHolelistLocal", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestBoundLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestBoundLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundLocal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestBoundLocal$descriptor() {
        return SCIPvarGetBestBoundLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundLocal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestBoundLocal$handle() {
        return SCIPvarGetBestBoundLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestBoundLocal$address() {
        return SCIPvarGetBestBoundLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBestBoundLocal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBestBoundLocal(MemorySegment var_) {
        var mh$ = SCIPvarGetBestBoundLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestBoundLocal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetWorstBoundLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetWorstBoundLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundLocal(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetWorstBoundLocal$descriptor() {
        return SCIPvarGetWorstBoundLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundLocal(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetWorstBoundLocal$handle() {
        return SCIPvarGetWorstBoundLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundLocal(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetWorstBoundLocal$address() {
        return SCIPvarGetWorstBoundLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetWorstBoundLocal(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetWorstBoundLocal(MemorySegment var_) {
        var mh$ = SCIPvarGetWorstBoundLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetWorstBoundLocal", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestBoundType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestBoundType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetBestBoundType(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestBoundType$descriptor() {
        return SCIPvarGetBestBoundType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetBestBoundType(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestBoundType$handle() {
        return SCIPvarGetBestBoundType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetBestBoundType(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestBoundType$address() {
        return SCIPvarGetBestBoundType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetBestBoundType(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetBestBoundType(MemorySegment var_) {
        var mh$ = SCIPvarGetBestBoundType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestBoundType", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetWorstBoundType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetWorstBoundType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetWorstBoundType(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetWorstBoundType$descriptor() {
        return SCIPvarGetWorstBoundType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetWorstBoundType(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetWorstBoundType$handle() {
        return SCIPvarGetWorstBoundType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetWorstBoundType(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetWorstBoundType$address() {
        return SCIPvarGetWorstBoundType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPvarGetWorstBoundType(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetWorstBoundType(MemorySegment var_) {
        var mh$ = SCIPvarGetWorstBoundType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetWorstBoundType", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbLazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbLazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLazy(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbLazy$descriptor() {
        return SCIPvarGetLbLazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLazy(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLbLazy$handle() {
        return SCIPvarGetLbLazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLbLazy(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLbLazy$address() {
        return SCIPvarGetLbLazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLbLazy(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLbLazy(MemorySegment var_) {
        var mh$ = SCIPvarGetLbLazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbLazy", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbLazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbLazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLazy(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbLazy$descriptor() {
        return SCIPvarGetUbLazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLazy(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetUbLazy$handle() {
        return SCIPvarGetUbLazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUbLazy(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetUbLazy$address() {
        return SCIPvarGetUbLazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUbLazy(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetUbLazy(MemorySegment var_) {
        var mh$ = SCIPvarGetUbLazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbLazy", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBranchFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBranchFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBranchFactor(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBranchFactor$descriptor() {
        return SCIPvarGetBranchFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBranchFactor(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBranchFactor$handle() {
        return SCIPvarGetBranchFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBranchFactor(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBranchFactor$address() {
        return SCIPvarGetBranchFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBranchFactor(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBranchFactor(MemorySegment var_) {
        var mh$ = SCIPvarGetBranchFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBranchFactor", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBranchPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBranchPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetBranchPriority(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBranchPriority$descriptor() {
        return SCIPvarGetBranchPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetBranchPriority(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBranchPriority$handle() {
        return SCIPvarGetBranchPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetBranchPriority(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBranchPriority$address() {
        return SCIPvarGetBranchPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetBranchPriority(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetBranchPriority(MemorySegment var_) {
        var mh$ = SCIPvarGetBranchPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBranchPriority", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBranchDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBranchDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BRANCHDIR SCIPvarGetBranchDirection(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBranchDirection$descriptor() {
        return SCIPvarGetBranchDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BRANCHDIR SCIPvarGetBranchDirection(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBranchDirection$handle() {
        return SCIPvarGetBranchDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BRANCHDIR SCIPvarGetBranchDirection(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBranchDirection$address() {
        return SCIPvarGetBranchDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BRANCHDIR SCIPvarGetBranchDirection(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetBranchDirection(MemorySegment var_) {
        var mh$ = SCIPvarGetBranchDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBranchDirection", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNVlbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNVlbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNVlbs(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNVlbs$descriptor() {
        return SCIPvarGetNVlbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNVlbs(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNVlbs$handle() {
        return SCIPvarGetNVlbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNVlbs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNVlbs$address() {
        return SCIPvarGetNVlbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNVlbs(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNVlbs(MemorySegment var_) {
        var mh$ = SCIPvarGetNVlbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNVlbs", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVlbVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVlbVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVlbVars(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVlbVars$descriptor() {
        return SCIPvarGetVlbVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVlbVars(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVlbVars$handle() {
        return SCIPvarGetVlbVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVlbVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbVars$address() {
        return SCIPvarGetVlbVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVlbVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbVars(MemorySegment var_) {
        var mh$ = SCIPvarGetVlbVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVlbVars", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVlbCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVlbCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbCoefs(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVlbCoefs$descriptor() {
        return SCIPvarGetVlbCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbCoefs(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVlbCoefs$handle() {
        return SCIPvarGetVlbCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbCoefs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbCoefs$address() {
        return SCIPvarGetVlbCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetVlbCoefs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbCoefs(MemorySegment var_) {
        var mh$ = SCIPvarGetVlbCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVlbCoefs", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVlbConstants {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVlbConstants");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbConstants(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVlbConstants$descriptor() {
        return SCIPvarGetVlbConstants.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbConstants(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVlbConstants$handle() {
        return SCIPvarGetVlbConstants.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetVlbConstants(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbConstants$address() {
        return SCIPvarGetVlbConstants.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetVlbConstants(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVlbConstants(MemorySegment var_) {
        var mh$ = SCIPvarGetVlbConstants.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVlbConstants", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNVubs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNVubs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNVubs(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNVubs$descriptor() {
        return SCIPvarGetNVubs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNVubs(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNVubs$handle() {
        return SCIPvarGetNVubs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNVubs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNVubs$address() {
        return SCIPvarGetNVubs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNVubs(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNVubs(MemorySegment var_) {
        var mh$ = SCIPvarGetNVubs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNVubs", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVubVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVubVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVubVars(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVubVars$descriptor() {
        return SCIPvarGetVubVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVubVars(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVubVars$handle() {
        return SCIPvarGetVubVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVubVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubVars$address() {
        return SCIPvarGetVubVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetVubVars(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubVars(MemorySegment var_) {
        var mh$ = SCIPvarGetVubVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVubVars", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVubCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVubCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubCoefs(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVubCoefs$descriptor() {
        return SCIPvarGetVubCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubCoefs(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVubCoefs$handle() {
        return SCIPvarGetVubCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubCoefs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubCoefs$address() {
        return SCIPvarGetVubCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetVubCoefs(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubCoefs(MemorySegment var_) {
        var mh$ = SCIPvarGetVubCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVubCoefs", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetVubConstants {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetVubConstants");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubConstants(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetVubConstants$descriptor() {
        return SCIPvarGetVubConstants.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubConstants(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetVubConstants$handle() {
        return SCIPvarGetVubConstants.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetVubConstants(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubConstants$address() {
        return SCIPvarGetVubConstants.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetVubConstants(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetVubConstants(MemorySegment var_) {
        var mh$ = SCIPvarGetVubConstants.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetVubConstants", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNImpls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNImpls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNImpls(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNImpls$descriptor() {
        return SCIPvarGetNImpls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNImpls(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetNImpls$handle() {
        return SCIPvarGetNImpls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNImpls(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetNImpls$address() {
        return SCIPvarGetNImpls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNImpls(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static int SCIPvarGetNImpls(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetNImpls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNImpls", var_, varfixing);
            }
            return (int)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetImplVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetImplVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetImplVars(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetImplVars$descriptor() {
        return SCIPvarGetImplVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetImplVars(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetImplVars$handle() {
        return SCIPvarGetImplVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetImplVars(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplVars$address() {
        return SCIPvarGetImplVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPvarGetImplVars(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplVars(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetImplVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetImplVars", var_, varfixing);
            }
            return (MemorySegment)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetImplTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetImplTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPvarGetImplTypes(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetImplTypes$descriptor() {
        return SCIPvarGetImplTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPvarGetImplTypes(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetImplTypes$handle() {
        return SCIPvarGetImplTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPvarGetImplTypes(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplTypes$address() {
        return SCIPvarGetImplTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPvarGetImplTypes(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplTypes(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetImplTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetImplTypes", var_, varfixing);
            }
            return (MemorySegment)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetImplBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetImplBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPvarGetImplBounds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetImplBounds$descriptor() {
        return SCIPvarGetImplBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPvarGetImplBounds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetImplBounds$handle() {
        return SCIPvarGetImplBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPvarGetImplBounds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplBounds$address() {
        return SCIPvarGetImplBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPvarGetImplBounds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplBounds(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetImplBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetImplBounds", var_, varfixing);
            }
            return (MemorySegment)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetImplIds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetImplIds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPvarGetImplIds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetImplIds$descriptor() {
        return SCIPvarGetImplIds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPvarGetImplIds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetImplIds$handle() {
        return SCIPvarGetImplIds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPvarGetImplIds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplIds$address() {
        return SCIPvarGetImplIds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPvarGetImplIds(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetImplIds(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetImplIds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetImplIds", var_, varfixing);
            }
            return (MemorySegment)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNCliques$descriptor() {
        return SCIPvarGetNCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetNCliques$handle() {
        return SCIPvarGetNCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetNCliques$address() {
        return SCIPvarGetNCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static int SCIPvarGetNCliques(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetNCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNCliques", var_, varfixing);
            }
            return (int)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPvarGetCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPvarGetCliques$descriptor() {
        return SCIPvarGetCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPvarGetCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPvarGetCliques$handle() {
        return SCIPvarGetCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPvarGetCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetCliques$address() {
        return SCIPvarGetCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPvarGetCliques(SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPvarGetCliques(MemorySegment var_, int varfixing) {
        var mh$ = SCIPvarGetCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetCliques", var_, varfixing);
            }
            return (MemorySegment)mh$.invokeExact(var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLPSol$descriptor() {
        return SCIPvarGetLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLPSol$handle() {
        return SCIPvarGetLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLPSol$address() {
        return SCIPvarGetLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLPSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLPSol(MemorySegment var_) {
        var mh$ = SCIPvarGetLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLPSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLPSol$descriptor() {
        return SCIPvarGetNLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNLPSol$handle() {
        return SCIPvarGetNLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNLPSol$address() {
        return SCIPvarGetNLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetNLPSol(MemorySegment var_) {
        var mh$ = SCIPvarGetNLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLPSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBdchgInfoLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBdchgInfoLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoLb(SCIP_VAR *var, int pos)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBdchgInfoLb$descriptor() {
        return SCIPvarGetBdchgInfoLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoLb(SCIP_VAR *var, int pos)
     * }
     */
    public static MethodHandle SCIPvarGetBdchgInfoLb$handle() {
        return SCIPvarGetBdchgInfoLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoLb(SCIP_VAR *var, int pos)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfoLb$address() {
        return SCIPvarGetBdchgInfoLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoLb(SCIP_VAR *var, int pos)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfoLb(MemorySegment var_, int pos) {
        var mh$ = SCIPvarGetBdchgInfoLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBdchgInfoLb", var_, pos);
            }
            return (MemorySegment)mh$.invokeExact(var_, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNBdchgInfosLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNBdchgInfosLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosLb(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNBdchgInfosLb$descriptor() {
        return SCIPvarGetNBdchgInfosLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosLb(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNBdchgInfosLb$handle() {
        return SCIPvarGetNBdchgInfosLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosLb(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNBdchgInfosLb$address() {
        return SCIPvarGetNBdchgInfosLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosLb(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNBdchgInfosLb(MemorySegment var_) {
        var mh$ = SCIPvarGetNBdchgInfosLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNBdchgInfosLb", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBdchgInfoUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBdchgInfoUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoUb(SCIP_VAR *var, int pos)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBdchgInfoUb$descriptor() {
        return SCIPvarGetBdchgInfoUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoUb(SCIP_VAR *var, int pos)
     * }
     */
    public static MethodHandle SCIPvarGetBdchgInfoUb$handle() {
        return SCIPvarGetBdchgInfoUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoUb(SCIP_VAR *var, int pos)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfoUb$address() {
        return SCIPvarGetBdchgInfoUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfoUb(SCIP_VAR *var, int pos)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfoUb(MemorySegment var_, int pos) {
        var mh$ = SCIPvarGetBdchgInfoUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBdchgInfoUb", var_, pos);
            }
            return (MemorySegment)mh$.invokeExact(var_, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNBdchgInfosUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNBdchgInfosUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosUb(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNBdchgInfosUb$descriptor() {
        return SCIPvarGetNBdchgInfosUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosUb(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNBdchgInfosUb$handle() {
        return SCIPvarGetNBdchgInfosUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosUb(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNBdchgInfosUb$address() {
        return SCIPvarGetNBdchgInfosUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNBdchgInfosUb(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNBdchgInfosUb(MemorySegment var_) {
        var mh$ = SCIPvarGetNBdchgInfosUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNBdchgInfosUb", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetValuehistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetValuehistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VALUEHISTORY *SCIPvarGetValuehistory(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetValuehistory$descriptor() {
        return SCIPvarGetValuehistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VALUEHISTORY *SCIPvarGetValuehistory(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetValuehistory$handle() {
        return SCIPvarGetValuehistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VALUEHISTORY *SCIPvarGetValuehistory(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetValuehistory$address() {
        return SCIPvarGetValuehistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VALUEHISTORY *SCIPvarGetValuehistory(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetValuehistory(MemorySegment var_) {
        var mh$ = SCIPvarGetValuehistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetValuehistory", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsRelaxationOnly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsRelaxationOnly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsRelaxationOnly$descriptor() {
        return SCIPvarIsRelaxationOnly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsRelaxationOnly$handle() {
        return SCIPvarIsRelaxationOnly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsRelaxationOnly$address() {
        return SCIPvarIsRelaxationOnly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsRelaxationOnly(MemorySegment var_) {
        var mh$ = SCIPvarIsRelaxationOnly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsRelaxationOnly", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarMarkRelaxationOnly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarMarkRelaxationOnly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarMarkRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarMarkRelaxationOnly$descriptor() {
        return SCIPvarMarkRelaxationOnly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarMarkRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarMarkRelaxationOnly$handle() {
        return SCIPvarMarkRelaxationOnly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarMarkRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarMarkRelaxationOnly$address() {
        return SCIPvarMarkRelaxationOnly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarMarkRelaxationOnly(SCIP_VAR *var)
     * }
     */
    public static void SCIPvarMarkRelaxationOnly(MemorySegment var_) {
        var mh$ = SCIPvarMarkRelaxationOnly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarMarkRelaxationOnly", var_);
            }
            mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLPSol_rec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLPSol_rec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLPSol_rec$descriptor() {
        return SCIPvarGetLPSol_rec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLPSol_rec$handle() {
        return SCIPvarGetLPSol_rec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLPSol_rec$address() {
        return SCIPvarGetLPSol_rec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetLPSol_rec(MemorySegment var_) {
        var mh$ = SCIPvarGetLPSol_rec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLPSol_rec", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNLPSol_rec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNLPSol_rec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNLPSol_rec$descriptor() {
        return SCIPvarGetNLPSol_rec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNLPSol_rec$handle() {
        return SCIPvarGetNLPSol_rec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNLPSol_rec$address() {
        return SCIPvarGetNLPSol_rec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetNLPSol_rec(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetNLPSol_rec(MemorySegment var_) {
        var mh$ = SCIPvarGetNLPSol_rec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNLPSol_rec", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetPseudoSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetPseudoSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetPseudoSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetPseudoSol$descriptor() {
        return SCIPvarGetPseudoSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetPseudoSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetPseudoSol$handle() {
        return SCIPvarGetPseudoSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetPseudoSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetPseudoSol$address() {
        return SCIPvarGetPseudoSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetPseudoSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetPseudoSol(MemorySegment var_) {
        var mh$ = SCIPvarGetPseudoSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetPseudoSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetSol(SCIP_VAR *var, unsigned int getlpval)
     * }
     */
    public static FunctionDescriptor SCIPvarGetSol$descriptor() {
        return SCIPvarGetSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetSol(SCIP_VAR *var, unsigned int getlpval)
     * }
     */
    public static MethodHandle SCIPvarGetSol$handle() {
        return SCIPvarGetSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetSol(SCIP_VAR *var, unsigned int getlpval)
     * }
     */
    public static MemorySegment SCIPvarGetSol$address() {
        return SCIPvarGetSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetSol(SCIP_VAR *var, unsigned int getlpval)
     * }
     */
    public static double SCIPvarGetSol(MemorySegment var_, int getlpval) {
        var mh$ = SCIPvarGetSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetSol", var_, getlpval);
            }
            return (double)mh$.invokeExact(var_, getlpval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetRootSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetRootSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetRootSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetRootSol$descriptor() {
        return SCIPvarGetRootSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetRootSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetRootSol$handle() {
        return SCIPvarGetRootSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetRootSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetRootSol$address() {
        return SCIPvarGetRootSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetRootSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetRootSol(MemorySegment var_) {
        var mh$ = SCIPvarGetRootSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetRootSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestRootSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestRootSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestRootSol$descriptor() {
        return SCIPvarGetBestRootSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestRootSol$handle() {
        return SCIPvarGetBestRootSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestRootSol$address() {
        return SCIPvarGetBestRootSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBestRootSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBestRootSol(MemorySegment var_) {
        var mh$ = SCIPvarGetBestRootSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestRootSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestRootRedcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestRootRedcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootRedcost(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestRootRedcost$descriptor() {
        return SCIPvarGetBestRootRedcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootRedcost(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestRootRedcost$handle() {
        return SCIPvarGetBestRootRedcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootRedcost(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestRootRedcost$address() {
        return SCIPvarGetBestRootRedcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBestRootRedcost(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBestRootRedcost(MemorySegment var_) {
        var mh$ = SCIPvarGetBestRootRedcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestRootRedcost", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBestRootLPObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBestRootLPObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootLPObjval(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBestRootLPObjval$descriptor() {
        return SCIPvarGetBestRootLPObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootLPObjval(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetBestRootLPObjval$handle() {
        return SCIPvarGetBestRootLPObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBestRootLPObjval(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetBestRootLPObjval$address() {
        return SCIPvarGetBestRootLPObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBestRootLPObjval(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetBestRootLPObjval(MemorySegment var_) {
        var mh$ = SCIPvarGetBestRootLPObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBestRootLPObjval", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarSetBestRootSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarSetBestRootSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarSetBestRootSol(SCIP_VAR *var, double rootsol, double rootredcost, double rootlpobjval)
     * }
     */
    public static FunctionDescriptor SCIPvarSetBestRootSol$descriptor() {
        return SCIPvarSetBestRootSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarSetBestRootSol(SCIP_VAR *var, double rootsol, double rootredcost, double rootlpobjval)
     * }
     */
    public static MethodHandle SCIPvarSetBestRootSol$handle() {
        return SCIPvarSetBestRootSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarSetBestRootSol(SCIP_VAR *var, double rootsol, double rootredcost, double rootlpobjval)
     * }
     */
    public static MemorySegment SCIPvarSetBestRootSol$address() {
        return SCIPvarSetBestRootSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarSetBestRootSol(SCIP_VAR *var, double rootsol, double rootredcost, double rootlpobjval)
     * }
     */
    public static void SCIPvarSetBestRootSol(MemorySegment var_, double rootsol, double rootredcost, double rootlpobjval) {
        var mh$ = SCIPvarSetBestRootSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarSetBestRootSol", var_, rootsol, rootredcost, rootlpobjval);
            }
            mh$.invokeExact(var_, rootsol, rootredcost, rootlpobjval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetAvgSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetAvgSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgSol(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetAvgSol$descriptor() {
        return SCIPvarGetAvgSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgSol(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetAvgSol$handle() {
        return SCIPvarGetAvgSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetAvgSol(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetAvgSol$address() {
        return SCIPvarGetAvgSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetAvgSol(SCIP_VAR *var)
     * }
     */
    public static double SCIPvarGetAvgSol(MemorySegment var_) {
        var mh$ = SCIPvarGetAvgSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetAvgSol", var_);
            }
            return (double)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbchgInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbchgInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetLbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbchgInfo$descriptor() {
        return SCIPvarGetLbchgInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetLbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetLbchgInfo$handle() {
        return SCIPvarGetLbchgInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetLbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetLbchgInfo$address() {
        return SCIPvarGetLbchgInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetLbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetLbchgInfo(MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetLbchgInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbchgInfo", var_, bdchgidx, after);
            }
            return (MemorySegment)mh$.invokeExact(var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbchgInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbchgInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetUbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbchgInfo$descriptor() {
        return SCIPvarGetUbchgInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetUbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetUbchgInfo$handle() {
        return SCIPvarGetUbchgInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetUbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetUbchgInfo$address() {
        return SCIPvarGetUbchgInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetUbchgInfo(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetUbchgInfo(MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetUbchgInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbchgInfo", var_, bdchgidx, after);
            }
            return (MemorySegment)mh$.invokeExact(var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBdchgInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBdchgInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfo(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBdchgInfo$descriptor() {
        return SCIPvarGetBdchgInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfo(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetBdchgInfo$handle() {
        return SCIPvarGetBdchgInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfo(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfo$address() {
        return SCIPvarGetBdchgInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGINFO *SCIPvarGetBdchgInfo(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetBdchgInfo(MemorySegment var_, int boundtype, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetBdchgInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBdchgInfo", var_, boundtype, bdchgidx, after);
            }
            return (MemorySegment)mh$.invokeExact(var_, boundtype, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLbAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLbAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetLbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLbAtIndex$descriptor() {
        return SCIPvarGetLbAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetLbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetLbAtIndex$handle() {
        return SCIPvarGetLbAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetLbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetLbAtIndex$address() {
        return SCIPvarGetLbAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetLbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPvarGetLbAtIndex(MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetLbAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLbAtIndex", var_, bdchgidx, after);
            }
            return (double)mh$.invokeExact(var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetUbAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetUbAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetUbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetUbAtIndex$descriptor() {
        return SCIPvarGetUbAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetUbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetUbAtIndex$handle() {
        return SCIPvarGetUbAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetUbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetUbAtIndex$address() {
        return SCIPvarGetUbAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetUbAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPvarGetUbAtIndex(MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetUbAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetUbAtIndex", var_, bdchgidx, after);
            }
            return (double)mh$.invokeExact(var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetBdAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetBdAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPvarGetBdAtIndex(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarGetBdAtIndex$descriptor() {
        return SCIPvarGetBdAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPvarGetBdAtIndex(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarGetBdAtIndex$handle() {
        return SCIPvarGetBdAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPvarGetBdAtIndex(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarGetBdAtIndex$address() {
        return SCIPvarGetBdAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPvarGetBdAtIndex(SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPvarGetBdAtIndex(MemorySegment var_, int boundtype, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarGetBdAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetBdAtIndex", var_, boundtype, bdchgidx, after);
            }
            return (double)mh$.invokeExact(var_, boundtype, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarWasFixedAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarWasFixedAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPvarWasFixedAtIndex$descriptor() {
        return SCIPvarWasFixedAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPvarWasFixedAtIndex$handle() {
        return SCIPvarWasFixedAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPvarWasFixedAtIndex$address() {
        return SCIPvarWasFixedAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedAtIndex(SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static int SCIPvarWasFixedAtIndex(MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPvarWasFixedAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarWasFixedAtIndex", var_, bdchgidx, after);
            }
            return (int)mh$.invokeExact(var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLastBdchgIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLastBdchgIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPvarGetLastBdchgIndex(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLastBdchgIndex$descriptor() {
        return SCIPvarGetLastBdchgIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPvarGetLastBdchgIndex(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLastBdchgIndex$handle() {
        return SCIPvarGetLastBdchgIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPvarGetLastBdchgIndex(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLastBdchgIndex$address() {
        return SCIPvarGetLastBdchgIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPvarGetLastBdchgIndex(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLastBdchgIndex(MemorySegment var_) {
        var mh$ = SCIPvarGetLastBdchgIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLastBdchgIndex", var_);
            }
            return (MemorySegment)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetLastBdchgDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetLastBdchgDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetLastBdchgDepth(SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetLastBdchgDepth$descriptor() {
        return SCIPvarGetLastBdchgDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetLastBdchgDepth(SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetLastBdchgDepth$handle() {
        return SCIPvarGetLastBdchgDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetLastBdchgDepth(SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetLastBdchgDepth$address() {
        return SCIPvarGetLastBdchgDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetLastBdchgDepth(SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetLastBdchgDepth(MemorySegment var_) {
        var mh$ = SCIPvarGetLastBdchgDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetLastBdchgDepth", var_);
            }
            return (int)mh$.invokeExact(var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarWasFixedEarlier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarWasFixedEarlier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedEarlier(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static FunctionDescriptor SCIPvarWasFixedEarlier$descriptor() {
        return SCIPvarWasFixedEarlier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedEarlier(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MethodHandle SCIPvarWasFixedEarlier$handle() {
        return SCIPvarWasFixedEarlier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedEarlier(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static MemorySegment SCIPvarWasFixedEarlier$address() {
        return SCIPvarWasFixedEarlier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarWasFixedEarlier(SCIP_VAR *var1, SCIP_VAR *var2)
     * }
     */
    public static int SCIPvarWasFixedEarlier(MemorySegment var1, MemorySegment var2) {
        var mh$ = SCIPvarWasFixedEarlier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarWasFixedEarlier", var1, var2);
            }
            return (int)mh$.invokeExact(var1, var2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchgidxIsEarlier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchgidxIsEarlier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlier(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static FunctionDescriptor SCIPbdchgidxIsEarlier$descriptor() {
        return SCIPbdchgidxIsEarlier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlier(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static MethodHandle SCIPbdchgidxIsEarlier$handle() {
        return SCIPbdchgidxIsEarlier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlier(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static MemorySegment SCIPbdchgidxIsEarlier$address() {
        return SCIPbdchgidxIsEarlier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlier(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static int SCIPbdchgidxIsEarlier(MemorySegment bdchgidx1, MemorySegment bdchgidx2) {
        var mh$ = SCIPbdchgidxIsEarlier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchgidxIsEarlier", bdchgidx1, bdchgidx2);
            }
            return (int)mh$.invokeExact(bdchgidx1, bdchgidx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchgidxIsEarlierNonNull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchgidxIsEarlierNonNull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlierNonNull(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static FunctionDescriptor SCIPbdchgidxIsEarlierNonNull$descriptor() {
        return SCIPbdchgidxIsEarlierNonNull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlierNonNull(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static MethodHandle SCIPbdchgidxIsEarlierNonNull$handle() {
        return SCIPbdchgidxIsEarlierNonNull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlierNonNull(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static MemorySegment SCIPbdchgidxIsEarlierNonNull$address() {
        return SCIPbdchgidxIsEarlierNonNull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbdchgidxIsEarlierNonNull(SCIP_BDCHGIDX *bdchgidx1, SCIP_BDCHGIDX *bdchgidx2)
     * }
     */
    public static int SCIPbdchgidxIsEarlierNonNull(MemorySegment bdchgidx1, MemorySegment bdchgidx2) {
        var mh$ = SCIPbdchgidxIsEarlierNonNull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchgidxIsEarlierNonNull", bdchgidx1, bdchgidx2);
            }
            return (int)mh$.invokeExact(bdchgidx1, bdchgidx2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetOldbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetOldbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetOldbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetOldbound$descriptor() {
        return SCIPbdchginfoGetOldbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetOldbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetOldbound$handle() {
        return SCIPbdchginfoGetOldbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetOldbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetOldbound$address() {
        return SCIPbdchginfoGetOldbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbdchginfoGetOldbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static double SCIPbdchginfoGetOldbound(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetOldbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetOldbound", bdchginfo);
            }
            return (double)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetNewbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetNewbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetNewbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetNewbound$descriptor() {
        return SCIPbdchginfoGetNewbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetNewbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetNewbound$handle() {
        return SCIPbdchginfoGetNewbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbdchginfoGetNewbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetNewbound$address() {
        return SCIPbdchginfoGetNewbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbdchginfoGetNewbound(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static double SCIPbdchginfoGetNewbound(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetNewbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetNewbound", bdchginfo);
            }
            return (double)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetVar$descriptor() {
        return SCIPbdchginfoGetVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetVar$handle() {
        return SCIPbdchginfoGetVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetVar$address() {
        return SCIPbdchginfoGetVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetVar(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetVar", bdchginfo);
            }
            return (MemorySegment)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetChgtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetChgtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPbdchginfoGetChgtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetChgtype$descriptor() {
        return SCIPbdchginfoGetChgtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPbdchginfoGetChgtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetChgtype$handle() {
        return SCIPbdchginfoGetChgtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPbdchginfoGetChgtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetChgtype$address() {
        return SCIPbdchginfoGetChgtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPbdchginfoGetChgtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetChgtype(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetChgtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetChgtype", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetBoundtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetBoundtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetBoundtype$descriptor() {
        return SCIPbdchginfoGetBoundtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetBoundtype$handle() {
        return SCIPbdchginfoGetBoundtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetBoundtype$address() {
        return SCIPbdchginfoGetBoundtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetBoundtype(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetBoundtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetBoundtype", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetDepth(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetDepth$descriptor() {
        return SCIPbdchginfoGetDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetDepth(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetDepth$handle() {
        return SCIPbdchginfoGetDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetDepth(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetDepth$address() {
        return SCIPbdchginfoGetDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbdchginfoGetDepth(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetDepth(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetDepth", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetPos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetPos(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetPos$descriptor() {
        return SCIPbdchginfoGetPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetPos(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetPos$handle() {
        return SCIPbdchginfoGetPos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetPos(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetPos$address() {
        return SCIPbdchginfoGetPos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbdchginfoGetPos(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetPos(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetPos", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPbdchginfoGetIdx(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetIdx$descriptor() {
        return SCIPbdchginfoGetIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPbdchginfoGetIdx(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetIdx$handle() {
        return SCIPbdchginfoGetIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPbdchginfoGetIdx(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetIdx$address() {
        return SCIPbdchginfoGetIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BDCHGIDX *SCIPbdchginfoGetIdx(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetIdx(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetIdx", bdchginfo);
            }
            return (MemorySegment)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetInferVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetInferVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetInferVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetInferVar$descriptor() {
        return SCIPbdchginfoGetInferVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetInferVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetInferVar$handle() {
        return SCIPbdchginfoGetInferVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetInferVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferVar$address() {
        return SCIPbdchginfoGetInferVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPbdchginfoGetInferVar(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferVar(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetInferVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetInferVar", bdchginfo);
            }
            return (MemorySegment)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetInferCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetInferCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPbdchginfoGetInferCons(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetInferCons$descriptor() {
        return SCIPbdchginfoGetInferCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPbdchginfoGetInferCons(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetInferCons$handle() {
        return SCIPbdchginfoGetInferCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPbdchginfoGetInferCons(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferCons$address() {
        return SCIPbdchginfoGetInferCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPbdchginfoGetInferCons(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferCons(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetInferCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetInferCons", bdchginfo);
            }
            return (MemorySegment)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetInferProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetInferProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPbdchginfoGetInferProp(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetInferProp$descriptor() {
        return SCIPbdchginfoGetInferProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPbdchginfoGetInferProp(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetInferProp$handle() {
        return SCIPbdchginfoGetInferProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPbdchginfoGetInferProp(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferProp$address() {
        return SCIPbdchginfoGetInferProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROP *SCIPbdchginfoGetInferProp(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferProp(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetInferProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetInferProp", bdchginfo);
            }
            return (MemorySegment)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetInferInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetInferInfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetInferInfo(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetInferInfo$descriptor() {
        return SCIPbdchginfoGetInferInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetInferInfo(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetInferInfo$handle() {
        return SCIPbdchginfoGetInferInfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPbdchginfoGetInferInfo(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferInfo$address() {
        return SCIPbdchginfoGetInferInfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPbdchginfoGetInferInfo(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetInferInfo(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetInferInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetInferInfo", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoGetInferBoundtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoGetInferBoundtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetInferBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoGetInferBoundtype$descriptor() {
        return SCIPbdchginfoGetInferBoundtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetInferBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoGetInferBoundtype$handle() {
        return SCIPbdchginfoGetInferBoundtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetInferBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoGetInferBoundtype$address() {
        return SCIPbdchginfoGetInferBoundtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPbdchginfoGetInferBoundtype(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoGetInferBoundtype(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoGetInferBoundtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoGetInferBoundtype", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoIsRedundant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoIsRedundant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsRedundant(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoIsRedundant$descriptor() {
        return SCIPbdchginfoIsRedundant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsRedundant(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoIsRedundant$handle() {
        return SCIPbdchginfoIsRedundant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsRedundant(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoIsRedundant$address() {
        return SCIPbdchginfoIsRedundant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsRedundant(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoIsRedundant(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoIsRedundant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoIsRedundant", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoHasInferenceReason {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoHasInferenceReason");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoHasInferenceReason(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoHasInferenceReason$descriptor() {
        return SCIPbdchginfoHasInferenceReason.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoHasInferenceReason(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MethodHandle SCIPbdchginfoHasInferenceReason$handle() {
        return SCIPbdchginfoHasInferenceReason.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoHasInferenceReason(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static MemorySegment SCIPbdchginfoHasInferenceReason$address() {
        return SCIPbdchginfoHasInferenceReason.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoHasInferenceReason(SCIP_BDCHGINFO *bdchginfo)
     * }
     */
    public static int SCIPbdchginfoHasInferenceReason(MemorySegment bdchginfo) {
        var mh$ = SCIPbdchginfoHasInferenceReason.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoHasInferenceReason", bdchginfo);
            }
            return (int)mh$.invokeExact(bdchginfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbdchginfoIsTighter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbdchginfoIsTighter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsTighter(SCIP_BDCHGINFO *bdchginfo1, SCIP_BDCHGINFO *bdchginfo2)
     * }
     */
    public static FunctionDescriptor SCIPbdchginfoIsTighter$descriptor() {
        return SCIPbdchginfoIsTighter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsTighter(SCIP_BDCHGINFO *bdchginfo1, SCIP_BDCHGINFO *bdchginfo2)
     * }
     */
    public static MethodHandle SCIPbdchginfoIsTighter$handle() {
        return SCIPbdchginfoIsTighter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsTighter(SCIP_BDCHGINFO *bdchginfo1, SCIP_BDCHGINFO *bdchginfo2)
     * }
     */
    public static MemorySegment SCIPbdchginfoIsTighter$address() {
        return SCIPbdchginfoIsTighter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPbdchginfoIsTighter(SCIP_BDCHGINFO *bdchginfo1, SCIP_BDCHGINFO *bdchginfo2)
     * }
     */
    public static int SCIPbdchginfoIsTighter(MemorySegment bdchginfo1, MemorySegment bdchginfo2) {
        var mh$ = SCIPbdchginfoIsTighter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbdchginfoIsTighter", bdchginfo1, bdchginfo2);
            }
            return (int)mh$.invokeExact(bdchginfo1, bdchginfo2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPboundchgGetNewbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPboundchgGetNewbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPboundchgGetNewbound(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static FunctionDescriptor SCIPboundchgGetNewbound$descriptor() {
        return SCIPboundchgGetNewbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPboundchgGetNewbound(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MethodHandle SCIPboundchgGetNewbound$handle() {
        return SCIPboundchgGetNewbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPboundchgGetNewbound(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgGetNewbound$address() {
        return SCIPboundchgGetNewbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPboundchgGetNewbound(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static double SCIPboundchgGetNewbound(MemorySegment boundchg) {
        var mh$ = SCIPboundchgGetNewbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPboundchgGetNewbound", boundchg);
            }
            return (double)mh$.invokeExact(boundchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPboundchgGetVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPboundchgGetVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPboundchgGetVar(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static FunctionDescriptor SCIPboundchgGetVar$descriptor() {
        return SCIPboundchgGetVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPboundchgGetVar(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MethodHandle SCIPboundchgGetVar$handle() {
        return SCIPboundchgGetVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPboundchgGetVar(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgGetVar$address() {
        return SCIPboundchgGetVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPboundchgGetVar(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgGetVar(MemorySegment boundchg) {
        var mh$ = SCIPboundchgGetVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPboundchgGetVar", boundchg);
            }
            return (MemorySegment)mh$.invokeExact(boundchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPboundchgGetBoundchgtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPboundchgGetBoundchgtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPboundchgGetBoundchgtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static FunctionDescriptor SCIPboundchgGetBoundchgtype$descriptor() {
        return SCIPboundchgGetBoundchgtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPboundchgGetBoundchgtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MethodHandle SCIPboundchgGetBoundchgtype$handle() {
        return SCIPboundchgGetBoundchgtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPboundchgGetBoundchgtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgGetBoundchgtype$address() {
        return SCIPboundchgGetBoundchgtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDCHGTYPE SCIPboundchgGetBoundchgtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static int SCIPboundchgGetBoundchgtype(MemorySegment boundchg) {
        var mh$ = SCIPboundchgGetBoundchgtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPboundchgGetBoundchgtype", boundchg);
            }
            return (int)mh$.invokeExact(boundchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPboundchgGetBoundtype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPboundchgGetBoundtype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPboundchgGetBoundtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static FunctionDescriptor SCIPboundchgGetBoundtype$descriptor() {
        return SCIPboundchgGetBoundtype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPboundchgGetBoundtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MethodHandle SCIPboundchgGetBoundtype$handle() {
        return SCIPboundchgGetBoundtype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPboundchgGetBoundtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgGetBoundtype$address() {
        return SCIPboundchgGetBoundtype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE SCIPboundchgGetBoundtype(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static int SCIPboundchgGetBoundtype(MemorySegment boundchg) {
        var mh$ = SCIPboundchgGetBoundtype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPboundchgGetBoundtype", boundchg);
            }
            return (int)mh$.invokeExact(boundchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPboundchgIsRedundant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPboundchgIsRedundant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPboundchgIsRedundant(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static FunctionDescriptor SCIPboundchgIsRedundant$descriptor() {
        return SCIPboundchgIsRedundant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPboundchgIsRedundant(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MethodHandle SCIPboundchgIsRedundant$handle() {
        return SCIPboundchgIsRedundant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPboundchgIsRedundant(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static MemorySegment SCIPboundchgIsRedundant$address() {
        return SCIPboundchgIsRedundant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPboundchgIsRedundant(SCIP_BOUNDCHG *boundchg)
     * }
     */
    public static int SCIPboundchgIsRedundant(MemorySegment boundchg) {
        var mh$ = SCIPboundchgIsRedundant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPboundchgIsRedundant", boundchg);
            }
            return (int)mh$.invokeExact(boundchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdomchgGetNBoundchgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdomchgGetNBoundchgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPdomchgGetNBoundchgs(SCIP_DOMCHG *domchg)
     * }
     */
    public static FunctionDescriptor SCIPdomchgGetNBoundchgs$descriptor() {
        return SCIPdomchgGetNBoundchgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPdomchgGetNBoundchgs(SCIP_DOMCHG *domchg)
     * }
     */
    public static MethodHandle SCIPdomchgGetNBoundchgs$handle() {
        return SCIPdomchgGetNBoundchgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPdomchgGetNBoundchgs(SCIP_DOMCHG *domchg)
     * }
     */
    public static MemorySegment SCIPdomchgGetNBoundchgs$address() {
        return SCIPdomchgGetNBoundchgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPdomchgGetNBoundchgs(SCIP_DOMCHG *domchg)
     * }
     */
    public static int SCIPdomchgGetNBoundchgs(MemorySegment domchg) {
        var mh$ = SCIPdomchgGetNBoundchgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdomchgGetNBoundchgs", domchg);
            }
            return (int)mh$.invokeExact(domchg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdomchgGetBoundchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdomchgGetBoundchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHG *SCIPdomchgGetBoundchg(SCIP_DOMCHG *domchg, int pos)
     * }
     */
    public static FunctionDescriptor SCIPdomchgGetBoundchg$descriptor() {
        return SCIPdomchgGetBoundchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHG *SCIPdomchgGetBoundchg(SCIP_DOMCHG *domchg, int pos)
     * }
     */
    public static MethodHandle SCIPdomchgGetBoundchg$handle() {
        return SCIPdomchgGetBoundchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDCHG *SCIPdomchgGetBoundchg(SCIP_DOMCHG *domchg, int pos)
     * }
     */
    public static MemorySegment SCIPdomchgGetBoundchg$address() {
        return SCIPdomchgGetBoundchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDCHG *SCIPdomchgGetBoundchg(SCIP_DOMCHG *domchg, int pos)
     * }
     */
    public static MemorySegment SCIPdomchgGetBoundchg(MemorySegment domchg, int pos) {
        var mh$ = SCIPdomchgGetBoundchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdomchgGetBoundchg", domchg, pos);
            }
            return (MemorySegment)mh$.invokeExact(domchg, pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPholelistGetLeft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPholelistGetLeft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPholelistGetLeft(SCIP_HOLELIST *holelist)
     * }
     */
    public static FunctionDescriptor SCIPholelistGetLeft$descriptor() {
        return SCIPholelistGetLeft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPholelistGetLeft(SCIP_HOLELIST *holelist)
     * }
     */
    public static MethodHandle SCIPholelistGetLeft$handle() {
        return SCIPholelistGetLeft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPholelistGetLeft(SCIP_HOLELIST *holelist)
     * }
     */
    public static MemorySegment SCIPholelistGetLeft$address() {
        return SCIPholelistGetLeft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPholelistGetLeft(SCIP_HOLELIST *holelist)
     * }
     */
    public static double SCIPholelistGetLeft(MemorySegment holelist) {
        var mh$ = SCIPholelistGetLeft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPholelistGetLeft", holelist);
            }
            return (double)mh$.invokeExact(holelist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPholelistGetRight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPholelistGetRight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPholelistGetRight(SCIP_HOLELIST *holelist)
     * }
     */
    public static FunctionDescriptor SCIPholelistGetRight$descriptor() {
        return SCIPholelistGetRight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPholelistGetRight(SCIP_HOLELIST *holelist)
     * }
     */
    public static MethodHandle SCIPholelistGetRight$handle() {
        return SCIPholelistGetRight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPholelistGetRight(SCIP_HOLELIST *holelist)
     * }
     */
    public static MemorySegment SCIPholelistGetRight$address() {
        return SCIPholelistGetRight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPholelistGetRight(SCIP_HOLELIST *holelist)
     * }
     */
    public static double SCIPholelistGetRight(MemorySegment holelist) {
        var mh$ = SCIPholelistGetRight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPholelistGetRight", holelist);
            }
            return (double)mh$.invokeExact(holelist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPholelistGetNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPholelistGetNext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPholelistGetNext(SCIP_HOLELIST *holelist)
     * }
     */
    public static FunctionDescriptor SCIPholelistGetNext$descriptor() {
        return SCIPholelistGetNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPholelistGetNext(SCIP_HOLELIST *holelist)
     * }
     */
    public static MethodHandle SCIPholelistGetNext$handle() {
        return SCIPholelistGetNext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPholelistGetNext(SCIP_HOLELIST *holelist)
     * }
     */
    public static MemorySegment SCIPholelistGetNext$address() {
        return SCIPholelistGetNext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HOLELIST *SCIPholelistGetNext(SCIP_HOLELIST *holelist)
     * }
     */
    public static MemorySegment SCIPholelistGetNext(MemorySegment holelist) {
        var mh$ = SCIPholelistGetNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPholelistGetNext", holelist);
            }
            return (MemorySegment)mh$.invokeExact(holelist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSolverName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSolverName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverName()
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSolverName$descriptor() {
        return SCIPlpiGetSolverName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverName()
     * }
     */
    public static MethodHandle SCIPlpiGetSolverName$handle() {
        return SCIPlpiGetSolverName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverName()
     * }
     */
    public static MemorySegment SCIPlpiGetSolverName$address() {
        return SCIPlpiGetSolverName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverName()
     * }
     */
    public static MemorySegment SCIPlpiGetSolverName() {
        var mh$ = SCIPlpiGetSolverName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSolverName");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSolverDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSolverDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverDesc()
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSolverDesc$descriptor() {
        return SCIPlpiGetSolverDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverDesc()
     * }
     */
    public static MethodHandle SCIPlpiGetSolverDesc$handle() {
        return SCIPlpiGetSolverDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverDesc()
     * }
     */
    public static MemorySegment SCIPlpiGetSolverDesc$address() {
        return SCIPlpiGetSolverDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPlpiGetSolverDesc()
     * }
     */
    public static MemorySegment SCIPlpiGetSolverDesc() {
        var mh$ = SCIPlpiGetSolverDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSolverDesc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSolverPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSolverPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPlpiGetSolverPointer(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSolverPointer$descriptor() {
        return SCIPlpiGetSolverPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPlpiGetSolverPointer(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiGetSolverPointer$handle() {
        return SCIPlpiGetSolverPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPlpiGetSolverPointer(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiGetSolverPointer$address() {
        return SCIPlpiGetSolverPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPlpiGetSolverPointer(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiGetSolverPointer(MemorySegment lpi) {
        var mh$ = SCIPlpiGetSolverPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSolverPointer", lpi);
            }
            return (MemorySegment)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetIntegralityInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetIntegralityInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntegralityInformation(SCIP_LPI *lpi, int ncols, int *intInfo)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetIntegralityInformation$descriptor() {
        return SCIPlpiSetIntegralityInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntegralityInformation(SCIP_LPI *lpi, int ncols, int *intInfo)
     * }
     */
    public static MethodHandle SCIPlpiSetIntegralityInformation$handle() {
        return SCIPlpiSetIntegralityInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntegralityInformation(SCIP_LPI *lpi, int ncols, int *intInfo)
     * }
     */
    public static MemorySegment SCIPlpiSetIntegralityInformation$address() {
        return SCIPlpiSetIntegralityInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntegralityInformation(SCIP_LPI *lpi, int ncols, int *intInfo)
     * }
     */
    public static int SCIPlpiSetIntegralityInformation(MemorySegment lpi, int ncols, MemorySegment intInfo) {
        var mh$ = SCIPlpiSetIntegralityInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetIntegralityInformation", lpi, ncols, intInfo);
            }
            return (int)mh$.invokeExact(lpi, ncols, intInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasPrimalSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasPrimalSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalSolve()
     * }
     */
    public static FunctionDescriptor SCIPlpiHasPrimalSolve$descriptor() {
        return SCIPlpiHasPrimalSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalSolve()
     * }
     */
    public static MethodHandle SCIPlpiHasPrimalSolve$handle() {
        return SCIPlpiHasPrimalSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalSolve()
     * }
     */
    public static MemorySegment SCIPlpiHasPrimalSolve$address() {
        return SCIPlpiHasPrimalSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalSolve()
     * }
     */
    public static int SCIPlpiHasPrimalSolve() {
        var mh$ = SCIPlpiHasPrimalSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasPrimalSolve");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasDualSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasDualSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualSolve()
     * }
     */
    public static FunctionDescriptor SCIPlpiHasDualSolve$descriptor() {
        return SCIPlpiHasDualSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualSolve()
     * }
     */
    public static MethodHandle SCIPlpiHasDualSolve$handle() {
        return SCIPlpiHasDualSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualSolve()
     * }
     */
    public static MemorySegment SCIPlpiHasDualSolve$address() {
        return SCIPlpiHasDualSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualSolve()
     * }
     */
    public static int SCIPlpiHasDualSolve() {
        var mh$ = SCIPlpiHasDualSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasDualSolve");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasBarrierSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasBarrierSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasBarrierSolve()
     * }
     */
    public static FunctionDescriptor SCIPlpiHasBarrierSolve$descriptor() {
        return SCIPlpiHasBarrierSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasBarrierSolve()
     * }
     */
    public static MethodHandle SCIPlpiHasBarrierSolve$handle() {
        return SCIPlpiHasBarrierSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasBarrierSolve()
     * }
     */
    public static MemorySegment SCIPlpiHasBarrierSolve$address() {
        return SCIPlpiHasBarrierSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasBarrierSolve()
     * }
     */
    public static int SCIPlpiHasBarrierSolve() {
        var mh$ = SCIPlpiHasBarrierSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasBarrierSolve");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiCreate(SCIP_LPI **lpi, SCIP_MESSAGEHDLR *messagehdlr, const char *name, SCIP_OBJSEN objsen)
     * }
     */
    public static FunctionDescriptor SCIPlpiCreate$descriptor() {
        return SCIPlpiCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiCreate(SCIP_LPI **lpi, SCIP_MESSAGEHDLR *messagehdlr, const char *name, SCIP_OBJSEN objsen)
     * }
     */
    public static MethodHandle SCIPlpiCreate$handle() {
        return SCIPlpiCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiCreate(SCIP_LPI **lpi, SCIP_MESSAGEHDLR *messagehdlr, const char *name, SCIP_OBJSEN objsen)
     * }
     */
    public static MemorySegment SCIPlpiCreate$address() {
        return SCIPlpiCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiCreate(SCIP_LPI **lpi, SCIP_MESSAGEHDLR *messagehdlr, const char *name, SCIP_OBJSEN objsen)
     * }
     */
    public static int SCIPlpiCreate(MemorySegment lpi, MemorySegment messagehdlr, MemorySegment name, int objsen) {
        var mh$ = SCIPlpiCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiCreate", lpi, messagehdlr, name, objsen);
            }
            return (int)mh$.invokeExact(lpi, messagehdlr, name, objsen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFree(SCIP_LPI **lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiFree$descriptor() {
        return SCIPlpiFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFree(SCIP_LPI **lpi)
     * }
     */
    public static MethodHandle SCIPlpiFree$handle() {
        return SCIPlpiFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFree(SCIP_LPI **lpi)
     * }
     */
    public static MemorySegment SCIPlpiFree$address() {
        return SCIPlpiFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFree(SCIP_LPI **lpi)
     * }
     */
    public static int SCIPlpiFree(MemorySegment lpi) {
        var mh$ = SCIPlpiFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiFree", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiLoadColLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiLoadColLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiLoadColLP(SCIP_LPI *lpi, SCIP_OBJSEN objsen, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiLoadColLP$descriptor() {
        return SCIPlpiLoadColLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiLoadColLP(SCIP_LPI *lpi, SCIP_OBJSEN objsen, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MethodHandle SCIPlpiLoadColLP$handle() {
        return SCIPlpiLoadColLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiLoadColLP(SCIP_LPI *lpi, SCIP_OBJSEN objsen, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MemorySegment SCIPlpiLoadColLP$address() {
        return SCIPlpiLoadColLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiLoadColLP(SCIP_LPI *lpi, SCIP_OBJSEN objsen, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static int SCIPlpiLoadColLP(MemorySegment lpi, int objsen, int ncols, MemorySegment obj, MemorySegment lb, MemorySegment ub, MemorySegment colnames, int nrows, MemorySegment lhs, MemorySegment rhs, MemorySegment rownames, int nnonz, MemorySegment beg, MemorySegment ind, MemorySegment val) {
        var mh$ = SCIPlpiLoadColLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiLoadColLP", lpi, objsen, ncols, obj, lb, ub, colnames, nrows, lhs, rhs, rownames, nnonz, beg, ind, val);
            }
            return (int)mh$.invokeExact(lpi, objsen, ncols, obj, lb, ub, colnames, nrows, lhs, rhs, rownames, nnonz, beg, ind, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiAddCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiAddCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddCols(SCIP_LPI *lpi, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiAddCols$descriptor() {
        return SCIPlpiAddCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddCols(SCIP_LPI *lpi, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MethodHandle SCIPlpiAddCols$handle() {
        return SCIPlpiAddCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddCols(SCIP_LPI *lpi, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MemorySegment SCIPlpiAddCols$address() {
        return SCIPlpiAddCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddCols(SCIP_LPI *lpi, int ncols, const double *obj, const double *lb, const double *ub, char **colnames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static int SCIPlpiAddCols(MemorySegment lpi, int ncols, MemorySegment obj, MemorySegment lb, MemorySegment ub, MemorySegment colnames, int nnonz, MemorySegment beg, MemorySegment ind, MemorySegment val) {
        var mh$ = SCIPlpiAddCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiAddCols", lpi, ncols, obj, lb, ub, colnames, nnonz, beg, ind, val);
            }
            return (int)mh$.invokeExact(lpi, ncols, obj, lb, ub, colnames, nnonz, beg, ind, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiDelCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiDelCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelCols(SCIP_LPI *lpi, int firstcol, int lastcol)
     * }
     */
    public static FunctionDescriptor SCIPlpiDelCols$descriptor() {
        return SCIPlpiDelCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelCols(SCIP_LPI *lpi, int firstcol, int lastcol)
     * }
     */
    public static MethodHandle SCIPlpiDelCols$handle() {
        return SCIPlpiDelCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelCols(SCIP_LPI *lpi, int firstcol, int lastcol)
     * }
     */
    public static MemorySegment SCIPlpiDelCols$address() {
        return SCIPlpiDelCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelCols(SCIP_LPI *lpi, int firstcol, int lastcol)
     * }
     */
    public static int SCIPlpiDelCols(MemorySegment lpi, int firstcol, int lastcol) {
        var mh$ = SCIPlpiDelCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiDelCols", lpi, firstcol, lastcol);
            }
            return (int)mh$.invokeExact(lpi, firstcol, lastcol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiDelColset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiDelColset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelColset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static FunctionDescriptor SCIPlpiDelColset$descriptor() {
        return SCIPlpiDelColset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelColset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static MethodHandle SCIPlpiDelColset$handle() {
        return SCIPlpiDelColset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelColset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static MemorySegment SCIPlpiDelColset$address() {
        return SCIPlpiDelColset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelColset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static int SCIPlpiDelColset(MemorySegment lpi, MemorySegment dstat) {
        var mh$ = SCIPlpiDelColset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiDelColset", lpi, dstat);
            }
            return (int)mh$.invokeExact(lpi, dstat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiAddRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiAddRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddRows(SCIP_LPI *lpi, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiAddRows$descriptor() {
        return SCIPlpiAddRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddRows(SCIP_LPI *lpi, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MethodHandle SCIPlpiAddRows$handle() {
        return SCIPlpiAddRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddRows(SCIP_LPI *lpi, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static MemorySegment SCIPlpiAddRows$address() {
        return SCIPlpiAddRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiAddRows(SCIP_LPI *lpi, int nrows, const double *lhs, const double *rhs, char **rownames, int nnonz, const int *beg, const int *ind, const double *val)
     * }
     */
    public static int SCIPlpiAddRows(MemorySegment lpi, int nrows, MemorySegment lhs, MemorySegment rhs, MemorySegment rownames, int nnonz, MemorySegment beg, MemorySegment ind, MemorySegment val) {
        var mh$ = SCIPlpiAddRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiAddRows", lpi, nrows, lhs, rhs, rownames, nnonz, beg, ind, val);
            }
            return (int)mh$.invokeExact(lpi, nrows, lhs, rhs, rownames, nnonz, beg, ind, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiDelRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiDelRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRows(SCIP_LPI *lpi, int firstrow, int lastrow)
     * }
     */
    public static FunctionDescriptor SCIPlpiDelRows$descriptor() {
        return SCIPlpiDelRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRows(SCIP_LPI *lpi, int firstrow, int lastrow)
     * }
     */
    public static MethodHandle SCIPlpiDelRows$handle() {
        return SCIPlpiDelRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRows(SCIP_LPI *lpi, int firstrow, int lastrow)
     * }
     */
    public static MemorySegment SCIPlpiDelRows$address() {
        return SCIPlpiDelRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRows(SCIP_LPI *lpi, int firstrow, int lastrow)
     * }
     */
    public static int SCIPlpiDelRows(MemorySegment lpi, int firstrow, int lastrow) {
        var mh$ = SCIPlpiDelRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiDelRows", lpi, firstrow, lastrow);
            }
            return (int)mh$.invokeExact(lpi, firstrow, lastrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiDelRowset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiDelRowset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRowset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static FunctionDescriptor SCIPlpiDelRowset$descriptor() {
        return SCIPlpiDelRowset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRowset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static MethodHandle SCIPlpiDelRowset$handle() {
        return SCIPlpiDelRowset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRowset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static MemorySegment SCIPlpiDelRowset$address() {
        return SCIPlpiDelRowset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiDelRowset(SCIP_LPI *lpi, int *dstat)
     * }
     */
    public static int SCIPlpiDelRowset(MemorySegment lpi, MemorySegment dstat) {
        var mh$ = SCIPlpiDelRowset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiDelRowset", lpi, dstat);
            }
            return (int)mh$.invokeExact(lpi, dstat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClear(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiClear$descriptor() {
        return SCIPlpiClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClear(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiClear$handle() {
        return SCIPlpiClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClear(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiClear$address() {
        return SCIPlpiClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClear(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiClear(MemorySegment lpi) {
        var mh$ = SCIPlpiClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiClear", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiChgBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiChgBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgBounds(SCIP_LPI *lpi, int ncols, const int *ind, const double *lb, const double *ub)
     * }
     */
    public static FunctionDescriptor SCIPlpiChgBounds$descriptor() {
        return SCIPlpiChgBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgBounds(SCIP_LPI *lpi, int ncols, const int *ind, const double *lb, const double *ub)
     * }
     */
    public static MethodHandle SCIPlpiChgBounds$handle() {
        return SCIPlpiChgBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgBounds(SCIP_LPI *lpi, int ncols, const int *ind, const double *lb, const double *ub)
     * }
     */
    public static MemorySegment SCIPlpiChgBounds$address() {
        return SCIPlpiChgBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgBounds(SCIP_LPI *lpi, int ncols, const int *ind, const double *lb, const double *ub)
     * }
     */
    public static int SCIPlpiChgBounds(MemorySegment lpi, int ncols, MemorySegment ind, MemorySegment lb, MemorySegment ub) {
        var mh$ = SCIPlpiChgBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiChgBounds", lpi, ncols, ind, lb, ub);
            }
            return (int)mh$.invokeExact(lpi, ncols, ind, lb, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiChgSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiChgSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgSides(SCIP_LPI *lpi, int nrows, const int *ind, const double *lhs, const double *rhs)
     * }
     */
    public static FunctionDescriptor SCIPlpiChgSides$descriptor() {
        return SCIPlpiChgSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgSides(SCIP_LPI *lpi, int nrows, const int *ind, const double *lhs, const double *rhs)
     * }
     */
    public static MethodHandle SCIPlpiChgSides$handle() {
        return SCIPlpiChgSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgSides(SCIP_LPI *lpi, int nrows, const int *ind, const double *lhs, const double *rhs)
     * }
     */
    public static MemorySegment SCIPlpiChgSides$address() {
        return SCIPlpiChgSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgSides(SCIP_LPI *lpi, int nrows, const int *ind, const double *lhs, const double *rhs)
     * }
     */
    public static int SCIPlpiChgSides(MemorySegment lpi, int nrows, MemorySegment ind, MemorySegment lhs, MemorySegment rhs) {
        var mh$ = SCIPlpiChgSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiChgSides", lpi, nrows, ind, lhs, rhs);
            }
            return (int)mh$.invokeExact(lpi, nrows, ind, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiChgCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiChgCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgCoef(SCIP_LPI *lpi, int row, int col, double newval)
     * }
     */
    public static FunctionDescriptor SCIPlpiChgCoef$descriptor() {
        return SCIPlpiChgCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgCoef(SCIP_LPI *lpi, int row, int col, double newval)
     * }
     */
    public static MethodHandle SCIPlpiChgCoef$handle() {
        return SCIPlpiChgCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgCoef(SCIP_LPI *lpi, int row, int col, double newval)
     * }
     */
    public static MemorySegment SCIPlpiChgCoef$address() {
        return SCIPlpiChgCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgCoef(SCIP_LPI *lpi, int row, int col, double newval)
     * }
     */
    public static int SCIPlpiChgCoef(MemorySegment lpi, int row, int col, double newval) {
        var mh$ = SCIPlpiChgCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiChgCoef", lpi, row, col, newval);
            }
            return (int)mh$.invokeExact(lpi, row, col, newval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiChgObjsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiChgObjsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObjsen(SCIP_LPI *lpi, SCIP_OBJSEN objsen)
     * }
     */
    public static FunctionDescriptor SCIPlpiChgObjsen$descriptor() {
        return SCIPlpiChgObjsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObjsen(SCIP_LPI *lpi, SCIP_OBJSEN objsen)
     * }
     */
    public static MethodHandle SCIPlpiChgObjsen$handle() {
        return SCIPlpiChgObjsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObjsen(SCIP_LPI *lpi, SCIP_OBJSEN objsen)
     * }
     */
    public static MemorySegment SCIPlpiChgObjsen$address() {
        return SCIPlpiChgObjsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObjsen(SCIP_LPI *lpi, SCIP_OBJSEN objsen)
     * }
     */
    public static int SCIPlpiChgObjsen(MemorySegment lpi, int objsen) {
        var mh$ = SCIPlpiChgObjsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiChgObjsen", lpi, objsen);
            }
            return (int)mh$.invokeExact(lpi, objsen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiChgObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiChgObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObj(SCIP_LPI *lpi, int ncols, const int *ind, const double *obj)
     * }
     */
    public static FunctionDescriptor SCIPlpiChgObj$descriptor() {
        return SCIPlpiChgObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObj(SCIP_LPI *lpi, int ncols, const int *ind, const double *obj)
     * }
     */
    public static MethodHandle SCIPlpiChgObj$handle() {
        return SCIPlpiChgObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObj(SCIP_LPI *lpi, int ncols, const int *ind, const double *obj)
     * }
     */
    public static MemorySegment SCIPlpiChgObj$address() {
        return SCIPlpiChgObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiChgObj(SCIP_LPI *lpi, int ncols, const int *ind, const double *obj)
     * }
     */
    public static int SCIPlpiChgObj(MemorySegment lpi, int ncols, MemorySegment ind, MemorySegment obj) {
        var mh$ = SCIPlpiChgObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiChgObj", lpi, ncols, ind, obj);
            }
            return (int)mh$.invokeExact(lpi, ncols, ind, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiScaleRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiScaleRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleRow(SCIP_LPI *lpi, int row, double scaleval)
     * }
     */
    public static FunctionDescriptor SCIPlpiScaleRow$descriptor() {
        return SCIPlpiScaleRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleRow(SCIP_LPI *lpi, int row, double scaleval)
     * }
     */
    public static MethodHandle SCIPlpiScaleRow$handle() {
        return SCIPlpiScaleRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleRow(SCIP_LPI *lpi, int row, double scaleval)
     * }
     */
    public static MemorySegment SCIPlpiScaleRow$address() {
        return SCIPlpiScaleRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleRow(SCIP_LPI *lpi, int row, double scaleval)
     * }
     */
    public static int SCIPlpiScaleRow(MemorySegment lpi, int row, double scaleval) {
        var mh$ = SCIPlpiScaleRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiScaleRow", lpi, row, scaleval);
            }
            return (int)mh$.invokeExact(lpi, row, scaleval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiScaleCol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiScaleCol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleCol(SCIP_LPI *lpi, int col, double scaleval)
     * }
     */
    public static FunctionDescriptor SCIPlpiScaleCol$descriptor() {
        return SCIPlpiScaleCol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleCol(SCIP_LPI *lpi, int col, double scaleval)
     * }
     */
    public static MethodHandle SCIPlpiScaleCol$handle() {
        return SCIPlpiScaleCol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleCol(SCIP_LPI *lpi, int col, double scaleval)
     * }
     */
    public static MemorySegment SCIPlpiScaleCol$address() {
        return SCIPlpiScaleCol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiScaleCol(SCIP_LPI *lpi, int col, double scaleval)
     * }
     */
    public static int SCIPlpiScaleCol(MemorySegment lpi, int col, double scaleval) {
        var mh$ = SCIPlpiScaleCol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiScaleCol", lpi, col, scaleval);
            }
            return (int)mh$.invokeExact(lpi, col, scaleval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetNRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetNRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNRows(SCIP_LPI *lpi, int *nrows)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetNRows$descriptor() {
        return SCIPlpiGetNRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNRows(SCIP_LPI *lpi, int *nrows)
     * }
     */
    public static MethodHandle SCIPlpiGetNRows$handle() {
        return SCIPlpiGetNRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNRows(SCIP_LPI *lpi, int *nrows)
     * }
     */
    public static MemorySegment SCIPlpiGetNRows$address() {
        return SCIPlpiGetNRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNRows(SCIP_LPI *lpi, int *nrows)
     * }
     */
    public static int SCIPlpiGetNRows(MemorySegment lpi, MemorySegment nrows) {
        var mh$ = SCIPlpiGetNRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetNRows", lpi, nrows);
            }
            return (int)mh$.invokeExact(lpi, nrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetNCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetNCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNCols(SCIP_LPI *lpi, int *ncols)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetNCols$descriptor() {
        return SCIPlpiGetNCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNCols(SCIP_LPI *lpi, int *ncols)
     * }
     */
    public static MethodHandle SCIPlpiGetNCols$handle() {
        return SCIPlpiGetNCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNCols(SCIP_LPI *lpi, int *ncols)
     * }
     */
    public static MemorySegment SCIPlpiGetNCols$address() {
        return SCIPlpiGetNCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNCols(SCIP_LPI *lpi, int *ncols)
     * }
     */
    public static int SCIPlpiGetNCols(MemorySegment lpi, MemorySegment ncols) {
        var mh$ = SCIPlpiGetNCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetNCols", lpi, ncols);
            }
            return (int)mh$.invokeExact(lpi, ncols);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetObjsen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetObjsen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjsen(SCIP_LPI *lpi, SCIP_OBJSEN *objsen)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetObjsen$descriptor() {
        return SCIPlpiGetObjsen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjsen(SCIP_LPI *lpi, SCIP_OBJSEN *objsen)
     * }
     */
    public static MethodHandle SCIPlpiGetObjsen$handle() {
        return SCIPlpiGetObjsen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjsen(SCIP_LPI *lpi, SCIP_OBJSEN *objsen)
     * }
     */
    public static MemorySegment SCIPlpiGetObjsen$address() {
        return SCIPlpiGetObjsen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjsen(SCIP_LPI *lpi, SCIP_OBJSEN *objsen)
     * }
     */
    public static int SCIPlpiGetObjsen(MemorySegment lpi, MemorySegment objsen) {
        var mh$ = SCIPlpiGetObjsen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetObjsen", lpi, objsen);
            }
            return (int)mh$.invokeExact(lpi, objsen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetNNonz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetNNonz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNNonz(SCIP_LPI *lpi, int *nnonz)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetNNonz$descriptor() {
        return SCIPlpiGetNNonz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNNonz(SCIP_LPI *lpi, int *nnonz)
     * }
     */
    public static MethodHandle SCIPlpiGetNNonz$handle() {
        return SCIPlpiGetNNonz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNNonz(SCIP_LPI *lpi, int *nnonz)
     * }
     */
    public static MemorySegment SCIPlpiGetNNonz$address() {
        return SCIPlpiGetNNonz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNNonz(SCIP_LPI *lpi, int *nnonz)
     * }
     */
    public static int SCIPlpiGetNNonz(MemorySegment lpi, MemorySegment nnonz) {
        var mh$ = SCIPlpiGetNNonz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetNNonz", lpi, nnonz);
            }
            return (int)mh$.invokeExact(lpi, nnonz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCols(SCIP_LPI *lpi, int firstcol, int lastcol, double *lb, double *ub, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetCols$descriptor() {
        return SCIPlpiGetCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCols(SCIP_LPI *lpi, int firstcol, int lastcol, double *lb, double *ub, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static MethodHandle SCIPlpiGetCols$handle() {
        return SCIPlpiGetCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCols(SCIP_LPI *lpi, int firstcol, int lastcol, double *lb, double *ub, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static MemorySegment SCIPlpiGetCols$address() {
        return SCIPlpiGetCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCols(SCIP_LPI *lpi, int firstcol, int lastcol, double *lb, double *ub, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static int SCIPlpiGetCols(MemorySegment lpi, int firstcol, int lastcol, MemorySegment lb, MemorySegment ub, MemorySegment nnonz, MemorySegment beg, MemorySegment ind, MemorySegment val) {
        var mh$ = SCIPlpiGetCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetCols", lpi, firstcol, lastcol, lb, ub, nnonz, beg, ind, val);
            }
            return (int)mh$.invokeExact(lpi, firstcol, lastcol, lb, ub, nnonz, beg, ind, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRows(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhs, double *rhs, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetRows$descriptor() {
        return SCIPlpiGetRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRows(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhs, double *rhs, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static MethodHandle SCIPlpiGetRows$handle() {
        return SCIPlpiGetRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRows(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhs, double *rhs, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static MemorySegment SCIPlpiGetRows$address() {
        return SCIPlpiGetRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRows(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhs, double *rhs, int *nnonz, int *beg, int *ind, double *val)
     * }
     */
    public static int SCIPlpiGetRows(MemorySegment lpi, int firstrow, int lastrow, MemorySegment lhs, MemorySegment rhs, MemorySegment nnonz, MemorySegment beg, MemorySegment ind, MemorySegment val) {
        var mh$ = SCIPlpiGetRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetRows", lpi, firstrow, lastrow, lhs, rhs, nnonz, beg, ind, val);
            }
            return (int)mh$.invokeExact(lpi, firstrow, lastrow, lhs, rhs, nnonz, beg, ind, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetColNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetColNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetColNames(SCIP_LPI *lpi, int firstcol, int lastcol, char **colnames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetColNames$descriptor() {
        return SCIPlpiGetColNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetColNames(SCIP_LPI *lpi, int firstcol, int lastcol, char **colnames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static MethodHandle SCIPlpiGetColNames$handle() {
        return SCIPlpiGetColNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetColNames(SCIP_LPI *lpi, int firstcol, int lastcol, char **colnames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static MemorySegment SCIPlpiGetColNames$address() {
        return SCIPlpiGetColNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetColNames(SCIP_LPI *lpi, int firstcol, int lastcol, char **colnames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static int SCIPlpiGetColNames(MemorySegment lpi, int firstcol, int lastcol, MemorySegment colnames, MemorySegment namestorage, int namestoragesize, MemorySegment storageleft) {
        var mh$ = SCIPlpiGetColNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetColNames", lpi, firstcol, lastcol, colnames, namestorage, namestoragesize, storageleft);
            }
            return (int)mh$.invokeExact(lpi, firstcol, lastcol, colnames, namestorage, namestoragesize, storageleft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetRowNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetRowNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRowNames(SCIP_LPI *lpi, int firstrow, int lastrow, char **rownames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetRowNames$descriptor() {
        return SCIPlpiGetRowNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRowNames(SCIP_LPI *lpi, int firstrow, int lastrow, char **rownames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static MethodHandle SCIPlpiGetRowNames$handle() {
        return SCIPlpiGetRowNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRowNames(SCIP_LPI *lpi, int firstrow, int lastrow, char **rownames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static MemorySegment SCIPlpiGetRowNames$address() {
        return SCIPlpiGetRowNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRowNames(SCIP_LPI *lpi, int firstrow, int lastrow, char **rownames, char *namestorage, int namestoragesize, int *storageleft)
     * }
     */
    public static int SCIPlpiGetRowNames(MemorySegment lpi, int firstrow, int lastrow, MemorySegment rownames, MemorySegment namestorage, int namestoragesize, MemorySegment storageleft) {
        var mh$ = SCIPlpiGetRowNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetRowNames", lpi, firstrow, lastrow, rownames, namestorage, namestoragesize, storageleft);
            }
            return (int)mh$.invokeExact(lpi, firstrow, lastrow, rownames, namestorage, namestoragesize, storageleft);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObj(SCIP_LPI *lpi, int firstcol, int lastcol, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetObj$descriptor() {
        return SCIPlpiGetObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObj(SCIP_LPI *lpi, int firstcol, int lastcol, double *vals)
     * }
     */
    public static MethodHandle SCIPlpiGetObj$handle() {
        return SCIPlpiGetObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObj(SCIP_LPI *lpi, int firstcol, int lastcol, double *vals)
     * }
     */
    public static MemorySegment SCIPlpiGetObj$address() {
        return SCIPlpiGetObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObj(SCIP_LPI *lpi, int firstcol, int lastcol, double *vals)
     * }
     */
    public static int SCIPlpiGetObj(MemorySegment lpi, int firstcol, int lastcol, MemorySegment vals) {
        var mh$ = SCIPlpiGetObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetObj", lpi, firstcol, lastcol, vals);
            }
            return (int)mh$.invokeExact(lpi, firstcol, lastcol, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBounds(SCIP_LPI *lpi, int firstcol, int lastcol, double *lbs, double *ubs)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBounds$descriptor() {
        return SCIPlpiGetBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBounds(SCIP_LPI *lpi, int firstcol, int lastcol, double *lbs, double *ubs)
     * }
     */
    public static MethodHandle SCIPlpiGetBounds$handle() {
        return SCIPlpiGetBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBounds(SCIP_LPI *lpi, int firstcol, int lastcol, double *lbs, double *ubs)
     * }
     */
    public static MemorySegment SCIPlpiGetBounds$address() {
        return SCIPlpiGetBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBounds(SCIP_LPI *lpi, int firstcol, int lastcol, double *lbs, double *ubs)
     * }
     */
    public static int SCIPlpiGetBounds(MemorySegment lpi, int firstcol, int lastcol, MemorySegment lbs, MemorySegment ubs) {
        var mh$ = SCIPlpiGetBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBounds", lpi, firstcol, lastcol, lbs, ubs);
            }
            return (int)mh$.invokeExact(lpi, firstcol, lastcol, lbs, ubs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSides(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhss, double *rhss)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSides$descriptor() {
        return SCIPlpiGetSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSides(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhss, double *rhss)
     * }
     */
    public static MethodHandle SCIPlpiGetSides$handle() {
        return SCIPlpiGetSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSides(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhss, double *rhss)
     * }
     */
    public static MemorySegment SCIPlpiGetSides$address() {
        return SCIPlpiGetSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSides(SCIP_LPI *lpi, int firstrow, int lastrow, double *lhss, double *rhss)
     * }
     */
    public static int SCIPlpiGetSides(MemorySegment lpi, int firstrow, int lastrow, MemorySegment lhss, MemorySegment rhss) {
        var mh$ = SCIPlpiGetSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSides", lpi, firstrow, lastrow, lhss, rhss);
            }
            return (int)mh$.invokeExact(lpi, firstrow, lastrow, lhss, rhss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCoef(SCIP_LPI *lpi, int row, int col, double *val)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetCoef$descriptor() {
        return SCIPlpiGetCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCoef(SCIP_LPI *lpi, int row, int col, double *val)
     * }
     */
    public static MethodHandle SCIPlpiGetCoef$handle() {
        return SCIPlpiGetCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCoef(SCIP_LPI *lpi, int row, int col, double *val)
     * }
     */
    public static MemorySegment SCIPlpiGetCoef$address() {
        return SCIPlpiGetCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetCoef(SCIP_LPI *lpi, int row, int col, double *val)
     * }
     */
    public static int SCIPlpiGetCoef(MemorySegment lpi, int row, int col, MemorySegment val) {
        var mh$ = SCIPlpiGetCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetCoef", lpi, row, col, val);
            }
            return (int)mh$.invokeExact(lpi, row, col, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSolvePrimal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSolvePrimal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolvePrimal(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiSolvePrimal$descriptor() {
        return SCIPlpiSolvePrimal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolvePrimal(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiSolvePrimal$handle() {
        return SCIPlpiSolvePrimal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolvePrimal(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiSolvePrimal$address() {
        return SCIPlpiSolvePrimal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolvePrimal(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiSolvePrimal(MemorySegment lpi) {
        var mh$ = SCIPlpiSolvePrimal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSolvePrimal", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSolveDual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSolveDual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveDual(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiSolveDual$descriptor() {
        return SCIPlpiSolveDual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveDual(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiSolveDual$handle() {
        return SCIPlpiSolveDual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveDual(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiSolveDual$address() {
        return SCIPlpiSolveDual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveDual(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiSolveDual(MemorySegment lpi) {
        var mh$ = SCIPlpiSolveDual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSolveDual", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSolveBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSolveBarrier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveBarrier(SCIP_LPI *lpi, unsigned int crossover)
     * }
     */
    public static FunctionDescriptor SCIPlpiSolveBarrier$descriptor() {
        return SCIPlpiSolveBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveBarrier(SCIP_LPI *lpi, unsigned int crossover)
     * }
     */
    public static MethodHandle SCIPlpiSolveBarrier$handle() {
        return SCIPlpiSolveBarrier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveBarrier(SCIP_LPI *lpi, unsigned int crossover)
     * }
     */
    public static MemorySegment SCIPlpiSolveBarrier$address() {
        return SCIPlpiSolveBarrier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSolveBarrier(SCIP_LPI *lpi, unsigned int crossover)
     * }
     */
    public static int SCIPlpiSolveBarrier(MemorySegment lpi, int crossover) {
        var mh$ = SCIPlpiSolveBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSolveBarrier", lpi, crossover);
            }
            return (int)mh$.invokeExact(lpi, crossover);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiStartStrongbranch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiStartStrongbranch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStartStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiStartStrongbranch$descriptor() {
        return SCIPlpiStartStrongbranch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStartStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiStartStrongbranch$handle() {
        return SCIPlpiStartStrongbranch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStartStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiStartStrongbranch$address() {
        return SCIPlpiStartStrongbranch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStartStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiStartStrongbranch(MemorySegment lpi) {
        var mh$ = SCIPlpiStartStrongbranch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiStartStrongbranch", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiEndStrongbranch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiEndStrongbranch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiEndStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiEndStrongbranch$descriptor() {
        return SCIPlpiEndStrongbranch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiEndStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiEndStrongbranch$handle() {
        return SCIPlpiEndStrongbranch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiEndStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiEndStrongbranch$address() {
        return SCIPlpiEndStrongbranch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiEndStrongbranch(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiEndStrongbranch(MemorySegment lpi) {
        var mh$ = SCIPlpiEndStrongbranch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiEndStrongbranch", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiStrongbranchFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiStrongbranchFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchFrac(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static FunctionDescriptor SCIPlpiStrongbranchFrac$descriptor() {
        return SCIPlpiStrongbranchFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchFrac(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MethodHandle SCIPlpiStrongbranchFrac$handle() {
        return SCIPlpiStrongbranchFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchFrac(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MemorySegment SCIPlpiStrongbranchFrac$address() {
        return SCIPlpiStrongbranchFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchFrac(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static int SCIPlpiStrongbranchFrac(MemorySegment lpi, int col, double psol, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment iter) {
        var mh$ = SCIPlpiStrongbranchFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiStrongbranchFrac", lpi, col, psol, itlim, down, up, downvalid, upvalid, iter);
            }
            return (int)mh$.invokeExact(lpi, col, psol, itlim, down, up, downvalid, upvalid, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiStrongbranchesFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiStrongbranchesFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesFrac(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static FunctionDescriptor SCIPlpiStrongbranchesFrac$descriptor() {
        return SCIPlpiStrongbranchesFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesFrac(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MethodHandle SCIPlpiStrongbranchesFrac$handle() {
        return SCIPlpiStrongbranchesFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesFrac(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MemorySegment SCIPlpiStrongbranchesFrac$address() {
        return SCIPlpiStrongbranchesFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesFrac(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static int SCIPlpiStrongbranchesFrac(MemorySegment lpi, MemorySegment cols, int ncols, MemorySegment psols, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment iter) {
        var mh$ = SCIPlpiStrongbranchesFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiStrongbranchesFrac", lpi, cols, ncols, psols, itlim, down, up, downvalid, upvalid, iter);
            }
            return (int)mh$.invokeExact(lpi, cols, ncols, psols, itlim, down, up, downvalid, upvalid, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiStrongbranchInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiStrongbranchInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchInt(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static FunctionDescriptor SCIPlpiStrongbranchInt$descriptor() {
        return SCIPlpiStrongbranchInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchInt(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MethodHandle SCIPlpiStrongbranchInt$handle() {
        return SCIPlpiStrongbranchInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchInt(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MemorySegment SCIPlpiStrongbranchInt$address() {
        return SCIPlpiStrongbranchInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchInt(SCIP_LPI *lpi, int col, double psol, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static int SCIPlpiStrongbranchInt(MemorySegment lpi, int col, double psol, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment iter) {
        var mh$ = SCIPlpiStrongbranchInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiStrongbranchInt", lpi, col, psol, itlim, down, up, downvalid, upvalid, iter);
            }
            return (int)mh$.invokeExact(lpi, col, psol, itlim, down, up, downvalid, upvalid, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiStrongbranchesInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiStrongbranchesInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesInt(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static FunctionDescriptor SCIPlpiStrongbranchesInt$descriptor() {
        return SCIPlpiStrongbranchesInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesInt(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MethodHandle SCIPlpiStrongbranchesInt$handle() {
        return SCIPlpiStrongbranchesInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesInt(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static MemorySegment SCIPlpiStrongbranchesInt$address() {
        return SCIPlpiStrongbranchesInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiStrongbranchesInt(SCIP_LPI *lpi, int *cols, int ncols, double *psols, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, int *iter)
     * }
     */
    public static int SCIPlpiStrongbranchesInt(MemorySegment lpi, MemorySegment cols, int ncols, MemorySegment psols, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment iter) {
        var mh$ = SCIPlpiStrongbranchesInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiStrongbranchesInt", lpi, cols, ncols, psols, itlim, down, up, downvalid, upvalid, iter);
            }
            return (int)mh$.invokeExact(lpi, cols, ncols, psols, itlim, down, up, downvalid, upvalid, iter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiWasSolved {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiWasSolved");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiWasSolved(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiWasSolved$descriptor() {
        return SCIPlpiWasSolved.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiWasSolved(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiWasSolved$handle() {
        return SCIPlpiWasSolved.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiWasSolved(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiWasSolved$address() {
        return SCIPlpiWasSolved.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiWasSolved(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiWasSolved(MemorySegment lpi) {
        var mh$ = SCIPlpiWasSolved.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiWasSolved", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSolFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSolFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSolFeasibility(SCIP_LPI *lpi, unsigned int *primalfeasible, unsigned int *dualfeasible)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSolFeasibility$descriptor() {
        return SCIPlpiGetSolFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSolFeasibility(SCIP_LPI *lpi, unsigned int *primalfeasible, unsigned int *dualfeasible)
     * }
     */
    public static MethodHandle SCIPlpiGetSolFeasibility$handle() {
        return SCIPlpiGetSolFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSolFeasibility(SCIP_LPI *lpi, unsigned int *primalfeasible, unsigned int *dualfeasible)
     * }
     */
    public static MemorySegment SCIPlpiGetSolFeasibility$address() {
        return SCIPlpiGetSolFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSolFeasibility(SCIP_LPI *lpi, unsigned int *primalfeasible, unsigned int *dualfeasible)
     * }
     */
    public static int SCIPlpiGetSolFeasibility(MemorySegment lpi, MemorySegment primalfeasible, MemorySegment dualfeasible) {
        var mh$ = SCIPlpiGetSolFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSolFeasibility", lpi, primalfeasible, dualfeasible);
            }
            return (int)mh$.invokeExact(lpi, primalfeasible, dualfeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiExistsPrimalRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiExistsPrimalRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiExistsPrimalRay$descriptor() {
        return SCIPlpiExistsPrimalRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiExistsPrimalRay$handle() {
        return SCIPlpiExistsPrimalRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiExistsPrimalRay$address() {
        return SCIPlpiExistsPrimalRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiExistsPrimalRay(MemorySegment lpi) {
        var mh$ = SCIPlpiExistsPrimalRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiExistsPrimalRay", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasPrimalRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasPrimalRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiHasPrimalRay$descriptor() {
        return SCIPlpiHasPrimalRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiHasPrimalRay$handle() {
        return SCIPlpiHasPrimalRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiHasPrimalRay$address() {
        return SCIPlpiHasPrimalRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasPrimalRay(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiHasPrimalRay(MemorySegment lpi) {
        var mh$ = SCIPlpiHasPrimalRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasPrimalRay", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsPrimalUnbounded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsPrimalUnbounded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsPrimalUnbounded$descriptor() {
        return SCIPlpiIsPrimalUnbounded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsPrimalUnbounded$handle() {
        return SCIPlpiIsPrimalUnbounded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsPrimalUnbounded$address() {
        return SCIPlpiIsPrimalUnbounded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsPrimalUnbounded(MemorySegment lpi) {
        var mh$ = SCIPlpiIsPrimalUnbounded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsPrimalUnbounded", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsPrimalInfeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsPrimalInfeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsPrimalInfeasible$descriptor() {
        return SCIPlpiIsPrimalInfeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsPrimalInfeasible$handle() {
        return SCIPlpiIsPrimalInfeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsPrimalInfeasible$address() {
        return SCIPlpiIsPrimalInfeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsPrimalInfeasible(MemorySegment lpi) {
        var mh$ = SCIPlpiIsPrimalInfeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsPrimalInfeasible", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsPrimalFeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsPrimalFeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalFeasible(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsPrimalFeasible$descriptor() {
        return SCIPlpiIsPrimalFeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalFeasible(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsPrimalFeasible$handle() {
        return SCIPlpiIsPrimalFeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalFeasible(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsPrimalFeasible$address() {
        return SCIPlpiIsPrimalFeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsPrimalFeasible(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsPrimalFeasible(MemorySegment lpi) {
        var mh$ = SCIPlpiIsPrimalFeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsPrimalFeasible", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiExistsDualRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiExistsDualRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsDualRay(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiExistsDualRay$descriptor() {
        return SCIPlpiExistsDualRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsDualRay(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiExistsDualRay$handle() {
        return SCIPlpiExistsDualRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsDualRay(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiExistsDualRay$address() {
        return SCIPlpiExistsDualRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiExistsDualRay(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiExistsDualRay(MemorySegment lpi) {
        var mh$ = SCIPlpiExistsDualRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiExistsDualRay", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasDualRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasDualRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualRay(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiHasDualRay$descriptor() {
        return SCIPlpiHasDualRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualRay(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiHasDualRay$handle() {
        return SCIPlpiHasDualRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualRay(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiHasDualRay$address() {
        return SCIPlpiHasDualRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasDualRay(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiHasDualRay(MemorySegment lpi) {
        var mh$ = SCIPlpiHasDualRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasDualRay", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsDualUnbounded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsDualUnbounded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsDualUnbounded$descriptor() {
        return SCIPlpiIsDualUnbounded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsDualUnbounded$handle() {
        return SCIPlpiIsDualUnbounded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsDualUnbounded$address() {
        return SCIPlpiIsDualUnbounded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualUnbounded(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsDualUnbounded(MemorySegment lpi) {
        var mh$ = SCIPlpiIsDualUnbounded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsDualUnbounded", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsDualInfeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsDualInfeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsDualInfeasible$descriptor() {
        return SCIPlpiIsDualInfeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsDualInfeasible$handle() {
        return SCIPlpiIsDualInfeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsDualInfeasible$address() {
        return SCIPlpiIsDualInfeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualInfeasible(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsDualInfeasible(MemorySegment lpi) {
        var mh$ = SCIPlpiIsDualInfeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsDualInfeasible", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsDualFeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsDualFeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualFeasible(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsDualFeasible$descriptor() {
        return SCIPlpiIsDualFeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualFeasible(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsDualFeasible$handle() {
        return SCIPlpiIsDualFeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualFeasible(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsDualFeasible$address() {
        return SCIPlpiIsDualFeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsDualFeasible(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsDualFeasible(MemorySegment lpi) {
        var mh$ = SCIPlpiIsDualFeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsDualFeasible", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsOptimal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsOptimal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsOptimal(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsOptimal$descriptor() {
        return SCIPlpiIsOptimal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsOptimal(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsOptimal$handle() {
        return SCIPlpiIsOptimal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsOptimal(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsOptimal$address() {
        return SCIPlpiIsOptimal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsOptimal(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsOptimal(MemorySegment lpi) {
        var mh$ = SCIPlpiIsOptimal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsOptimal", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsStable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsStable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsStable(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsStable$descriptor() {
        return SCIPlpiIsStable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsStable(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsStable$handle() {
        return SCIPlpiIsStable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsStable(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsStable$address() {
        return SCIPlpiIsStable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsStable(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsStable(MemorySegment lpi) {
        var mh$ = SCIPlpiIsStable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsStable", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsObjlimExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsObjlimExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsObjlimExc(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsObjlimExc$descriptor() {
        return SCIPlpiIsObjlimExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsObjlimExc(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsObjlimExc$handle() {
        return SCIPlpiIsObjlimExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsObjlimExc(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsObjlimExc$address() {
        return SCIPlpiIsObjlimExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsObjlimExc(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsObjlimExc(MemorySegment lpi) {
        var mh$ = SCIPlpiIsObjlimExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsObjlimExc", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsIterlimExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsIterlimExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsIterlimExc(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsIterlimExc$descriptor() {
        return SCIPlpiIsIterlimExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsIterlimExc(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsIterlimExc$handle() {
        return SCIPlpiIsIterlimExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsIterlimExc(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsIterlimExc$address() {
        return SCIPlpiIsIterlimExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsIterlimExc(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsIterlimExc(MemorySegment lpi) {
        var mh$ = SCIPlpiIsIterlimExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsIterlimExc", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsTimelimExc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsTimelimExc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsTimelimExc(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsTimelimExc$descriptor() {
        return SCIPlpiIsTimelimExc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsTimelimExc(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiIsTimelimExc$handle() {
        return SCIPlpiIsTimelimExc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsTimelimExc(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiIsTimelimExc$address() {
        return SCIPlpiIsTimelimExc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsTimelimExc(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiIsTimelimExc(MemorySegment lpi) {
        var mh$ = SCIPlpiIsTimelimExc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsTimelimExc", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetInternalStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetInternalStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPlpiGetInternalStatus(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetInternalStatus$descriptor() {
        return SCIPlpiGetInternalStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPlpiGetInternalStatus(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiGetInternalStatus$handle() {
        return SCIPlpiGetInternalStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPlpiGetInternalStatus(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiGetInternalStatus$address() {
        return SCIPlpiGetInternalStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPlpiGetInternalStatus(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiGetInternalStatus(MemorySegment lpi) {
        var mh$ = SCIPlpiGetInternalStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetInternalStatus", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIgnoreInstability {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIgnoreInstability");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiIgnoreInstability(SCIP_LPI *lpi, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPlpiIgnoreInstability$descriptor() {
        return SCIPlpiIgnoreInstability.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiIgnoreInstability(SCIP_LPI *lpi, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPlpiIgnoreInstability$handle() {
        return SCIPlpiIgnoreInstability.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiIgnoreInstability(SCIP_LPI *lpi, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPlpiIgnoreInstability$address() {
        return SCIPlpiIgnoreInstability.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiIgnoreInstability(SCIP_LPI *lpi, unsigned int *success)
     * }
     */
    public static int SCIPlpiIgnoreInstability(MemorySegment lpi, MemorySegment success) {
        var mh$ = SCIPlpiIgnoreInstability.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIgnoreInstability", lpi, success);
            }
            return (int)mh$.invokeExact(lpi, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjval(SCIP_LPI *lpi, double *objval)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetObjval$descriptor() {
        return SCIPlpiGetObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjval(SCIP_LPI *lpi, double *objval)
     * }
     */
    public static MethodHandle SCIPlpiGetObjval$handle() {
        return SCIPlpiGetObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjval(SCIP_LPI *lpi, double *objval)
     * }
     */
    public static MemorySegment SCIPlpiGetObjval$address() {
        return SCIPlpiGetObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetObjval(SCIP_LPI *lpi, double *objval)
     * }
     */
    public static int SCIPlpiGetObjval(MemorySegment lpi, MemorySegment objval) {
        var mh$ = SCIPlpiGetObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetObjval", lpi, objval);
            }
            return (int)mh$.invokeExact(lpi, objval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSol(SCIP_LPI *lpi, double *objval, double *primsol, double *dualsol, double *activity, double *redcost)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetSol$descriptor() {
        return SCIPlpiGetSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSol(SCIP_LPI *lpi, double *objval, double *primsol, double *dualsol, double *activity, double *redcost)
     * }
     */
    public static MethodHandle SCIPlpiGetSol$handle() {
        return SCIPlpiGetSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSol(SCIP_LPI *lpi, double *objval, double *primsol, double *dualsol, double *activity, double *redcost)
     * }
     */
    public static MemorySegment SCIPlpiGetSol$address() {
        return SCIPlpiGetSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetSol(SCIP_LPI *lpi, double *objval, double *primsol, double *dualsol, double *activity, double *redcost)
     * }
     */
    public static int SCIPlpiGetSol(MemorySegment lpi, MemorySegment objval, MemorySegment primsol, MemorySegment dualsol, MemorySegment activity, MemorySegment redcost) {
        var mh$ = SCIPlpiGetSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetSol", lpi, objval, primsol, dualsol, activity, redcost);
            }
            return (int)mh$.invokeExact(lpi, objval, primsol, dualsol, activity, redcost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetPrimalRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetPrimalRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetPrimalRay(SCIP_LPI *lpi, double *ray)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetPrimalRay$descriptor() {
        return SCIPlpiGetPrimalRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetPrimalRay(SCIP_LPI *lpi, double *ray)
     * }
     */
    public static MethodHandle SCIPlpiGetPrimalRay$handle() {
        return SCIPlpiGetPrimalRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetPrimalRay(SCIP_LPI *lpi, double *ray)
     * }
     */
    public static MemorySegment SCIPlpiGetPrimalRay$address() {
        return SCIPlpiGetPrimalRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetPrimalRay(SCIP_LPI *lpi, double *ray)
     * }
     */
    public static int SCIPlpiGetPrimalRay(MemorySegment lpi, MemorySegment ray) {
        var mh$ = SCIPlpiGetPrimalRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetPrimalRay", lpi, ray);
            }
            return (int)mh$.invokeExact(lpi, ray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetDualfarkas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetDualfarkas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetDualfarkas(SCIP_LPI *lpi, double *dualfarkas)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetDualfarkas$descriptor() {
        return SCIPlpiGetDualfarkas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetDualfarkas(SCIP_LPI *lpi, double *dualfarkas)
     * }
     */
    public static MethodHandle SCIPlpiGetDualfarkas$handle() {
        return SCIPlpiGetDualfarkas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetDualfarkas(SCIP_LPI *lpi, double *dualfarkas)
     * }
     */
    public static MemorySegment SCIPlpiGetDualfarkas$address() {
        return SCIPlpiGetDualfarkas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetDualfarkas(SCIP_LPI *lpi, double *dualfarkas)
     * }
     */
    public static int SCIPlpiGetDualfarkas(MemorySegment lpi, MemorySegment dualfarkas) {
        var mh$ = SCIPlpiGetDualfarkas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetDualfarkas", lpi, dualfarkas);
            }
            return (int)mh$.invokeExact(lpi, dualfarkas);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIterations(SCIP_LPI *lpi, int *iterations)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetIterations$descriptor() {
        return SCIPlpiGetIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIterations(SCIP_LPI *lpi, int *iterations)
     * }
     */
    public static MethodHandle SCIPlpiGetIterations$handle() {
        return SCIPlpiGetIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIterations(SCIP_LPI *lpi, int *iterations)
     * }
     */
    public static MemorySegment SCIPlpiGetIterations$address() {
        return SCIPlpiGetIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIterations(SCIP_LPI *lpi, int *iterations)
     * }
     */
    public static int SCIPlpiGetIterations(MemorySegment lpi, MemorySegment iterations) {
        var mh$ = SCIPlpiGetIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetIterations", lpi, iterations);
            }
            return (int)mh$.invokeExact(lpi, iterations);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetRealSolQuality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetRealSolQuality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealSolQuality(SCIP_LPI *lpi, SCIP_LPSOLQUALITY qualityindicator, double *quality)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetRealSolQuality$descriptor() {
        return SCIPlpiGetRealSolQuality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealSolQuality(SCIP_LPI *lpi, SCIP_LPSOLQUALITY qualityindicator, double *quality)
     * }
     */
    public static MethodHandle SCIPlpiGetRealSolQuality$handle() {
        return SCIPlpiGetRealSolQuality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealSolQuality(SCIP_LPI *lpi, SCIP_LPSOLQUALITY qualityindicator, double *quality)
     * }
     */
    public static MemorySegment SCIPlpiGetRealSolQuality$address() {
        return SCIPlpiGetRealSolQuality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealSolQuality(SCIP_LPI *lpi, SCIP_LPSOLQUALITY qualityindicator, double *quality)
     * }
     */
    public static int SCIPlpiGetRealSolQuality(MemorySegment lpi, int qualityindicator, MemorySegment quality) {
        var mh$ = SCIPlpiGetRealSolQuality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetRealSolQuality", lpi, qualityindicator, quality);
            }
            return (int)mh$.invokeExact(lpi, qualityindicator, quality);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBase(SCIP_LPI *lpi, int *cstat, int *rstat)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBase$descriptor() {
        return SCIPlpiGetBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBase(SCIP_LPI *lpi, int *cstat, int *rstat)
     * }
     */
    public static MethodHandle SCIPlpiGetBase$handle() {
        return SCIPlpiGetBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBase(SCIP_LPI *lpi, int *cstat, int *rstat)
     * }
     */
    public static MemorySegment SCIPlpiGetBase$address() {
        return SCIPlpiGetBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBase(SCIP_LPI *lpi, int *cstat, int *rstat)
     * }
     */
    public static int SCIPlpiGetBase(MemorySegment lpi, MemorySegment cstat, MemorySegment rstat) {
        var mh$ = SCIPlpiGetBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBase", lpi, cstat, rstat);
            }
            return (int)mh$.invokeExact(lpi, cstat, rstat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetBase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetBase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetBase(SCIP_LPI *lpi, const int *cstat, const int *rstat)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetBase$descriptor() {
        return SCIPlpiSetBase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetBase(SCIP_LPI *lpi, const int *cstat, const int *rstat)
     * }
     */
    public static MethodHandle SCIPlpiSetBase$handle() {
        return SCIPlpiSetBase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetBase(SCIP_LPI *lpi, const int *cstat, const int *rstat)
     * }
     */
    public static MemorySegment SCIPlpiSetBase$address() {
        return SCIPlpiSetBase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetBase(SCIP_LPI *lpi, const int *cstat, const int *rstat)
     * }
     */
    public static int SCIPlpiSetBase(MemorySegment lpi, MemorySegment cstat, MemorySegment rstat) {
        var mh$ = SCIPlpiSetBase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetBase", lpi, cstat, rstat);
            }
            return (int)mh$.invokeExact(lpi, cstat, rstat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBasisInd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBasisInd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBasisInd(SCIP_LPI *lpi, int *bind)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBasisInd$descriptor() {
        return SCIPlpiGetBasisInd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBasisInd(SCIP_LPI *lpi, int *bind)
     * }
     */
    public static MethodHandle SCIPlpiGetBasisInd$handle() {
        return SCIPlpiGetBasisInd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBasisInd(SCIP_LPI *lpi, int *bind)
     * }
     */
    public static MemorySegment SCIPlpiGetBasisInd$address() {
        return SCIPlpiGetBasisInd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBasisInd(SCIP_LPI *lpi, int *bind)
     * }
     */
    public static int SCIPlpiGetBasisInd(MemorySegment lpi, MemorySegment bind) {
        var mh$ = SCIPlpiGetBasisInd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBasisInd", lpi, bind);
            }
            return (int)mh$.invokeExact(lpi, bind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBInvRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBInvRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvRow(SCIP_LPI *lpi, int r, double *coef, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBInvRow$descriptor() {
        return SCIPlpiGetBInvRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvRow(SCIP_LPI *lpi, int r, double *coef, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPlpiGetBInvRow$handle() {
        return SCIPlpiGetBInvRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvRow(SCIP_LPI *lpi, int r, double *coef, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPlpiGetBInvRow$address() {
        return SCIPlpiGetBInvRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvRow(SCIP_LPI *lpi, int r, double *coef, int *inds, int *ninds)
     * }
     */
    public static int SCIPlpiGetBInvRow(MemorySegment lpi, int r, MemorySegment coef, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPlpiGetBInvRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBInvRow", lpi, r, coef, inds, ninds);
            }
            return (int)mh$.invokeExact(lpi, r, coef, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBInvCol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBInvCol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvCol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBInvCol$descriptor() {
        return SCIPlpiGetBInvCol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvCol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPlpiGetBInvCol$handle() {
        return SCIPlpiGetBInvCol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvCol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPlpiGetBInvCol$address() {
        return SCIPlpiGetBInvCol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvCol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static int SCIPlpiGetBInvCol(MemorySegment lpi, int c, MemorySegment coef, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPlpiGetBInvCol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBInvCol", lpi, c, coef, inds, ninds);
            }
            return (int)mh$.invokeExact(lpi, c, coef, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBInvARow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBInvARow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvARow(SCIP_LPI *lpi, int r, const double *binvrow, double *coef, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBInvARow$descriptor() {
        return SCIPlpiGetBInvARow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvARow(SCIP_LPI *lpi, int r, const double *binvrow, double *coef, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPlpiGetBInvARow$handle() {
        return SCIPlpiGetBInvARow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvARow(SCIP_LPI *lpi, int r, const double *binvrow, double *coef, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPlpiGetBInvARow$address() {
        return SCIPlpiGetBInvARow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvARow(SCIP_LPI *lpi, int r, const double *binvrow, double *coef, int *inds, int *ninds)
     * }
     */
    public static int SCIPlpiGetBInvARow(MemorySegment lpi, int r, MemorySegment binvrow, MemorySegment coef, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPlpiGetBInvARow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBInvARow", lpi, r, binvrow, coef, inds, ninds);
            }
            return (int)mh$.invokeExact(lpi, r, binvrow, coef, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetBInvACol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetBInvACol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvACol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetBInvACol$descriptor() {
        return SCIPlpiGetBInvACol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvACol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPlpiGetBInvACol$handle() {
        return SCIPlpiGetBInvACol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvACol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPlpiGetBInvACol$address() {
        return SCIPlpiGetBInvACol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetBInvACol(SCIP_LPI *lpi, int c, double *coef, int *inds, int *ninds)
     * }
     */
    public static int SCIPlpiGetBInvACol(MemorySegment lpi, int c, MemorySegment coef, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPlpiGetBInvACol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetBInvACol", lpi, c, coef, inds, ninds);
            }
            return (int)mh$.invokeExact(lpi, c, coef, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetState$descriptor() {
        return SCIPlpiGetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static MethodHandle SCIPlpiGetState$handle() {
        return SCIPlpiGetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static MemorySegment SCIPlpiGetState$address() {
        return SCIPlpiGetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static int SCIPlpiGetState(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpistate) {
        var mh$ = SCIPlpiGetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetState", lpi, blkmem, lpistate);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpistate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPISTATE *lpistate)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetState$descriptor() {
        return SCIPlpiSetState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPISTATE *lpistate)
     * }
     */
    public static MethodHandle SCIPlpiSetState$handle() {
        return SCIPlpiSetState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPISTATE *lpistate)
     * }
     */
    public static MemorySegment SCIPlpiSetState$address() {
        return SCIPlpiSetState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPISTATE *lpistate)
     * }
     */
    public static int SCIPlpiSetState(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpistate) {
        var mh$ = SCIPlpiSetState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetState", lpi, blkmem, lpistate);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpistate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiClearState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiClearState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClearState(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiClearState$descriptor() {
        return SCIPlpiClearState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClearState(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiClearState$handle() {
        return SCIPlpiClearState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClearState(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiClearState$address() {
        return SCIPlpiClearState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiClearState(SCIP_LPI *lpi)
     * }
     */
    public static int SCIPlpiClearState(MemorySegment lpi) {
        var mh$ = SCIPlpiClearState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiClearState", lpi);
            }
            return (int)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiFreeState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiFreeState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static FunctionDescriptor SCIPlpiFreeState$descriptor() {
        return SCIPlpiFreeState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static MethodHandle SCIPlpiFreeState$handle() {
        return SCIPlpiFreeState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static MemorySegment SCIPlpiFreeState$address() {
        return SCIPlpiFreeState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeState(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPISTATE **lpistate)
     * }
     */
    public static int SCIPlpiFreeState(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpistate) {
        var mh$ = SCIPlpiFreeState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiFreeState", lpi, blkmem, lpistate);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpistate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiHasStateBasis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiHasStateBasis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasStateBasis(SCIP_LPI *lpi, SCIP_LPISTATE *lpistate)
     * }
     */
    public static FunctionDescriptor SCIPlpiHasStateBasis$descriptor() {
        return SCIPlpiHasStateBasis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasStateBasis(SCIP_LPI *lpi, SCIP_LPISTATE *lpistate)
     * }
     */
    public static MethodHandle SCIPlpiHasStateBasis$handle() {
        return SCIPlpiHasStateBasis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasStateBasis(SCIP_LPI *lpi, SCIP_LPISTATE *lpistate)
     * }
     */
    public static MemorySegment SCIPlpiHasStateBasis$address() {
        return SCIPlpiHasStateBasis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiHasStateBasis(SCIP_LPI *lpi, SCIP_LPISTATE *lpistate)
     * }
     */
    public static int SCIPlpiHasStateBasis(MemorySegment lpi, MemorySegment lpistate) {
        var mh$ = SCIPlpiHasStateBasis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiHasStateBasis", lpi, lpistate);
            }
            return (int)mh$.invokeExact(lpi, lpistate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiReadState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiReadState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static FunctionDescriptor SCIPlpiReadState$descriptor() {
        return SCIPlpiReadState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MethodHandle SCIPlpiReadState$handle() {
        return SCIPlpiReadState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MemorySegment SCIPlpiReadState$address() {
        return SCIPlpiReadState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static int SCIPlpiReadState(MemorySegment lpi, MemorySegment fname) {
        var mh$ = SCIPlpiReadState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiReadState", lpi, fname);
            }
            return (int)mh$.invokeExact(lpi, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiWriteState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiWriteState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static FunctionDescriptor SCIPlpiWriteState$descriptor() {
        return SCIPlpiWriteState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MethodHandle SCIPlpiWriteState$handle() {
        return SCIPlpiWriteState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MemorySegment SCIPlpiWriteState$address() {
        return SCIPlpiWriteState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteState(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static int SCIPlpiWriteState(MemorySegment lpi, MemorySegment fname) {
        var mh$ = SCIPlpiWriteState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiWriteState", lpi, fname);
            }
            return (int)mh$.invokeExact(lpi, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetNorms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetNorms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetNorms$descriptor() {
        return SCIPlpiGetNorms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static MethodHandle SCIPlpiGetNorms$handle() {
        return SCIPlpiGetNorms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static MemorySegment SCIPlpiGetNorms$address() {
        return SCIPlpiGetNorms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static int SCIPlpiGetNorms(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpinorms) {
        var mh$ = SCIPlpiGetNorms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetNorms", lpi, blkmem, lpinorms);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpinorms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetNorms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetNorms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPINORMS *lpinorms)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetNorms$descriptor() {
        return SCIPlpiSetNorms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPINORMS *lpinorms)
     * }
     */
    public static MethodHandle SCIPlpiSetNorms$handle() {
        return SCIPlpiSetNorms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPINORMS *lpinorms)
     * }
     */
    public static MemorySegment SCIPlpiSetNorms$address() {
        return SCIPlpiSetNorms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, const SCIP_LPINORMS *lpinorms)
     * }
     */
    public static int SCIPlpiSetNorms(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpinorms) {
        var mh$ = SCIPlpiSetNorms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetNorms", lpi, blkmem, lpinorms);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpinorms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiFreeNorms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiFreeNorms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static FunctionDescriptor SCIPlpiFreeNorms$descriptor() {
        return SCIPlpiFreeNorms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static MethodHandle SCIPlpiFreeNorms$handle() {
        return SCIPlpiFreeNorms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static MemorySegment SCIPlpiFreeNorms$address() {
        return SCIPlpiFreeNorms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiFreeNorms(SCIP_LPI *lpi, BMS_BLKMEM *blkmem, SCIP_LPINORMS **lpinorms)
     * }
     */
    public static int SCIPlpiFreeNorms(MemorySegment lpi, MemorySegment blkmem, MemorySegment lpinorms) {
        var mh$ = SCIPlpiFreeNorms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiFreeNorms", lpi, blkmem, lpinorms);
            }
            return (int)mh$.invokeExact(lpi, blkmem, lpinorms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetIntpar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetIntpar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int *ival)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetIntpar$descriptor() {
        return SCIPlpiGetIntpar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int *ival)
     * }
     */
    public static MethodHandle SCIPlpiGetIntpar$handle() {
        return SCIPlpiGetIntpar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int *ival)
     * }
     */
    public static MemorySegment SCIPlpiGetIntpar$address() {
        return SCIPlpiGetIntpar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int *ival)
     * }
     */
    public static int SCIPlpiGetIntpar(MemorySegment lpi, int type, MemorySegment ival) {
        var mh$ = SCIPlpiGetIntpar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetIntpar", lpi, type, ival);
            }
            return (int)mh$.invokeExact(lpi, type, ival);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetIntpar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetIntpar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int ival)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetIntpar$descriptor() {
        return SCIPlpiSetIntpar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int ival)
     * }
     */
    public static MethodHandle SCIPlpiSetIntpar$handle() {
        return SCIPlpiSetIntpar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int ival)
     * }
     */
    public static MemorySegment SCIPlpiSetIntpar$address() {
        return SCIPlpiSetIntpar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetIntpar(SCIP_LPI *lpi, SCIP_LPPARAM type, int ival)
     * }
     */
    public static int SCIPlpiSetIntpar(MemorySegment lpi, int type, int ival) {
        var mh$ = SCIPlpiSetIntpar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetIntpar", lpi, type, ival);
            }
            return (int)mh$.invokeExact(lpi, type, ival);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiGetRealpar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiGetRealpar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double *dval)
     * }
     */
    public static FunctionDescriptor SCIPlpiGetRealpar$descriptor() {
        return SCIPlpiGetRealpar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double *dval)
     * }
     */
    public static MethodHandle SCIPlpiGetRealpar$handle() {
        return SCIPlpiGetRealpar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double *dval)
     * }
     */
    public static MemorySegment SCIPlpiGetRealpar$address() {
        return SCIPlpiGetRealpar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiGetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double *dval)
     * }
     */
    public static int SCIPlpiGetRealpar(MemorySegment lpi, int type, MemorySegment dval) {
        var mh$ = SCIPlpiGetRealpar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiGetRealpar", lpi, type, dval);
            }
            return (int)mh$.invokeExact(lpi, type, dval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiSetRealpar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiSetRealpar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double dval)
     * }
     */
    public static FunctionDescriptor SCIPlpiSetRealpar$descriptor() {
        return SCIPlpiSetRealpar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double dval)
     * }
     */
    public static MethodHandle SCIPlpiSetRealpar$handle() {
        return SCIPlpiSetRealpar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double dval)
     * }
     */
    public static MemorySegment SCIPlpiSetRealpar$address() {
        return SCIPlpiSetRealpar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiSetRealpar(SCIP_LPI *lpi, SCIP_LPPARAM type, double dval)
     * }
     */
    public static int SCIPlpiSetRealpar(MemorySegment lpi, int type, double dval) {
        var mh$ = SCIPlpiSetRealpar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiSetRealpar", lpi, type, dval);
            }
            return (int)mh$.invokeExact(lpi, type, dval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiInterrupt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiInterrupt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiInterrupt(SCIP_LPI *lpi, unsigned int interrupt)
     * }
     */
    public static FunctionDescriptor SCIPlpiInterrupt$descriptor() {
        return SCIPlpiInterrupt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiInterrupt(SCIP_LPI *lpi, unsigned int interrupt)
     * }
     */
    public static MethodHandle SCIPlpiInterrupt$handle() {
        return SCIPlpiInterrupt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiInterrupt(SCIP_LPI *lpi, unsigned int interrupt)
     * }
     */
    public static MemorySegment SCIPlpiInterrupt$address() {
        return SCIPlpiInterrupt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiInterrupt(SCIP_LPI *lpi, unsigned int interrupt)
     * }
     */
    public static int SCIPlpiInterrupt(MemorySegment lpi, int interrupt) {
        var mh$ = SCIPlpiInterrupt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiInterrupt", lpi, interrupt);
            }
            return (int)mh$.invokeExact(lpi, interrupt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiInfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiInfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPlpiInfinity(SCIP_LPI *lpi)
     * }
     */
    public static FunctionDescriptor SCIPlpiInfinity$descriptor() {
        return SCIPlpiInfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPlpiInfinity(SCIP_LPI *lpi)
     * }
     */
    public static MethodHandle SCIPlpiInfinity$handle() {
        return SCIPlpiInfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPlpiInfinity(SCIP_LPI *lpi)
     * }
     */
    public static MemorySegment SCIPlpiInfinity$address() {
        return SCIPlpiInfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPlpiInfinity(SCIP_LPI *lpi)
     * }
     */
    public static double SCIPlpiInfinity(MemorySegment lpi) {
        var mh$ = SCIPlpiInfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiInfinity", lpi);
            }
            return (double)mh$.invokeExact(lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiIsInfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiIsInfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsInfinity(SCIP_LPI *lpi, double val)
     * }
     */
    public static FunctionDescriptor SCIPlpiIsInfinity$descriptor() {
        return SCIPlpiIsInfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsInfinity(SCIP_LPI *lpi, double val)
     * }
     */
    public static MethodHandle SCIPlpiIsInfinity$handle() {
        return SCIPlpiIsInfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsInfinity(SCIP_LPI *lpi, double val)
     * }
     */
    public static MemorySegment SCIPlpiIsInfinity$address() {
        return SCIPlpiIsInfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPlpiIsInfinity(SCIP_LPI *lpi, double val)
     * }
     */
    public static int SCIPlpiIsInfinity(MemorySegment lpi, double val) {
        var mh$ = SCIPlpiIsInfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiIsInfinity", lpi, val);
            }
            return (int)mh$.invokeExact(lpi, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiReadLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiReadLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static FunctionDescriptor SCIPlpiReadLP$descriptor() {
        return SCIPlpiReadLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MethodHandle SCIPlpiReadLP$handle() {
        return SCIPlpiReadLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MemorySegment SCIPlpiReadLP$address() {
        return SCIPlpiReadLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiReadLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static int SCIPlpiReadLP(MemorySegment lpi, MemorySegment fname) {
        var mh$ = SCIPlpiReadLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiReadLP", lpi, fname);
            }
            return (int)mh$.invokeExact(lpi, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpiWriteLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpiWriteLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static FunctionDescriptor SCIPlpiWriteLP$descriptor() {
        return SCIPlpiWriteLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MethodHandle SCIPlpiWriteLP$handle() {
        return SCIPlpiWriteLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static MemorySegment SCIPlpiWriteLP$address() {
        return SCIPlpiWriteLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlpiWriteLP(SCIP_LPI *lpi, const char *fname)
     * }
     */
    public static int SCIPlpiWriteLP(MemorySegment lpi, MemorySegment fname) {
        var mh$ = SCIPlpiWriteLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpiWriteLP", lpi, fname);
            }
            return (int)mh$.invokeExact(lpi, fname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPshrinkDisjunctiveVarSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPshrinkDisjunctiveVarSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshrinkDisjunctiveVarSet(SCIP *scip, SCIP_VAR **vars, double *bounds, unsigned int *boundtypes, unsigned int *redundants, int nvars, int *nredvars, int *nglobalred, unsigned int *setredundant, unsigned int *glbinfeas, unsigned int fullshortening)
     * }
     */
    public static FunctionDescriptor SCIPshrinkDisjunctiveVarSet$descriptor() {
        return SCIPshrinkDisjunctiveVarSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshrinkDisjunctiveVarSet(SCIP *scip, SCIP_VAR **vars, double *bounds, unsigned int *boundtypes, unsigned int *redundants, int nvars, int *nredvars, int *nglobalred, unsigned int *setredundant, unsigned int *glbinfeas, unsigned int fullshortening)
     * }
     */
    public static MethodHandle SCIPshrinkDisjunctiveVarSet$handle() {
        return SCIPshrinkDisjunctiveVarSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshrinkDisjunctiveVarSet(SCIP *scip, SCIP_VAR **vars, double *bounds, unsigned int *boundtypes, unsigned int *redundants, int nvars, int *nredvars, int *nglobalred, unsigned int *setredundant, unsigned int *glbinfeas, unsigned int fullshortening)
     * }
     */
    public static MemorySegment SCIPshrinkDisjunctiveVarSet$address() {
        return SCIPshrinkDisjunctiveVarSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshrinkDisjunctiveVarSet(SCIP *scip, SCIP_VAR **vars, double *bounds, unsigned int *boundtypes, unsigned int *redundants, int nvars, int *nredvars, int *nglobalred, unsigned int *setredundant, unsigned int *glbinfeas, unsigned int fullshortening)
     * }
     */
    public static int SCIPshrinkDisjunctiveVarSet(MemorySegment scip, MemorySegment vars, MemorySegment bounds, MemorySegment boundtypes, MemorySegment redundants, int nvars, MemorySegment nredvars, MemorySegment nglobalred, MemorySegment setredundant, MemorySegment glbinfeas, int fullshortening) {
        var mh$ = SCIPshrinkDisjunctiveVarSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPshrinkDisjunctiveVarSet", scip, vars, bounds, boundtypes, redundants, nvars, nredvars, nglobalred, setredundant, glbinfeas, fullshortening);
            }
            return (int)mh$.invokeExact(scip, vars, bounds, boundtypes, redundants, nvars, nredvars, nglobalred, setredundant, glbinfeas, fullshortening);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutsTightenCoefficients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutsTightenCoefficients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcutsTightenCoefficients(SCIP *scip, unsigned int cutislocal, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, int *nchgcoefs)
     * }
     */
    public static FunctionDescriptor SCIPcutsTightenCoefficients$descriptor() {
        return SCIPcutsTightenCoefficients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcutsTightenCoefficients(SCIP *scip, unsigned int cutislocal, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, int *nchgcoefs)
     * }
     */
    public static MethodHandle SCIPcutsTightenCoefficients$handle() {
        return SCIPcutsTightenCoefficients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcutsTightenCoefficients(SCIP *scip, unsigned int cutislocal, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, int *nchgcoefs)
     * }
     */
    public static MemorySegment SCIPcutsTightenCoefficients$address() {
        return SCIPcutsTightenCoefficients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcutsTightenCoefficients(SCIP *scip, unsigned int cutislocal, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, int *nchgcoefs)
     * }
     */
    public static int SCIPcutsTightenCoefficients(MemorySegment scip, int cutislocal, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment nchgcoefs) {
        var mh$ = SCIPcutsTightenCoefficients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutsTightenCoefficients", scip, cutislocal, cutcoefs, cutrhs, cutinds, cutnnz, nchgcoefs);
            }
            return (int)mh$.invokeExact(scip, cutislocal, cutcoefs, cutrhs, cutinds, cutnnz, nchgcoefs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowCreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCreate(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowCreate$descriptor() {
        return SCIPaggrRowCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCreate(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowCreate$handle() {
        return SCIPaggrRowCreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCreate(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowCreate$address() {
        return SCIPaggrRowCreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCreate(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static int SCIPaggrRowCreate(MemorySegment scip, MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowCreate", scip, aggrrow);
            }
            return (int)mh$.invokeExact(scip, aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowFree(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowFree$descriptor() {
        return SCIPaggrRowFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowFree(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowFree$handle() {
        return SCIPaggrRowFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowFree(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowFree$address() {
        return SCIPaggrRowFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowFree(SCIP *scip, SCIP_AGGRROW **aggrrow)
     * }
     */
    public static void SCIPaggrRowFree(MemorySegment scip, MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowFree", scip, aggrrow);
            }
            mh$.invokeExact(scip, aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowPrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowPrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowPrint(SCIP *scip, SCIP_AGGRROW *aggrrow, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowPrint$descriptor() {
        return SCIPaggrRowPrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowPrint(SCIP *scip, SCIP_AGGRROW *aggrrow, FILE *file)
     * }
     */
    public static MethodHandle SCIPaggrRowPrint$handle() {
        return SCIPaggrRowPrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowPrint(SCIP *scip, SCIP_AGGRROW *aggrrow, FILE *file)
     * }
     */
    public static MemorySegment SCIPaggrRowPrint$address() {
        return SCIPaggrRowPrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowPrint(SCIP *scip, SCIP_AGGRROW *aggrrow, FILE *file)
     * }
     */
    public static void SCIPaggrRowPrint(MemorySegment scip, MemorySegment aggrrow, MemorySegment file) {
        var mh$ = SCIPaggrRowPrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowPrint", scip, aggrrow, file);
            }
            mh$.invokeExact(scip, aggrrow, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCopy(SCIP *scip, SCIP_AGGRROW **aggrrow, SCIP_AGGRROW *source)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowCopy$descriptor() {
        return SCIPaggrRowCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCopy(SCIP *scip, SCIP_AGGRROW **aggrrow, SCIP_AGGRROW *source)
     * }
     */
    public static MethodHandle SCIPaggrRowCopy$handle() {
        return SCIPaggrRowCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCopy(SCIP *scip, SCIP_AGGRROW **aggrrow, SCIP_AGGRROW *source)
     * }
     */
    public static MemorySegment SCIPaggrRowCopy$address() {
        return SCIPaggrRowCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowCopy(SCIP *scip, SCIP_AGGRROW **aggrrow, SCIP_AGGRROW *source)
     * }
     */
    public static int SCIPaggrRowCopy(MemorySegment scip, MemorySegment aggrrow, MemorySegment source) {
        var mh$ = SCIPaggrRowCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowCopy", scip, aggrrow, source);
            }
            return (int)mh$.invokeExact(scip, aggrrow, source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowAddRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowAddRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddRow(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_ROW *row, double weight, int sidetype)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowAddRow$descriptor() {
        return SCIPaggrRowAddRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddRow(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_ROW *row, double weight, int sidetype)
     * }
     */
    public static MethodHandle SCIPaggrRowAddRow$handle() {
        return SCIPaggrRowAddRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddRow(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_ROW *row, double weight, int sidetype)
     * }
     */
    public static MemorySegment SCIPaggrRowAddRow$address() {
        return SCIPaggrRowAddRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddRow(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_ROW *row, double weight, int sidetype)
     * }
     */
    public static int SCIPaggrRowAddRow(MemorySegment scip, MemorySegment aggrrow, MemorySegment row, double weight, int sidetype) {
        var mh$ = SCIPaggrRowAddRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowAddRow", scip, aggrrow, row, weight, sidetype);
            }
            return (int)mh$.invokeExact(scip, aggrrow, row, weight, sidetype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowCancelVarWithBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowCancelVarWithBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowCancelVarWithBound(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_VAR *var, int pos, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowCancelVarWithBound$descriptor() {
        return SCIPaggrRowCancelVarWithBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowCancelVarWithBound(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_VAR *var, int pos, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPaggrRowCancelVarWithBound$handle() {
        return SCIPaggrRowCancelVarWithBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowCancelVarWithBound(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_VAR *var, int pos, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPaggrRowCancelVarWithBound$address() {
        return SCIPaggrRowCancelVarWithBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowCancelVarWithBound(SCIP *scip, SCIP_AGGRROW *aggrrow, SCIP_VAR *var, int pos, unsigned int *valid)
     * }
     */
    public static void SCIPaggrRowCancelVarWithBound(MemorySegment scip, MemorySegment aggrrow, MemorySegment var_, int pos, MemorySegment valid) {
        var mh$ = SCIPaggrRowCancelVarWithBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowCancelVarWithBound", scip, aggrrow, var_, pos, valid);
            }
            mh$.invokeExact(scip, aggrrow, var_, pos, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowAddObjectiveFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowAddObjectiveFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddObjectiveFunction(SCIP *scip, SCIP_AGGRROW *aggrrow, double rhs, double scale)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowAddObjectiveFunction$descriptor() {
        return SCIPaggrRowAddObjectiveFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddObjectiveFunction(SCIP *scip, SCIP_AGGRROW *aggrrow, double rhs, double scale)
     * }
     */
    public static MethodHandle SCIPaggrRowAddObjectiveFunction$handle() {
        return SCIPaggrRowAddObjectiveFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddObjectiveFunction(SCIP *scip, SCIP_AGGRROW *aggrrow, double rhs, double scale)
     * }
     */
    public static MemorySegment SCIPaggrRowAddObjectiveFunction$address() {
        return SCIPaggrRowAddObjectiveFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddObjectiveFunction(SCIP *scip, SCIP_AGGRROW *aggrrow, double rhs, double scale)
     * }
     */
    public static int SCIPaggrRowAddObjectiveFunction(MemorySegment scip, MemorySegment aggrrow, double rhs, double scale) {
        var mh$ = SCIPaggrRowAddObjectiveFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowAddObjectiveFunction", scip, aggrrow, rhs, scale);
            }
            return (int)mh$.invokeExact(scip, aggrrow, rhs, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowAddCustomCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowAddCustomCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddCustomCons(SCIP *scip, SCIP_AGGRROW *aggrrow, int *inds, double *vals, int len, double rhs, double weight, int rank, unsigned int local)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowAddCustomCons$descriptor() {
        return SCIPaggrRowAddCustomCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddCustomCons(SCIP *scip, SCIP_AGGRROW *aggrrow, int *inds, double *vals, int len, double rhs, double weight, int rank, unsigned int local)
     * }
     */
    public static MethodHandle SCIPaggrRowAddCustomCons$handle() {
        return SCIPaggrRowAddCustomCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddCustomCons(SCIP *scip, SCIP_AGGRROW *aggrrow, int *inds, double *vals, int len, double rhs, double weight, int rank, unsigned int local)
     * }
     */
    public static MemorySegment SCIPaggrRowAddCustomCons$address() {
        return SCIPaggrRowAddCustomCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowAddCustomCons(SCIP *scip, SCIP_AGGRROW *aggrrow, int *inds, double *vals, int len, double rhs, double weight, int rank, unsigned int local)
     * }
     */
    public static int SCIPaggrRowAddCustomCons(MemorySegment scip, MemorySegment aggrrow, MemorySegment inds, MemorySegment vals, int len, double rhs, double weight, int rank, int local) {
        var mh$ = SCIPaggrRowAddCustomCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowAddCustomCons", scip, aggrrow, inds, vals, len, rhs, weight, rank, local);
            }
            return (int)mh$.invokeExact(scip, aggrrow, inds, vals, len, rhs, weight, rank, local);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowCalcEfficacyNorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowCalcEfficacyNorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPaggrRowCalcEfficacyNorm(SCIP *scip, SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowCalcEfficacyNorm$descriptor() {
        return SCIPaggrRowCalcEfficacyNorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPaggrRowCalcEfficacyNorm(SCIP *scip, SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowCalcEfficacyNorm$handle() {
        return SCIPaggrRowCalcEfficacyNorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPaggrRowCalcEfficacyNorm(SCIP *scip, SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowCalcEfficacyNorm$address() {
        return SCIPaggrRowCalcEfficacyNorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPaggrRowCalcEfficacyNorm(SCIP *scip, SCIP_AGGRROW *aggrrow)
     * }
     */
    public static double SCIPaggrRowCalcEfficacyNorm(MemorySegment scip, MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowCalcEfficacyNorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowCalcEfficacyNorm", scip, aggrrow);
            }
            return (double)mh$.invokeExact(scip, aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowClear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowClear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowClear(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowClear$descriptor() {
        return SCIPaggrRowClear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowClear(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowClear$handle() {
        return SCIPaggrRowClear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowClear(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowClear$address() {
        return SCIPaggrRowClear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowClear(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static void SCIPaggrRowClear(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowClear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowClear", aggrrow);
            }
            mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowSumRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowSumRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowSumRows(SCIP *scip, SCIP_AGGRROW *aggrrow, double *weights, int *rowinds, int nrowinds, unsigned int sidetypebasis, unsigned int allowlocal, int negslack, int maxaggrlen, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowSumRows$descriptor() {
        return SCIPaggrRowSumRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowSumRows(SCIP *scip, SCIP_AGGRROW *aggrrow, double *weights, int *rowinds, int nrowinds, unsigned int sidetypebasis, unsigned int allowlocal, int negslack, int maxaggrlen, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPaggrRowSumRows$handle() {
        return SCIPaggrRowSumRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowSumRows(SCIP *scip, SCIP_AGGRROW *aggrrow, double *weights, int *rowinds, int nrowinds, unsigned int sidetypebasis, unsigned int allowlocal, int negslack, int maxaggrlen, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPaggrRowSumRows$address() {
        return SCIPaggrRowSumRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggrRowSumRows(SCIP *scip, SCIP_AGGRROW *aggrrow, double *weights, int *rowinds, int nrowinds, unsigned int sidetypebasis, unsigned int allowlocal, int negslack, int maxaggrlen, unsigned int *valid)
     * }
     */
    public static int SCIPaggrRowSumRows(MemorySegment scip, MemorySegment aggrrow, MemorySegment weights, MemorySegment rowinds, int nrowinds, int sidetypebasis, int allowlocal, int negslack, int maxaggrlen, MemorySegment valid) {
        var mh$ = SCIPaggrRowSumRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowSumRows", scip, aggrrow, weights, rowinds, nrowinds, sidetypebasis, allowlocal, negslack, maxaggrlen, valid);
            }
            return (int)mh$.invokeExact(scip, aggrrow, weights, rowinds, nrowinds, sidetypebasis, allowlocal, negslack, maxaggrlen, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowRemoveZeros {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowRemoveZeros");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowRemoveZeros(SCIP *scip, SCIP_AGGRROW *aggrrow, unsigned int useglbbounds, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowRemoveZeros$descriptor() {
        return SCIPaggrRowRemoveZeros.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowRemoveZeros(SCIP *scip, SCIP_AGGRROW *aggrrow, unsigned int useglbbounds, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPaggrRowRemoveZeros$handle() {
        return SCIPaggrRowRemoveZeros.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowRemoveZeros(SCIP *scip, SCIP_AGGRROW *aggrrow, unsigned int useglbbounds, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPaggrRowRemoveZeros$address() {
        return SCIPaggrRowRemoveZeros.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowRemoveZeros(SCIP *scip, SCIP_AGGRROW *aggrrow, unsigned int useglbbounds, unsigned int *valid)
     * }
     */
    public static void SCIPaggrRowRemoveZeros(MemorySegment scip, MemorySegment aggrrow, int useglbbounds, MemorySegment valid) {
        var mh$ = SCIPaggrRowRemoveZeros.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowRemoveZeros", scip, aggrrow, useglbbounds, valid);
            }
            mh$.invokeExact(scip, aggrrow, useglbbounds, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetRowInds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetRowInds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetRowInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetRowInds$descriptor() {
        return SCIPaggrRowGetRowInds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetRowInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetRowInds$handle() {
        return SCIPaggrRowGetRowInds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetRowInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRowInds$address() {
        return SCIPaggrRowGetRowInds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPaggrRowGetRowInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRowInds(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetRowInds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetRowInds", aggrrow);
            }
            return (MemorySegment)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetRowWeights {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetRowWeights");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPaggrRowGetRowWeights(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetRowWeights$descriptor() {
        return SCIPaggrRowGetRowWeights.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPaggrRowGetRowWeights(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetRowWeights$handle() {
        return SCIPaggrRowGetRowWeights.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPaggrRowGetRowWeights(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRowWeights$address() {
        return SCIPaggrRowGetRowWeights.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPaggrRowGetRowWeights(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRowWeights(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetRowWeights.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetRowWeights", aggrrow);
            }
            return (MemorySegment)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowHasRowBeenAdded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowHasRowBeenAdded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowHasRowBeenAdded(SCIP_AGGRROW *aggrrow, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowHasRowBeenAdded$descriptor() {
        return SCIPaggrRowHasRowBeenAdded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowHasRowBeenAdded(SCIP_AGGRROW *aggrrow, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaggrRowHasRowBeenAdded$handle() {
        return SCIPaggrRowHasRowBeenAdded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowHasRowBeenAdded(SCIP_AGGRROW *aggrrow, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaggrRowHasRowBeenAdded$address() {
        return SCIPaggrRowHasRowBeenAdded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowHasRowBeenAdded(SCIP_AGGRROW *aggrrow, SCIP_ROW *row)
     * }
     */
    public static int SCIPaggrRowHasRowBeenAdded(MemorySegment aggrrow, MemorySegment row) {
        var mh$ = SCIPaggrRowHasRowBeenAdded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowHasRowBeenAdded", aggrrow, row);
            }
            return (int)mh$.invokeExact(aggrrow, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetAbsWeightRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetAbsWeightRange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaggrRowGetAbsWeightRange(SCIP_AGGRROW *aggrrow, double *minabsrowweight, double *maxabsrowweight)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetAbsWeightRange$descriptor() {
        return SCIPaggrRowGetAbsWeightRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaggrRowGetAbsWeightRange(SCIP_AGGRROW *aggrrow, double *minabsrowweight, double *maxabsrowweight)
     * }
     */
    public static MethodHandle SCIPaggrRowGetAbsWeightRange$handle() {
        return SCIPaggrRowGetAbsWeightRange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaggrRowGetAbsWeightRange(SCIP_AGGRROW *aggrrow, double *minabsrowweight, double *maxabsrowweight)
     * }
     */
    public static MemorySegment SCIPaggrRowGetAbsWeightRange$address() {
        return SCIPaggrRowGetAbsWeightRange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaggrRowGetAbsWeightRange(SCIP_AGGRROW *aggrrow, double *minabsrowweight, double *maxabsrowweight)
     * }
     */
    public static void SCIPaggrRowGetAbsWeightRange(MemorySegment aggrrow, MemorySegment minabsrowweight, MemorySegment maxabsrowweight) {
        var mh$ = SCIPaggrRowGetAbsWeightRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetAbsWeightRange", aggrrow, minabsrowweight, maxabsrowweight);
            }
            mh$.invokeExact(aggrrow, minabsrowweight, maxabsrowweight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetInds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetInds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetInds$descriptor() {
        return SCIPaggrRowGetInds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetInds$handle() {
        return SCIPaggrRowGetInds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPaggrRowGetInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetInds$address() {
        return SCIPaggrRowGetInds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPaggrRowGetInds(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetInds(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetInds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetInds", aggrrow);
            }
            return (MemorySegment)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetNNz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetNNz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNNz(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetNNz$descriptor() {
        return SCIPaggrRowGetNNz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNNz(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetNNz$handle() {
        return SCIPaggrRowGetNNz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNNz(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetNNz$address() {
        return SCIPaggrRowGetNNz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPaggrRowGetNNz(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static int SCIPaggrRowGetNNz(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetNNz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetNNz", aggrrow);
            }
            return (int)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetRank {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetRank");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetRank(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetRank$descriptor() {
        return SCIPaggrRowGetRank.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetRank(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetRank$handle() {
        return SCIPaggrRowGetRank.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetRank(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRank$address() {
        return SCIPaggrRowGetRank.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPaggrRowGetRank(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static int SCIPaggrRowGetRank(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetRank.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetRank", aggrrow);
            }
            return (int)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowIsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowIsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowIsLocal(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowIsLocal$descriptor() {
        return SCIPaggrRowIsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowIsLocal(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowIsLocal$handle() {
        return SCIPaggrRowIsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowIsLocal(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowIsLocal$address() {
        return SCIPaggrRowIsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPaggrRowIsLocal(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static int SCIPaggrRowIsLocal(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowIsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowIsLocal", aggrrow);
            }
            return (int)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetRhs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetRhs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPaggrRowGetRhs(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetRhs$descriptor() {
        return SCIPaggrRowGetRhs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPaggrRowGetRhs(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetRhs$handle() {
        return SCIPaggrRowGetRhs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPaggrRowGetRhs(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetRhs$address() {
        return SCIPaggrRowGetRhs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPaggrRowGetRhs(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static double SCIPaggrRowGetRhs(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetRhs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetRhs", aggrrow);
            }
            return (double)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggrRowGetNRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggrRowGetNRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNRows(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static FunctionDescriptor SCIPaggrRowGetNRows$descriptor() {
        return SCIPaggrRowGetNRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNRows(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MethodHandle SCIPaggrRowGetNRows$handle() {
        return SCIPaggrRowGetNRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPaggrRowGetNRows(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static MemorySegment SCIPaggrRowGetNRows$address() {
        return SCIPaggrRowGetNRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPaggrRowGetNRows(SCIP_AGGRROW *aggrrow)
     * }
     */
    public static int SCIPaggrRowGetNRows(MemorySegment aggrrow) {
        var mh$ = SCIPaggrRowGetNRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggrRowGetNRows", aggrrow);
            }
            return (int)mh$.invokeExact(aggrrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcMIR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcMIR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, unsigned int fixintegralrhs, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcMIR$descriptor() {
        return SCIPcalcMIR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, unsigned int fixintegralrhs, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcMIR$handle() {
        return SCIPcalcMIR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, unsigned int fixintegralrhs, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcMIR$address() {
        return SCIPcalcMIR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, unsigned int fixintegralrhs, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static int SCIPcalcMIR(MemorySegment scip, MemorySegment sol, int postprocess, double boundswitch, int usevbds, int allowlocal, int fixintegralrhs, MemorySegment boundsfortrans, MemorySegment boundtypesfortrans, double minfrac, double maxfrac, double scale, MemorySegment aggrrow, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment cutefficacy, MemorySegment cutrank, MemorySegment cutislocal, MemorySegment success) {
        var mh$ = SCIPcalcMIR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcMIR", scip, sol, postprocess, boundswitch, usevbds, allowlocal, fixintegralrhs, boundsfortrans, boundtypesfortrans, minfrac, maxfrac, scale, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
            }
            return (int)mh$.invokeExact(scip, sol, postprocess, boundswitch, usevbds, allowlocal, fixintegralrhs, boundsfortrans, boundtypesfortrans, minfrac, maxfrac, scale, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutGenerationHeuristicCMIR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutGenerationHeuristicCMIR");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutGenerationHeuristicCMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, int maxtestdelta, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcutGenerationHeuristicCMIR$descriptor() {
        return SCIPcutGenerationHeuristicCMIR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutGenerationHeuristicCMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, int maxtestdelta, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcutGenerationHeuristicCMIR$handle() {
        return SCIPcutGenerationHeuristicCMIR.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutGenerationHeuristicCMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, int maxtestdelta, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcutGenerationHeuristicCMIR$address() {
        return SCIPcutGenerationHeuristicCMIR.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutGenerationHeuristicCMIR(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, int maxtestdelta, int *boundsfortrans, SCIP_BOUNDTYPE *boundtypesfortrans, double minfrac, double maxfrac, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static int SCIPcutGenerationHeuristicCMIR(MemorySegment scip, MemorySegment sol, int postprocess, double boundswitch, int usevbds, int allowlocal, int maxtestdelta, MemorySegment boundsfortrans, MemorySegment boundtypesfortrans, double minfrac, double maxfrac, MemorySegment aggrrow, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment cutefficacy, MemorySegment cutrank, MemorySegment cutislocal, MemorySegment success) {
        var mh$ = SCIPcutGenerationHeuristicCMIR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutGenerationHeuristicCMIR", scip, sol, postprocess, boundswitch, usevbds, allowlocal, maxtestdelta, boundsfortrans, boundtypesfortrans, minfrac, maxfrac, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
            }
            return (int)mh$.invokeExact(scip, sol, postprocess, boundswitch, usevbds, allowlocal, maxtestdelta, boundsfortrans, boundtypesfortrans, minfrac, maxfrac, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcFlowCover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcFlowCover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcFlowCover(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcFlowCover$descriptor() {
        return SCIPcalcFlowCover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcFlowCover(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcFlowCover$handle() {
        return SCIPcalcFlowCover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcFlowCover(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcFlowCover$address() {
        return SCIPcalcFlowCover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcFlowCover(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static int SCIPcalcFlowCover(MemorySegment scip, MemorySegment sol, int postprocess, double boundswitch, int allowlocal, MemorySegment aggrrow, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment cutefficacy, MemorySegment cutrank, MemorySegment cutislocal, MemorySegment success) {
        var mh$ = SCIPcalcFlowCover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcFlowCover", scip, sol, postprocess, boundswitch, allowlocal, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
            }
            return (int)mh$.invokeExact(scip, sol, postprocess, boundswitch, allowlocal, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcKnapsackCover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcKnapsackCover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcKnapsackCover(SCIP *scip, SCIP_SOL *sol, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcKnapsackCover$descriptor() {
        return SCIPcalcKnapsackCover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcKnapsackCover(SCIP *scip, SCIP_SOL *sol, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcKnapsackCover$handle() {
        return SCIPcalcKnapsackCover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcKnapsackCover(SCIP *scip, SCIP_SOL *sol, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcKnapsackCover$address() {
        return SCIPcalcKnapsackCover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcKnapsackCover(SCIP *scip, SCIP_SOL *sol, unsigned int allowlocal, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static int SCIPcalcKnapsackCover(MemorySegment scip, MemorySegment sol, int allowlocal, MemorySegment aggrrow, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment cutefficacy, MemorySegment cutrank, MemorySegment cutislocal, MemorySegment success) {
        var mh$ = SCIPcalcKnapsackCover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcKnapsackCover", scip, sol, allowlocal, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
            }
            return (int)mh$.invokeExact(scip, sol, allowlocal, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcStrongCG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcStrongCG");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcStrongCG(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcStrongCG$descriptor() {
        return SCIPcalcStrongCG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcStrongCG(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcStrongCG$handle() {
        return SCIPcalcStrongCG.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcStrongCG(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcStrongCG$address() {
        return SCIPcalcStrongCG.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcStrongCG(SCIP *scip, SCIP_SOL *sol, unsigned int postprocess, double boundswitch, unsigned int usevbds, unsigned int allowlocal, double minfrac, double maxfrac, double scale, SCIP_AGGRROW *aggrrow, double *cutcoefs, double *cutrhs, int *cutinds, int *cutnnz, double *cutefficacy, int *cutrank, unsigned int *cutislocal, unsigned int *success)
     * }
     */
    public static int SCIPcalcStrongCG(MemorySegment scip, MemorySegment sol, int postprocess, double boundswitch, int usevbds, int allowlocal, double minfrac, double maxfrac, double scale, MemorySegment aggrrow, MemorySegment cutcoefs, MemorySegment cutrhs, MemorySegment cutinds, MemorySegment cutnnz, MemorySegment cutefficacy, MemorySegment cutrank, MemorySegment cutislocal, MemorySegment success) {
        var mh$ = SCIPcalcStrongCG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcStrongCG", scip, sol, postprocess, boundswitch, usevbds, allowlocal, minfrac, maxfrac, scale, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
            }
            return (int)mh$.invokeExact(scip, sol, postprocess, boundswitch, usevbds, allowlocal, minfrac, maxfrac, scale, aggrrow, cutcoefs, cutrhs, cutinds, cutnnz, cutefficacy, cutrank, cutislocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPperformGenericDivingAlgorithm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_LONG_LONG,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPperformGenericDivingAlgorithm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPperformGenericDivingAlgorithm(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *worksol, SCIP_HEUR *heur, SCIP_RESULT *result, unsigned int nodeinfeasible, long long iterlim, int nodelimit, double lpresolvedomchgquot, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPperformGenericDivingAlgorithm$descriptor() {
        return SCIPperformGenericDivingAlgorithm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPperformGenericDivingAlgorithm(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *worksol, SCIP_HEUR *heur, SCIP_RESULT *result, unsigned int nodeinfeasible, long long iterlim, int nodelimit, double lpresolvedomchgquot, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPperformGenericDivingAlgorithm$handle() {
        return SCIPperformGenericDivingAlgorithm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPperformGenericDivingAlgorithm(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *worksol, SCIP_HEUR *heur, SCIP_RESULT *result, unsigned int nodeinfeasible, long long iterlim, int nodelimit, double lpresolvedomchgquot, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPperformGenericDivingAlgorithm$address() {
        return SCIPperformGenericDivingAlgorithm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPperformGenericDivingAlgorithm(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *worksol, SCIP_HEUR *heur, SCIP_RESULT *result, unsigned int nodeinfeasible, long long iterlim, int nodelimit, double lpresolvedomchgquot, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static int SCIPperformGenericDivingAlgorithm(MemorySegment scip, MemorySegment diveset, MemorySegment worksol, MemorySegment heur, MemorySegment result, int nodeinfeasible, long iterlim, int nodelimit, double lpresolvedomchgquot, int divecontext) {
        var mh$ = SCIPperformGenericDivingAlgorithm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPperformGenericDivingAlgorithm", scip, diveset, worksol, heur, result, nodeinfeasible, iterlim, nodelimit, lpresolvedomchgquot, divecontext);
            }
            return (int)mh$.invokeExact(scip, diveset, worksol, heur, result, nodeinfeasible, iterlim, nodelimit, lpresolvedomchgquot, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyLargeNeighborhoodSearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyLargeNeighborhoodSearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLargeNeighborhoodSearch(SCIP *sourcescip, SCIP *subscip, SCIP_HASHMAP *varmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int uselprows, unsigned int copycuts, unsigned int *success, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyLargeNeighborhoodSearch$descriptor() {
        return SCIPcopyLargeNeighborhoodSearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLargeNeighborhoodSearch(SCIP *sourcescip, SCIP *subscip, SCIP_HASHMAP *varmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int uselprows, unsigned int copycuts, unsigned int *success, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyLargeNeighborhoodSearch$handle() {
        return SCIPcopyLargeNeighborhoodSearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLargeNeighborhoodSearch(SCIP *sourcescip, SCIP *subscip, SCIP_HASHMAP *varmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int uselprows, unsigned int copycuts, unsigned int *success, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyLargeNeighborhoodSearch$address() {
        return SCIPcopyLargeNeighborhoodSearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLargeNeighborhoodSearch(SCIP *sourcescip, SCIP *subscip, SCIP_HASHMAP *varmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int uselprows, unsigned int copycuts, unsigned int *success, unsigned int *valid)
     * }
     */
    public static int SCIPcopyLargeNeighborhoodSearch(MemorySegment sourcescip, MemorySegment subscip, MemorySegment varmap, MemorySegment suffix, MemorySegment fixedvars, MemorySegment fixedvals, int nfixedvars, int uselprows, int copycuts, MemorySegment success, MemorySegment valid) {
        var mh$ = SCIPcopyLargeNeighborhoodSearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyLargeNeighborhoodSearch", sourcescip, subscip, varmap, suffix, fixedvars, fixedvals, nfixedvars, uselprows, copycuts, success, valid);
            }
            return (int)mh$.invokeExact(sourcescip, subscip, varmap, suffix, fixedvars, fixedvals, nfixedvars, uselprows, copycuts, success, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddTrustregionNeighborhoodConstraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddTrustregionNeighborhoodConstraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTrustregionNeighborhoodConstraint(SCIP *scip, SCIP *subscip, SCIP_VAR **subvars, double violpenalty)
     * }
     */
    public static FunctionDescriptor SCIPaddTrustregionNeighborhoodConstraint$descriptor() {
        return SCIPaddTrustregionNeighborhoodConstraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTrustregionNeighborhoodConstraint(SCIP *scip, SCIP *subscip, SCIP_VAR **subvars, double violpenalty)
     * }
     */
    public static MethodHandle SCIPaddTrustregionNeighborhoodConstraint$handle() {
        return SCIPaddTrustregionNeighborhoodConstraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTrustregionNeighborhoodConstraint(SCIP *scip, SCIP *subscip, SCIP_VAR **subvars, double violpenalty)
     * }
     */
    public static MemorySegment SCIPaddTrustregionNeighborhoodConstraint$address() {
        return SCIPaddTrustregionNeighborhoodConstraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTrustregionNeighborhoodConstraint(SCIP *scip, SCIP *subscip, SCIP_VAR **subvars, double violpenalty)
     * }
     */
    public static int SCIPaddTrustregionNeighborhoodConstraint(MemorySegment scip, MemorySegment subscip, MemorySegment subvars, double violpenalty) {
        var mh$ = SCIPaddTrustregionNeighborhoodConstraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddTrustregionNeighborhoodConstraint", scip, subscip, subvars, violpenalty);
            }
            return (int)mh$.invokeExact(scip, subscip, subvars, violpenalty);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBanditvtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBanditvtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBanditvtable(SCIP *scip, SCIP_BANDITVTABLE **banditvtable, const char *name, SCIP_RETCODE (*banditfree)(BMS_BLKMEM *, SCIP_BANDIT *), SCIP_RETCODE (*banditselect)(SCIP_BANDIT *, int *), SCIP_RETCODE (*banditupdate)(SCIP_BANDIT *, int, double), SCIP_RETCODE (*banditreset)(BMS_BUFMEM *, SCIP_BANDIT *, double *))
     * }
     */
    public static FunctionDescriptor SCIPincludeBanditvtable$descriptor() {
        return SCIPincludeBanditvtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBanditvtable(SCIP *scip, SCIP_BANDITVTABLE **banditvtable, const char *name, SCIP_RETCODE (*banditfree)(BMS_BLKMEM *, SCIP_BANDIT *), SCIP_RETCODE (*banditselect)(SCIP_BANDIT *, int *), SCIP_RETCODE (*banditupdate)(SCIP_BANDIT *, int, double), SCIP_RETCODE (*banditreset)(BMS_BUFMEM *, SCIP_BANDIT *, double *))
     * }
     */
    public static MethodHandle SCIPincludeBanditvtable$handle() {
        return SCIPincludeBanditvtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBanditvtable(SCIP *scip, SCIP_BANDITVTABLE **banditvtable, const char *name, SCIP_RETCODE (*banditfree)(BMS_BLKMEM *, SCIP_BANDIT *), SCIP_RETCODE (*banditselect)(SCIP_BANDIT *, int *), SCIP_RETCODE (*banditupdate)(SCIP_BANDIT *, int, double), SCIP_RETCODE (*banditreset)(BMS_BUFMEM *, SCIP_BANDIT *, double *))
     * }
     */
    public static MemorySegment SCIPincludeBanditvtable$address() {
        return SCIPincludeBanditvtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBanditvtable(SCIP *scip, SCIP_BANDITVTABLE **banditvtable, const char *name, SCIP_RETCODE (*banditfree)(BMS_BLKMEM *, SCIP_BANDIT *), SCIP_RETCODE (*banditselect)(SCIP_BANDIT *, int *), SCIP_RETCODE (*banditupdate)(SCIP_BANDIT *, int, double), SCIP_RETCODE (*banditreset)(BMS_BUFMEM *, SCIP_BANDIT *, double *))
     * }
     */
    public static int SCIPincludeBanditvtable(MemorySegment scip, MemorySegment banditvtable, MemorySegment name, MemorySegment banditfree, MemorySegment banditselect, MemorySegment banditupdate, MemorySegment banditreset) {
        var mh$ = SCIPincludeBanditvtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBanditvtable", scip, banditvtable, name, banditfree, banditselect, banditupdate, banditreset);
            }
            return (int)mh$.invokeExact(scip, banditvtable, name, banditfree, banditselect, banditupdate, banditreset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindBanditvtable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindBanditvtable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BANDITVTABLE *SCIPfindBanditvtable(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindBanditvtable$descriptor() {
        return SCIPfindBanditvtable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BANDITVTABLE *SCIPfindBanditvtable(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindBanditvtable$handle() {
        return SCIPfindBanditvtable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BANDITVTABLE *SCIPfindBanditvtable(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBanditvtable$address() {
        return SCIPfindBanditvtable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BANDITVTABLE *SCIPfindBanditvtable(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBanditvtable(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindBanditvtable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindBanditvtable", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeBandit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeBandit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBandit(SCIP *scip, SCIP_BANDIT **bandit)
     * }
     */
    public static FunctionDescriptor SCIPfreeBandit$descriptor() {
        return SCIPfreeBandit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBandit(SCIP *scip, SCIP_BANDIT **bandit)
     * }
     */
    public static MethodHandle SCIPfreeBandit$handle() {
        return SCIPfreeBandit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBandit(SCIP *scip, SCIP_BANDIT **bandit)
     * }
     */
    public static MemorySegment SCIPfreeBandit$address() {
        return SCIPfreeBandit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBandit(SCIP *scip, SCIP_BANDIT **bandit)
     * }
     */
    public static int SCIPfreeBandit(MemorySegment scip, MemorySegment bandit) {
        var mh$ = SCIPfreeBandit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeBandit", scip, bandit);
            }
            return (int)mh$.invokeExact(scip, bandit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetBandit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetBandit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetBandit(SCIP *scip, SCIP_BANDIT *bandit, double *priorities, unsigned int seed)
     * }
     */
    public static FunctionDescriptor SCIPresetBandit$descriptor() {
        return SCIPresetBandit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetBandit(SCIP *scip, SCIP_BANDIT *bandit, double *priorities, unsigned int seed)
     * }
     */
    public static MethodHandle SCIPresetBandit$handle() {
        return SCIPresetBandit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetBandit(SCIP *scip, SCIP_BANDIT *bandit, double *priorities, unsigned int seed)
     * }
     */
    public static MemorySegment SCIPresetBandit$address() {
        return SCIPresetBandit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetBandit(SCIP *scip, SCIP_BANDIT *bandit, double *priorities, unsigned int seed)
     * }
     */
    public static int SCIPresetBandit(MemorySegment scip, MemorySegment bandit, MemorySegment priorities, int seed) {
        var mh$ = SCIPresetBandit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetBandit", scip, bandit, priorities, seed);
            }
            return (int)mh$.invokeExact(scip, bandit, priorities, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenders(SCIP *scip, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int), SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBenders$descriptor() {
        return SCIPincludeBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenders(SCIP *scip, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int), SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MethodHandle SCIPincludeBenders$handle() {
        return SCIPincludeBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenders(SCIP *scip, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int), SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MemorySegment SCIPincludeBenders$address() {
        return SCIPincludeBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenders(SCIP *scip, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int), SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *), SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static int SCIPincludeBenders(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int cutlp, int cutpseudo, int cutrelax, int shareauxvars, MemorySegment benderscopy, MemorySegment bendersfree, MemorySegment bendersinit, MemorySegment bendersexit, MemorySegment bendersinitpre, MemorySegment bendersexitpre, MemorySegment bendersinitsol, MemorySegment bendersexitsol, MemorySegment bendersgetvar, MemorySegment benderscreatesub, MemorySegment benderspresubsolve, MemorySegment benderssolvesubconvex, MemorySegment benderssolvesub, MemorySegment benderspostsolve, MemorySegment bendersfreesub, MemorySegment bendersdata) {
        var mh$ = SCIPincludeBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBenders", scip, name, desc, priority, cutlp, cutpseudo, cutrelax, shareauxvars, benderscopy, bendersfree, bendersinit, bendersexit, bendersinitpre, bendersexitpre, bendersinitsol, bendersexitsol, bendersgetvar, benderscreatesub, benderspresubsolve, benderssolvesubconvex, benderssolvesub, benderspostsolve, bendersfreesub, bendersdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, cutlp, cutpseudo, cutrelax, shareauxvars, benderscopy, bendersfree, bendersinit, bendersexit, bendersinitpre, bendersexitpre, bendersinitsol, bendersexitsol, bendersgetvar, benderscreatesub, benderspresubsolve, benderssolvesubconvex, benderssolvesub, benderspostsolve, bendersfreesub, bendersdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBendersBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBendersBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersBasic(SCIP *scip, SCIP_BENDERS **bendersptr, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBendersBasic$descriptor() {
        return SCIPincludeBendersBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersBasic(SCIP *scip, SCIP_BENDERS **bendersptr, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MethodHandle SCIPincludeBendersBasic$handle() {
        return SCIPincludeBendersBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersBasic(SCIP *scip, SCIP_BENDERS **bendersptr, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static MemorySegment SCIPincludeBendersBasic$address() {
        return SCIPincludeBendersBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersBasic(SCIP *scip, SCIP_BENDERS **bendersptr, const char *name, const char *desc, int priority, unsigned int cutlp, unsigned int cutpseudo, unsigned int cutrelax, unsigned int shareauxvars, SCIP_RETCODE (*bendersgetvar)(SCIP *, SCIP_BENDERS *, SCIP_VAR *, SCIP_VAR **, int), SCIP_RETCODE (*benderscreatesub)(SCIP *, SCIP_BENDERS *, int), SCIP_BENDERSDATA *bendersdata)
     * }
     */
    public static int SCIPincludeBendersBasic(MemorySegment scip, MemorySegment bendersptr, MemorySegment name, MemorySegment desc, int priority, int cutlp, int cutpseudo, int cutrelax, int shareauxvars, MemorySegment bendersgetvar, MemorySegment benderscreatesub, MemorySegment bendersdata) {
        var mh$ = SCIPincludeBendersBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBendersBasic", scip, bendersptr, name, desc, priority, cutlp, cutpseudo, cutrelax, shareauxvars, bendersgetvar, benderscreatesub, bendersdata);
            }
            return (int)mh$.invokeExact(scip, bendersptr, name, desc, priority, cutlp, cutpseudo, cutrelax, shareauxvars, bendersgetvar, benderscreatesub, bendersdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersCopy(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersCopy$descriptor() {
        return SCIPsetBendersCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersCopy(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int))
     * }
     */
    public static MethodHandle SCIPsetBendersCopy$handle() {
        return SCIPsetBendersCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersCopy(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int))
     * }
     */
    public static MemorySegment SCIPsetBendersCopy$address() {
        return SCIPsetBendersCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersCopy(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderscopy)(SCIP *, SCIP_BENDERS *, unsigned int))
     * }
     */
    public static int SCIPsetBendersCopy(MemorySegment scip, MemorySegment benders, MemorySegment benderscopy) {
        var mh$ = SCIPsetBendersCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersCopy", scip, benders, benderscopy);
            }
            return (int)mh$.invokeExact(scip, benders, benderscopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersFree(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersFree$descriptor() {
        return SCIPsetBendersFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersFree(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersFree$handle() {
        return SCIPsetBendersFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersFree(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersFree$address() {
        return SCIPsetBendersFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersFree(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersfree)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersFree(MemorySegment scip, MemorySegment benders, MemorySegment bendersfree) {
        var mh$ = SCIPsetBendersFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersFree", scip, benders, bendersfree);
            }
            return (int)mh$.invokeExact(scip, benders, bendersfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersInit$descriptor() {
        return SCIPsetBendersInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersInit$handle() {
        return SCIPsetBendersInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersInit$address() {
        return SCIPsetBendersInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersInit(MemorySegment scip, MemorySegment benders, MemorySegment bendersinit) {
        var mh$ = SCIPsetBendersInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersInit", scip, benders, bendersinit);
            }
            return (int)mh$.invokeExact(scip, benders, bendersinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersExit$descriptor() {
        return SCIPsetBendersExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersExit$handle() {
        return SCIPsetBendersExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersExit$address() {
        return SCIPsetBendersExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExit(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexit)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersExit(MemorySegment scip, MemorySegment benders, MemorySegment bendersexit) {
        var mh$ = SCIPsetBendersExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersExit", scip, benders, bendersexit);
            }
            return (int)mh$.invokeExact(scip, benders, bendersexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersInitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersInitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersInitpre$descriptor() {
        return SCIPsetBendersInitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersInitpre$handle() {
        return SCIPsetBendersInitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersInitpre$address() {
        return SCIPsetBendersInitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersInitpre(MemorySegment scip, MemorySegment benders, MemorySegment bendersinitpre) {
        var mh$ = SCIPsetBendersInitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersInitpre", scip, benders, bendersinitpre);
            }
            return (int)mh$.invokeExact(scip, benders, bendersinitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersExitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersExitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersExitpre$descriptor() {
        return SCIPsetBendersExitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersExitpre$handle() {
        return SCIPsetBendersExitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersExitpre$address() {
        return SCIPsetBendersExitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitpre(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitpre)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersExitpre(MemorySegment scip, MemorySegment benders, MemorySegment bendersexitpre) {
        var mh$ = SCIPsetBendersExitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersExitpre", scip, benders, bendersexitpre);
            }
            return (int)mh$.invokeExact(scip, benders, bendersexitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersInitsol$descriptor() {
        return SCIPsetBendersInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersInitsol$handle() {
        return SCIPsetBendersInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersInitsol$address() {
        return SCIPsetBendersInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersInitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersinitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersInitsol(MemorySegment scip, MemorySegment benders, MemorySegment bendersinitsol) {
        var mh$ = SCIPsetBendersInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersInitsol", scip, benders, bendersinitsol);
            }
            return (int)mh$.invokeExact(scip, benders, bendersinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersExitsol$descriptor() {
        return SCIPsetBendersExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MethodHandle SCIPsetBendersExitsol$handle() {
        return SCIPsetBendersExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static MemorySegment SCIPsetBendersExitsol$address() {
        return SCIPsetBendersExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersExitsol(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*bendersexitsol)(SCIP *, SCIP_BENDERS *))
     * }
     */
    public static int SCIPsetBendersExitsol(MemorySegment scip, MemorySegment benders, MemorySegment bendersexitsol) {
        var mh$ = SCIPsetBendersExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersExitsol", scip, benders, bendersexitsol);
            }
            return (int)mh$.invokeExact(scip, benders, bendersexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersPresubsolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersPresubsolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPresubsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersPresubsolve$descriptor() {
        return SCIPsetBendersPresubsolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPresubsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetBendersPresubsolve$handle() {
        return SCIPsetBendersPresubsolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPresubsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetBendersPresubsolve$address() {
        return SCIPsetBendersPresubsolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPresubsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspresubsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, unsigned int, unsigned int *, unsigned int *, unsigned int *, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetBendersPresubsolve(MemorySegment scip, MemorySegment benders, MemorySegment benderspresubsolve) {
        var mh$ = SCIPsetBendersPresubsolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersPresubsolve", scip, benders, benderspresubsolve);
            }
            return (int)mh$.invokeExact(scip, benders, benderspresubsolve);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersSolveAndFreesub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersSolveAndFreesub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSolveAndFreesub(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersSolveAndFreesub$descriptor() {
        return SCIPsetBendersSolveAndFreesub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSolveAndFreesub(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int))
     * }
     */
    public static MethodHandle SCIPsetBendersSolveAndFreesub$handle() {
        return SCIPsetBendersSolveAndFreesub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSolveAndFreesub(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int))
     * }
     */
    public static MemorySegment SCIPsetBendersSolveAndFreesub$address() {
        return SCIPsetBendersSolveAndFreesub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSolveAndFreesub(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderssolvesubconvex)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, unsigned int, double *, SCIP_RESULT *), SCIP_RETCODE (*benderssolvesub)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, int, double *, SCIP_RESULT *), SCIP_RETCODE (*bendersfreesub)(SCIP *, SCIP_BENDERS *, int))
     * }
     */
    public static int SCIPsetBendersSolveAndFreesub(MemorySegment scip, MemorySegment benders, MemorySegment benderssolvesubconvex, MemorySegment benderssolvesub, MemorySegment bendersfreesub) {
        var mh$ = SCIPsetBendersSolveAndFreesub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersSolveAndFreesub", scip, benders, benderssolvesubconvex, benderssolvesub, bendersfreesub);
            }
            return (int)mh$.invokeExact(scip, benders, benderssolvesubconvex, benderssolvesub, bendersfreesub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersPostsolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersPostsolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPostsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersPostsolve$descriptor() {
        return SCIPsetBendersPostsolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPostsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetBendersPostsolve$handle() {
        return SCIPsetBendersPostsolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPostsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetBendersPostsolve$address() {
        return SCIPsetBendersPostsolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersPostsolve(SCIP *scip, SCIP_BENDERS *benders, SCIP_RETCODE (*benderspostsolve)(SCIP *, SCIP_BENDERS *, SCIP_SOL *, SCIP_BENDERSENFOTYPE, int *, int, int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static int SCIPsetBendersPostsolve(MemorySegment scip, MemorySegment benders, MemorySegment benderspostsolve) {
        var mh$ = SCIPsetBendersPostsolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersPostsolve", scip, benders, benderspostsolve);
            }
            return (int)mh$.invokeExact(scip, benders, benderspostsolve);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersSubproblemComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersSubproblemComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSubproblemComp(SCIP *scip, SCIP_BENDERS *benders, int (*benderssubcomp)(void *, void *))
     * }
     */
    public static FunctionDescriptor SCIPsetBendersSubproblemComp$descriptor() {
        return SCIPsetBendersSubproblemComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSubproblemComp(SCIP *scip, SCIP_BENDERS *benders, int (*benderssubcomp)(void *, void *))
     * }
     */
    public static MethodHandle SCIPsetBendersSubproblemComp$handle() {
        return SCIPsetBendersSubproblemComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSubproblemComp(SCIP *scip, SCIP_BENDERS *benders, int (*benderssubcomp)(void *, void *))
     * }
     */
    public static MemorySegment SCIPsetBendersSubproblemComp$address() {
        return SCIPsetBendersSubproblemComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBendersSubproblemComp(SCIP *scip, SCIP_BENDERS *benders, int (*benderssubcomp)(void *, void *))
     * }
     */
    public static int SCIPsetBendersSubproblemComp(MemorySegment scip, MemorySegment benders, MemorySegment benderssubcomp) {
        var mh$ = SCIPsetBendersSubproblemComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersSubproblemComp", scip, benders, benderssubcomp);
            }
            return (int)mh$.invokeExact(scip, benders, benderssubcomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERS *SCIPfindBenders(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindBenders$descriptor() {
        return SCIPfindBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERS *SCIPfindBenders(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindBenders$handle() {
        return SCIPfindBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERS *SCIPfindBenders(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBenders$address() {
        return SCIPfindBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERS *SCIPfindBenders(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBenders(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindBenders", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BENDERS **SCIPgetBenders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBenders$descriptor() {
        return SCIPgetBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BENDERS **SCIPgetBenders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBenders$handle() {
        return SCIPgetBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BENDERS **SCIPgetBenders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBenders$address() {
        return SCIPgetBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BENDERS **SCIPgetBenders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBenders(MemorySegment scip) {
        var mh$ = SCIPgetBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBenders", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNBenders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBenders$descriptor() {
        return SCIPgetNBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNBenders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBenders$handle() {
        return SCIPgetNBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNBenders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBenders$address() {
        return SCIPgetNBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNBenders(SCIP *scip)
     * }
     */
    public static int SCIPgetNBenders(MemorySegment scip) {
        var mh$ = SCIPgetNBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBenders", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNActiveBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNActiveBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNActiveBenders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNActiveBenders$descriptor() {
        return SCIPgetNActiveBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNActiveBenders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNActiveBenders$handle() {
        return SCIPgetNActiveBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNActiveBenders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNActiveBenders$address() {
        return SCIPgetNActiveBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNActiveBenders(SCIP *scip)
     * }
     */
    public static int SCIPgetNActiveBenders(MemorySegment scip) {
        var mh$ = SCIPgetNActiveBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNActiveBenders", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPactivateBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPactivateBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivateBenders(SCIP *scip, SCIP_BENDERS *benders, int nsubproblems)
     * }
     */
    public static FunctionDescriptor SCIPactivateBenders$descriptor() {
        return SCIPactivateBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivateBenders(SCIP *scip, SCIP_BENDERS *benders, int nsubproblems)
     * }
     */
    public static MethodHandle SCIPactivateBenders$handle() {
        return SCIPactivateBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivateBenders(SCIP *scip, SCIP_BENDERS *benders, int nsubproblems)
     * }
     */
    public static MemorySegment SCIPactivateBenders$address() {
        return SCIPactivateBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivateBenders(SCIP *scip, SCIP_BENDERS *benders, int nsubproblems)
     * }
     */
    public static int SCIPactivateBenders(MemorySegment scip, MemorySegment benders, int nsubproblems) {
        var mh$ = SCIPactivateBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPactivateBenders", scip, benders, nsubproblems);
            }
            return (int)mh$.invokeExact(scip, benders, nsubproblems);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeactivateBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeactivateBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivateBenders(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPdeactivateBenders$descriptor() {
        return SCIPdeactivateBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivateBenders(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPdeactivateBenders$handle() {
        return SCIPdeactivateBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivateBenders(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPdeactivateBenders$address() {
        return SCIPdeactivateBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivateBenders(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPdeactivateBenders(MemorySegment scip, MemorySegment benders) {
        var mh$ = SCIPdeactivateBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeactivateBenders", scip, benders);
            }
            return (int)mh$.invokeExact(scip, benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBendersPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBendersPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetBendersPriority(SCIP *scip, SCIP_BENDERS *benders, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetBendersPriority$descriptor() {
        return SCIPsetBendersPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetBendersPriority(SCIP *scip, SCIP_BENDERS *benders, int priority)
     * }
     */
    public static MethodHandle SCIPsetBendersPriority$handle() {
        return SCIPsetBendersPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetBendersPriority(SCIP *scip, SCIP_BENDERS *benders, int priority)
     * }
     */
    public static MemorySegment SCIPsetBendersPriority$address() {
        return SCIPsetBendersPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetBendersPriority(SCIP *scip, SCIP_BENDERS *benders, int priority)
     * }
     */
    public static void SCIPsetBendersPriority(MemorySegment scip, MemorySegment benders, int priority) {
        var mh$ = SCIPsetBendersPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBendersPriority", scip, benders, priority);
            }
            mh$.invokeExact(scip, benders, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveBendersSubproblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveBendersSubproblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblems(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, SCIP_RESULT *result, unsigned int *infeasible, unsigned int *auxviol, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static FunctionDescriptor SCIPsolveBendersSubproblems$descriptor() {
        return SCIPsolveBendersSubproblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblems(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, SCIP_RESULT *result, unsigned int *infeasible, unsigned int *auxviol, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static MethodHandle SCIPsolveBendersSubproblems$handle() {
        return SCIPsolveBendersSubproblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblems(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, SCIP_RESULT *result, unsigned int *infeasible, unsigned int *auxviol, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static MemorySegment SCIPsolveBendersSubproblems$address() {
        return SCIPsolveBendersSubproblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblems(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, SCIP_RESULT *result, unsigned int *infeasible, unsigned int *auxviol, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static int SCIPsolveBendersSubproblems(MemorySegment scip, MemorySegment benders, MemorySegment sol, MemorySegment result, MemorySegment infeasible, MemorySegment auxviol, int type, int checkint) {
        var mh$ = SCIPsolveBendersSubproblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveBendersSubproblems", scip, benders, sol, result, infeasible, auxviol, type, checkint);
            }
            return (int)mh$.invokeExact(scip, benders, sol, result, infeasible, auxviol, type, checkint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBendersMasterVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBendersMasterVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersMasterVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar)
     * }
     */
    public static FunctionDescriptor SCIPgetBendersMasterVar$descriptor() {
        return SCIPgetBendersMasterVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersMasterVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar)
     * }
     */
    public static MethodHandle SCIPgetBendersMasterVar$handle() {
        return SCIPgetBendersMasterVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersMasterVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar)
     * }
     */
    public static MemorySegment SCIPgetBendersMasterVar$address() {
        return SCIPgetBendersMasterVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersMasterVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar)
     * }
     */
    public static int SCIPgetBendersMasterVar(MemorySegment scip, MemorySegment benders, MemorySegment var_, MemorySegment mappedvar) {
        var mh$ = SCIPgetBendersMasterVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBendersMasterVar", scip, benders, var_, mappedvar);
            }
            return (int)mh$.invokeExact(scip, benders, var_, mappedvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBendersSubproblemVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBendersSubproblemVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersSubproblemVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPgetBendersSubproblemVar$descriptor() {
        return SCIPgetBendersSubproblemVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersSubproblemVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar, int probnumber)
     * }
     */
    public static MethodHandle SCIPgetBendersSubproblemVar$handle() {
        return SCIPgetBendersSubproblemVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersSubproblemVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar, int probnumber)
     * }
     */
    public static MemorySegment SCIPgetBendersSubproblemVar$address() {
        return SCIPgetBendersSubproblemVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBendersSubproblemVar(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR *var, SCIP_VAR **mappedvar, int probnumber)
     * }
     */
    public static int SCIPgetBendersSubproblemVar(MemorySegment scip, MemorySegment benders, MemorySegment var_, MemorySegment mappedvar, int probnumber) {
        var mh$ = SCIPgetBendersSubproblemVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBendersSubproblemVar", scip, benders, var_, mappedvar, probnumber);
            }
            return (int)mh$.invokeExact(scip, benders, var_, mappedvar, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBendersNSubproblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBendersNSubproblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetBendersNSubproblems(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPgetBendersNSubproblems$descriptor() {
        return SCIPgetBendersNSubproblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetBendersNSubproblems(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPgetBendersNSubproblems$handle() {
        return SCIPgetBendersNSubproblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetBendersNSubproblems(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPgetBendersNSubproblems$address() {
        return SCIPgetBendersNSubproblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetBendersNSubproblems(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPgetBendersNSubproblems(MemorySegment scip, MemorySegment benders) {
        var mh$ = SCIPgetBendersNSubproblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBendersNSubproblems", scip, benders);
            }
            return (int)mh$.invokeExact(scip, benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddBendersSubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddBendersSubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP *subproblem)
     * }
     */
    public static FunctionDescriptor SCIPaddBendersSubproblem$descriptor() {
        return SCIPaddBendersSubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP *subproblem)
     * }
     */
    public static MethodHandle SCIPaddBendersSubproblem$handle() {
        return SCIPaddBendersSubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP *subproblem)
     * }
     */
    public static MemorySegment SCIPaddBendersSubproblem$address() {
        return SCIPaddBendersSubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP *subproblem)
     * }
     */
    public static int SCIPaddBendersSubproblem(MemorySegment scip, MemorySegment benders, MemorySegment subproblem) {
        var mh$ = SCIPaddBendersSubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddBendersSubproblem", scip, benders, subproblem);
            }
            return (int)mh$.invokeExact(scip, benders, subproblem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetupBendersSubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetupBendersSubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetupBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, SCIP_BENDERSENFOTYPE type)
     * }
     */
    public static FunctionDescriptor SCIPsetupBendersSubproblem$descriptor() {
        return SCIPsetupBendersSubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetupBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, SCIP_BENDERSENFOTYPE type)
     * }
     */
    public static MethodHandle SCIPsetupBendersSubproblem$handle() {
        return SCIPsetupBendersSubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetupBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, SCIP_BENDERSENFOTYPE type)
     * }
     */
    public static MemorySegment SCIPsetupBendersSubproblem$address() {
        return SCIPsetupBendersSubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetupBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, SCIP_BENDERSENFOTYPE type)
     * }
     */
    public static int SCIPsetupBendersSubproblem(MemorySegment scip, MemorySegment benders, MemorySegment sol, int probnumber, int type) {
        var mh$ = SCIPsetupBendersSubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetupBendersSubproblem", scip, benders, sol, probnumber, type);
            }
            return (int)mh$.invokeExact(scip, benders, sol, probnumber, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveBendersSubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveBendersSubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *infeasible, unsigned int solvecip, double *objective)
     * }
     */
    public static FunctionDescriptor SCIPsolveBendersSubproblem$descriptor() {
        return SCIPsolveBendersSubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *infeasible, unsigned int solvecip, double *objective)
     * }
     */
    public static MethodHandle SCIPsolveBendersSubproblem$handle() {
        return SCIPsolveBendersSubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *infeasible, unsigned int solvecip, double *objective)
     * }
     */
    public static MemorySegment SCIPsolveBendersSubproblem$address() {
        return SCIPsolveBendersSubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *infeasible, unsigned int solvecip, double *objective)
     * }
     */
    public static int SCIPsolveBendersSubproblem(MemorySegment scip, MemorySegment benders, MemorySegment sol, int probnumber, MemorySegment infeasible, int solvecip, MemorySegment objective) {
        var mh$ = SCIPsolveBendersSubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveBendersSubproblem", scip, benders, sol, probnumber, infeasible, solvecip, objective);
            }
            return (int)mh$.invokeExact(scip, benders, sol, probnumber, infeasible, solvecip, objective);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeBendersSubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeBendersSubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPfreeBendersSubproblem$descriptor() {
        return SCIPfreeBendersSubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MethodHandle SCIPfreeBendersSubproblem$handle() {
        return SCIPfreeBendersSubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static MemorySegment SCIPfreeBendersSubproblem$address() {
        return SCIPfreeBendersSubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBendersSubproblem(SCIP *scip, SCIP_BENDERS *benders, int probnumber)
     * }
     */
    public static int SCIPfreeBendersSubproblem(MemorySegment scip, MemorySegment benders, int probnumber) {
        var mh$ = SCIPfreeBendersSubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeBendersSubproblem", scip, benders, probnumber);
            }
            return (int)mh$.invokeExact(scip, benders, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckBendersSubproblemOptimality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckBendersSubproblemOptimality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckBendersSubproblemOptimality(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *optimal)
     * }
     */
    public static FunctionDescriptor SCIPcheckBendersSubproblemOptimality$descriptor() {
        return SCIPcheckBendersSubproblemOptimality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckBendersSubproblemOptimality(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *optimal)
     * }
     */
    public static MethodHandle SCIPcheckBendersSubproblemOptimality$handle() {
        return SCIPcheckBendersSubproblemOptimality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckBendersSubproblemOptimality(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *optimal)
     * }
     */
    public static MemorySegment SCIPcheckBendersSubproblemOptimality$address() {
        return SCIPcheckBendersSubproblemOptimality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckBendersSubproblemOptimality(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber, unsigned int *optimal)
     * }
     */
    public static int SCIPcheckBendersSubproblemOptimality(MemorySegment scip, MemorySegment benders, MemorySegment sol, int probnumber, MemorySegment optimal) {
        var mh$ = SCIPcheckBendersSubproblemOptimality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckBendersSubproblemOptimality", scip, benders, sol, probnumber, optimal);
            }
            return (int)mh$.invokeExact(scip, benders, sol, probnumber, optimal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBendersAuxiliaryVarVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBendersAuxiliaryVarVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetBendersAuxiliaryVarVal(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPgetBendersAuxiliaryVarVal$descriptor() {
        return SCIPgetBendersAuxiliaryVarVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetBendersAuxiliaryVarVal(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber)
     * }
     */
    public static MethodHandle SCIPgetBendersAuxiliaryVarVal$handle() {
        return SCIPgetBendersAuxiliaryVarVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetBendersAuxiliaryVarVal(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber)
     * }
     */
    public static MemorySegment SCIPgetBendersAuxiliaryVarVal$address() {
        return SCIPgetBendersAuxiliaryVarVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetBendersAuxiliaryVarVal(SCIP *scip, SCIP_BENDERS *benders, SCIP_SOL *sol, int probnumber)
     * }
     */
    public static double SCIPgetBendersAuxiliaryVarVal(MemorySegment scip, MemorySegment benders, MemorySegment sol, int probnumber) {
        var mh$ = SCIPgetBendersAuxiliaryVarVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBendersAuxiliaryVarVal", scip, benders, sol, probnumber);
            }
            return (double)mh$.invokeExact(scip, benders, sol, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeBendersSubproblemLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeBendersSubproblemLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeBendersSubproblemLowerbound(SCIP *scip, SCIP_BENDERS *benders, int probnumber, double *lowerbound, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPcomputeBendersSubproblemLowerbound$descriptor() {
        return SCIPcomputeBendersSubproblemLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeBendersSubproblemLowerbound(SCIP *scip, SCIP_BENDERS *benders, int probnumber, double *lowerbound, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPcomputeBendersSubproblemLowerbound$handle() {
        return SCIPcomputeBendersSubproblemLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeBendersSubproblemLowerbound(SCIP *scip, SCIP_BENDERS *benders, int probnumber, double *lowerbound, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPcomputeBendersSubproblemLowerbound$address() {
        return SCIPcomputeBendersSubproblemLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeBendersSubproblemLowerbound(SCIP *scip, SCIP_BENDERS *benders, int probnumber, double *lowerbound, unsigned int *infeasible)
     * }
     */
    public static int SCIPcomputeBendersSubproblemLowerbound(MemorySegment scip, MemorySegment benders, int probnumber, MemorySegment lowerbound, MemorySegment infeasible) {
        var mh$ = SCIPcomputeBendersSubproblemLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeBendersSubproblemLowerbound", scip, benders, probnumber, lowerbound, infeasible);
            }
            return (int)mh$.invokeExact(scip, benders, probnumber, lowerbound, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmergeBendersSubproblemIntoMaster {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmergeBendersSubproblemIntoMaster");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeBendersSubproblemIntoMaster(SCIP *scip, SCIP_BENDERS *benders, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, int probnumber)
     * }
     */
    public static FunctionDescriptor SCIPmergeBendersSubproblemIntoMaster$descriptor() {
        return SCIPmergeBendersSubproblemIntoMaster.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeBendersSubproblemIntoMaster(SCIP *scip, SCIP_BENDERS *benders, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, int probnumber)
     * }
     */
    public static MethodHandle SCIPmergeBendersSubproblemIntoMaster$handle() {
        return SCIPmergeBendersSubproblemIntoMaster.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeBendersSubproblemIntoMaster(SCIP *scip, SCIP_BENDERS *benders, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, int probnumber)
     * }
     */
    public static MemorySegment SCIPmergeBendersSubproblemIntoMaster$address() {
        return SCIPmergeBendersSubproblemIntoMaster.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeBendersSubproblemIntoMaster(SCIP *scip, SCIP_BENDERS *benders, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, int probnumber)
     * }
     */
    public static int SCIPmergeBendersSubproblemIntoMaster(MemorySegment scip, MemorySegment benders, MemorySegment varmap, MemorySegment consmap, int probnumber) {
        var mh$ = SCIPmergeBendersSubproblemIntoMaster.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmergeBendersSubproblemIntoMaster", scip, benders, varmap, consmap, probnumber);
            }
            return (int)mh$.invokeExact(scip, benders, varmap, consmap, probnumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyBendersDecomposition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyBendersDecomposition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersDecomposition(SCIP *scip, int decompindex)
     * }
     */
    public static FunctionDescriptor SCIPapplyBendersDecomposition$descriptor() {
        return SCIPapplyBendersDecomposition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersDecomposition(SCIP *scip, int decompindex)
     * }
     */
    public static MethodHandle SCIPapplyBendersDecomposition$handle() {
        return SCIPapplyBendersDecomposition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersDecomposition(SCIP *scip, int decompindex)
     * }
     */
    public static MemorySegment SCIPapplyBendersDecomposition$address() {
        return SCIPapplyBendersDecomposition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersDecomposition(SCIP *scip, int decompindex)
     * }
     */
    public static int SCIPapplyBendersDecomposition(MemorySegment scip, int decompindex) {
        var mh$ = SCIPapplyBendersDecomposition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyBendersDecomposition", scip, decompindex);
            }
            return (int)mh$.invokeExact(scip, decompindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBenderscut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBenderscut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscut(SCIP *scip, SCIP_BENDERS *benders, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBenderscut$descriptor() {
        return SCIPincludeBenderscut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscut(SCIP *scip, SCIP_BENDERS *benders, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MethodHandle SCIPincludeBenderscut$handle() {
        return SCIPincludeBenderscut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscut(SCIP *scip, SCIP_BENDERS *benders, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MemorySegment SCIPincludeBenderscut$address() {
        return SCIPincludeBenderscut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscut(SCIP *scip, SCIP_BENDERS *benders, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *), SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static int SCIPincludeBenderscut(MemorySegment scip, MemorySegment benders, MemorySegment name, MemorySegment desc, int priority, int islpcut, MemorySegment benderscutcopy, MemorySegment benderscutfree, MemorySegment benderscutinit, MemorySegment benderscutexit, MemorySegment benderscutinitsol, MemorySegment benderscutexitsol, MemorySegment benderscutexec, MemorySegment benderscutdata) {
        var mh$ = SCIPincludeBenderscut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBenderscut", scip, benders, name, desc, priority, islpcut, benderscutcopy, benderscutfree, benderscutinit, benderscutexit, benderscutinitsol, benderscutexitsol, benderscutexec, benderscutdata);
            }
            return (int)mh$.invokeExact(scip, benders, name, desc, priority, islpcut, benderscutcopy, benderscutfree, benderscutinit, benderscutexit, benderscutinitsol, benderscutexitsol, benderscutexec, benderscutdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBenderscutBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBenderscutBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscutBasic(SCIP *scip, SCIP_BENDERS *benders, SCIP_BENDERSCUT **benderscutptr, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBenderscutBasic$descriptor() {
        return SCIPincludeBenderscutBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscutBasic(SCIP *scip, SCIP_BENDERS *benders, SCIP_BENDERSCUT **benderscutptr, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MethodHandle SCIPincludeBenderscutBasic$handle() {
        return SCIPincludeBenderscutBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscutBasic(SCIP *scip, SCIP_BENDERS *benders, SCIP_BENDERSCUT **benderscutptr, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static MemorySegment SCIPincludeBenderscutBasic$address() {
        return SCIPincludeBenderscutBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBenderscutBasic(SCIP *scip, SCIP_BENDERS *benders, SCIP_BENDERSCUT **benderscutptr, const char *name, const char *desc, int priority, unsigned int islpcut, SCIP_RETCODE (*benderscutexec)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *, SCIP_SOL *, int, SCIP_BENDERSENFOTYPE, SCIP_RESULT *), SCIP_BENDERSCUTDATA *benderscutdata)
     * }
     */
    public static int SCIPincludeBenderscutBasic(MemorySegment scip, MemorySegment benders, MemorySegment benderscutptr, MemorySegment name, MemorySegment desc, int priority, int islpcut, MemorySegment benderscutexec, MemorySegment benderscutdata) {
        var mh$ = SCIPincludeBenderscutBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBenderscutBasic", scip, benders, benderscutptr, name, desc, priority, islpcut, benderscutexec, benderscutdata);
            }
            return (int)mh$.invokeExact(scip, benders, benderscutptr, name, desc, priority, islpcut, benderscutexec, benderscutdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutCopy(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutCopy$descriptor() {
        return SCIPsetBenderscutCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutCopy(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutCopy$handle() {
        return SCIPsetBenderscutCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutCopy(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutCopy$address() {
        return SCIPsetBenderscutCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutCopy(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutcopy)(SCIP *, SCIP_BENDERS *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutCopy(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutcopy) {
        var mh$ = SCIPsetBenderscutCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutCopy", scip, benderscut, benderscutcopy);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutFree(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutFree$descriptor() {
        return SCIPsetBenderscutFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutFree(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutFree$handle() {
        return SCIPsetBenderscutFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutFree(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutFree$address() {
        return SCIPsetBenderscutFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutFree(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutfree)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutFree(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutfree) {
        var mh$ = SCIPsetBenderscutFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutFree", scip, benderscut, benderscutfree);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutInit$descriptor() {
        return SCIPsetBenderscutInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutInit$handle() {
        return SCIPsetBenderscutInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutInit$address() {
        return SCIPsetBenderscutInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutInit(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutinit) {
        var mh$ = SCIPsetBenderscutInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutInit", scip, benderscut, benderscutinit);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutExit$descriptor() {
        return SCIPsetBenderscutExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutExit$handle() {
        return SCIPsetBenderscutExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutExit$address() {
        return SCIPsetBenderscutExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExit(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexit)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutExit(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutexit) {
        var mh$ = SCIPsetBenderscutExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutExit", scip, benderscut, benderscutexit);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutInitsol$descriptor() {
        return SCIPsetBenderscutInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutInitsol$handle() {
        return SCIPsetBenderscutInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutInitsol$address() {
        return SCIPsetBenderscutInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutInitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutinitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutInitsol(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutinitsol) {
        var mh$ = SCIPsetBenderscutInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutInitsol", scip, benderscut, benderscutinitsol);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutExitsol$descriptor() {
        return SCIPsetBenderscutExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MethodHandle SCIPsetBenderscutExitsol$handle() {
        return SCIPsetBenderscutExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static MemorySegment SCIPsetBenderscutExitsol$address() {
        return SCIPsetBenderscutExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutExitsol(SCIP *scip, SCIP_BENDERSCUT *benderscut, SCIP_RETCODE (*benderscutexitsol)(SCIP *, SCIP_BENDERSCUT *))
     * }
     */
    public static int SCIPsetBenderscutExitsol(MemorySegment scip, MemorySegment benderscut, MemorySegment benderscutexitsol) {
        var mh$ = SCIPsetBenderscutExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutExitsol", scip, benderscut, benderscutexitsol);
            }
            return (int)mh$.invokeExact(scip, benderscut, benderscutexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBenderscutPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBenderscutPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutPriority(SCIP *scip, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetBenderscutPriority$descriptor() {
        return SCIPsetBenderscutPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutPriority(SCIP *scip, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static MethodHandle SCIPsetBenderscutPriority$handle() {
        return SCIPsetBenderscutPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutPriority(SCIP *scip, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static MemorySegment SCIPsetBenderscutPriority$address() {
        return SCIPsetBenderscutPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBenderscutPriority(SCIP *scip, SCIP_BENDERSCUT *benderscut, int priority)
     * }
     */
    public static int SCIPsetBenderscutPriority(MemorySegment scip, MemorySegment benderscut, int priority) {
        var mh$ = SCIPsetBenderscutPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBenderscutPriority", scip, benderscut, priority);
            }
            return (int)mh$.invokeExact(scip, benderscut, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstoreBendersCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstoreBendersCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstoreBendersCut(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR **vars, double *vals, double lhs, double rhs, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPstoreBendersCut$descriptor() {
        return SCIPstoreBendersCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstoreBendersCut(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR **vars, double *vals, double lhs, double rhs, int nvars)
     * }
     */
    public static MethodHandle SCIPstoreBendersCut$handle() {
        return SCIPstoreBendersCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstoreBendersCut(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR **vars, double *vals, double lhs, double rhs, int nvars)
     * }
     */
    public static MemorySegment SCIPstoreBendersCut$address() {
        return SCIPstoreBendersCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstoreBendersCut(SCIP *scip, SCIP_BENDERS *benders, SCIP_VAR **vars, double *vals, double lhs, double rhs, int nvars)
     * }
     */
    public static int SCIPstoreBendersCut(MemorySegment scip, MemorySegment benders, MemorySegment vars, MemorySegment vals, double lhs, double rhs, int nvars) {
        var mh$ = SCIPstoreBendersCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstoreBendersCut", scip, benders, vars, vals, lhs, rhs, nvars);
            }
            return (int)mh$.invokeExact(scip, benders, vars, vals, lhs, rhs, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyBendersStoredCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyBendersStoredCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersStoredCuts(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static FunctionDescriptor SCIPapplyBendersStoredCuts$descriptor() {
        return SCIPapplyBendersStoredCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersStoredCuts(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MethodHandle SCIPapplyBendersStoredCuts$handle() {
        return SCIPapplyBendersStoredCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersStoredCuts(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static MemorySegment SCIPapplyBendersStoredCuts$address() {
        return SCIPapplyBendersStoredCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyBendersStoredCuts(SCIP *scip, SCIP_BENDERS *benders)
     * }
     */
    public static int SCIPapplyBendersStoredCuts(MemorySegment scip, MemorySegment benders) {
        var mh$ = SCIPapplyBendersStoredCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyBendersStoredCuts", scip, benders);
            }
            return (int)mh$.invokeExact(scip, benders);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchrule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchrule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrule(SCIP *scip, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchrule$descriptor() {
        return SCIPincludeBranchrule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrule(SCIP *scip, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MethodHandle SCIPincludeBranchrule$handle() {
        return SCIPincludeBranchrule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrule(SCIP *scip, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MemorySegment SCIPincludeBranchrule$address() {
        return SCIPincludeBranchrule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrule(SCIP *scip, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *), SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *), SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static int SCIPincludeBranchrule(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int maxdepth, double maxbounddist, MemorySegment branchcopy, MemorySegment branchfree, MemorySegment branchinit, MemorySegment branchexit, MemorySegment branchinitsol, MemorySegment branchexitsol, MemorySegment branchexeclp, MemorySegment branchexecext, MemorySegment branchexecps, MemorySegment branchruledata) {
        var mh$ = SCIPincludeBranchrule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchrule", scip, name, desc, priority, maxdepth, maxbounddist, branchcopy, branchfree, branchinit, branchexit, branchinitsol, branchexitsol, branchexeclp, branchexecext, branchexecps, branchruledata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, maxdepth, maxbounddist, branchcopy, branchfree, branchinit, branchexit, branchinitsol, branchexitsol, branchexeclp, branchexecext, branchexecps, branchruledata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleBasic(SCIP *scip, SCIP_BRANCHRULE **branchruleptr, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleBasic$descriptor() {
        return SCIPincludeBranchruleBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleBasic(SCIP *scip, SCIP_BRANCHRULE **branchruleptr, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleBasic$handle() {
        return SCIPincludeBranchruleBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleBasic(SCIP *scip, SCIP_BRANCHRULE **branchruleptr, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleBasic$address() {
        return SCIPincludeBranchruleBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleBasic(SCIP *scip, SCIP_BRANCHRULE **branchruleptr, const char *name, const char *desc, int priority, int maxdepth, double maxbounddist, SCIP_BRANCHRULEDATA *branchruledata)
     * }
     */
    public static int SCIPincludeBranchruleBasic(MemorySegment scip, MemorySegment branchruleptr, MemorySegment name, MemorySegment desc, int priority, int maxdepth, double maxbounddist, MemorySegment branchruledata) {
        var mh$ = SCIPincludeBranchruleBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleBasic", scip, branchruleptr, name, desc, priority, maxdepth, maxbounddist, branchruledata);
            }
            return (int)mh$.invokeExact(scip, branchruleptr, name, desc, priority, maxdepth, maxbounddist, branchruledata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleCopy(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleCopy$descriptor() {
        return SCIPsetBranchruleCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleCopy(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleCopy$handle() {
        return SCIPsetBranchruleCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleCopy(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleCopy$address() {
        return SCIPsetBranchruleCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleCopy(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchcopy)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleCopy(MemorySegment scip, MemorySegment branchrule, MemorySegment branchcopy) {
        var mh$ = SCIPsetBranchruleCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleCopy", scip, branchrule, branchcopy);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleFree(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleFree$descriptor() {
        return SCIPsetBranchruleFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleFree(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleFree$handle() {
        return SCIPsetBranchruleFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleFree(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleFree$address() {
        return SCIPsetBranchruleFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleFree(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchfree)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleFree(MemorySegment scip, MemorySegment branchrule, MemorySegment branchfree) {
        var mh$ = SCIPsetBranchruleFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleFree", scip, branchrule, branchfree);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleInit$descriptor() {
        return SCIPsetBranchruleInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleInit$handle() {
        return SCIPsetBranchruleInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleInit$address() {
        return SCIPsetBranchruleInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleInit(MemorySegment scip, MemorySegment branchrule, MemorySegment branchinit) {
        var mh$ = SCIPsetBranchruleInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleInit", scip, branchrule, branchinit);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleExit$descriptor() {
        return SCIPsetBranchruleExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleExit$handle() {
        return SCIPsetBranchruleExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleExit$address() {
        return SCIPsetBranchruleExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExit(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexit)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleExit(MemorySegment scip, MemorySegment branchrule, MemorySegment branchexit) {
        var mh$ = SCIPsetBranchruleExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleExit", scip, branchrule, branchexit);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleInitsol$descriptor() {
        return SCIPsetBranchruleInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleInitsol$handle() {
        return SCIPsetBranchruleInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleInitsol$address() {
        return SCIPsetBranchruleInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleInitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchinitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleInitsol(MemorySegment scip, MemorySegment branchrule, MemorySegment branchinitsol) {
        var mh$ = SCIPsetBranchruleInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleInitsol", scip, branchrule, branchinitsol);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleExitsol$descriptor() {
        return SCIPsetBranchruleExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleExitsol$handle() {
        return SCIPsetBranchruleExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleExitsol$address() {
        return SCIPsetBranchruleExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExitsol(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexitsol)(SCIP *, SCIP_BRANCHRULE *))
     * }
     */
    public static int SCIPsetBranchruleExitsol(MemorySegment scip, MemorySegment branchrule, MemorySegment branchexitsol) {
        var mh$ = SCIPsetBranchruleExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleExitsol", scip, branchrule, branchexitsol);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleExecLp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleExecLp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecLp(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleExecLp$descriptor() {
        return SCIPsetBranchruleExecLp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecLp(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleExecLp$handle() {
        return SCIPsetBranchruleExecLp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecLp(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleExecLp$address() {
        return SCIPsetBranchruleExecLp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecLp(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexeclp)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetBranchruleExecLp(MemorySegment scip, MemorySegment branchrule, MemorySegment branchexeclp) {
        var mh$ = SCIPsetBranchruleExecLp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleExecLp", scip, branchrule, branchexeclp);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchexeclp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleExecExt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleExecExt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecExt(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleExecExt$descriptor() {
        return SCIPsetBranchruleExecExt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecExt(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleExecExt$handle() {
        return SCIPsetBranchruleExecExt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecExt(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleExecExt$address() {
        return SCIPsetBranchruleExecExt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecExt(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecext)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetBranchruleExecExt(MemorySegment scip, MemorySegment branchrule, MemorySegment branchexecext) {
        var mh$ = SCIPsetBranchruleExecExt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleExecExt", scip, branchrule, branchexecext);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchexecext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleExecPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleExecPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecPs(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleExecPs$descriptor() {
        return SCIPsetBranchruleExecPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecPs(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetBranchruleExecPs$handle() {
        return SCIPsetBranchruleExecPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecPs(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetBranchruleExecPs$address() {
        return SCIPsetBranchruleExecPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleExecPs(SCIP *scip, SCIP_BRANCHRULE *branchrule, SCIP_RETCODE (*branchexecps)(SCIP *, SCIP_BRANCHRULE *, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetBranchruleExecPs(MemorySegment scip, MemorySegment branchrule, MemorySegment branchexecps) {
        var mh$ = SCIPsetBranchruleExecPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleExecPs", scip, branchrule, branchexecps);
            }
            return (int)mh$.invokeExact(scip, branchrule, branchexecps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindBranchrule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindBranchrule");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE *SCIPfindBranchrule(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindBranchrule$descriptor() {
        return SCIPfindBranchrule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE *SCIPfindBranchrule(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindBranchrule$handle() {
        return SCIPfindBranchrule.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE *SCIPfindBranchrule(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBranchrule$address() {
        return SCIPfindBranchrule.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BRANCHRULE *SCIPfindBranchrule(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindBranchrule(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindBranchrule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindBranchrule", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBranchrules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBranchrules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE **SCIPgetBranchrules(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBranchrules$descriptor() {
        return SCIPgetBranchrules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE **SCIPgetBranchrules(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBranchrules$handle() {
        return SCIPgetBranchrules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BRANCHRULE **SCIPgetBranchrules(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBranchrules$address() {
        return SCIPgetBranchrules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BRANCHRULE **SCIPgetBranchrules(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBranchrules(MemorySegment scip) {
        var mh$ = SCIPgetBranchrules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBranchrules", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBranchrules {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBranchrules");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNBranchrules(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBranchrules$descriptor() {
        return SCIPgetNBranchrules.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNBranchrules(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBranchrules$handle() {
        return SCIPgetNBranchrules.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNBranchrules(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBranchrules$address() {
        return SCIPgetNBranchrules.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNBranchrules(SCIP *scip)
     * }
     */
    public static int SCIPgetNBranchrules(MemorySegment scip) {
        var mh$ = SCIPgetNBranchrules.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBranchrules", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchrulePriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchrulePriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchrulePriority(SCIP *scip, SCIP_BRANCHRULE *branchrule, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetBranchrulePriority$descriptor() {
        return SCIPsetBranchrulePriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchrulePriority(SCIP *scip, SCIP_BRANCHRULE *branchrule, int priority)
     * }
     */
    public static MethodHandle SCIPsetBranchrulePriority$handle() {
        return SCIPsetBranchrulePriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchrulePriority(SCIP *scip, SCIP_BRANCHRULE *branchrule, int priority)
     * }
     */
    public static MemorySegment SCIPsetBranchrulePriority$address() {
        return SCIPsetBranchrulePriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchrulePriority(SCIP *scip, SCIP_BRANCHRULE *branchrule, int priority)
     * }
     */
    public static int SCIPsetBranchrulePriority(MemorySegment scip, MemorySegment branchrule, int priority) {
        var mh$ = SCIPsetBranchrulePriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchrulePriority", scip, branchrule, priority);
            }
            return (int)mh$.invokeExact(scip, branchrule, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleMaxdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleMaxdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxdepth(SCIP *scip, SCIP_BRANCHRULE *branchrule, int maxdepth)
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleMaxdepth$descriptor() {
        return SCIPsetBranchruleMaxdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxdepth(SCIP *scip, SCIP_BRANCHRULE *branchrule, int maxdepth)
     * }
     */
    public static MethodHandle SCIPsetBranchruleMaxdepth$handle() {
        return SCIPsetBranchruleMaxdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxdepth(SCIP *scip, SCIP_BRANCHRULE *branchrule, int maxdepth)
     * }
     */
    public static MemorySegment SCIPsetBranchruleMaxdepth$address() {
        return SCIPsetBranchruleMaxdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxdepth(SCIP *scip, SCIP_BRANCHRULE *branchrule, int maxdepth)
     * }
     */
    public static int SCIPsetBranchruleMaxdepth(MemorySegment scip, MemorySegment branchrule, int maxdepth) {
        var mh$ = SCIPsetBranchruleMaxdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleMaxdepth", scip, branchrule, maxdepth);
            }
            return (int)mh$.invokeExact(scip, branchrule, maxdepth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBranchruleMaxbounddist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBranchruleMaxbounddist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxbounddist(SCIP *scip, SCIP_BRANCHRULE *branchrule, double maxbounddist)
     * }
     */
    public static FunctionDescriptor SCIPsetBranchruleMaxbounddist$descriptor() {
        return SCIPsetBranchruleMaxbounddist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxbounddist(SCIP *scip, SCIP_BRANCHRULE *branchrule, double maxbounddist)
     * }
     */
    public static MethodHandle SCIPsetBranchruleMaxbounddist$handle() {
        return SCIPsetBranchruleMaxbounddist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxbounddist(SCIP *scip, SCIP_BRANCHRULE *branchrule, double maxbounddist)
     * }
     */
    public static MemorySegment SCIPsetBranchruleMaxbounddist$address() {
        return SCIPsetBranchruleMaxbounddist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBranchruleMaxbounddist(SCIP *scip, SCIP_BRANCHRULE *branchrule, double maxbounddist)
     * }
     */
    public static int SCIPsetBranchruleMaxbounddist(MemorySegment scip, MemorySegment branchrule, double maxbounddist) {
        var mh$ = SCIPsetBranchruleMaxbounddist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBranchruleMaxbounddist", scip, branchrule, maxbounddist);
            }
            return (int)mh$.invokeExact(scip, branchrule, maxbounddist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBranchCands(SCIP *scip, SCIP_VAR ***lpcands, double **lpcandssol, double **lpcandsfrac, int *nlpcands, int *npriolpcands, int *nfracimplvars)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBranchCands$descriptor() {
        return SCIPgetLPBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBranchCands(SCIP *scip, SCIP_VAR ***lpcands, double **lpcandssol, double **lpcandsfrac, int *nlpcands, int *npriolpcands, int *nfracimplvars)
     * }
     */
    public static MethodHandle SCIPgetLPBranchCands$handle() {
        return SCIPgetLPBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBranchCands(SCIP *scip, SCIP_VAR ***lpcands, double **lpcandssol, double **lpcandsfrac, int *nlpcands, int *npriolpcands, int *nfracimplvars)
     * }
     */
    public static MemorySegment SCIPgetLPBranchCands$address() {
        return SCIPgetLPBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBranchCands(SCIP *scip, SCIP_VAR ***lpcands, double **lpcandssol, double **lpcandsfrac, int *nlpcands, int *npriolpcands, int *nfracimplvars)
     * }
     */
    public static int SCIPgetLPBranchCands(MemorySegment scip, MemorySegment lpcands, MemorySegment lpcandssol, MemorySegment lpcandsfrac, MemorySegment nlpcands, MemorySegment npriolpcands, MemorySegment nfracimplvars) {
        var mh$ = SCIPgetLPBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBranchCands", scip, lpcands, lpcandssol, lpcandsfrac, nlpcands, npriolpcands, nfracimplvars);
            }
            return (int)mh$.invokeExact(scip, lpcands, lpcandssol, lpcandsfrac, nlpcands, npriolpcands, nfracimplvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNLPBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPBranchCands$descriptor() {
        return SCIPgetNLPBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNLPBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPBranchCands$handle() {
        return SCIPgetNLPBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNLPBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPBranchCands$address() {
        return SCIPgetNLPBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNLPBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNLPBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNLPBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioLPBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioLPBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioLPBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioLPBranchCands$descriptor() {
        return SCIPgetNPrioLPBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioLPBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioLPBranchCands$handle() {
        return SCIPgetNPrioLPBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioLPBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioLPBranchCands$address() {
        return SCIPgetNPrioLPBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioLPBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioLPBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNPrioLPBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioLPBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExternBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExternBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExternBranchCands(SCIP *scip, SCIP_VAR ***externcands, double **externcandssol, double **externcandsscore, int *nexterncands, int *nprioexterncands, int *nprioexternbins, int *nprioexternints, int *nprioexternimpls)
     * }
     */
    public static FunctionDescriptor SCIPgetExternBranchCands$descriptor() {
        return SCIPgetExternBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExternBranchCands(SCIP *scip, SCIP_VAR ***externcands, double **externcandssol, double **externcandsscore, int *nexterncands, int *nprioexterncands, int *nprioexternbins, int *nprioexternints, int *nprioexternimpls)
     * }
     */
    public static MethodHandle SCIPgetExternBranchCands$handle() {
        return SCIPgetExternBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExternBranchCands(SCIP *scip, SCIP_VAR ***externcands, double **externcandssol, double **externcandsscore, int *nexterncands, int *nprioexterncands, int *nprioexternbins, int *nprioexternints, int *nprioexternimpls)
     * }
     */
    public static MemorySegment SCIPgetExternBranchCands$address() {
        return SCIPgetExternBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExternBranchCands(SCIP *scip, SCIP_VAR ***externcands, double **externcandssol, double **externcandsscore, int *nexterncands, int *nprioexterncands, int *nprioexternbins, int *nprioexternints, int *nprioexternimpls)
     * }
     */
    public static int SCIPgetExternBranchCands(MemorySegment scip, MemorySegment externcands, MemorySegment externcandssol, MemorySegment externcandsscore, MemorySegment nexterncands, MemorySegment nprioexterncands, MemorySegment nprioexternbins, MemorySegment nprioexternints, MemorySegment nprioexternimpls) {
        var mh$ = SCIPgetExternBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExternBranchCands", scip, externcands, externcandssol, externcandsscore, nexterncands, nprioexterncands, nprioexternbins, nprioexternints, nprioexternimpls);
            }
            return (int)mh$.invokeExact(scip, externcands, externcandssol, externcandsscore, nexterncands, nprioexterncands, nprioexternbins, nprioexternints, nprioexternimpls);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNExternBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNExternBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNExternBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNExternBranchCands$descriptor() {
        return SCIPgetNExternBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNExternBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNExternBranchCands$handle() {
        return SCIPgetNExternBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNExternBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNExternBranchCands$address() {
        return SCIPgetNExternBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNExternBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNExternBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNExternBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNExternBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioExternBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioExternBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioExternBranchCands$descriptor() {
        return SCIPgetNPrioExternBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioExternBranchCands$handle() {
        return SCIPgetNPrioExternBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioExternBranchCands$address() {
        return SCIPgetNPrioExternBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioExternBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNPrioExternBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioExternBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioExternBranchBins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioExternBranchBins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchBins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioExternBranchBins$descriptor() {
        return SCIPgetNPrioExternBranchBins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchBins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioExternBranchBins$handle() {
        return SCIPgetNPrioExternBranchBins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchBins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioExternBranchBins$address() {
        return SCIPgetNPrioExternBranchBins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchBins(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioExternBranchBins(MemorySegment scip) {
        var mh$ = SCIPgetNPrioExternBranchBins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioExternBranchBins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioExternBranchInts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioExternBranchInts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchInts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioExternBranchInts$descriptor() {
        return SCIPgetNPrioExternBranchInts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchInts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioExternBranchInts$handle() {
        return SCIPgetNPrioExternBranchInts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchInts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioExternBranchInts$address() {
        return SCIPgetNPrioExternBranchInts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchInts(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioExternBranchInts(MemorySegment scip) {
        var mh$ = SCIPgetNPrioExternBranchInts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioExternBranchInts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioExternBranchImpls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioExternBranchImpls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchImpls(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioExternBranchImpls$descriptor() {
        return SCIPgetNPrioExternBranchImpls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchImpls(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioExternBranchImpls$handle() {
        return SCIPgetNPrioExternBranchImpls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchImpls(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioExternBranchImpls$address() {
        return SCIPgetNPrioExternBranchImpls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchImpls(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioExternBranchImpls(MemorySegment scip) {
        var mh$ = SCIPgetNPrioExternBranchImpls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioExternBranchImpls", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioExternBranchConts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioExternBranchConts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchConts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioExternBranchConts$descriptor() {
        return SCIPgetNPrioExternBranchConts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchConts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioExternBranchConts$handle() {
        return SCIPgetNPrioExternBranchConts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchConts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioExternBranchConts$address() {
        return SCIPgetNPrioExternBranchConts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioExternBranchConts(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioExternBranchConts(MemorySegment scip) {
        var mh$ = SCIPgetNPrioExternBranchConts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioExternBranchConts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddExternBranchCand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddExternBranchCand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExternBranchCand(SCIP *scip, SCIP_VAR *var, double score, double solval)
     * }
     */
    public static FunctionDescriptor SCIPaddExternBranchCand$descriptor() {
        return SCIPaddExternBranchCand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExternBranchCand(SCIP *scip, SCIP_VAR *var, double score, double solval)
     * }
     */
    public static MethodHandle SCIPaddExternBranchCand$handle() {
        return SCIPaddExternBranchCand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExternBranchCand(SCIP *scip, SCIP_VAR *var, double score, double solval)
     * }
     */
    public static MemorySegment SCIPaddExternBranchCand$address() {
        return SCIPaddExternBranchCand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExternBranchCand(SCIP *scip, SCIP_VAR *var, double score, double solval)
     * }
     */
    public static int SCIPaddExternBranchCand(MemorySegment scip, MemorySegment var_, double score, double solval) {
        var mh$ = SCIPaddExternBranchCand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddExternBranchCand", scip, var_, score, solval);
            }
            return (int)mh$.invokeExact(scip, var_, score, solval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearExternBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearExternBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPclearExternBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPclearExternBranchCands$descriptor() {
        return SCIPclearExternBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPclearExternBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPclearExternBranchCands$handle() {
        return SCIPclearExternBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPclearExternBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPclearExternBranchCands$address() {
        return SCIPclearExternBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPclearExternBranchCands(SCIP *scip)
     * }
     */
    public static void SCIPclearExternBranchCands(MemorySegment scip) {
        var mh$ = SCIPclearExternBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearExternBranchCands", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcontainsExternBranchCand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcontainsExternBranchCand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcontainsExternBranchCand(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcontainsExternBranchCand$descriptor() {
        return SCIPcontainsExternBranchCand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcontainsExternBranchCand(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcontainsExternBranchCand$handle() {
        return SCIPcontainsExternBranchCand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcontainsExternBranchCand(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcontainsExternBranchCand$address() {
        return SCIPcontainsExternBranchCand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcontainsExternBranchCand(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPcontainsExternBranchCand(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcontainsExternBranchCand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcontainsExternBranchCand", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPseudoBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPseudoBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetPseudoBranchCands(SCIP *scip, SCIP_VAR ***pseudocands, int *npseudocands, int *npriopseudocands)
     * }
     */
    public static FunctionDescriptor SCIPgetPseudoBranchCands$descriptor() {
        return SCIPgetPseudoBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetPseudoBranchCands(SCIP *scip, SCIP_VAR ***pseudocands, int *npseudocands, int *npriopseudocands)
     * }
     */
    public static MethodHandle SCIPgetPseudoBranchCands$handle() {
        return SCIPgetPseudoBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetPseudoBranchCands(SCIP *scip, SCIP_VAR ***pseudocands, int *npseudocands, int *npriopseudocands)
     * }
     */
    public static MemorySegment SCIPgetPseudoBranchCands$address() {
        return SCIPgetPseudoBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetPseudoBranchCands(SCIP *scip, SCIP_VAR ***pseudocands, int *npseudocands, int *npriopseudocands)
     * }
     */
    public static int SCIPgetPseudoBranchCands(MemorySegment scip, MemorySegment pseudocands, MemorySegment npseudocands, MemorySegment npriopseudocands) {
        var mh$ = SCIPgetPseudoBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPseudoBranchCands", scip, pseudocands, npseudocands, npriopseudocands);
            }
            return (int)mh$.invokeExact(scip, pseudocands, npseudocands, npriopseudocands);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPseudoBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPseudoBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPseudoBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPseudoBranchCands$descriptor() {
        return SCIPgetNPseudoBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPseudoBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPseudoBranchCands$handle() {
        return SCIPgetNPseudoBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPseudoBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPseudoBranchCands$address() {
        return SCIPgetNPseudoBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPseudoBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNPseudoBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNPseudoBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPseudoBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioPseudoBranchCands {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioPseudoBranchCands");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchCands(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioPseudoBranchCands$descriptor() {
        return SCIPgetNPrioPseudoBranchCands.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchCands(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioPseudoBranchCands$handle() {
        return SCIPgetNPrioPseudoBranchCands.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchCands(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioPseudoBranchCands$address() {
        return SCIPgetNPrioPseudoBranchCands.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchCands(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioPseudoBranchCands(MemorySegment scip) {
        var mh$ = SCIPgetNPrioPseudoBranchCands.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioPseudoBranchCands", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioPseudoBranchBins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioPseudoBranchBins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchBins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioPseudoBranchBins$descriptor() {
        return SCIPgetNPrioPseudoBranchBins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchBins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioPseudoBranchBins$handle() {
        return SCIPgetNPrioPseudoBranchBins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchBins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioPseudoBranchBins$address() {
        return SCIPgetNPrioPseudoBranchBins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchBins(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioPseudoBranchBins(MemorySegment scip) {
        var mh$ = SCIPgetNPrioPseudoBranchBins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioPseudoBranchBins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioPseudoBranchInts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioPseudoBranchInts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchInts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioPseudoBranchInts$descriptor() {
        return SCIPgetNPrioPseudoBranchInts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchInts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioPseudoBranchInts$handle() {
        return SCIPgetNPrioPseudoBranchInts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchInts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioPseudoBranchInts$address() {
        return SCIPgetNPrioPseudoBranchInts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchInts(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioPseudoBranchInts(MemorySegment scip) {
        var mh$ = SCIPgetNPrioPseudoBranchInts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioPseudoBranchInts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrioPseudoBranchImpls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrioPseudoBranchImpls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchImpls(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrioPseudoBranchImpls$descriptor() {
        return SCIPgetNPrioPseudoBranchImpls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchImpls(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrioPseudoBranchImpls$handle() {
        return SCIPgetNPrioPseudoBranchImpls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchImpls(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrioPseudoBranchImpls$address() {
        return SCIPgetNPrioPseudoBranchImpls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPrioPseudoBranchImpls(SCIP *scip)
     * }
     */
    public static int SCIPgetNPrioPseudoBranchImpls(MemorySegment scip) {
        var mh$ = SCIPgetNPrioPseudoBranchImpls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrioPseudoBranchImpls", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBranchScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBranchScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetBranchScore(SCIP *scip, SCIP_VAR *var, double downgain, double upgain)
     * }
     */
    public static FunctionDescriptor SCIPgetBranchScore$descriptor() {
        return SCIPgetBranchScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetBranchScore(SCIP *scip, SCIP_VAR *var, double downgain, double upgain)
     * }
     */
    public static MethodHandle SCIPgetBranchScore$handle() {
        return SCIPgetBranchScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetBranchScore(SCIP *scip, SCIP_VAR *var, double downgain, double upgain)
     * }
     */
    public static MemorySegment SCIPgetBranchScore$address() {
        return SCIPgetBranchScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetBranchScore(SCIP *scip, SCIP_VAR *var, double downgain, double upgain)
     * }
     */
    public static double SCIPgetBranchScore(MemorySegment scip, MemorySegment var_, double downgain, double upgain) {
        var mh$ = SCIPgetBranchScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBranchScore", scip, var_, downgain, upgain);
            }
            return (double)mh$.invokeExact(scip, var_, downgain, upgain);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBranchScoreMultiple {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBranchScoreMultiple");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetBranchScoreMultiple(SCIP *scip, SCIP_VAR *var, int nchildren, double *gains)
     * }
     */
    public static FunctionDescriptor SCIPgetBranchScoreMultiple$descriptor() {
        return SCIPgetBranchScoreMultiple.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetBranchScoreMultiple(SCIP *scip, SCIP_VAR *var, int nchildren, double *gains)
     * }
     */
    public static MethodHandle SCIPgetBranchScoreMultiple$handle() {
        return SCIPgetBranchScoreMultiple.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetBranchScoreMultiple(SCIP *scip, SCIP_VAR *var, int nchildren, double *gains)
     * }
     */
    public static MemorySegment SCIPgetBranchScoreMultiple$address() {
        return SCIPgetBranchScoreMultiple.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetBranchScoreMultiple(SCIP *scip, SCIP_VAR *var, int nchildren, double *gains)
     * }
     */
    public static double SCIPgetBranchScoreMultiple(MemorySegment scip, MemorySegment var_, int nchildren, MemorySegment gains) {
        var mh$ = SCIPgetBranchScoreMultiple.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBranchScoreMultiple", scip, var_, nchildren, gains);
            }
            return (double)mh$.invokeExact(scip, var_, nchildren, gains);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBranchingPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBranchingPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetBranchingPoint(SCIP *scip, SCIP_VAR *var, double suggestion)
     * }
     */
    public static FunctionDescriptor SCIPgetBranchingPoint$descriptor() {
        return SCIPgetBranchingPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetBranchingPoint(SCIP *scip, SCIP_VAR *var, double suggestion)
     * }
     */
    public static MethodHandle SCIPgetBranchingPoint$handle() {
        return SCIPgetBranchingPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetBranchingPoint(SCIP *scip, SCIP_VAR *var, double suggestion)
     * }
     */
    public static MemorySegment SCIPgetBranchingPoint$address() {
        return SCIPgetBranchingPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetBranchingPoint(SCIP *scip, SCIP_VAR *var, double suggestion)
     * }
     */
    public static double SCIPgetBranchingPoint(MemorySegment scip, MemorySegment var_, double suggestion) {
        var mh$ = SCIPgetBranchingPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBranchingPoint", scip, var_, suggestion);
            }
            return (double)mh$.invokeExact(scip, var_, suggestion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcNodeselPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcNodeselPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcNodeselPriority(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdir, double targetvalue)
     * }
     */
    public static FunctionDescriptor SCIPcalcNodeselPriority$descriptor() {
        return SCIPcalcNodeselPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcNodeselPriority(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdir, double targetvalue)
     * }
     */
    public static MethodHandle SCIPcalcNodeselPriority$handle() {
        return SCIPcalcNodeselPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcNodeselPriority(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdir, double targetvalue)
     * }
     */
    public static MemorySegment SCIPcalcNodeselPriority$address() {
        return SCIPcalcNodeselPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcNodeselPriority(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdir, double targetvalue)
     * }
     */
    public static double SCIPcalcNodeselPriority(MemorySegment scip, MemorySegment var_, int branchdir, double targetvalue) {
        var mh$ = SCIPcalcNodeselPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcNodeselPriority", scip, var_, branchdir, targetvalue);
            }
            return (double)mh$.invokeExact(scip, var_, branchdir, targetvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcChildEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcChildEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimate(SCIP *scip, SCIP_VAR *var, double targetvalue)
     * }
     */
    public static FunctionDescriptor SCIPcalcChildEstimate$descriptor() {
        return SCIPcalcChildEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimate(SCIP *scip, SCIP_VAR *var, double targetvalue)
     * }
     */
    public static MethodHandle SCIPcalcChildEstimate$handle() {
        return SCIPcalcChildEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimate(SCIP *scip, SCIP_VAR *var, double targetvalue)
     * }
     */
    public static MemorySegment SCIPcalcChildEstimate$address() {
        return SCIPcalcChildEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcChildEstimate(SCIP *scip, SCIP_VAR *var, double targetvalue)
     * }
     */
    public static double SCIPcalcChildEstimate(MemorySegment scip, MemorySegment var_, double targetvalue) {
        var mh$ = SCIPcalcChildEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcChildEstimate", scip, var_, targetvalue);
            }
            return (double)mh$.invokeExact(scip, var_, targetvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcChildEstimateIncrease {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcChildEstimateIncrease");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimateIncrease(SCIP *scip, SCIP_VAR *var, double varsol, double targetvalue)
     * }
     */
    public static FunctionDescriptor SCIPcalcChildEstimateIncrease$descriptor() {
        return SCIPcalcChildEstimateIncrease.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimateIncrease(SCIP *scip, SCIP_VAR *var, double varsol, double targetvalue)
     * }
     */
    public static MethodHandle SCIPcalcChildEstimateIncrease$handle() {
        return SCIPcalcChildEstimateIncrease.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcChildEstimateIncrease(SCIP *scip, SCIP_VAR *var, double varsol, double targetvalue)
     * }
     */
    public static MemorySegment SCIPcalcChildEstimateIncrease$address() {
        return SCIPcalcChildEstimateIncrease.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcChildEstimateIncrease(SCIP *scip, SCIP_VAR *var, double varsol, double targetvalue)
     * }
     */
    public static double SCIPcalcChildEstimateIncrease(MemorySegment scip, MemorySegment var_, double varsol, double targetvalue) {
        var mh$ = SCIPcalcChildEstimateIncrease.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcChildEstimateIncrease", scip, var_, varsol, targetvalue);
            }
            return (double)mh$.invokeExact(scip, var_, varsol, targetvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateChild(SCIP *scip, SCIP_NODE **node, double nodeselprio, double estimate)
     * }
     */
    public static FunctionDescriptor SCIPcreateChild$descriptor() {
        return SCIPcreateChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateChild(SCIP *scip, SCIP_NODE **node, double nodeselprio, double estimate)
     * }
     */
    public static MethodHandle SCIPcreateChild$handle() {
        return SCIPcreateChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateChild(SCIP *scip, SCIP_NODE **node, double nodeselprio, double estimate)
     * }
     */
    public static MemorySegment SCIPcreateChild$address() {
        return SCIPcreateChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateChild(SCIP *scip, SCIP_NODE **node, double nodeselprio, double estimate)
     * }
     */
    public static int SCIPcreateChild(MemorySegment scip, MemorySegment node, double nodeselprio, double estimate) {
        var mh$ = SCIPcreateChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateChild", scip, node, nodeselprio, estimate);
            }
            return (int)mh$.invokeExact(scip, node, nodeselprio, estimate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVar(SCIP *scip, SCIP_VAR *var, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static FunctionDescriptor SCIPbranchVar$descriptor() {
        return SCIPbranchVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVar(SCIP *scip, SCIP_VAR *var, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static MethodHandle SCIPbranchVar$handle() {
        return SCIPbranchVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVar(SCIP *scip, SCIP_VAR *var, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static MemorySegment SCIPbranchVar$address() {
        return SCIPbranchVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVar(SCIP *scip, SCIP_VAR *var, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static int SCIPbranchVar(MemorySegment scip, MemorySegment var_, MemorySegment downchild, MemorySegment eqchild, MemorySegment upchild) {
        var mh$ = SCIPbranchVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchVar", scip, var_, downchild, eqchild, upchild);
            }
            return (int)mh$.invokeExact(scip, var_, downchild, eqchild, upchild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchVarHole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchVarHole");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarHole(SCIP *scip, SCIP_VAR *var, double left, double right, SCIP_NODE **downchild, SCIP_NODE **upchild)
     * }
     */
    public static FunctionDescriptor SCIPbranchVarHole$descriptor() {
        return SCIPbranchVarHole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarHole(SCIP *scip, SCIP_VAR *var, double left, double right, SCIP_NODE **downchild, SCIP_NODE **upchild)
     * }
     */
    public static MethodHandle SCIPbranchVarHole$handle() {
        return SCIPbranchVarHole.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarHole(SCIP *scip, SCIP_VAR *var, double left, double right, SCIP_NODE **downchild, SCIP_NODE **upchild)
     * }
     */
    public static MemorySegment SCIPbranchVarHole$address() {
        return SCIPbranchVarHole.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarHole(SCIP *scip, SCIP_VAR *var, double left, double right, SCIP_NODE **downchild, SCIP_NODE **upchild)
     * }
     */
    public static int SCIPbranchVarHole(MemorySegment scip, MemorySegment var_, double left, double right, MemorySegment downchild, MemorySegment upchild) {
        var mh$ = SCIPbranchVarHole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchVarHole", scip, var_, left, right, downchild, upchild);
            }
            return (int)mh$.invokeExact(scip, var_, left, right, downchild, upchild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchVarVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchVarVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarVal(SCIP *scip, SCIP_VAR *var, double val, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static FunctionDescriptor SCIPbranchVarVal$descriptor() {
        return SCIPbranchVarVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarVal(SCIP *scip, SCIP_VAR *var, double val, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static MethodHandle SCIPbranchVarVal$handle() {
        return SCIPbranchVarVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarVal(SCIP *scip, SCIP_VAR *var, double val, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static MemorySegment SCIPbranchVarVal$address() {
        return SCIPbranchVarVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarVal(SCIP *scip, SCIP_VAR *var, double val, SCIP_NODE **downchild, SCIP_NODE **eqchild, SCIP_NODE **upchild)
     * }
     */
    public static int SCIPbranchVarVal(MemorySegment scip, MemorySegment var_, double val, MemorySegment downchild, MemorySegment eqchild, MemorySegment upchild) {
        var mh$ = SCIPbranchVarVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchVarVal", scip, var_, val, downchild, eqchild, upchild);
            }
            return (int)mh$.invokeExact(scip, var_, val, downchild, eqchild, upchild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchVarValNary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchVarValNary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarValNary(SCIP *scip, SCIP_VAR *var, double val, int n, double minwidth, double widthfactor, int *nchildren)
     * }
     */
    public static FunctionDescriptor SCIPbranchVarValNary$descriptor() {
        return SCIPbranchVarValNary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarValNary(SCIP *scip, SCIP_VAR *var, double val, int n, double minwidth, double widthfactor, int *nchildren)
     * }
     */
    public static MethodHandle SCIPbranchVarValNary$handle() {
        return SCIPbranchVarValNary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarValNary(SCIP *scip, SCIP_VAR *var, double val, int n, double minwidth, double widthfactor, int *nchildren)
     * }
     */
    public static MemorySegment SCIPbranchVarValNary$address() {
        return SCIPbranchVarValNary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchVarValNary(SCIP *scip, SCIP_VAR *var, double val, int n, double minwidth, double widthfactor, int *nchildren)
     * }
     */
    public static int SCIPbranchVarValNary(MemorySegment scip, MemorySegment var_, double val, int n, double minwidth, double widthfactor, MemorySegment nchildren) {
        var mh$ = SCIPbranchVarValNary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchVarValNary", scip, var_, val, n, minwidth, widthfactor, nchildren);
            }
            return (int)mh$.invokeExact(scip, var_, val, n, minwidth, widthfactor, nchildren);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchLP(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPbranchLP$descriptor() {
        return SCIPbranchLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchLP(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPbranchLP$handle() {
        return SCIPbranchLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchLP(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPbranchLP$address() {
        return SCIPbranchLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchLP(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static int SCIPbranchLP(MemorySegment scip, MemorySegment result) {
        var mh$ = SCIPbranchLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchLP", scip, result);
            }
            return (int)mh$.invokeExact(scip, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchExtern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchExtern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchExtern(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPbranchExtern$descriptor() {
        return SCIPbranchExtern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchExtern(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPbranchExtern$handle() {
        return SCIPbranchExtern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchExtern(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPbranchExtern$address() {
        return SCIPbranchExtern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchExtern(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static int SCIPbranchExtern(MemorySegment scip, MemorySegment result) {
        var mh$ = SCIPbranchExtern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchExtern", scip, result);
            }
            return (int)mh$.invokeExact(scip, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbranchPseudo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbranchPseudo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchPseudo(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPbranchPseudo$descriptor() {
        return SCIPbranchPseudo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchPseudo(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPbranchPseudo$handle() {
        return SCIPbranchPseudo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchPseudo(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPbranchPseudo$address() {
        return SCIPbranchPseudo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbranchPseudo(SCIP *scip, SCIP_RESULT *result)
     * }
     */
    public static int SCIPbranchPseudo(MemorySegment scip, MemorySegment result) {
        var mh$ = SCIPbranchPseudo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbranchPseudo", scip, result);
            }
            return (int)mh$.invokeExact(scip, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCompr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCompr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCompr(SCIP *scip, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeCompr$descriptor() {
        return SCIPincludeCompr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCompr(SCIP *scip, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MethodHandle SCIPincludeCompr$handle() {
        return SCIPincludeCompr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCompr(SCIP *scip, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MemorySegment SCIPincludeCompr$address() {
        return SCIPincludeCompr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCompr(SCIP *scip, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *), SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static int SCIPincludeCompr(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int minnnodes, MemorySegment comprcopy, MemorySegment comprfree, MemorySegment comprinit, MemorySegment comprexit, MemorySegment comprinitsol, MemorySegment comprexitsol, MemorySegment comprexec, MemorySegment comprdata) {
        var mh$ = SCIPincludeCompr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCompr", scip, name, desc, priority, minnnodes, comprcopy, comprfree, comprinit, comprexit, comprinitsol, comprexitsol, comprexec, comprdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, minnnodes, comprcopy, comprfree, comprinit, comprexit, comprinitsol, comprexitsol, comprexec, comprdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeComprBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeComprBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprBasic(SCIP *scip, SCIP_COMPR **compr, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeComprBasic$descriptor() {
        return SCIPincludeComprBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprBasic(SCIP *scip, SCIP_COMPR **compr, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MethodHandle SCIPincludeComprBasic$handle() {
        return SCIPincludeComprBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprBasic(SCIP *scip, SCIP_COMPR **compr, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static MemorySegment SCIPincludeComprBasic$address() {
        return SCIPincludeComprBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprBasic(SCIP *scip, SCIP_COMPR **compr, const char *name, const char *desc, int priority, int minnnodes, SCIP_RETCODE (*comprexec)(SCIP *, SCIP_COMPR *, SCIP_RESULT *), SCIP_COMPRDATA *comprdata)
     * }
     */
    public static int SCIPincludeComprBasic(MemorySegment scip, MemorySegment compr, MemorySegment name, MemorySegment desc, int priority, int minnnodes, MemorySegment comprexec, MemorySegment comprdata) {
        var mh$ = SCIPincludeComprBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeComprBasic", scip, compr, name, desc, priority, minnnodes, comprexec, comprdata);
            }
            return (int)mh$.invokeExact(scip, compr, name, desc, priority, minnnodes, comprexec, comprdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprCopy(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprCopy$descriptor() {
        return SCIPsetComprCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprCopy(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprCopy$handle() {
        return SCIPsetComprCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprCopy(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprCopy$address() {
        return SCIPsetComprCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprCopy(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprcopy)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprCopy(MemorySegment scip, MemorySegment compr, MemorySegment comprcopy) {
        var mh$ = SCIPsetComprCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprCopy", scip, compr, comprcopy);
            }
            return (int)mh$.invokeExact(scip, compr, comprcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprFree(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprFree$descriptor() {
        return SCIPsetComprFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprFree(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprFree$handle() {
        return SCIPsetComprFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprFree(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprFree$address() {
        return SCIPsetComprFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprFree(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprfree)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprFree(MemorySegment scip, MemorySegment compr, MemorySegment comprfree) {
        var mh$ = SCIPsetComprFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprFree", scip, compr, comprfree);
            }
            return (int)mh$.invokeExact(scip, compr, comprfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprInit$descriptor() {
        return SCIPsetComprInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprInit$handle() {
        return SCIPsetComprInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprInit$address() {
        return SCIPsetComprInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprInit(MemorySegment scip, MemorySegment compr, MemorySegment comprinit) {
        var mh$ = SCIPsetComprInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprInit", scip, compr, comprinit);
            }
            return (int)mh$.invokeExact(scip, compr, comprinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprExit$descriptor() {
        return SCIPsetComprExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprExit$handle() {
        return SCIPsetComprExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprExit$address() {
        return SCIPsetComprExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExit(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexit)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprExit(MemorySegment scip, MemorySegment compr, MemorySegment comprexit) {
        var mh$ = SCIPsetComprExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprExit", scip, compr, comprexit);
            }
            return (int)mh$.invokeExact(scip, compr, comprexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprInitsol$descriptor() {
        return SCIPsetComprInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprInitsol$handle() {
        return SCIPsetComprInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprInitsol$address() {
        return SCIPsetComprInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprInitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprinitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprInitsol(MemorySegment scip, MemorySegment compr, MemorySegment comprinitsol) {
        var mh$ = SCIPsetComprInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprInitsol", scip, compr, comprinitsol);
            }
            return (int)mh$.invokeExact(scip, compr, comprinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static FunctionDescriptor SCIPsetComprExitsol$descriptor() {
        return SCIPsetComprExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MethodHandle SCIPsetComprExitsol$handle() {
        return SCIPsetComprExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static MemorySegment SCIPsetComprExitsol$address() {
        return SCIPsetComprExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprExitsol(SCIP *scip, SCIP_COMPR *compr, SCIP_RETCODE (*comprexitsol)(SCIP *, SCIP_COMPR *))
     * }
     */
    public static int SCIPsetComprExitsol(MemorySegment scip, MemorySegment compr, MemorySegment comprexitsol) {
        var mh$ = SCIPsetComprExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprExitsol", scip, compr, comprexitsol);
            }
            return (int)mh$.invokeExact(scip, compr, comprexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindCompr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindCompr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COMPR *SCIPfindCompr(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindCompr$descriptor() {
        return SCIPfindCompr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COMPR *SCIPfindCompr(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindCompr$handle() {
        return SCIPfindCompr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COMPR *SCIPfindCompr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCompr$address() {
        return SCIPfindCompr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COMPR *SCIPfindCompr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCompr(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindCompr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindCompr", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetComprs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetComprs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COMPR **SCIPgetComprs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetComprs$descriptor() {
        return SCIPgetComprs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COMPR **SCIPgetComprs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetComprs$handle() {
        return SCIPgetComprs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COMPR **SCIPgetComprs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetComprs$address() {
        return SCIPgetComprs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COMPR **SCIPgetComprs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetComprs(MemorySegment scip) {
        var mh$ = SCIPgetComprs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetComprs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCompr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCompr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCompr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCompr$descriptor() {
        return SCIPgetNCompr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCompr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCompr$handle() {
        return SCIPgetNCompr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCompr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCompr$address() {
        return SCIPgetNCompr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCompr(SCIP *scip)
     * }
     */
    public static int SCIPgetNCompr(MemorySegment scip) {
        var mh$ = SCIPgetNCompr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCompr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetComprPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetComprPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprPriority(SCIP *scip, SCIP_COMPR *compr, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetComprPriority$descriptor() {
        return SCIPsetComprPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprPriority(SCIP *scip, SCIP_COMPR *compr, int priority)
     * }
     */
    public static MethodHandle SCIPsetComprPriority$handle() {
        return SCIPsetComprPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprPriority(SCIP *scip, SCIP_COMPR *compr, int priority)
     * }
     */
    public static MemorySegment SCIPsetComprPriority$address() {
        return SCIPsetComprPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetComprPriority(SCIP *scip, SCIP_COMPR *compr, int priority)
     * }
     */
    public static int SCIPsetComprPriority(MemorySegment scip, MemorySegment compr, int priority) {
        var mh$ = SCIPsetComprPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetComprPriority", scip, compr, priority);
            }
            return (int)mh$.invokeExact(scip, compr, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConcsolverType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConcsolverType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcsolverType(SCIP *scip, const char *name, double prefpriodefault, SCIP_RETCODE (*concsolvercreateinst)(SCIP *, SCIP_CONCSOLVERTYPE *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverdestroyinst)(SCIP *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverinitseeds)(SCIP_CONCSOLVER *, unsigned int), SCIP_RETCODE (*concsolverexec)(SCIP_CONCSOLVER *, double *, long long *, long long *), SCIP_RETCODE (*concsolvercopysolvdata)(SCIP_CONCSOLVER *, SCIP *), SCIP_RETCODE (*concsolverstop)(SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolversyncwrite)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int, int, int *), SCIP_RETCODE (*concsolversyncread)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int *, int *, int *), void (*concsolvertypefreedata)(SCIP_CONCSOLVERTYPEDATA **), SCIP_CONCSOLVERTYPEDATA *data)
     * }
     */
    public static FunctionDescriptor SCIPincludeConcsolverType$descriptor() {
        return SCIPincludeConcsolverType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcsolverType(SCIP *scip, const char *name, double prefpriodefault, SCIP_RETCODE (*concsolvercreateinst)(SCIP *, SCIP_CONCSOLVERTYPE *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverdestroyinst)(SCIP *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverinitseeds)(SCIP_CONCSOLVER *, unsigned int), SCIP_RETCODE (*concsolverexec)(SCIP_CONCSOLVER *, double *, long long *, long long *), SCIP_RETCODE (*concsolvercopysolvdata)(SCIP_CONCSOLVER *, SCIP *), SCIP_RETCODE (*concsolverstop)(SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolversyncwrite)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int, int, int *), SCIP_RETCODE (*concsolversyncread)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int *, int *, int *), void (*concsolvertypefreedata)(SCIP_CONCSOLVERTYPEDATA **), SCIP_CONCSOLVERTYPEDATA *data)
     * }
     */
    public static MethodHandle SCIPincludeConcsolverType$handle() {
        return SCIPincludeConcsolverType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcsolverType(SCIP *scip, const char *name, double prefpriodefault, SCIP_RETCODE (*concsolvercreateinst)(SCIP *, SCIP_CONCSOLVERTYPE *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverdestroyinst)(SCIP *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverinitseeds)(SCIP_CONCSOLVER *, unsigned int), SCIP_RETCODE (*concsolverexec)(SCIP_CONCSOLVER *, double *, long long *, long long *), SCIP_RETCODE (*concsolvercopysolvdata)(SCIP_CONCSOLVER *, SCIP *), SCIP_RETCODE (*concsolverstop)(SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolversyncwrite)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int, int, int *), SCIP_RETCODE (*concsolversyncread)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int *, int *, int *), void (*concsolvertypefreedata)(SCIP_CONCSOLVERTYPEDATA **), SCIP_CONCSOLVERTYPEDATA *data)
     * }
     */
    public static MemorySegment SCIPincludeConcsolverType$address() {
        return SCIPincludeConcsolverType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcsolverType(SCIP *scip, const char *name, double prefpriodefault, SCIP_RETCODE (*concsolvercreateinst)(SCIP *, SCIP_CONCSOLVERTYPE *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverdestroyinst)(SCIP *, SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolverinitseeds)(SCIP_CONCSOLVER *, unsigned int), SCIP_RETCODE (*concsolverexec)(SCIP_CONCSOLVER *, double *, long long *, long long *), SCIP_RETCODE (*concsolvercopysolvdata)(SCIP_CONCSOLVER *, SCIP *), SCIP_RETCODE (*concsolverstop)(SCIP_CONCSOLVER *), SCIP_RETCODE (*concsolversyncwrite)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int, int, int *), SCIP_RETCODE (*concsolversyncread)(SCIP_CONCSOLVER *, SCIP_SYNCSTORE *, SCIP_SYNCDATA *, int *, int *, int *), void (*concsolvertypefreedata)(SCIP_CONCSOLVERTYPEDATA **), SCIP_CONCSOLVERTYPEDATA *data)
     * }
     */
    public static int SCIPincludeConcsolverType(MemorySegment scip, MemorySegment name, double prefpriodefault, MemorySegment concsolvercreateinst, MemorySegment concsolverdestroyinst, MemorySegment concsolverinitseeds, MemorySegment concsolverexec, MemorySegment concsolvercopysolvdata, MemorySegment concsolverstop, MemorySegment concsolversyncwrite, MemorySegment concsolversyncread, MemorySegment concsolvertypefreedata, MemorySegment data) {
        var mh$ = SCIPincludeConcsolverType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConcsolverType", scip, name, prefpriodefault, concsolvercreateinst, concsolverdestroyinst, concsolverinitseeds, concsolverexec, concsolvercopysolvdata, concsolverstop, concsolversyncwrite, concsolversyncread, concsolvertypefreedata, data);
            }
            return (int)mh$.invokeExact(scip, name, prefpriodefault, concsolvercreateinst, concsolverdestroyinst, concsolverinitseeds, concsolverexec, concsolvercopysolvdata, concsolverstop, concsolversyncwrite, concsolversyncread, concsolvertypefreedata, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindConcsolverType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindConcsolverType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE *SCIPfindConcsolverType(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindConcsolverType$descriptor() {
        return SCIPfindConcsolverType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE *SCIPfindConcsolverType(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindConcsolverType$handle() {
        return SCIPfindConcsolverType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE *SCIPfindConcsolverType(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConcsolverType$address() {
        return SCIPfindConcsolverType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE *SCIPfindConcsolverType(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConcsolverType(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindConcsolverType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindConcsolverType", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConcsolverTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConcsolverTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE **SCIPgetConcsolverTypes(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetConcsolverTypes$descriptor() {
        return SCIPgetConcsolverTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE **SCIPgetConcsolverTypes(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetConcsolverTypes$handle() {
        return SCIPgetConcsolverTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE **SCIPgetConcsolverTypes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConcsolverTypes$address() {
        return SCIPgetConcsolverTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONCSOLVERTYPE **SCIPgetConcsolverTypes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConcsolverTypes(MemorySegment scip) {
        var mh$ = SCIPgetConcsolverTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConcsolverTypes", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConcsolverTypes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConcsolverTypes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNConcsolverTypes(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConcsolverTypes$descriptor() {
        return SCIPgetNConcsolverTypes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNConcsolverTypes(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConcsolverTypes$handle() {
        return SCIPgetNConcsolverTypes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNConcsolverTypes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConcsolverTypes$address() {
        return SCIPgetNConcsolverTypes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNConcsolverTypes(SCIP *scip)
     * }
     */
    public static int SCIPgetNConcsolverTypes(MemorySegment scip) {
        var mh$ = SCIPgetNConcsolverTypes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConcsolverTypes", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconstructSyncstore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconstructSyncstore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructSyncstore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPconstructSyncstore$descriptor() {
        return SCIPconstructSyncstore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructSyncstore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPconstructSyncstore$handle() {
        return SCIPconstructSyncstore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructSyncstore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPconstructSyncstore$address() {
        return SCIPconstructSyncstore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructSyncstore(SCIP *scip)
     * }
     */
    public static int SCIPconstructSyncstore(MemorySegment scip) {
        var mh$ = SCIPconstructSyncstore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconstructSyncstore", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeSyncstore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeSyncstore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSyncstore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPfreeSyncstore$descriptor() {
        return SCIPfreeSyncstore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSyncstore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPfreeSyncstore$handle() {
        return SCIPfreeSyncstore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSyncstore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPfreeSyncstore$address() {
        return SCIPfreeSyncstore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSyncstore(SCIP *scip)
     * }
     */
    public static int SCIPfreeSyncstore(MemorySegment scip) {
        var mh$ = SCIPfreeSyncstore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeSyncstore", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSyncstore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSyncstore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SYNCSTORE *SCIPgetSyncstore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSyncstore$descriptor() {
        return SCIPgetSyncstore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SYNCSTORE *SCIPgetSyncstore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSyncstore$handle() {
        return SCIPgetSyncstore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SYNCSTORE *SCIPgetSyncstore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSyncstore$address() {
        return SCIPgetSyncstore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SYNCSTORE *SCIPgetSyncstore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSyncstore(MemorySegment scip) {
        var mh$ = SCIPgetSyncstore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSyncstore", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConflicthdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConflicthdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlr(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeConflicthdlr$descriptor() {
        return SCIPincludeConflicthdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlr(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeConflicthdlr$handle() {
        return SCIPincludeConflicthdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlr(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeConflicthdlr$address() {
        return SCIPincludeConflicthdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlr(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *), SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static int SCIPincludeConflicthdlr(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, MemorySegment conflictcopy, MemorySegment conflictfree, MemorySegment conflictinit, MemorySegment conflictexit, MemorySegment conflictinitsol, MemorySegment conflictexitsol, MemorySegment conflictexec, MemorySegment conflicthdlrdata) {
        var mh$ = SCIPincludeConflicthdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConflicthdlr", scip, name, desc, priority, conflictcopy, conflictfree, conflictinit, conflictexit, conflictinitsol, conflictexitsol, conflictexec, conflicthdlrdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, conflictcopy, conflictfree, conflictinit, conflictexit, conflictinitsol, conflictexitsol, conflictexec, conflicthdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConflicthdlrBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConflicthdlrBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlrBasic(SCIP *scip, SCIP_CONFLICTHDLR **conflicthdlrptr, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeConflicthdlrBasic$descriptor() {
        return SCIPincludeConflicthdlrBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlrBasic(SCIP *scip, SCIP_CONFLICTHDLR **conflicthdlrptr, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeConflicthdlrBasic$handle() {
        return SCIPincludeConflicthdlrBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlrBasic(SCIP *scip, SCIP_CONFLICTHDLR **conflicthdlrptr, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeConflicthdlrBasic$address() {
        return SCIPincludeConflicthdlrBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConflicthdlrBasic(SCIP *scip, SCIP_CONFLICTHDLR **conflicthdlrptr, const char *name, const char *desc, int priority, SCIP_RETCODE (*conflictexec)(SCIP *, SCIP_CONFLICTHDLR *, SCIP_NODE *, SCIP_NODE *, SCIP_BDCHGINFO **, double *, int, SCIP_CONFTYPE, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_CONFLICTHDLRDATA *conflicthdlrdata)
     * }
     */
    public static int SCIPincludeConflicthdlrBasic(MemorySegment scip, MemorySegment conflicthdlrptr, MemorySegment name, MemorySegment desc, int priority, MemorySegment conflictexec, MemorySegment conflicthdlrdata) {
        var mh$ = SCIPincludeConflicthdlrBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConflicthdlrBasic", scip, conflicthdlrptr, name, desc, priority, conflictexec, conflicthdlrdata);
            }
            return (int)mh$.invokeExact(scip, conflicthdlrptr, name, desc, priority, conflictexec, conflicthdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrCopy(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrCopy$descriptor() {
        return SCIPsetConflicthdlrCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrCopy(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrCopy$handle() {
        return SCIPsetConflicthdlrCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrCopy(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrCopy$address() {
        return SCIPsetConflicthdlrCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrCopy(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictcopy)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrCopy(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictcopy) {
        var mh$ = SCIPsetConflicthdlrCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrCopy", scip, conflicthdlr, conflictcopy);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrFree(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrFree$descriptor() {
        return SCIPsetConflicthdlrFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrFree(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrFree$handle() {
        return SCIPsetConflicthdlrFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrFree(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrFree$address() {
        return SCIPsetConflicthdlrFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrFree(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictfree)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrFree(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictfree) {
        var mh$ = SCIPsetConflicthdlrFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrFree", scip, conflicthdlr, conflictfree);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrInit$descriptor() {
        return SCIPsetConflicthdlrInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrInit$handle() {
        return SCIPsetConflicthdlrInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrInit$address() {
        return SCIPsetConflicthdlrInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrInit(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictinit) {
        var mh$ = SCIPsetConflicthdlrInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrInit", scip, conflicthdlr, conflictinit);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrExit$descriptor() {
        return SCIPsetConflicthdlrExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrExit$handle() {
        return SCIPsetConflicthdlrExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrExit$address() {
        return SCIPsetConflicthdlrExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExit(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexit)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrExit(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictexit) {
        var mh$ = SCIPsetConflicthdlrExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrExit", scip, conflicthdlr, conflictexit);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrInitsol$descriptor() {
        return SCIPsetConflicthdlrInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrInitsol$handle() {
        return SCIPsetConflicthdlrInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrInitsol$address() {
        return SCIPsetConflicthdlrInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrInitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictinitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrInitsol(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictinitsol) {
        var mh$ = SCIPsetConflicthdlrInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrInitsol", scip, conflicthdlr, conflictinitsol);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrExitsol$descriptor() {
        return SCIPsetConflicthdlrExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrExitsol$handle() {
        return SCIPsetConflicthdlrExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrExitsol$address() {
        return SCIPsetConflicthdlrExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrExitsol(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, SCIP_RETCODE (*conflictexitsol)(SCIP *, SCIP_CONFLICTHDLR *))
     * }
     */
    public static int SCIPsetConflicthdlrExitsol(MemorySegment scip, MemorySegment conflicthdlr, MemorySegment conflictexitsol) {
        var mh$ = SCIPsetConflicthdlrExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrExitsol", scip, conflicthdlr, conflictexitsol);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, conflictexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindConflicthdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindConflicthdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR *SCIPfindConflicthdlr(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindConflicthdlr$descriptor() {
        return SCIPfindConflicthdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR *SCIPfindConflicthdlr(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindConflicthdlr$handle() {
        return SCIPfindConflicthdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR *SCIPfindConflicthdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConflicthdlr$address() {
        return SCIPfindConflicthdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR *SCIPfindConflicthdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConflicthdlr(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindConflicthdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindConflicthdlr", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConflicthdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConflicthdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR **SCIPgetConflicthdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetConflicthdlrs$descriptor() {
        return SCIPgetConflicthdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR **SCIPgetConflicthdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetConflicthdlrs$handle() {
        return SCIPgetConflicthdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR **SCIPgetConflicthdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConflicthdlrs$address() {
        return SCIPgetConflicthdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONFLICTHDLR **SCIPgetConflicthdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConflicthdlrs(MemorySegment scip) {
        var mh$ = SCIPgetConflicthdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConflicthdlrs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConflicthdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConflicthdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNConflicthdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConflicthdlrs$descriptor() {
        return SCIPgetNConflicthdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNConflicthdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConflicthdlrs$handle() {
        return SCIPgetNConflicthdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNConflicthdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConflicthdlrs$address() {
        return SCIPgetNConflicthdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNConflicthdlrs(SCIP *scip)
     * }
     */
    public static int SCIPgetNConflicthdlrs(MemorySegment scip) {
        var mh$ = SCIPgetNConflicthdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConflicthdlrs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConflicthdlrPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConflicthdlrPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrPriority(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetConflicthdlrPriority$descriptor() {
        return SCIPsetConflicthdlrPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrPriority(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, int priority)
     * }
     */
    public static MethodHandle SCIPsetConflicthdlrPriority$handle() {
        return SCIPsetConflicthdlrPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrPriority(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, int priority)
     * }
     */
    public static MemorySegment SCIPsetConflicthdlrPriority$address() {
        return SCIPsetConflicthdlrPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConflicthdlrPriority(SCIP *scip, SCIP_CONFLICTHDLR *conflicthdlr, int priority)
     * }
     */
    public static int SCIPsetConflicthdlrPriority(MemorySegment scip, MemorySegment conflicthdlr, int priority) {
        var mh$ = SCIPsetConflicthdlrPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConflicthdlrPriority", scip, conflicthdlr, priority);
            }
            return (int)mh$.invokeExact(scip, conflicthdlr, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisConflictAnalysisApplicable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisConflictAnalysisApplicable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisConflictAnalysisApplicable(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisConflictAnalysisApplicable$descriptor() {
        return SCIPisConflictAnalysisApplicable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisConflictAnalysisApplicable(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisConflictAnalysisApplicable$handle() {
        return SCIPisConflictAnalysisApplicable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisConflictAnalysisApplicable(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisConflictAnalysisApplicable$address() {
        return SCIPisConflictAnalysisApplicable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisConflictAnalysisApplicable(SCIP *scip)
     * }
     */
    public static int SCIPisConflictAnalysisApplicable(MemorySegment scip) {
        var mh$ = SCIPisConflictAnalysisApplicable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisConflictAnalysisApplicable", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitConflictAnalysis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitConflictAnalysis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitConflictAnalysis(SCIP *scip, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static FunctionDescriptor SCIPinitConflictAnalysis$descriptor() {
        return SCIPinitConflictAnalysis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitConflictAnalysis(SCIP *scip, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static MethodHandle SCIPinitConflictAnalysis$handle() {
        return SCIPinitConflictAnalysis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitConflictAnalysis(SCIP *scip, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static MemorySegment SCIPinitConflictAnalysis$address() {
        return SCIPinitConflictAnalysis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitConflictAnalysis(SCIP *scip, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static int SCIPinitConflictAnalysis(MemorySegment scip, int conftype, int iscutoffinvolved) {
        var mh$ = SCIPinitConflictAnalysis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitConflictAnalysis", scip, conftype, iscutoffinvolved);
            }
            return (int)mh$.invokeExact(scip, conftype, iscutoffinvolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictLb$descriptor() {
        return SCIPaddConflictLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MethodHandle SCIPaddConflictLb$handle() {
        return SCIPaddConflictLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MemorySegment SCIPaddConflictLb$address() {
        return SCIPaddConflictLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static int SCIPaddConflictLb(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx) {
        var mh$ = SCIPaddConflictLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictLb", scip, var_, bdchgidx);
            }
            return (int)mh$.invokeExact(scip, var_, bdchgidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictRelaxedLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictRelaxedLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedlb)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictRelaxedLb$descriptor() {
        return SCIPaddConflictRelaxedLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedlb)
     * }
     */
    public static MethodHandle SCIPaddConflictRelaxedLb$handle() {
        return SCIPaddConflictRelaxedLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedlb)
     * }
     */
    public static MemorySegment SCIPaddConflictRelaxedLb$address() {
        return SCIPaddConflictRelaxedLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedLb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedlb)
     * }
     */
    public static int SCIPaddConflictRelaxedLb(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx, double relaxedlb) {
        var mh$ = SCIPaddConflictRelaxedLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictRelaxedLb", scip, var_, bdchgidx, relaxedlb);
            }
            return (int)mh$.invokeExact(scip, var_, bdchgidx, relaxedlb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictUb$descriptor() {
        return SCIPaddConflictUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MethodHandle SCIPaddConflictUb$handle() {
        return SCIPaddConflictUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MemorySegment SCIPaddConflictUb$address() {
        return SCIPaddConflictUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static int SCIPaddConflictUb(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx) {
        var mh$ = SCIPaddConflictUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictUb", scip, var_, bdchgidx);
            }
            return (int)mh$.invokeExact(scip, var_, bdchgidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictRelaxedUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictRelaxedUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedub)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictRelaxedUb$descriptor() {
        return SCIPaddConflictRelaxedUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedub)
     * }
     */
    public static MethodHandle SCIPaddConflictRelaxedUb$handle() {
        return SCIPaddConflictRelaxedUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedub)
     * }
     */
    public static MemorySegment SCIPaddConflictRelaxedUb$address() {
        return SCIPaddConflictRelaxedUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedUb(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, double relaxedub)
     * }
     */
    public static int SCIPaddConflictRelaxedUb(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx, double relaxedub) {
        var mh$ = SCIPaddConflictRelaxedUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictRelaxedUb", scip, var_, bdchgidx, relaxedub);
            }
            return (int)mh$.invokeExact(scip, var_, bdchgidx, relaxedub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictBd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictBd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictBd$descriptor() {
        return SCIPaddConflictBd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MethodHandle SCIPaddConflictBd$handle() {
        return SCIPaddConflictBd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static MemorySegment SCIPaddConflictBd$address() {
        return SCIPaddConflictBd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx)
     * }
     */
    public static int SCIPaddConflictBd(MemorySegment scip, MemorySegment var_, int boundtype, MemorySegment bdchgidx) {
        var mh$ = SCIPaddConflictBd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictBd", scip, var_, boundtype, bdchgidx);
            }
            return (int)mh$.invokeExact(scip, var_, boundtype, bdchgidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictRelaxedBd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictRelaxedBd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictRelaxedBd$descriptor() {
        return SCIPaddConflictRelaxedBd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd)
     * }
     */
    public static MethodHandle SCIPaddConflictRelaxedBd$handle() {
        return SCIPaddConflictRelaxedBd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd)
     * }
     */
    public static MemorySegment SCIPaddConflictRelaxedBd$address() {
        return SCIPaddConflictRelaxedBd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictRelaxedBd(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd)
     * }
     */
    public static int SCIPaddConflictRelaxedBd(MemorySegment scip, MemorySegment var_, int boundtype, MemorySegment bdchgidx, double relaxedbd) {
        var mh$ = SCIPaddConflictRelaxedBd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictRelaxedBd", scip, var_, boundtype, bdchgidx, relaxedbd);
            }
            return (int)mh$.invokeExact(scip, var_, boundtype, bdchgidx, relaxedbd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflictBinvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflictBinvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBinvar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPaddConflictBinvar$descriptor() {
        return SCIPaddConflictBinvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBinvar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPaddConflictBinvar$handle() {
        return SCIPaddConflictBinvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBinvar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPaddConflictBinvar$address() {
        return SCIPaddConflictBinvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflictBinvar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPaddConflictBinvar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPaddConflictBinvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflictBinvar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisConflictVarUsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisConflictVarUsed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisConflictVarUsed(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int *used)
     * }
     */
    public static FunctionDescriptor SCIPisConflictVarUsed$descriptor() {
        return SCIPisConflictVarUsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisConflictVarUsed(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int *used)
     * }
     */
    public static MethodHandle SCIPisConflictVarUsed$handle() {
        return SCIPisConflictVarUsed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisConflictVarUsed(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int *used)
     * }
     */
    public static MemorySegment SCIPisConflictVarUsed$address() {
        return SCIPisConflictVarUsed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisConflictVarUsed(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int *used)
     * }
     */
    public static int SCIPisConflictVarUsed(MemorySegment scip, MemorySegment var_, int boundtype, MemorySegment bdchgidx, MemorySegment used) {
        var mh$ = SCIPisConflictVarUsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisConflictVarUsed", scip, var_, boundtype, bdchgidx, used);
            }
            return (int)mh$.invokeExact(scip, var_, boundtype, bdchgidx, used);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConflictVarLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConflictVarLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarLb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetConflictVarLb$descriptor() {
        return SCIPgetConflictVarLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarLb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetConflictVarLb$handle() {
        return SCIPgetConflictVarLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarLb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetConflictVarLb$address() {
        return SCIPgetConflictVarLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetConflictVarLb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetConflictVarLb(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetConflictVarLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConflictVarLb", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConflictVarUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConflictVarUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarUb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetConflictVarUb$descriptor() {
        return SCIPgetConflictVarUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarUb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetConflictVarUb$handle() {
        return SCIPgetConflictVarUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetConflictVarUb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetConflictVarUb$address() {
        return SCIPgetConflictVarUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetConflictVarUb(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetConflictVarUb(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetConflictVarUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConflictVarUb", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPanalyzeConflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPanalyzeConflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflict(SCIP *scip, int validdepth, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPanalyzeConflict$descriptor() {
        return SCIPanalyzeConflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflict(SCIP *scip, int validdepth, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPanalyzeConflict$handle() {
        return SCIPanalyzeConflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflict(SCIP *scip, int validdepth, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPanalyzeConflict$address() {
        return SCIPanalyzeConflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflict(SCIP *scip, int validdepth, unsigned int *success)
     * }
     */
    public static int SCIPanalyzeConflict(MemorySegment scip, int validdepth, MemorySegment success) {
        var mh$ = SCIPanalyzeConflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPanalyzeConflict", scip, validdepth, success);
            }
            return (int)mh$.invokeExact(scip, validdepth, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPanalyzeConflictCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPanalyzeConflictCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflictCons(SCIP *scip, SCIP_CONS *cons, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPanalyzeConflictCons$descriptor() {
        return SCIPanalyzeConflictCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflictCons(SCIP *scip, SCIP_CONS *cons, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPanalyzeConflictCons$handle() {
        return SCIPanalyzeConflictCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflictCons(SCIP *scip, SCIP_CONS *cons, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPanalyzeConflictCons$address() {
        return SCIPanalyzeConflictCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeConflictCons(SCIP *scip, SCIP_CONS *cons, unsigned int *success)
     * }
     */
    public static int SCIPanalyzeConflictCons(MemorySegment scip, MemorySegment cons, MemorySegment success) {
        var mh$ = SCIPanalyzeConflictCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPanalyzeConflictCons", scip, cons, success);
            }
            return (int)mh$.invokeExact(scip, cons, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlr(SCIP *scip, const char *name, const char *desc, int sepapriority, int enfopriority, int chckpriority, int sepafreq, int propfreq, int eagerfreq, int maxprerounds, unsigned int delaysepa, unsigned int delayprop, unsigned int needscons, SCIP_PROPTIMING proptiming, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *), SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int), SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **), SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **), SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *), SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *), SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *), SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *), SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlr$descriptor() {
        return SCIPincludeConshdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlr(SCIP *scip, const char *name, const char *desc, int sepapriority, int enfopriority, int chckpriority, int sepafreq, int propfreq, int eagerfreq, int maxprerounds, unsigned int delaysepa, unsigned int delayprop, unsigned int needscons, SCIP_PROPTIMING proptiming, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *), SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int), SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **), SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **), SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *), SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *), SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *), SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *), SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeConshdlr$handle() {
        return SCIPincludeConshdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlr(SCIP *scip, const char *name, const char *desc, int sepapriority, int enfopriority, int chckpriority, int sepafreq, int propfreq, int eagerfreq, int maxprerounds, unsigned int delaysepa, unsigned int delayprop, unsigned int needscons, SCIP_PROPTIMING proptiming, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *), SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int), SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **), SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **), SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *), SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *), SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *), SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *), SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeConshdlr$address() {
        return SCIPincludeConshdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlr(SCIP *scip, const char *name, const char *desc, int sepapriority, int enfopriority, int chckpriority, int sepafreq, int propfreq, int eagerfreq, int maxprerounds, unsigned int delaysepa, unsigned int delayprop, unsigned int needscons, SCIP_PROPTIMING proptiming, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *), SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int), SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **), SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **), SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *), SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *), SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int), SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *), SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *), SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *), SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static int SCIPincludeConshdlr(MemorySegment scip, MemorySegment name, MemorySegment desc, int sepapriority, int enfopriority, int chckpriority, int sepafreq, int propfreq, int eagerfreq, int maxprerounds, int delaysepa, int delayprop, int needscons, int proptiming, int presoltiming, MemorySegment conshdlrcopy, MemorySegment consfree, MemorySegment consinit, MemorySegment consexit, MemorySegment consinitpre, MemorySegment consexitpre, MemorySegment consinitsol, MemorySegment consexitsol, MemorySegment consdelete, MemorySegment constrans, MemorySegment consinitlp, MemorySegment conssepalp, MemorySegment conssepasol, MemorySegment consenfolp, MemorySegment consenforelax, MemorySegment consenfops, MemorySegment conscheck, MemorySegment consprop, MemorySegment conspresol, MemorySegment consresprop, MemorySegment conslock, MemorySegment consactive, MemorySegment consdeactive, MemorySegment consenable, MemorySegment consdisable, MemorySegment consdelvars, MemorySegment consprint, MemorySegment conscopy, MemorySegment consparse, MemorySegment consgetvars, MemorySegment consgetnvars, MemorySegment consgetdivebdchgs, MemorySegment consgetpermsymgraph, MemorySegment consgetsignedpermsymgraph, MemorySegment conshdlrdata) {
        var mh$ = SCIPincludeConshdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlr", scip, name, desc, sepapriority, enfopriority, chckpriority, sepafreq, propfreq, eagerfreq, maxprerounds, delaysepa, delayprop, needscons, proptiming, presoltiming, conshdlrcopy, consfree, consinit, consexit, consinitpre, consexitpre, consinitsol, consexitsol, consdelete, constrans, consinitlp, conssepalp, conssepasol, consenfolp, consenforelax, consenfops, conscheck, consprop, conspresol, consresprop, conslock, consactive, consdeactive, consenable, consdisable, consdelvars, consprint, conscopy, consparse, consgetvars, consgetnvars, consgetdivebdchgs, consgetpermsymgraph, consgetsignedpermsymgraph, conshdlrdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, sepapriority, enfopriority, chckpriority, sepafreq, propfreq, eagerfreq, maxprerounds, delaysepa, delayprop, needscons, proptiming, presoltiming, conshdlrcopy, consfree, consinit, consexit, consinitpre, consexitpre, consinitsol, consexitsol, consdelete, constrans, consinitlp, conssepalp, conssepasol, consenfolp, consenforelax, consenfops, conscheck, consprop, conspresol, consresprop, conslock, consactive, consdeactive, consenable, consdisable, consdelvars, consprint, conscopy, consparse, consgetvars, consgetnvars, consgetdivebdchgs, consgetpermsymgraph, consgetsignedpermsymgraph, conshdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBasic(SCIP *scip, SCIP_CONSHDLR **conshdlrptr, const char *name, const char *desc, int enfopriority, int chckpriority, int eagerfreq, unsigned int needscons, SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrBasic$descriptor() {
        return SCIPincludeConshdlrBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBasic(SCIP *scip, SCIP_CONSHDLR **conshdlrptr, const char *name, const char *desc, int enfopriority, int chckpriority, int eagerfreq, unsigned int needscons, SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrBasic$handle() {
        return SCIPincludeConshdlrBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBasic(SCIP *scip, SCIP_CONSHDLR **conshdlrptr, const char *name, const char *desc, int enfopriority, int chckpriority, int eagerfreq, unsigned int needscons, SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrBasic$address() {
        return SCIPincludeConshdlrBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBasic(SCIP *scip, SCIP_CONSHDLR **conshdlrptr, const char *name, const char *desc, int enfopriority, int chckpriority, int eagerfreq, unsigned int needscons, SCIP_RETCODE (*consenfolp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*consenfops)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conscheck)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, SCIP_SOL *, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*conslock)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_LOCKTYPE, int, int), SCIP_CONSHDLRDATA *conshdlrdata)
     * }
     */
    public static int SCIPincludeConshdlrBasic(MemorySegment scip, MemorySegment conshdlrptr, MemorySegment name, MemorySegment desc, int enfopriority, int chckpriority, int eagerfreq, int needscons, MemorySegment consenfolp, MemorySegment consenfops, MemorySegment conscheck, MemorySegment conslock, MemorySegment conshdlrdata) {
        var mh$ = SCIPincludeConshdlrBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrBasic", scip, conshdlrptr, name, desc, enfopriority, chckpriority, eagerfreq, needscons, consenfolp, consenfops, conscheck, conslock, conshdlrdata);
            }
            return (int)mh$.invokeExact(scip, conshdlrptr, name, desc, enfopriority, chckpriority, eagerfreq, needscons, consenfolp, consenfops, conscheck, conslock, conshdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrSepa(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrSepa$descriptor() {
        return SCIPsetConshdlrSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrSepa(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static MethodHandle SCIPsetConshdlrSepa$handle() {
        return SCIPsetConshdlrSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrSepa(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static MemorySegment SCIPsetConshdlrSepa$address() {
        return SCIPsetConshdlrSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrSepa(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conssepalp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_RESULT *), SCIP_RETCODE (*conssepasol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_SOL *, SCIP_RESULT *), int sepafreq, int sepapriority, unsigned int delaysepa)
     * }
     */
    public static int SCIPsetConshdlrSepa(MemorySegment scip, MemorySegment conshdlr, MemorySegment conssepalp, MemorySegment conssepasol, int sepafreq, int sepapriority, int delaysepa) {
        var mh$ = SCIPsetConshdlrSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrSepa", scip, conshdlr, conssepalp, conssepasol, sepafreq, sepapriority, delaysepa);
            }
            return (int)mh$.invokeExact(scip, conshdlr, conssepalp, conssepasol, sepafreq, sepapriority, delaysepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrProp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING proptiming)
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrProp$descriptor() {
        return SCIPsetConshdlrProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrProp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING proptiming)
     * }
     */
    public static MethodHandle SCIPsetConshdlrProp$handle() {
        return SCIPsetConshdlrProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrProp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING proptiming)
     * }
     */
    public static MemorySegment SCIPsetConshdlrProp$address() {
        return SCIPsetConshdlrProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrProp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, int, SCIP_PROPTIMING, SCIP_RESULT *), int propfreq, unsigned int delayprop, SCIP_PROPTIMING proptiming)
     * }
     */
    public static int SCIPsetConshdlrProp(MemorySegment scip, MemorySegment conshdlr, MemorySegment consprop, int propfreq, int delayprop, int proptiming) {
        var mh$ = SCIPsetConshdlrProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrProp", scip, conshdlr, consprop, propfreq, delayprop, proptiming);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consprop, propfreq, delayprop, proptiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrEnforelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrEnforelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnforelax(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrEnforelax$descriptor() {
        return SCIPsetConshdlrEnforelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnforelax(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrEnforelax$handle() {
        return SCIPsetConshdlrEnforelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnforelax(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrEnforelax$address() {
        return SCIPsetConshdlrEnforelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnforelax(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenforelax)(SCIP *, SCIP_SOL *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetConshdlrEnforelax(MemorySegment scip, MemorySegment conshdlr, MemorySegment consenforelax) {
        var mh$ = SCIPsetConshdlrEnforelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrEnforelax", scip, conshdlr, consenforelax);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consenforelax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrCopy(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrCopy$descriptor() {
        return SCIPsetConshdlrCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrCopy(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrCopy$handle() {
        return SCIPsetConshdlrCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrCopy(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrCopy$address() {
        return SCIPsetConshdlrCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrCopy(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conshdlrcopy)(SCIP *, SCIP_CONSHDLR *, unsigned int *), SCIP_RETCODE (*conscopy)(SCIP *, SCIP_CONS **, const char *, SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_HASHMAP *, SCIP_HASHMAP *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrCopy(MemorySegment scip, MemorySegment conshdlr, MemorySegment conshdlrcopy, MemorySegment conscopy) {
        var mh$ = SCIPsetConshdlrCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrCopy", scip, conshdlr, conshdlrcopy, conscopy);
            }
            return (int)mh$.invokeExact(scip, conshdlr, conshdlrcopy, conscopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrFree(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrFree$descriptor() {
        return SCIPsetConshdlrFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrFree(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrFree$handle() {
        return SCIPsetConshdlrFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrFree(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrFree$address() {
        return SCIPsetConshdlrFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrFree(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consfree)(SCIP *, SCIP_CONSHDLR *))
     * }
     */
    public static int SCIPsetConshdlrFree(MemorySegment scip, MemorySegment conshdlr, MemorySegment consfree) {
        var mh$ = SCIPsetConshdlrFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrFree", scip, conshdlr, consfree);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrInit$descriptor() {
        return SCIPsetConshdlrInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrInit$handle() {
        return SCIPsetConshdlrInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrInit$address() {
        return SCIPsetConshdlrInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrInit(MemorySegment scip, MemorySegment conshdlr, MemorySegment consinit) {
        var mh$ = SCIPsetConshdlrInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrInit", scip, conshdlr, consinit);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrExit$descriptor() {
        return SCIPsetConshdlrExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrExit$handle() {
        return SCIPsetConshdlrExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrExit$address() {
        return SCIPsetConshdlrExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExit(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexit)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrExit(MemorySegment scip, MemorySegment conshdlr, MemorySegment consexit) {
        var mh$ = SCIPsetConshdlrExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrExit", scip, conshdlr, consexit);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrInitsol$descriptor() {
        return SCIPsetConshdlrInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrInitsol$handle() {
        return SCIPsetConshdlrInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrInitsol$address() {
        return SCIPsetConshdlrInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrInitsol(MemorySegment scip, MemorySegment conshdlr, MemorySegment consinitsol) {
        var mh$ = SCIPsetConshdlrInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrInitsol", scip, conshdlr, consinitsol);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrExitsol$descriptor() {
        return SCIPsetConshdlrExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrExitsol$handle() {
        return SCIPsetConshdlrExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrExitsol$address() {
        return SCIPsetConshdlrExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitsol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitsol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int))
     * }
     */
    public static int SCIPsetConshdlrExitsol(MemorySegment scip, MemorySegment conshdlr, MemorySegment consexitsol) {
        var mh$ = SCIPsetConshdlrExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrExitsol", scip, conshdlr, consexitsol);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrInitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrInitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrInitpre$descriptor() {
        return SCIPsetConshdlrInitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrInitpre$handle() {
        return SCIPsetConshdlrInitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrInitpre$address() {
        return SCIPsetConshdlrInitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrInitpre(MemorySegment scip, MemorySegment conshdlr, MemorySegment consinitpre) {
        var mh$ = SCIPsetConshdlrInitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrInitpre", scip, conshdlr, consinitpre);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consinitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrExitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrExitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrExitpre$descriptor() {
        return SCIPsetConshdlrExitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrExitpre$handle() {
        return SCIPsetConshdlrExitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrExitpre$address() {
        return SCIPsetConshdlrExitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrExitpre(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consexitpre)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrExitpre(MemorySegment scip, MemorySegment conshdlr, MemorySegment consexitpre) {
        var mh$ = SCIPsetConshdlrExitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrExitpre", scip, conshdlr, consexitpre);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consexitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrPresol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrPresol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPresol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int maxprerounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrPresol$descriptor() {
        return SCIPsetConshdlrPresol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPresol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int maxprerounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MethodHandle SCIPsetConshdlrPresol$handle() {
        return SCIPsetConshdlrPresol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPresol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int maxprerounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MemorySegment SCIPsetConshdlrPresol$address() {
        return SCIPsetConshdlrPresol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPresol(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*conspresol)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int maxprerounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static int SCIPsetConshdlrPresol(MemorySegment scip, MemorySegment conshdlr, MemorySegment conspresol, int maxprerounds, int presoltiming) {
        var mh$ = SCIPsetConshdlrPresol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrPresol", scip, conshdlr, conspresol, maxprerounds, presoltiming);
            }
            return (int)mh$.invokeExact(scip, conshdlr, conspresol, maxprerounds, presoltiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrDelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrDelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelete(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrDelete$descriptor() {
        return SCIPsetConshdlrDelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelete(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **))
     * }
     */
    public static MethodHandle SCIPsetConshdlrDelete$handle() {
        return SCIPsetConshdlrDelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelete(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **))
     * }
     */
    public static MemorySegment SCIPsetConshdlrDelete$address() {
        return SCIPsetConshdlrDelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelete(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelete)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONSDATA **))
     * }
     */
    public static int SCIPsetConshdlrDelete(MemorySegment scip, MemorySegment conshdlr, MemorySegment consdelete) {
        var mh$ = SCIPsetConshdlrDelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrDelete", scip, conshdlr, consdelete);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consdelete);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrTrans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrTrans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrTrans(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrTrans$descriptor() {
        return SCIPsetConshdlrTrans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrTrans(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **))
     * }
     */
    public static MethodHandle SCIPsetConshdlrTrans$handle() {
        return SCIPsetConshdlrTrans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrTrans(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **))
     * }
     */
    public static MemorySegment SCIPsetConshdlrTrans$address() {
        return SCIPsetConshdlrTrans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrTrans(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*constrans)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_CONS **))
     * }
     */
    public static int SCIPsetConshdlrTrans(MemorySegment scip, MemorySegment conshdlr, MemorySegment constrans) {
        var mh$ = SCIPsetConshdlrTrans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrTrans", scip, conshdlr, constrans);
            }
            return (int)mh$.invokeExact(scip, conshdlr, constrans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrInitlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrInitlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitlp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrInitlp$descriptor() {
        return SCIPsetConshdlrInitlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitlp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrInitlp$handle() {
        return SCIPsetConshdlrInitlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitlp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrInitlp$address() {
        return SCIPsetConshdlrInitlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrInitlp(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consinitlp)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrInitlp(MemorySegment scip, MemorySegment conshdlr, MemorySegment consinitlp) {
        var mh$ = SCIPsetConshdlrInitlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrInitlp", scip, conshdlr, consinitlp);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consinitlp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrResprop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrResprop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrResprop(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrResprop$descriptor() {
        return SCIPsetConshdlrResprop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrResprop(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrResprop$handle() {
        return SCIPsetConshdlrResprop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrResprop(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrResprop$address() {
        return SCIPsetConshdlrResprop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrResprop(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consresprop)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetConshdlrResprop(MemorySegment scip, MemorySegment conshdlr, MemorySegment consresprop) {
        var mh$ = SCIPsetConshdlrResprop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrResprop", scip, conshdlr, consresprop);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consresprop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrActive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrActive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrActive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrActive$descriptor() {
        return SCIPsetConshdlrActive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrActive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrActive$handle() {
        return SCIPsetConshdlrActive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrActive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrActive$address() {
        return SCIPsetConshdlrActive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrActive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static int SCIPsetConshdlrActive(MemorySegment scip, MemorySegment conshdlr, MemorySegment consactive) {
        var mh$ = SCIPsetConshdlrActive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrActive", scip, conshdlr, consactive);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consactive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrDeactive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrDeactive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDeactive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrDeactive$descriptor() {
        return SCIPsetConshdlrDeactive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDeactive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrDeactive$handle() {
        return SCIPsetConshdlrDeactive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDeactive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrDeactive$address() {
        return SCIPsetConshdlrDeactive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDeactive(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdeactive)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static int SCIPsetConshdlrDeactive(MemorySegment scip, MemorySegment conshdlr, MemorySegment consdeactive) {
        var mh$ = SCIPsetConshdlrDeactive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrDeactive", scip, conshdlr, consdeactive);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consdeactive);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrEnable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrEnable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrEnable$descriptor() {
        return SCIPsetConshdlrEnable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrEnable$handle() {
        return SCIPsetConshdlrEnable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrEnable$address() {
        return SCIPsetConshdlrEnable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrEnable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consenable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static int SCIPsetConshdlrEnable(MemorySegment scip, MemorySegment conshdlr, MemorySegment consenable) {
        var mh$ = SCIPsetConshdlrEnable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrEnable", scip, conshdlr, consenable);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consenable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrDisable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrDisable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDisable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrDisable$descriptor() {
        return SCIPsetConshdlrDisable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDisable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrDisable$handle() {
        return SCIPsetConshdlrDisable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDisable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrDisable$address() {
        return SCIPsetConshdlrDisable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDisable(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdisable)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *))
     * }
     */
    public static int SCIPsetConshdlrDisable(MemorySegment scip, MemorySegment conshdlr, MemorySegment consdisable) {
        var mh$ = SCIPsetConshdlrDisable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrDisable", scip, conshdlr, consdisable);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consdisable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrDelvars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrDelvars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelvars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrDelvars$descriptor() {
        return SCIPsetConshdlrDelvars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelvars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MethodHandle SCIPsetConshdlrDelvars$handle() {
        return SCIPsetConshdlrDelvars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelvars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static MemorySegment SCIPsetConshdlrDelvars$address() {
        return SCIPsetConshdlrDelvars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrDelvars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consdelvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, int))
     * }
     */
    public static int SCIPsetConshdlrDelvars(MemorySegment scip, MemorySegment conshdlr, MemorySegment consdelvars) {
        var mh$ = SCIPsetConshdlrDelvars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrDelvars", scip, conshdlr, consdelvars);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consdelvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrPrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrPrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPrint(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrPrint$descriptor() {
        return SCIPsetConshdlrPrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPrint(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrPrint$handle() {
        return SCIPsetConshdlrPrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPrint(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrPrint$address() {
        return SCIPsetConshdlrPrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrPrint(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consprint)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, FILE *))
     * }
     */
    public static int SCIPsetConshdlrPrint(MemorySegment scip, MemorySegment conshdlr, MemorySegment consprint) {
        var mh$ = SCIPsetConshdlrPrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrPrint", scip, conshdlr, consprint);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consprint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrParse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrParse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrParse(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrParse$descriptor() {
        return SCIPsetConshdlrParse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrParse(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrParse$handle() {
        return SCIPsetConshdlrParse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrParse(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrParse$address() {
        return SCIPsetConshdlrParse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrParse(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consparse)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS **, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrParse(MemorySegment scip, MemorySegment conshdlr, MemorySegment consparse) {
        var mh$ = SCIPsetConshdlrParse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrParse", scip, conshdlr, consparse);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consparse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrGetVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrGetVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrGetVars$descriptor() {
        return SCIPsetConshdlrGetVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrGetVars$handle() {
        return SCIPsetConshdlrGetVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrGetVars$address() {
        return SCIPsetConshdlrGetVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_VAR **, int, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrGetVars(MemorySegment scip, MemorySegment conshdlr, MemorySegment consgetvars) {
        var mh$ = SCIPsetConshdlrGetVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrGetVars", scip, conshdlr, consgetvars);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consgetvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrGetNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrGetNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetNVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrGetNVars$descriptor() {
        return SCIPsetConshdlrGetNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetNVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrGetNVars$handle() {
        return SCIPsetConshdlrGetNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetNVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrGetNVars$address() {
        return SCIPsetConshdlrGetNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetNVars(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetnvars)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, int *, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrGetNVars(MemorySegment scip, MemorySegment conshdlr, MemorySegment consgetnvars) {
        var mh$ = SCIPsetConshdlrGetNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrGetNVars", scip, conshdlr, consgetnvars);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consgetnvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrGetDiveBdChgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrGetDiveBdChgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetDiveBdChgs(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrGetDiveBdChgs$descriptor() {
        return SCIPsetConshdlrGetDiveBdChgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetDiveBdChgs(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrGetDiveBdChgs$handle() {
        return SCIPsetConshdlrGetDiveBdChgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetDiveBdChgs(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrGetDiveBdChgs$address() {
        return SCIPsetConshdlrGetDiveBdChgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetDiveBdChgs(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetdivebdchgs)(SCIP *, SCIP_CONSHDLR *, SCIP_DIVESET *, SCIP_SOL *, unsigned int *, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrGetDiveBdChgs(MemorySegment scip, MemorySegment conshdlr, MemorySegment consgetdivebdchgs) {
        var mh$ = SCIPsetConshdlrGetDiveBdChgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrGetDiveBdChgs", scip, conshdlr, consgetdivebdchgs);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consgetdivebdchgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrGetPermsymGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrGetPermsymGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrGetPermsymGraph$descriptor() {
        return SCIPsetConshdlrGetPermsymGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrGetPermsymGraph$handle() {
        return SCIPsetConshdlrGetPermsymGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrGetPermsymGraph$address() {
        return SCIPsetConshdlrGetPermsymGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrGetPermsymGraph(MemorySegment scip, MemorySegment conshdlr, MemorySegment consgetpermsymgraph) {
        var mh$ = SCIPsetConshdlrGetPermsymGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrGetPermsymGraph", scip, conshdlr, consgetpermsymgraph);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consgetpermsymgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConshdlrGetSignedPermsymGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConshdlrGetSignedPermsymGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetSignedPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetConshdlrGetSignedPermsymGraph$descriptor() {
        return SCIPsetConshdlrGetSignedPermsymGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetSignedPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetConshdlrGetSignedPermsymGraph$handle() {
        return SCIPsetConshdlrGetSignedPermsymGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetSignedPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetConshdlrGetSignedPermsymGraph$address() {
        return SCIPsetConshdlrGetSignedPermsymGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConshdlrGetSignedPermsymGraph(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_RETCODE (*consgetsignedpermsymgraph)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SYM_GRAPH *, unsigned int *))
     * }
     */
    public static int SCIPsetConshdlrGetSignedPermsymGraph(MemorySegment scip, MemorySegment conshdlr, MemorySegment consgetsignedpermsymgraph) {
        var mh$ = SCIPsetConshdlrGetSignedPermsymGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConshdlrGetSignedPermsymGraph", scip, conshdlr, consgetsignedpermsymgraph);
            }
            return (int)mh$.invokeExact(scip, conshdlr, consgetsignedpermsymgraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindConshdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindConshdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPfindConshdlr(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindConshdlr$descriptor() {
        return SCIPfindConshdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPfindConshdlr(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindConshdlr$handle() {
        return SCIPfindConshdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPfindConshdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConshdlr$address() {
        return SCIPfindConshdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSHDLR *SCIPfindConshdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindConshdlr(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindConshdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindConshdlr", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConshdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConshdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR **SCIPgetConshdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetConshdlrs$descriptor() {
        return SCIPgetConshdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR **SCIPgetConshdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetConshdlrs$handle() {
        return SCIPgetConshdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSHDLR **SCIPgetConshdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConshdlrs$address() {
        return SCIPgetConshdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSHDLR **SCIPgetConshdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConshdlrs(MemorySegment scip) {
        var mh$ = SCIPgetConshdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConshdlrs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConshdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConshdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNConshdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConshdlrs$descriptor() {
        return SCIPgetNConshdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNConshdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConshdlrs$handle() {
        return SCIPgetNConshdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNConshdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConshdlrs$address() {
        return SCIPgetNConshdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNConshdlrs(SCIP *scip)
     * }
     */
    public static int SCIPgetNConshdlrs(MemorySegment scip) {
        var mh$ = SCIPgetNConshdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConshdlrs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONSHDLR *conshdlr, SCIP_CONSDATA *consdata, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateCons$descriptor() {
        return SCIPcreateCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONSHDLR *conshdlr, SCIP_CONSDATA *consdata, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateCons$handle() {
        return SCIPcreateCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONSHDLR *conshdlr, SCIP_CONSDATA *consdata, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateCons$address() {
        return SCIPcreateCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONSHDLR *conshdlr, SCIP_CONSDATA *consdata, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateCons(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment conshdlr, MemorySegment consdata, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateCons", scip, cons, name, conshdlr, consdata, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, conshdlr, consdata, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseCons(SCIP *scip, SCIP_CONS **cons, const char *str, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPparseCons$descriptor() {
        return SCIPparseCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseCons(SCIP *scip, SCIP_CONS **cons, const char *str, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPparseCons$handle() {
        return SCIPparseCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseCons(SCIP *scip, SCIP_CONS **cons, const char *str, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPparseCons$address() {
        return SCIPparseCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseCons(SCIP *scip, SCIP_CONS **cons, const char *str, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int *success)
     * }
     */
    public static int SCIPparseCons(MemorySegment scip, MemorySegment cons, MemorySegment str, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode, MemorySegment success) {
        var mh$ = SCIPparseCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseCons", scip, cons, str, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, success);
            }
            return (int)mh$.invokeExact(scip, cons, str, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPcaptureCons$descriptor() {
        return SCIPcaptureCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPcaptureCons$handle() {
        return SCIPcaptureCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPcaptureCons$address() {
        return SCIPcaptureCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPcaptureCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPcaptureCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseCons(SCIP *scip, SCIP_CONS **cons)
     * }
     */
    public static FunctionDescriptor SCIPreleaseCons$descriptor() {
        return SCIPreleaseCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseCons(SCIP *scip, SCIP_CONS **cons)
     * }
     */
    public static MethodHandle SCIPreleaseCons$handle() {
        return SCIPreleaseCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseCons(SCIP *scip, SCIP_CONS **cons)
     * }
     */
    public static MemorySegment SCIPreleaseCons$address() {
        return SCIPreleaseCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseCons(SCIP *scip, SCIP_CONS **cons)
     * }
     */
    public static int SCIPreleaseCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPreleaseCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgConsName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgConsName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgConsName(SCIP *scip, SCIP_CONS *cons, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPchgConsName$descriptor() {
        return SCIPchgConsName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgConsName(SCIP *scip, SCIP_CONS *cons, const char *name)
     * }
     */
    public static MethodHandle SCIPchgConsName$handle() {
        return SCIPchgConsName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgConsName(SCIP *scip, SCIP_CONS *cons, const char *name)
     * }
     */
    public static MemorySegment SCIPchgConsName$address() {
        return SCIPchgConsName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgConsName(SCIP *scip, SCIP_CONS *cons, const char *name)
     * }
     */
    public static int SCIPchgConsName(MemorySegment scip, MemorySegment cons, MemorySegment name) {
        var mh$ = SCIPchgConsName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgConsName", scip, cons, name);
            }
            return (int)mh$.invokeExact(scip, cons, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsInitial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsInitial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsInitial(SCIP *scip, SCIP_CONS *cons, unsigned int initial)
     * }
     */
    public static FunctionDescriptor SCIPsetConsInitial$descriptor() {
        return SCIPsetConsInitial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsInitial(SCIP *scip, SCIP_CONS *cons, unsigned int initial)
     * }
     */
    public static MethodHandle SCIPsetConsInitial$handle() {
        return SCIPsetConsInitial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsInitial(SCIP *scip, SCIP_CONS *cons, unsigned int initial)
     * }
     */
    public static MemorySegment SCIPsetConsInitial$address() {
        return SCIPsetConsInitial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsInitial(SCIP *scip, SCIP_CONS *cons, unsigned int initial)
     * }
     */
    public static int SCIPsetConsInitial(MemorySegment scip, MemorySegment cons, int initial) {
        var mh$ = SCIPsetConsInitial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsInitial", scip, cons, initial);
            }
            return (int)mh$.invokeExact(scip, cons, initial);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsSeparated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsSeparated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsSeparated(SCIP *scip, SCIP_CONS *cons, unsigned int separate)
     * }
     */
    public static FunctionDescriptor SCIPsetConsSeparated$descriptor() {
        return SCIPsetConsSeparated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsSeparated(SCIP *scip, SCIP_CONS *cons, unsigned int separate)
     * }
     */
    public static MethodHandle SCIPsetConsSeparated$handle() {
        return SCIPsetConsSeparated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsSeparated(SCIP *scip, SCIP_CONS *cons, unsigned int separate)
     * }
     */
    public static MemorySegment SCIPsetConsSeparated$address() {
        return SCIPsetConsSeparated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsSeparated(SCIP *scip, SCIP_CONS *cons, unsigned int separate)
     * }
     */
    public static int SCIPsetConsSeparated(MemorySegment scip, MemorySegment cons, int separate) {
        var mh$ = SCIPsetConsSeparated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsSeparated", scip, cons, separate);
            }
            return (int)mh$.invokeExact(scip, cons, separate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsEnforced {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsEnforced");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsEnforced(SCIP *scip, SCIP_CONS *cons, unsigned int enforce)
     * }
     */
    public static FunctionDescriptor SCIPsetConsEnforced$descriptor() {
        return SCIPsetConsEnforced.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsEnforced(SCIP *scip, SCIP_CONS *cons, unsigned int enforce)
     * }
     */
    public static MethodHandle SCIPsetConsEnforced$handle() {
        return SCIPsetConsEnforced.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsEnforced(SCIP *scip, SCIP_CONS *cons, unsigned int enforce)
     * }
     */
    public static MemorySegment SCIPsetConsEnforced$address() {
        return SCIPsetConsEnforced.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsEnforced(SCIP *scip, SCIP_CONS *cons, unsigned int enforce)
     * }
     */
    public static int SCIPsetConsEnforced(MemorySegment scip, MemorySegment cons, int enforce) {
        var mh$ = SCIPsetConsEnforced.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsEnforced", scip, cons, enforce);
            }
            return (int)mh$.invokeExact(scip, cons, enforce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsChecked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsChecked(SCIP *scip, SCIP_CONS *cons, unsigned int check)
     * }
     */
    public static FunctionDescriptor SCIPsetConsChecked$descriptor() {
        return SCIPsetConsChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsChecked(SCIP *scip, SCIP_CONS *cons, unsigned int check)
     * }
     */
    public static MethodHandle SCIPsetConsChecked$handle() {
        return SCIPsetConsChecked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsChecked(SCIP *scip, SCIP_CONS *cons, unsigned int check)
     * }
     */
    public static MemorySegment SCIPsetConsChecked$address() {
        return SCIPsetConsChecked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsChecked(SCIP *scip, SCIP_CONS *cons, unsigned int check)
     * }
     */
    public static int SCIPsetConsChecked(MemorySegment scip, MemorySegment cons, int check) {
        var mh$ = SCIPsetConsChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsChecked", scip, cons, check);
            }
            return (int)mh$.invokeExact(scip, cons, check);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsPropagated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsPropagated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsPropagated(SCIP *scip, SCIP_CONS *cons, unsigned int propagate)
     * }
     */
    public static FunctionDescriptor SCIPsetConsPropagated$descriptor() {
        return SCIPsetConsPropagated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsPropagated(SCIP *scip, SCIP_CONS *cons, unsigned int propagate)
     * }
     */
    public static MethodHandle SCIPsetConsPropagated$handle() {
        return SCIPsetConsPropagated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsPropagated(SCIP *scip, SCIP_CONS *cons, unsigned int propagate)
     * }
     */
    public static MemorySegment SCIPsetConsPropagated$address() {
        return SCIPsetConsPropagated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsPropagated(SCIP *scip, SCIP_CONS *cons, unsigned int propagate)
     * }
     */
    public static int SCIPsetConsPropagated(MemorySegment scip, MemorySegment cons, int propagate) {
        var mh$ = SCIPsetConsPropagated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsPropagated", scip, cons, propagate);
            }
            return (int)mh$.invokeExact(scip, cons, propagate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsLocal(SCIP *scip, SCIP_CONS *cons, unsigned int local)
     * }
     */
    public static FunctionDescriptor SCIPsetConsLocal$descriptor() {
        return SCIPsetConsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsLocal(SCIP *scip, SCIP_CONS *cons, unsigned int local)
     * }
     */
    public static MethodHandle SCIPsetConsLocal$handle() {
        return SCIPsetConsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsLocal(SCIP *scip, SCIP_CONS *cons, unsigned int local)
     * }
     */
    public static MemorySegment SCIPsetConsLocal$address() {
        return SCIPsetConsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsLocal(SCIP *scip, SCIP_CONS *cons, unsigned int local)
     * }
     */
    public static int SCIPsetConsLocal(MemorySegment scip, MemorySegment cons, int local) {
        var mh$ = SCIPsetConsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsLocal", scip, cons, local);
            }
            return (int)mh$.invokeExact(scip, cons, local);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsModifiable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsModifiable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsModifiable(SCIP *scip, SCIP_CONS *cons, unsigned int modifiable)
     * }
     */
    public static FunctionDescriptor SCIPsetConsModifiable$descriptor() {
        return SCIPsetConsModifiable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsModifiable(SCIP *scip, SCIP_CONS *cons, unsigned int modifiable)
     * }
     */
    public static MethodHandle SCIPsetConsModifiable$handle() {
        return SCIPsetConsModifiable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsModifiable(SCIP *scip, SCIP_CONS *cons, unsigned int modifiable)
     * }
     */
    public static MemorySegment SCIPsetConsModifiable$address() {
        return SCIPsetConsModifiable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsModifiable(SCIP *scip, SCIP_CONS *cons, unsigned int modifiable)
     * }
     */
    public static int SCIPsetConsModifiable(MemorySegment scip, MemorySegment cons, int modifiable) {
        var mh$ = SCIPsetConsModifiable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsModifiable", scip, cons, modifiable);
            }
            return (int)mh$.invokeExact(scip, cons, modifiable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsDynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsDynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsDynamic(SCIP *scip, SCIP_CONS *cons, unsigned int dynamic)
     * }
     */
    public static FunctionDescriptor SCIPsetConsDynamic$descriptor() {
        return SCIPsetConsDynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsDynamic(SCIP *scip, SCIP_CONS *cons, unsigned int dynamic)
     * }
     */
    public static MethodHandle SCIPsetConsDynamic$handle() {
        return SCIPsetConsDynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsDynamic(SCIP *scip, SCIP_CONS *cons, unsigned int dynamic)
     * }
     */
    public static MemorySegment SCIPsetConsDynamic$address() {
        return SCIPsetConsDynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsDynamic(SCIP *scip, SCIP_CONS *cons, unsigned int dynamic)
     * }
     */
    public static int SCIPsetConsDynamic(MemorySegment scip, MemorySegment cons, int dynamic) {
        var mh$ = SCIPsetConsDynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsDynamic", scip, cons, dynamic);
            }
            return (int)mh$.invokeExact(scip, cons, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsRemovable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsRemovable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsRemovable(SCIP *scip, SCIP_CONS *cons, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPsetConsRemovable$descriptor() {
        return SCIPsetConsRemovable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsRemovable(SCIP *scip, SCIP_CONS *cons, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPsetConsRemovable$handle() {
        return SCIPsetConsRemovable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsRemovable(SCIP *scip, SCIP_CONS *cons, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPsetConsRemovable$address() {
        return SCIPsetConsRemovable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsRemovable(SCIP *scip, SCIP_CONS *cons, unsigned int removable)
     * }
     */
    public static int SCIPsetConsRemovable(MemorySegment scip, MemorySegment cons, int removable) {
        var mh$ = SCIPsetConsRemovable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsRemovable", scip, cons, removable);
            }
            return (int)mh$.invokeExact(scip, cons, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConsStickingAtNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConsStickingAtNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsStickingAtNode(SCIP *scip, SCIP_CONS *cons, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPsetConsStickingAtNode$descriptor() {
        return SCIPsetConsStickingAtNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsStickingAtNode(SCIP *scip, SCIP_CONS *cons, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPsetConsStickingAtNode$handle() {
        return SCIPsetConsStickingAtNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsStickingAtNode(SCIP *scip, SCIP_CONS *cons, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPsetConsStickingAtNode$address() {
        return SCIPsetConsStickingAtNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetConsStickingAtNode(SCIP *scip, SCIP_CONS *cons, unsigned int stickingatnode)
     * }
     */
    public static int SCIPsetConsStickingAtNode(MemorySegment scip, MemorySegment cons, int stickingatnode) {
        var mh$ = SCIPsetConsStickingAtNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConsStickingAtNode", scip, cons, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateConsFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateConsFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateConsFlags(SCIP *scip, SCIP_CONS *cons0, SCIP_CONS *cons1)
     * }
     */
    public static FunctionDescriptor SCIPupdateConsFlags$descriptor() {
        return SCIPupdateConsFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateConsFlags(SCIP *scip, SCIP_CONS *cons0, SCIP_CONS *cons1)
     * }
     */
    public static MethodHandle SCIPupdateConsFlags$handle() {
        return SCIPupdateConsFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateConsFlags(SCIP *scip, SCIP_CONS *cons0, SCIP_CONS *cons1)
     * }
     */
    public static MemorySegment SCIPupdateConsFlags$address() {
        return SCIPupdateConsFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateConsFlags(SCIP *scip, SCIP_CONS *cons0, SCIP_CONS *cons1)
     * }
     */
    public static int SCIPupdateConsFlags(MemorySegment scip, MemorySegment cons0, MemorySegment cons1) {
        var mh$ = SCIPupdateConsFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateConsFlags", scip, cons0, cons1);
            }
            return (int)mh$.invokeExact(scip, cons0, cons1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static FunctionDescriptor SCIPtransformCons$descriptor() {
        return SCIPtransformCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static MethodHandle SCIPtransformCons$handle() {
        return SCIPtransformCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static MemorySegment SCIPtransformCons$address() {
        return SCIPtransformCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static int SCIPtransformCons(MemorySegment scip, MemorySegment cons, MemorySegment transcons) {
        var mh$ = SCIPtransformCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformCons", scip, cons, transcons);
            }
            return (int)mh$.invokeExact(scip, cons, transcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static FunctionDescriptor SCIPtransformConss$descriptor() {
        return SCIPtransformConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static MethodHandle SCIPtransformConss$handle() {
        return SCIPtransformConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static MemorySegment SCIPtransformConss$address() {
        return SCIPtransformConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static int SCIPtransformConss(MemorySegment scip, int nconss, MemorySegment conss, MemorySegment transconss) {
        var mh$ = SCIPtransformConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformConss", scip, nconss, conss, transconss);
            }
            return (int)mh$.invokeExact(scip, nconss, conss, transconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransformedCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransformedCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static FunctionDescriptor SCIPgetTransformedCons$descriptor() {
        return SCIPgetTransformedCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static MethodHandle SCIPgetTransformedCons$handle() {
        return SCIPgetTransformedCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static MemorySegment SCIPgetTransformedCons$address() {
        return SCIPgetTransformedCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedCons(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **transcons)
     * }
     */
    public static int SCIPgetTransformedCons(MemorySegment scip, MemorySegment cons, MemorySegment transcons) {
        var mh$ = SCIPgetTransformedCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransformedCons", scip, cons, transcons);
            }
            return (int)mh$.invokeExact(scip, cons, transcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransformedConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransformedConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static FunctionDescriptor SCIPgetTransformedConss$descriptor() {
        return SCIPgetTransformedConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static MethodHandle SCIPgetTransformedConss$handle() {
        return SCIPgetTransformedConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static MemorySegment SCIPgetTransformedConss$address() {
        return SCIPgetTransformedConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedConss(SCIP *scip, int nconss, SCIP_CONS **conss, SCIP_CONS **transconss)
     * }
     */
    public static int SCIPgetTransformedConss(MemorySegment scip, int nconss, MemorySegment conss, MemorySegment transconss) {
        var mh$ = SCIPgetTransformedConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransformedConss", scip, nconss, conss, transconss);
            }
            return (int)mh$.invokeExact(scip, nconss, conss, transconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsAge(SCIP *scip, SCIP_CONS *cons, double deltaage)
     * }
     */
    public static FunctionDescriptor SCIPaddConsAge$descriptor() {
        return SCIPaddConsAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsAge(SCIP *scip, SCIP_CONS *cons, double deltaage)
     * }
     */
    public static MethodHandle SCIPaddConsAge$handle() {
        return SCIPaddConsAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsAge(SCIP *scip, SCIP_CONS *cons, double deltaage)
     * }
     */
    public static MemorySegment SCIPaddConsAge$address() {
        return SCIPaddConsAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsAge(SCIP *scip, SCIP_CONS *cons, double deltaage)
     * }
     */
    public static int SCIPaddConsAge(MemorySegment scip, MemorySegment cons, double deltaage) {
        var mh$ = SCIPaddConsAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsAge", scip, cons, deltaage);
            }
            return (int)mh$.invokeExact(scip, cons, deltaage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincConsAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincConsAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPincConsAge$descriptor() {
        return SCIPincConsAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPincConsAge$handle() {
        return SCIPincConsAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPincConsAge$address() {
        return SCIPincConsAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPincConsAge(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPincConsAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincConsAge", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetConsAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetConsAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPresetConsAge$descriptor() {
        return SCIPresetConsAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPresetConsAge$handle() {
        return SCIPresetConsAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPresetConsAge$address() {
        return SCIPresetConsAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetConsAge(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPresetConsAge(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPresetConsAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetConsAge", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPenableCons$descriptor() {
        return SCIPenableCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPenableCons$handle() {
        return SCIPenableCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPenableCons$address() {
        return SCIPenableCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPenableCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPenableCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisableCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisableCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdisableCons$descriptor() {
        return SCIPdisableCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdisableCons$handle() {
        return SCIPdisableCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdisableCons$address() {
        return SCIPdisableCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdisableCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdisableCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisableCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableConsSeparation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableConsSeparation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPenableConsSeparation$descriptor() {
        return SCIPenableConsSeparation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPenableConsSeparation$handle() {
        return SCIPenableConsSeparation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPenableConsSeparation$address() {
        return SCIPenableConsSeparation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPenableConsSeparation(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPenableConsSeparation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableConsSeparation", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisableConsSeparation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisableConsSeparation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdisableConsSeparation$descriptor() {
        return SCIPdisableConsSeparation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdisableConsSeparation$handle() {
        return SCIPdisableConsSeparation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdisableConsSeparation$address() {
        return SCIPdisableConsSeparation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsSeparation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdisableConsSeparation(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdisableConsSeparation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisableConsSeparation", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableConsPropagation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableConsPropagation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPenableConsPropagation$descriptor() {
        return SCIPenableConsPropagation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPenableConsPropagation$handle() {
        return SCIPenableConsPropagation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPenableConsPropagation$address() {
        return SCIPenableConsPropagation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPenableConsPropagation(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPenableConsPropagation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableConsPropagation", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisableConsPropagation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisableConsPropagation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdisableConsPropagation$descriptor() {
        return SCIPdisableConsPropagation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdisableConsPropagation$handle() {
        return SCIPdisableConsPropagation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdisableConsPropagation$address() {
        return SCIPdisableConsPropagation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdisableConsPropagation(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdisableConsPropagation(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdisableConsPropagation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisableConsPropagation", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkConsPropagate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkConsPropagate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPmarkConsPropagate$descriptor() {
        return SCIPmarkConsPropagate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPmarkConsPropagate$handle() {
        return SCIPmarkConsPropagate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPmarkConsPropagate$address() {
        return SCIPmarkConsPropagate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPmarkConsPropagate(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPmarkConsPropagate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkConsPropagate", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPunmarkConsPropagate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPunmarkConsPropagate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPunmarkConsPropagate$descriptor() {
        return SCIPunmarkConsPropagate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPunmarkConsPropagate$handle() {
        return SCIPunmarkConsPropagate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPunmarkConsPropagate$address() {
        return SCIPunmarkConsPropagate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunmarkConsPropagate(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPunmarkConsPropagate(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPunmarkConsPropagate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPunmarkConsPropagate", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsLocksType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsLocksType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocksType(SCIP *scip, SCIP_CONS *cons, SCIP_LOCKTYPE locktype, int nlockspos, int nlocksneg)
     * }
     */
    public static FunctionDescriptor SCIPaddConsLocksType$descriptor() {
        return SCIPaddConsLocksType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocksType(SCIP *scip, SCIP_CONS *cons, SCIP_LOCKTYPE locktype, int nlockspos, int nlocksneg)
     * }
     */
    public static MethodHandle SCIPaddConsLocksType$handle() {
        return SCIPaddConsLocksType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocksType(SCIP *scip, SCIP_CONS *cons, SCIP_LOCKTYPE locktype, int nlockspos, int nlocksneg)
     * }
     */
    public static MemorySegment SCIPaddConsLocksType$address() {
        return SCIPaddConsLocksType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocksType(SCIP *scip, SCIP_CONS *cons, SCIP_LOCKTYPE locktype, int nlockspos, int nlocksneg)
     * }
     */
    public static int SCIPaddConsLocksType(MemorySegment scip, MemorySegment cons, int locktype, int nlockspos, int nlocksneg) {
        var mh$ = SCIPaddConsLocksType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsLocksType", scip, cons, locktype, nlockspos, nlocksneg);
            }
            return (int)mh$.invokeExact(scip, cons, locktype, nlockspos, nlocksneg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsLocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsLocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocks(SCIP *scip, SCIP_CONS *cons, int nlockspos, int nlocksneg)
     * }
     */
    public static FunctionDescriptor SCIPaddConsLocks$descriptor() {
        return SCIPaddConsLocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocks(SCIP *scip, SCIP_CONS *cons, int nlockspos, int nlocksneg)
     * }
     */
    public static MethodHandle SCIPaddConsLocks$handle() {
        return SCIPaddConsLocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocks(SCIP *scip, SCIP_CONS *cons, int nlockspos, int nlocksneg)
     * }
     */
    public static MemorySegment SCIPaddConsLocks$address() {
        return SCIPaddConsLocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocks(SCIP *scip, SCIP_CONS *cons, int nlockspos, int nlocksneg)
     * }
     */
    public static int SCIPaddConsLocks(MemorySegment scip, MemorySegment cons, int nlockspos, int nlocksneg) {
        var mh$ = SCIPaddConsLocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsLocks", scip, cons, nlockspos, nlocksneg);
            }
            return (int)mh$.invokeExact(scip, cons, nlockspos, nlocksneg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int checkintegrality, unsigned int checklprows, unsigned int printreason, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPcheckCons$descriptor() {
        return SCIPcheckCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int checkintegrality, unsigned int checklprows, unsigned int printreason, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPcheckCons$handle() {
        return SCIPcheckCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int checkintegrality, unsigned int checklprows, unsigned int printreason, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPcheckCons$address() {
        return SCIPcheckCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int checkintegrality, unsigned int checklprows, unsigned int printreason, SCIP_RESULT *result)
     * }
     */
    public static int SCIPcheckCons(MemorySegment scip, MemorySegment cons, MemorySegment sol, int checkintegrality, int checklprows, int printreason, MemorySegment result) {
        var mh$ = SCIPcheckCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckCons", scip, cons, sol, checkintegrality, checklprows, printreason, result);
            }
            return (int)mh$.invokeExact(scip, cons, sol, checkintegrality, checklprows, printreason, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenfopsCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenfopsCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfopsCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, unsigned int objinfeasible, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPenfopsCons$descriptor() {
        return SCIPenfopsCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfopsCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, unsigned int objinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPenfopsCons$handle() {
        return SCIPenfopsCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfopsCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, unsigned int objinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPenfopsCons$address() {
        return SCIPenfopsCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfopsCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, unsigned int objinfeasible, SCIP_RESULT *result)
     * }
     */
    public static int SCIPenfopsCons(MemorySegment scip, MemorySegment cons, int solinfeasible, int objinfeasible, MemorySegment result) {
        var mh$ = SCIPenfopsCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenfopsCons", scip, cons, solinfeasible, objinfeasible, result);
            }
            return (int)mh$.invokeExact(scip, cons, solinfeasible, objinfeasible, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenfolpCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenfolpCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfolpCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPenfolpCons$descriptor() {
        return SCIPenfolpCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfolpCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPenfolpCons$handle() {
        return SCIPenfolpCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfolpCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPenfolpCons$address() {
        return SCIPenfolpCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenfolpCons(SCIP *scip, SCIP_CONS *cons, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static int SCIPenfolpCons(MemorySegment scip, MemorySegment cons, int solinfeasible, MemorySegment result) {
        var mh$ = SCIPenfolpCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenfolpCons", scip, cons, solinfeasible, result);
            }
            return (int)mh$.invokeExact(scip, cons, solinfeasible, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenforelaxCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenforelaxCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenforelaxCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPenforelaxCons$descriptor() {
        return SCIPenforelaxCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenforelaxCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPenforelaxCons$handle() {
        return SCIPenforelaxCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenforelaxCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPenforelaxCons$address() {
        return SCIPenforelaxCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenforelaxCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int solinfeasible, SCIP_RESULT *result)
     * }
     */
    public static int SCIPenforelaxCons(MemorySegment scip, MemorySegment cons, MemorySegment sol, int solinfeasible, MemorySegment result) {
        var mh$ = SCIPenforelaxCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenforelaxCons", scip, cons, sol, solinfeasible, result);
            }
            return (int)mh$.invokeExact(scip, cons, sol, solinfeasible, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitlpCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitlpCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitlpCons(SCIP *scip, SCIP_CONS *cons, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPinitlpCons$descriptor() {
        return SCIPinitlpCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitlpCons(SCIP *scip, SCIP_CONS *cons, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPinitlpCons$handle() {
        return SCIPinitlpCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitlpCons(SCIP *scip, SCIP_CONS *cons, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPinitlpCons$address() {
        return SCIPinitlpCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitlpCons(SCIP *scip, SCIP_CONS *cons, unsigned int *infeasible)
     * }
     */
    public static int SCIPinitlpCons(MemorySegment scip, MemorySegment cons, MemorySegment infeasible) {
        var mh$ = SCIPinitlpCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitlpCons", scip, cons, infeasible);
            }
            return (int)mh$.invokeExact(scip, cons, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepalpCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepalpCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepalpCons(SCIP *scip, SCIP_CONS *cons, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPsepalpCons$descriptor() {
        return SCIPsepalpCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepalpCons(SCIP *scip, SCIP_CONS *cons, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPsepalpCons$handle() {
        return SCIPsepalpCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepalpCons(SCIP *scip, SCIP_CONS *cons, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPsepalpCons$address() {
        return SCIPsepalpCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepalpCons(SCIP *scip, SCIP_CONS *cons, SCIP_RESULT *result)
     * }
     */
    public static int SCIPsepalpCons(MemorySegment scip, MemorySegment cons, MemorySegment result) {
        var mh$ = SCIPsepalpCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepalpCons", scip, cons, result);
            }
            return (int)mh$.invokeExact(scip, cons, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsepasolCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsepasolCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepasolCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPsepasolCons$descriptor() {
        return SCIPsepasolCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepasolCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPsepasolCons$handle() {
        return SCIPsepasolCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepasolCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPsepasolCons$address() {
        return SCIPsepasolCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsepasolCons(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static int SCIPsepasolCons(MemorySegment scip, MemorySegment cons, MemorySegment sol, MemorySegment result) {
        var mh$ = SCIPsepasolCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsepasolCons", scip, cons, sol, result);
            }
            return (int)mh$.invokeExact(scip, cons, sol, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCons(SCIP *scip, SCIP_CONS *cons, SCIP_PROPTIMING proptiming, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPpropCons$descriptor() {
        return SCIPpropCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCons(SCIP *scip, SCIP_CONS *cons, SCIP_PROPTIMING proptiming, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPpropCons$handle() {
        return SCIPpropCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCons(SCIP *scip, SCIP_CONS *cons, SCIP_PROPTIMING proptiming, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPpropCons$address() {
        return SCIPpropCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCons(SCIP *scip, SCIP_CONS *cons, SCIP_PROPTIMING proptiming, SCIP_RESULT *result)
     * }
     */
    public static int SCIPpropCons(MemorySegment scip, MemorySegment cons, int proptiming, MemorySegment result) {
        var mh$ = SCIPpropCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropCons", scip, cons, proptiming, result);
            }
            return (int)mh$.invokeExact(scip, cons, proptiming, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrespropCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrespropCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCons(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPrespropCons$descriptor() {
        return SCIPrespropCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCons(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPrespropCons$handle() {
        return SCIPrespropCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCons(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPrespropCons$address() {
        return SCIPrespropCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCons(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, SCIP_RESULT *result)
     * }
     */
    public static int SCIPrespropCons(MemorySegment scip, MemorySegment cons, MemorySegment infervar, int inferinfo, int boundtype, MemorySegment bdchgidx, double relaxedbd, MemorySegment result) {
        var mh$ = SCIPrespropCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrespropCons", scip, cons, infervar, inferinfo, boundtype, bdchgidx, relaxedbd, result);
            }
            return (int)mh$.invokeExact(scip, cons, infervar, inferinfo, boundtype, bdchgidx, relaxedbd, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolCons(SCIP *scip, SCIP_CONS *cons, int nrounds, SCIP_PRESOLTIMING presoltiming, int nnewfixedvars, int nnewaggrvars, int nnewchgvartypes, int nnewchgbds, int nnewholes, int nnewdelconss, int nnewaddconss, int nnewupgdconss, int nnewchgcoefs, int nnewchgsides, int *nfixedvars, int *naggrvars, int *nchgvartypes, int *nchgbds, int *naddholes, int *ndelconss, int *naddconss, int *nupgdconss, int *nchgcoefs, int *nchgsides, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPpresolCons$descriptor() {
        return SCIPpresolCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolCons(SCIP *scip, SCIP_CONS *cons, int nrounds, SCIP_PRESOLTIMING presoltiming, int nnewfixedvars, int nnewaggrvars, int nnewchgvartypes, int nnewchgbds, int nnewholes, int nnewdelconss, int nnewaddconss, int nnewupgdconss, int nnewchgcoefs, int nnewchgsides, int *nfixedvars, int *naggrvars, int *nchgvartypes, int *nchgbds, int *naddholes, int *ndelconss, int *naddconss, int *nupgdconss, int *nchgcoefs, int *nchgsides, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPpresolCons$handle() {
        return SCIPpresolCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolCons(SCIP *scip, SCIP_CONS *cons, int nrounds, SCIP_PRESOLTIMING presoltiming, int nnewfixedvars, int nnewaggrvars, int nnewchgvartypes, int nnewchgbds, int nnewholes, int nnewdelconss, int nnewaddconss, int nnewupgdconss, int nnewchgcoefs, int nnewchgsides, int *nfixedvars, int *naggrvars, int *nchgvartypes, int *nchgbds, int *naddholes, int *ndelconss, int *naddconss, int *nupgdconss, int *nchgcoefs, int *nchgsides, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPpresolCons$address() {
        return SCIPpresolCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolCons(SCIP *scip, SCIP_CONS *cons, int nrounds, SCIP_PRESOLTIMING presoltiming, int nnewfixedvars, int nnewaggrvars, int nnewchgvartypes, int nnewchgbds, int nnewholes, int nnewdelconss, int nnewaddconss, int nnewupgdconss, int nnewchgcoefs, int nnewchgsides, int *nfixedvars, int *naggrvars, int *nchgvartypes, int *nchgbds, int *naddholes, int *ndelconss, int *naddconss, int *nupgdconss, int *nchgcoefs, int *nchgsides, SCIP_RESULT *result)
     * }
     */
    public static int SCIPpresolCons(MemorySegment scip, MemorySegment cons, int nrounds, int presoltiming, int nnewfixedvars, int nnewaggrvars, int nnewchgvartypes, int nnewchgbds, int nnewholes, int nnewdelconss, int nnewaddconss, int nnewupgdconss, int nnewchgcoefs, int nnewchgsides, MemorySegment nfixedvars, MemorySegment naggrvars, MemorySegment nchgvartypes, MemorySegment nchgbds, MemorySegment naddholes, MemorySegment ndelconss, MemorySegment naddconss, MemorySegment nupgdconss, MemorySegment nchgcoefs, MemorySegment nchgsides, MemorySegment result) {
        var mh$ = SCIPpresolCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolCons", scip, cons, nrounds, presoltiming, nnewfixedvars, nnewaggrvars, nnewchgvartypes, nnewchgbds, nnewholes, nnewdelconss, nnewaddconss, nnewupgdconss, nnewchgcoefs, nnewchgsides, nfixedvars, naggrvars, nchgvartypes, nchgbds, naddholes, ndelconss, naddconss, nupgdconss, nchgcoefs, nchgsides, result);
            }
            return (int)mh$.invokeExact(scip, cons, nrounds, presoltiming, nnewfixedvars, nnewaggrvars, nnewchgvartypes, nnewchgbds, nnewholes, nnewdelconss, nnewaddconss, nnewupgdconss, nnewchgcoefs, nnewchgsides, nfixedvars, naggrvars, nchgvartypes, nchgbds, naddholes, ndelconss, naddconss, nupgdconss, nchgcoefs, nchgsides, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPactiveCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPactiveCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPactiveCons$descriptor() {
        return SCIPactiveCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPactiveCons$handle() {
        return SCIPactiveCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPactiveCons$address() {
        return SCIPactiveCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPactiveCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPactiveCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPactiveCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeactiveCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeactiveCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdeactiveCons$descriptor() {
        return SCIPdeactiveCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdeactiveCons$handle() {
        return SCIPdeactiveCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdeactiveCons$address() {
        return SCIPdeactiveCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactiveCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdeactiveCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdeactiveCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeactiveCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintCons(SCIP *scip, SCIP_CONS *cons, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintCons$descriptor() {
        return SCIPprintCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintCons(SCIP *scip, SCIP_CONS *cons, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintCons$handle() {
        return SCIPprintCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintCons(SCIP *scip, SCIP_CONS *cons, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintCons$address() {
        return SCIPprintCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintCons(SCIP *scip, SCIP_CONS *cons, FILE *file)
     * }
     */
    public static int SCIPprintCons(MemorySegment scip, MemorySegment cons, MemorySegment file) {
        var mh$ = SCIPprintCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintCons", scip, cons, file);
            }
            return (int)mh$.invokeExact(scip, cons, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsVars(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **vars, int varssize, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPgetConsVars$descriptor() {
        return SCIPgetConsVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsVars(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **vars, int varssize, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPgetConsVars$handle() {
        return SCIPgetConsVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsVars(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **vars, int varssize, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPgetConsVars$address() {
        return SCIPgetConsVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsVars(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **vars, int varssize, unsigned int *success)
     * }
     */
    public static int SCIPgetConsVars(MemorySegment scip, MemorySegment cons, MemorySegment vars, int varssize, MemorySegment success) {
        var mh$ = SCIPgetConsVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsVars", scip, cons, vars, varssize, success);
            }
            return (int)mh$.invokeExact(scip, cons, vars, varssize, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsNVars(SCIP *scip, SCIP_CONS *cons, int *nvars, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPgetConsNVars$descriptor() {
        return SCIPgetConsNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsNVars(SCIP *scip, SCIP_CONS *cons, int *nvars, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPgetConsNVars$handle() {
        return SCIPgetConsNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsNVars(SCIP *scip, SCIP_CONS *cons, int *nvars, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPgetConsNVars$address() {
        return SCIPgetConsNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsNVars(SCIP *scip, SCIP_CONS *cons, int *nvars, unsigned int *success)
     * }
     */
    public static int SCIPgetConsNVars(MemorySegment scip, MemorySegment cons, MemorySegment nvars, MemorySegment success) {
        var mh$ = SCIPgetConsNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsNVars", scip, cons, nvars, success);
            }
            return (int)mh$.invokeExact(scip, cons, nvars, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsPermsymGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsPermsymGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPgetConsPermsymGraph$descriptor() {
        return SCIPgetConsPermsymGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPgetConsPermsymGraph$handle() {
        return SCIPgetConsPermsymGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPgetConsPermsymGraph$address() {
        return SCIPgetConsPermsymGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static int SCIPgetConsPermsymGraph(MemorySegment scip, MemorySegment cons, MemorySegment graph, MemorySegment success) {
        var mh$ = SCIPgetConsPermsymGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsPermsymGraph", scip, cons, graph, success);
            }
            return (int)mh$.invokeExact(scip, cons, graph, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsSignedPermsymGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsSignedPermsymGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsSignedPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPgetConsSignedPermsymGraph$descriptor() {
        return SCIPgetConsSignedPermsymGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsSignedPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPgetConsSignedPermsymGraph$handle() {
        return SCIPgetConsSignedPermsymGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsSignedPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPgetConsSignedPermsymGraph$address() {
        return SCIPgetConsSignedPermsymGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsSignedPermsymGraph(SCIP *scip, SCIP_CONS *cons, SYM_GRAPH *graph, unsigned int *success)
     * }
     */
    public static int SCIPgetConsSignedPermsymGraph(MemorySegment scip, MemorySegment cons, MemorySegment graph, MemorySegment success) {
        var mh$ = SCIPgetConsSignedPermsymGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsSignedPermsymGraph", scip, cons, graph, success);
            }
            return (int)mh$.invokeExact(scip, cons, graph, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyPlugins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyPlugins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyPlugins(SCIP *sourcescip, SCIP *targetscip, unsigned int copyreaders, unsigned int copypricers, unsigned int copyconshdlrs, unsigned int copyconflicthdlrs, unsigned int copypresolvers, unsigned int copyrelaxators, unsigned int copyseparators, unsigned int copycutselectors, unsigned int copypropagators, unsigned int copyheuristics, unsigned int copyeventhdlrs, unsigned int copynodeselectors, unsigned int copybranchrules, unsigned int copydisplays, unsigned int copydialogs, unsigned int copytables, unsigned int copyexprhdlrs, unsigned int copynlpis, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyPlugins$descriptor() {
        return SCIPcopyPlugins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyPlugins(SCIP *sourcescip, SCIP *targetscip, unsigned int copyreaders, unsigned int copypricers, unsigned int copyconshdlrs, unsigned int copyconflicthdlrs, unsigned int copypresolvers, unsigned int copyrelaxators, unsigned int copyseparators, unsigned int copycutselectors, unsigned int copypropagators, unsigned int copyheuristics, unsigned int copyeventhdlrs, unsigned int copynodeselectors, unsigned int copybranchrules, unsigned int copydisplays, unsigned int copydialogs, unsigned int copytables, unsigned int copyexprhdlrs, unsigned int copynlpis, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyPlugins$handle() {
        return SCIPcopyPlugins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyPlugins(SCIP *sourcescip, SCIP *targetscip, unsigned int copyreaders, unsigned int copypricers, unsigned int copyconshdlrs, unsigned int copyconflicthdlrs, unsigned int copypresolvers, unsigned int copyrelaxators, unsigned int copyseparators, unsigned int copycutselectors, unsigned int copypropagators, unsigned int copyheuristics, unsigned int copyeventhdlrs, unsigned int copynodeselectors, unsigned int copybranchrules, unsigned int copydisplays, unsigned int copydialogs, unsigned int copytables, unsigned int copyexprhdlrs, unsigned int copynlpis, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyPlugins$address() {
        return SCIPcopyPlugins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyPlugins(SCIP *sourcescip, SCIP *targetscip, unsigned int copyreaders, unsigned int copypricers, unsigned int copyconshdlrs, unsigned int copyconflicthdlrs, unsigned int copypresolvers, unsigned int copyrelaxators, unsigned int copyseparators, unsigned int copycutselectors, unsigned int copypropagators, unsigned int copyheuristics, unsigned int copyeventhdlrs, unsigned int copynodeselectors, unsigned int copybranchrules, unsigned int copydisplays, unsigned int copydialogs, unsigned int copytables, unsigned int copyexprhdlrs, unsigned int copynlpis, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static int SCIPcopyPlugins(MemorySegment sourcescip, MemorySegment targetscip, int copyreaders, int copypricers, int copyconshdlrs, int copyconflicthdlrs, int copypresolvers, int copyrelaxators, int copyseparators, int copycutselectors, int copypropagators, int copyheuristics, int copyeventhdlrs, int copynodeselectors, int copybranchrules, int copydisplays, int copydialogs, int copytables, int copyexprhdlrs, int copynlpis, int passmessagehdlr, MemorySegment valid) {
        var mh$ = SCIPcopyPlugins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyPlugins", sourcescip, targetscip, copyreaders, copypricers, copyconshdlrs, copyconflicthdlrs, copypresolvers, copyrelaxators, copyseparators, copycutselectors, copypropagators, copyheuristics, copyeventhdlrs, copynodeselectors, copybranchrules, copydisplays, copydialogs, copytables, copyexprhdlrs, copynlpis, passmessagehdlr, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, copyreaders, copypricers, copyconshdlrs, copyconflicthdlrs, copypresolvers, copyrelaxators, copyseparators, copycutselectors, copypropagators, copyheuristics, copyeventhdlrs, copynodeselectors, copybranchrules, copydisplays, copydialogs, copytables, copyexprhdlrs, copynlpis, passmessagehdlr, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyBenders(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, unsigned int threadsafe, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyBenders$descriptor() {
        return SCIPcopyBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyBenders(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, unsigned int threadsafe, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyBenders$handle() {
        return SCIPcopyBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyBenders(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, unsigned int threadsafe, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyBenders$address() {
        return SCIPcopyBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyBenders(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, unsigned int threadsafe, unsigned int *valid)
     * }
     */
    public static int SCIPcopyBenders(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, int threadsafe, MemorySegment valid) {
        var mh$ = SCIPcopyBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyBenders", sourcescip, targetscip, varmap, threadsafe, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, threadsafe, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPcopyProb$descriptor() {
        return SCIPcopyProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, const char *name)
     * }
     */
    public static MethodHandle SCIPcopyProb$handle() {
        return SCIPcopyProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, const char *name)
     * }
     */
    public static MemorySegment SCIPcopyProb$address() {
        return SCIPcopyProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, const char *name)
     * }
     */
    public static int SCIPcopyProb(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment name) {
        var mh$ = SCIPcopyProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyProb", sourcescip, targetscip, varmap, consmap, global, name);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, global, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyOrigProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyOrigProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPcopyOrigProb$descriptor() {
        return SCIPcopyOrigProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name)
     * }
     */
    public static MethodHandle SCIPcopyOrigProb$handle() {
        return SCIPcopyOrigProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name)
     * }
     */
    public static MemorySegment SCIPcopyOrigProb$address() {
        return SCIPcopyOrigProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigProb(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name)
     * }
     */
    public static int SCIPcopyOrigProb(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment name) {
        var mh$ = SCIPcopyOrigProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyOrigProb", sourcescip, targetscip, varmap, consmap, name);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableConsCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableConsCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsCompression(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPenableConsCompression$descriptor() {
        return SCIPenableConsCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsCompression(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPenableConsCompression$handle() {
        return SCIPenableConsCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsCompression(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPenableConsCompression$address() {
        return SCIPenableConsCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableConsCompression(SCIP *scip)
     * }
     */
    public static int SCIPenableConsCompression(MemorySegment scip) {
        var mh$ = SCIPenableConsCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableConsCompression", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisConsCompressionEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisConsCompressionEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisConsCompressionEnabled(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisConsCompressionEnabled$descriptor() {
        return SCIPisConsCompressionEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisConsCompressionEnabled(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisConsCompressionEnabled$handle() {
        return SCIPisConsCompressionEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisConsCompressionEnabled(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisConsCompressionEnabled$address() {
        return SCIPisConsCompressionEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisConsCompressionEnabled(SCIP *scip)
     * }
     */
    public static int SCIPisConsCompressionEnabled(MemorySegment scip) {
        var mh$ = SCIPisConsCompressionEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisConsCompressionEnabled", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR *sourcevar, SCIP_VAR **targetvar, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPgetVarCopy$descriptor() {
        return SCIPgetVarCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR *sourcevar, SCIP_VAR **targetvar, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPgetVarCopy$handle() {
        return SCIPgetVarCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR *sourcevar, SCIP_VAR **targetvar, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPgetVarCopy$address() {
        return SCIPgetVarCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR *sourcevar, SCIP_VAR **targetvar, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *success)
     * }
     */
    public static int SCIPgetVarCopy(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment sourcevar, MemorySegment targetvar, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment success) {
        var mh$ = SCIPgetVarCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarCopy", sourcescip, targetscip, sourcevar, targetvar, varmap, consmap, global, success);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, sourcevar, targetvar, varmap, consmap, global, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global)
     * }
     */
    public static FunctionDescriptor SCIPcopyVars$descriptor() {
        return SCIPcopyVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global)
     * }
     */
    public static MethodHandle SCIPcopyVars$handle() {
        return SCIPcopyVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global)
     * }
     */
    public static MemorySegment SCIPcopyVars$address() {
        return SCIPcopyVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global)
     * }
     */
    public static int SCIPcopyVars(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment fixedvars, MemorySegment fixedvals, int nfixedvars, int global) {
        var mh$ = SCIPcopyVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyVars", sourcescip, targetscip, varmap, consmap, fixedvars, fixedvals, nfixedvars, global);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, fixedvars, fixedvals, nfixedvars, global);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyOrigVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyOrigVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars)
     * }
     */
    public static FunctionDescriptor SCIPcopyOrigVars$descriptor() {
        return SCIPcopyOrigVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars)
     * }
     */
    public static MethodHandle SCIPcopyOrigVars$handle() {
        return SCIPcopyOrigVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars)
     * }
     */
    public static MemorySegment SCIPcopyOrigVars$address() {
        return SCIPcopyOrigVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigVars(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars)
     * }
     */
    public static int SCIPcopyOrigVars(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment fixedvars, MemorySegment fixedvals, int nfixedvars) {
        var mh$ = SCIPcopyOrigVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyOrigVars", sourcescip, targetscip, varmap, consmap, fixedvars, fixedvals, nfixedvars);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, fixedvars, fixedvals, nfixedvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmergeVariableStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmergeVariableStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeVariableStatistics(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR **sourcevars, SCIP_VAR **targetvars, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPmergeVariableStatistics$descriptor() {
        return SCIPmergeVariableStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeVariableStatistics(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR **sourcevars, SCIP_VAR **targetvars, int nvars)
     * }
     */
    public static MethodHandle SCIPmergeVariableStatistics$handle() {
        return SCIPmergeVariableStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeVariableStatistics(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR **sourcevars, SCIP_VAR **targetvars, int nvars)
     * }
     */
    public static MemorySegment SCIPmergeVariableStatistics$address() {
        return SCIPmergeVariableStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmergeVariableStatistics(SCIP *sourcescip, SCIP *targetscip, SCIP_VAR **sourcevars, SCIP_VAR **targetvars, int nvars)
     * }
     */
    public static int SCIPmergeVariableStatistics(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment sourcevars, MemorySegment targetvars, int nvars) {
        var mh$ = SCIPmergeVariableStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmergeVariableStatistics", sourcescip, targetscip, sourcevars, targetvars, nvars);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, sourcevars, targetvars, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmergeNLPIStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmergeNLPIStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPmergeNLPIStatistics(SCIP *sourcescip, SCIP *targetscip, unsigned int reset)
     * }
     */
    public static FunctionDescriptor SCIPmergeNLPIStatistics$descriptor() {
        return SCIPmergeNLPIStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPmergeNLPIStatistics(SCIP *sourcescip, SCIP *targetscip, unsigned int reset)
     * }
     */
    public static MethodHandle SCIPmergeNLPIStatistics$handle() {
        return SCIPmergeNLPIStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPmergeNLPIStatistics(SCIP *sourcescip, SCIP *targetscip, unsigned int reset)
     * }
     */
    public static MemorySegment SCIPmergeNLPIStatistics$address() {
        return SCIPmergeNLPIStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPmergeNLPIStatistics(SCIP *sourcescip, SCIP *targetscip, unsigned int reset)
     * }
     */
    public static void SCIPmergeNLPIStatistics(MemorySegment sourcescip, MemorySegment targetscip, int reset) {
        var mh$ = SCIPmergeNLPIStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmergeNLPIStatistics", sourcescip, targetscip, reset);
            }
            mh$.invokeExact(sourcescip, targetscip, reset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtranslateSubSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtranslateSubSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSol(SCIP *scip, SCIP *subscip, SCIP_SOL *subsol, SCIP_HEUR *heur, SCIP_VAR **subvars, SCIP_SOL **newsol)
     * }
     */
    public static FunctionDescriptor SCIPtranslateSubSol$descriptor() {
        return SCIPtranslateSubSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSol(SCIP *scip, SCIP *subscip, SCIP_SOL *subsol, SCIP_HEUR *heur, SCIP_VAR **subvars, SCIP_SOL **newsol)
     * }
     */
    public static MethodHandle SCIPtranslateSubSol$handle() {
        return SCIPtranslateSubSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSol(SCIP *scip, SCIP *subscip, SCIP_SOL *subsol, SCIP_HEUR *heur, SCIP_VAR **subvars, SCIP_SOL **newsol)
     * }
     */
    public static MemorySegment SCIPtranslateSubSol$address() {
        return SCIPtranslateSubSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSol(SCIP *scip, SCIP *subscip, SCIP_SOL *subsol, SCIP_HEUR *heur, SCIP_VAR **subvars, SCIP_SOL **newsol)
     * }
     */
    public static int SCIPtranslateSubSol(MemorySegment scip, MemorySegment subscip, MemorySegment subsol, MemorySegment heur, MemorySegment subvars, MemorySegment newsol) {
        var mh$ = SCIPtranslateSubSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtranslateSubSol", scip, subscip, subsol, heur, subvars, newsol);
            }
            return (int)mh$.invokeExact(scip, subscip, subsol, heur, subvars, newsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtranslateSubSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtranslateSubSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSols(SCIP *scip, SCIP *subscip, SCIP_HEUR *heur, SCIP_VAR **subvars, unsigned int *success, int *solindex)
     * }
     */
    public static FunctionDescriptor SCIPtranslateSubSols$descriptor() {
        return SCIPtranslateSubSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSols(SCIP *scip, SCIP *subscip, SCIP_HEUR *heur, SCIP_VAR **subvars, unsigned int *success, int *solindex)
     * }
     */
    public static MethodHandle SCIPtranslateSubSols$handle() {
        return SCIPtranslateSubSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSols(SCIP *scip, SCIP *subscip, SCIP_HEUR *heur, SCIP_VAR **subvars, unsigned int *success, int *solindex)
     * }
     */
    public static MemorySegment SCIPtranslateSubSols$address() {
        return SCIPtranslateSubSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtranslateSubSols(SCIP *scip, SCIP *subscip, SCIP_HEUR *heur, SCIP_VAR **subvars, unsigned int *success, int *solindex)
     * }
     */
    public static int SCIPtranslateSubSols(MemorySegment scip, MemorySegment subscip, MemorySegment heur, MemorySegment subvars, MemorySegment success, MemorySegment solindex) {
        var mh$ = SCIPtranslateSubSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtranslateSubSols", scip, subscip, heur, subvars, success, solindex);
            }
            return (int)mh$.invokeExact(scip, subscip, heur, subvars, success, solindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_CONS *sourcecons, SCIP_CONS **targetcons, SCIP_CONSHDLR *sourceconshdlr, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPgetConsCopy$descriptor() {
        return SCIPgetConsCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_CONS *sourcecons, SCIP_CONS **targetcons, SCIP_CONSHDLR *sourceconshdlr, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPgetConsCopy$handle() {
        return SCIPgetConsCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_CONS *sourcecons, SCIP_CONS **targetcons, SCIP_CONSHDLR *sourceconshdlr, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPgetConsCopy$address() {
        return SCIPgetConsCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetConsCopy(SCIP *sourcescip, SCIP *targetscip, SCIP_CONS *sourcecons, SCIP_CONS **targetcons, SCIP_CONSHDLR *sourceconshdlr, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *name, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static int SCIPgetConsCopy(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment sourcecons, MemorySegment targetcons, MemorySegment sourceconshdlr, MemorySegment varmap, MemorySegment consmap, MemorySegment name, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode, int global, MemorySegment valid) {
        var mh$ = SCIPgetConsCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsCopy", sourcescip, targetscip, sourcecons, targetcons, sourceconshdlr, varmap, consmap, name, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, global, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, sourcecons, targetcons, sourceconshdlr, varmap, consmap, name, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, global, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyConss$descriptor() {
        return SCIPcopyConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyConss$handle() {
        return SCIPcopyConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyConss$address() {
        return SCIPcopyConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static int SCIPcopyConss(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int global, int enablepricing, MemorySegment valid) {
        var mh$ = SCIPcopyConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyConss", sourcescip, targetscip, varmap, consmap, global, enablepricing, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, global, enablepricing, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyOrigConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyOrigConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyOrigConss$descriptor() {
        return SCIPcopyOrigConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyOrigConss$handle() {
        return SCIPcopyOrigConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyOrigConss$address() {
        return SCIPcopyOrigConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConss(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static int SCIPcopyOrigConss(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int enablepricing, MemorySegment valid) {
        var mh$ = SCIPcopyOrigConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyOrigConss", sourcescip, targetscip, varmap, consmap, enablepricing, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, enablepricing, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconvertCutsToConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconvertCutsToConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconvertCutsToConss(SCIP *scip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static FunctionDescriptor SCIPconvertCutsToConss$descriptor() {
        return SCIPconvertCutsToConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconvertCutsToConss(SCIP *scip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static MethodHandle SCIPconvertCutsToConss$handle() {
        return SCIPconvertCutsToConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconvertCutsToConss(SCIP *scip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static MemorySegment SCIPconvertCutsToConss$address() {
        return SCIPconvertCutsToConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconvertCutsToConss(SCIP *scip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static int SCIPconvertCutsToConss(MemorySegment scip, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment ncutsadded) {
        var mh$ = SCIPconvertCutsToConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconvertCutsToConss", scip, varmap, consmap, global, ncutsadded);
            }
            return (int)mh$.invokeExact(scip, varmap, consmap, global, ncutsadded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyCuts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static FunctionDescriptor SCIPcopyCuts$descriptor() {
        return SCIPcopyCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyCuts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static MethodHandle SCIPcopyCuts$handle() {
        return SCIPcopyCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyCuts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static MemorySegment SCIPcopyCuts$address() {
        return SCIPcopyCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyCuts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, int *ncutsadded)
     * }
     */
    public static int SCIPcopyCuts(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment ncutsadded) {
        var mh$ = SCIPcopyCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyCuts", sourcescip, targetscip, varmap, consmap, global, ncutsadded);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, global, ncutsadded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyConflicts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyConflicts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConflicts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyConflicts$descriptor() {
        return SCIPcopyConflicts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConflicts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyConflicts$handle() {
        return SCIPcopyConflicts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConflicts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyConflicts$address() {
        return SCIPcopyConflicts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConflicts(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int enablepricing, unsigned int *valid)
     * }
     */
    public static int SCIPcopyConflicts(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int global, int enablepricing, MemorySegment valid) {
        var mh$ = SCIPcopyConflicts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyConflicts", sourcescip, targetscip, varmap, consmap, global, enablepricing, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, global, enablepricing, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyImplicationsCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyImplicationsCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyImplicationsCliques(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *infeasible, int *nbdchgs, int *ncopied)
     * }
     */
    public static FunctionDescriptor SCIPcopyImplicationsCliques$descriptor() {
        return SCIPcopyImplicationsCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyImplicationsCliques(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *infeasible, int *nbdchgs, int *ncopied)
     * }
     */
    public static MethodHandle SCIPcopyImplicationsCliques$handle() {
        return SCIPcopyImplicationsCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyImplicationsCliques(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *infeasible, int *nbdchgs, int *ncopied)
     * }
     */
    public static MemorySegment SCIPcopyImplicationsCliques$address() {
        return SCIPcopyImplicationsCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyImplicationsCliques(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *infeasible, int *nbdchgs, int *ncopied)
     * }
     */
    public static int SCIPcopyImplicationsCliques(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment infeasible, MemorySegment nbdchgs, MemorySegment ncopied) {
        var mh$ = SCIPcopyImplicationsCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyImplicationsCliques", sourcescip, targetscip, varmap, consmap, global, infeasible, nbdchgs, ncopied);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, global, infeasible, nbdchgs, ncopied);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyParamSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyParamSettings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyParamSettings(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static FunctionDescriptor SCIPcopyParamSettings$descriptor() {
        return SCIPcopyParamSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyParamSettings(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static MethodHandle SCIPcopyParamSettings$handle() {
        return SCIPcopyParamSettings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyParamSettings(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static MemorySegment SCIPcopyParamSettings$address() {
        return SCIPcopyParamSettings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyParamSettings(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static int SCIPcopyParamSettings(MemorySegment sourcescip, MemorySegment targetscip) {
        var mh$ = SCIPcopyParamSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyParamSettings", sourcescip, targetscip);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSubscipDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSubscipDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetSubscipDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSubscipDepth$descriptor() {
        return SCIPgetSubscipDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetSubscipDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSubscipDepth$handle() {
        return SCIPgetSubscipDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetSubscipDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSubscipDepth$address() {
        return SCIPgetSubscipDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetSubscipDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetSubscipDepth(MemorySegment scip) {
        var mh$ = SCIPgetSubscipDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSubscipDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSubscipDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSubscipDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetSubscipDepth(SCIP *scip, int newdepth)
     * }
     */
    public static FunctionDescriptor SCIPsetSubscipDepth$descriptor() {
        return SCIPsetSubscipDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetSubscipDepth(SCIP *scip, int newdepth)
     * }
     */
    public static MethodHandle SCIPsetSubscipDepth$handle() {
        return SCIPsetSubscipDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetSubscipDepth(SCIP *scip, int newdepth)
     * }
     */
    public static MemorySegment SCIPsetSubscipDepth$address() {
        return SCIPsetSubscipDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetSubscipDepth(SCIP *scip, int newdepth)
     * }
     */
    public static void SCIPsetSubscipDepth(MemorySegment scip, int newdepth) {
        var mh$ = SCIPsetSubscipDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSubscipDepth", scip, newdepth);
            }
            mh$.invokeExact(scip, newdepth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopy(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopy$descriptor() {
        return SCIPcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopy(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopy$handle() {
        return SCIPcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopy(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopy$address() {
        return SCIPcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopy(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static int SCIPcopy(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment suffix, int global, int enablepricing, int threadsafe, int passmessagehdlr, MemorySegment valid) {
        var mh$ = SCIPcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopy", sourcescip, targetscip, varmap, consmap, suffix, global, enablepricing, threadsafe, passmessagehdlr, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, suffix, global, enablepricing, threadsafe, passmessagehdlr, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyConsCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyConsCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyConsCompression$descriptor() {
        return SCIPcopyConsCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyConsCompression$handle() {
        return SCIPcopyConsCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyConsCompression$address() {
        return SCIPcopyConsCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int global, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static int SCIPcopyConsCompression(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment suffix, MemorySegment fixedvars, MemorySegment fixedvals, int nfixedvars, int global, int enablepricing, int threadsafe, int passmessagehdlr, MemorySegment valid) {
        var mh$ = SCIPcopyConsCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyConsCompression", sourcescip, targetscip, varmap, consmap, suffix, fixedvars, fixedvals, nfixedvars, global, enablepricing, threadsafe, passmessagehdlr, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, suffix, fixedvars, fixedvals, nfixedvars, global, enablepricing, threadsafe, passmessagehdlr, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyOrig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyOrig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrig(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyOrig$descriptor() {
        return SCIPcopyOrig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrig(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyOrig$handle() {
        return SCIPcopyOrig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrig(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyOrig$address() {
        return SCIPcopyOrig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrig(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static int SCIPcopyOrig(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment suffix, int enablepricing, int threadsafe, int passmessagehdlr, MemorySegment valid) {
        var mh$ = SCIPcopyOrig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyOrig", sourcescip, targetscip, varmap, consmap, suffix, enablepricing, threadsafe, passmessagehdlr, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, suffix, enablepricing, threadsafe, passmessagehdlr, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyOrigConsCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyOrigConsCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyOrigConsCompression$descriptor() {
        return SCIPcopyOrigConsCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyOrigConsCompression$handle() {
        return SCIPcopyOrigConsCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyOrigConsCompression$address() {
        return SCIPcopyOrigConsCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyOrigConsCompression(SCIP *sourcescip, SCIP *targetscip, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, const char *suffix, SCIP_VAR **fixedvars, double *fixedvals, int nfixedvars, unsigned int enablepricing, unsigned int threadsafe, unsigned int passmessagehdlr, unsigned int *valid)
     * }
     */
    public static int SCIPcopyOrigConsCompression(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment varmap, MemorySegment consmap, MemorySegment suffix, MemorySegment fixedvars, MemorySegment fixedvals, int nfixedvars, int enablepricing, int threadsafe, int passmessagehdlr, MemorySegment valid) {
        var mh$ = SCIPcopyOrigConsCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyOrigConsCompression", sourcescip, targetscip, varmap, consmap, suffix, fixedvars, fixedvals, nfixedvars, enablepricing, threadsafe, passmessagehdlr, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, varmap, consmap, suffix, fixedvars, fixedvals, nfixedvars, enablepricing, threadsafe, passmessagehdlr, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckCopyLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckCopyLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCopyLimits(SCIP *sourcescip, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcheckCopyLimits$descriptor() {
        return SCIPcheckCopyLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCopyLimits(SCIP *sourcescip, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcheckCopyLimits$handle() {
        return SCIPcheckCopyLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCopyLimits(SCIP *sourcescip, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcheckCopyLimits$address() {
        return SCIPcheckCopyLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCopyLimits(SCIP *sourcescip, unsigned int *success)
     * }
     */
    public static int SCIPcheckCopyLimits(MemorySegment sourcescip, MemorySegment success) {
        var mh$ = SCIPcheckCopyLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckCopyLimits", sourcescip, success);
            }
            return (int)mh$.invokeExact(sourcescip, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyLimits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLimits(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static FunctionDescriptor SCIPcopyLimits$descriptor() {
        return SCIPcopyLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLimits(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static MethodHandle SCIPcopyLimits$handle() {
        return SCIPcopyLimits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLimits(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static MemorySegment SCIPcopyLimits$address() {
        return SCIPcopyLimits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyLimits(SCIP *sourcescip, SCIP *targetscip)
     * }
     */
    public static int SCIPcopyLimits(MemorySegment sourcescip, MemorySegment targetscip) {
        var mh$ = SCIPcopyLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyLimits", sourcescip, targetscip);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCommonSubscipParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCommonSubscipParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCommonSubscipParams(SCIP *sourcescip, SCIP *subscip, long long nsubnodes, long long nstallnodes, int bestsollimit)
     * }
     */
    public static FunctionDescriptor SCIPsetCommonSubscipParams$descriptor() {
        return SCIPsetCommonSubscipParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCommonSubscipParams(SCIP *sourcescip, SCIP *subscip, long long nsubnodes, long long nstallnodes, int bestsollimit)
     * }
     */
    public static MethodHandle SCIPsetCommonSubscipParams$handle() {
        return SCIPsetCommonSubscipParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCommonSubscipParams(SCIP *sourcescip, SCIP *subscip, long long nsubnodes, long long nstallnodes, int bestsollimit)
     * }
     */
    public static MemorySegment SCIPsetCommonSubscipParams$address() {
        return SCIPsetCommonSubscipParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCommonSubscipParams(SCIP *sourcescip, SCIP *subscip, long long nsubnodes, long long nstallnodes, int bestsollimit)
     * }
     */
    public static int SCIPsetCommonSubscipParams(MemorySegment sourcescip, MemorySegment subscip, long nsubnodes, long nstallnodes, int bestsollimit) {
        var mh$ = SCIPsetCommonSubscipParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCommonSubscipParams", sourcescip, subscip, nsubnodes, nstallnodes, bestsollimit);
            }
            return (int)mh$.invokeExact(sourcescip, subscip, nsubnodes, nstallnodes, bestsollimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCutLPSolCutoffDistance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCutLPSolCutoffDistance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetCutLPSolCutoffDistance(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static FunctionDescriptor SCIPgetCutLPSolCutoffDistance$descriptor() {
        return SCIPgetCutLPSolCutoffDistance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetCutLPSolCutoffDistance(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MethodHandle SCIPgetCutLPSolCutoffDistance$handle() {
        return SCIPgetCutLPSolCutoffDistance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetCutLPSolCutoffDistance(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MemorySegment SCIPgetCutLPSolCutoffDistance$address() {
        return SCIPgetCutLPSolCutoffDistance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetCutLPSolCutoffDistance(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static double SCIPgetCutLPSolCutoffDistance(MemorySegment scip, MemorySegment sol, MemorySegment cut) {
        var mh$ = SCIPgetCutLPSolCutoffDistance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCutLPSolCutoffDistance", scip, sol, cut);
            }
            return (double)mh$.invokeExact(scip, sol, cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCutEfficacy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCutEfficacy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetCutEfficacy(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static FunctionDescriptor SCIPgetCutEfficacy$descriptor() {
        return SCIPgetCutEfficacy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetCutEfficacy(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MethodHandle SCIPgetCutEfficacy$handle() {
        return SCIPgetCutEfficacy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetCutEfficacy(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MemorySegment SCIPgetCutEfficacy$address() {
        return SCIPgetCutEfficacy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetCutEfficacy(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static double SCIPgetCutEfficacy(MemorySegment scip, MemorySegment sol, MemorySegment cut) {
        var mh$ = SCIPgetCutEfficacy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCutEfficacy", scip, sol, cut);
            }
            return (double)mh$.invokeExact(scip, sol, cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisCutEfficacious {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisCutEfficacious");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutEfficacious(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static FunctionDescriptor SCIPisCutEfficacious$descriptor() {
        return SCIPisCutEfficacious.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutEfficacious(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MethodHandle SCIPisCutEfficacious$handle() {
        return SCIPisCutEfficacious.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutEfficacious(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static MemorySegment SCIPisCutEfficacious$address() {
        return SCIPisCutEfficacious.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisCutEfficacious(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut)
     * }
     */
    public static int SCIPisCutEfficacious(MemorySegment scip, MemorySegment sol, MemorySegment cut) {
        var mh$ = SCIPisCutEfficacious.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisCutEfficacious", scip, sol, cut);
            }
            return (int)mh$.invokeExact(scip, sol, cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisEfficacious {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisEfficacious");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisEfficacious(SCIP *scip, double efficacy)
     * }
     */
    public static FunctionDescriptor SCIPisEfficacious$descriptor() {
        return SCIPisEfficacious.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisEfficacious(SCIP *scip, double efficacy)
     * }
     */
    public static MethodHandle SCIPisEfficacious$handle() {
        return SCIPisEfficacious.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisEfficacious(SCIP *scip, double efficacy)
     * }
     */
    public static MemorySegment SCIPisEfficacious$address() {
        return SCIPisEfficacious.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisEfficacious(SCIP *scip, double efficacy)
     * }
     */
    public static int SCIPisEfficacious(MemorySegment scip, double efficacy) {
        var mh$ = SCIPisEfficacious.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisEfficacious", scip, efficacy);
            }
            return (int)mh$.invokeExact(scip, efficacy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVectorEfficacyNorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVectorEfficacyNorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVectorEfficacyNorm(SCIP *scip, double *vals, int nvals)
     * }
     */
    public static FunctionDescriptor SCIPgetVectorEfficacyNorm$descriptor() {
        return SCIPgetVectorEfficacyNorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVectorEfficacyNorm(SCIP *scip, double *vals, int nvals)
     * }
     */
    public static MethodHandle SCIPgetVectorEfficacyNorm$handle() {
        return SCIPgetVectorEfficacyNorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVectorEfficacyNorm(SCIP *scip, double *vals, int nvals)
     * }
     */
    public static MemorySegment SCIPgetVectorEfficacyNorm$address() {
        return SCIPgetVectorEfficacyNorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVectorEfficacyNorm(SCIP *scip, double *vals, int nvals)
     * }
     */
    public static double SCIPgetVectorEfficacyNorm(MemorySegment scip, MemorySegment vals, int nvals) {
        var mh$ = SCIPgetVectorEfficacyNorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVectorEfficacyNorm", scip, vals, nvals);
            }
            return (double)mh$.invokeExact(scip, vals, nvals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisCutApplicable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisCutApplicable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutApplicable(SCIP *scip, SCIP_ROW *cut)
     * }
     */
    public static FunctionDescriptor SCIPisCutApplicable$descriptor() {
        return SCIPisCutApplicable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutApplicable(SCIP *scip, SCIP_ROW *cut)
     * }
     */
    public static MethodHandle SCIPisCutApplicable$handle() {
        return SCIPisCutApplicable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutApplicable(SCIP *scip, SCIP_ROW *cut)
     * }
     */
    public static MemorySegment SCIPisCutApplicable$address() {
        return SCIPisCutApplicable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisCutApplicable(SCIP *scip, SCIP_ROW *cut)
     * }
     */
    public static int SCIPisCutApplicable(MemorySegment scip, MemorySegment cut) {
        var mh$ = SCIPisCutApplicable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisCutApplicable", scip, cut);
            }
            return (int)mh$.invokeExact(scip, cut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCut(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPaddCut$descriptor() {
        return SCIPaddCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCut(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPaddCut$handle() {
        return SCIPaddCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCut(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPaddCut$address() {
        return SCIPaddCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCut(SCIP *scip, SCIP_SOL *sol, SCIP_ROW *cut, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static int SCIPaddCut(MemorySegment scip, MemorySegment sol, MemorySegment cut, int forcecut, MemorySegment infeasible) {
        var mh$ = SCIPaddCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCut", scip, sol, cut, forcecut, infeasible);
            }
            return (int)mh$.invokeExact(scip, sol, cut, forcecut, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRow(SCIP *scip, SCIP_ROW *row, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPaddRow$descriptor() {
        return SCIPaddRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRow(SCIP *scip, SCIP_ROW *row, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPaddRow$handle() {
        return SCIPaddRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRow(SCIP *scip, SCIP_ROW *row, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPaddRow$address() {
        return SCIPaddRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRow(SCIP *scip, SCIP_ROW *row, unsigned int forcecut, unsigned int *infeasible)
     * }
     */
    public static int SCIPaddRow(MemorySegment scip, MemorySegment row, int forcecut, MemorySegment infeasible) {
        var mh$ = SCIPaddRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRow", scip, row, forcecut, infeasible);
            }
            return (int)mh$.invokeExact(scip, row, forcecut, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisCutNew {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisCutNew");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutNew(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPisCutNew$descriptor() {
        return SCIPisCutNew.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutNew(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPisCutNew$handle() {
        return SCIPisCutNew.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisCutNew(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPisCutNew$address() {
        return SCIPisCutNew.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisCutNew(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPisCutNew(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPisCutNew.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisCutNew", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddPoolCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddPoolCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddPoolCut$descriptor() {
        return SCIPaddPoolCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddPoolCut$handle() {
        return SCIPaddPoolCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddPoolCut$address() {
        return SCIPaddPoolCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddPoolCut(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPaddPoolCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddPoolCut", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelPoolCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelPoolCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPdelPoolCut$descriptor() {
        return SCIPdelPoolCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPdelPoolCut$handle() {
        return SCIPdelPoolCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPdelPoolCut$address() {
        return SCIPdelPoolCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPdelPoolCut(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPdelPoolCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelPoolCut", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPoolCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPoolCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetPoolCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPoolCuts$descriptor() {
        return SCIPgetPoolCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetPoolCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPoolCuts$handle() {
        return SCIPgetPoolCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPoolCuts$address() {
        return SCIPgetPoolCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPoolCuts(MemorySegment scip) {
        var mh$ = SCIPgetPoolCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPoolCuts", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPoolCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPoolCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPoolCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPoolCuts$descriptor() {
        return SCIPgetNPoolCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPoolCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPoolCuts$handle() {
        return SCIPgetNPoolCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPoolCuts$address() {
        return SCIPgetNPoolCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPoolCuts(SCIP *scip)
     * }
     */
    public static int SCIPgetNPoolCuts(MemorySegment scip) {
        var mh$ = SCIPgetNPoolCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPoolCuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetGlobalCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetGlobalCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetGlobalCutpool(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetGlobalCutpool$descriptor() {
        return SCIPgetGlobalCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetGlobalCutpool(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetGlobalCutpool$handle() {
        return SCIPgetGlobalCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetGlobalCutpool(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetGlobalCutpool$address() {
        return SCIPgetGlobalCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetGlobalCutpool(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetGlobalCutpool(MemorySegment scip) {
        var mh$ = SCIPgetGlobalCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetGlobalCutpool", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool, int agelimit)
     * }
     */
    public static FunctionDescriptor SCIPcreateCutpool$descriptor() {
        return SCIPcreateCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool, int agelimit)
     * }
     */
    public static MethodHandle SCIPcreateCutpool$handle() {
        return SCIPcreateCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool, int agelimit)
     * }
     */
    public static MemorySegment SCIPcreateCutpool$address() {
        return SCIPcreateCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool, int agelimit)
     * }
     */
    public static int SCIPcreateCutpool(MemorySegment scip, MemorySegment cutpool, int agelimit) {
        var mh$ = SCIPcreateCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateCutpool", scip, cutpool, agelimit);
            }
            return (int)mh$.invokeExact(scip, cutpool, agelimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool)
     * }
     */
    public static FunctionDescriptor SCIPfreeCutpool$descriptor() {
        return SCIPfreeCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool)
     * }
     */
    public static MethodHandle SCIPfreeCutpool$handle() {
        return SCIPfreeCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool)
     * }
     */
    public static MemorySegment SCIPfreeCutpool$address() {
        return SCIPfreeCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeCutpool(SCIP *scip, SCIP_CUTPOOL **cutpool)
     * }
     */
    public static int SCIPfreeCutpool(MemorySegment scip, MemorySegment cutpool) {
        var mh$ = SCIPfreeCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeCutpool", scip, cutpool);
            }
            return (int)mh$.invokeExact(scip, cutpool);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRowCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRowCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddRowCutpool$descriptor() {
        return SCIPaddRowCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddRowCutpool$handle() {
        return SCIPaddRowCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddRowCutpool$address() {
        return SCIPaddRowCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddRowCutpool(MemorySegment scip, MemorySegment cutpool, MemorySegment row) {
        var mh$ = SCIPaddRowCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRowCutpool", scip, cutpool, row);
            }
            return (int)mh$.invokeExact(scip, cutpool, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNewRowCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNewRowCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNewRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddNewRowCutpool$descriptor() {
        return SCIPaddNewRowCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNewRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddNewRowCutpool$handle() {
        return SCIPaddNewRowCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNewRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddNewRowCutpool$address() {
        return SCIPaddNewRowCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNewRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddNewRowCutpool(MemorySegment scip, MemorySegment cutpool, MemorySegment row) {
        var mh$ = SCIPaddNewRowCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNewRowCutpool", scip, cutpool, row);
            }
            return (int)mh$.invokeExact(scip, cutpool, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelRowCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelRowCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPdelRowCutpool$descriptor() {
        return SCIPdelRowCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPdelRowCutpool$handle() {
        return SCIPdelRowCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPdelRowCutpool$address() {
        return SCIPdelRowCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelRowCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_ROW *row)
     * }
     */
    public static int SCIPdelRowCutpool(MemorySegment scip, MemorySegment cutpool, MemorySegment row) {
        var mh$ = SCIPdelRowCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelRowCutpool", scip, cutpool, row);
            }
            return (int)mh$.invokeExact(scip, cutpool, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPseparateCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPseparateCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPseparateCutpool$descriptor() {
        return SCIPseparateCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPseparateCutpool$handle() {
        return SCIPseparateCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPseparateCutpool$address() {
        return SCIPseparateCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_RESULT *result)
     * }
     */
    public static int SCIPseparateCutpool(MemorySegment scip, MemorySegment cutpool, MemorySegment result) {
        var mh$ = SCIPseparateCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPseparateCutpool", scip, cutpool, result);
            }
            return (int)mh$.invokeExact(scip, cutpool, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPseparateSolCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPseparateSolCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSolCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_SOL *sol, unsigned int pretendroot, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPseparateSolCutpool$descriptor() {
        return SCIPseparateSolCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSolCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_SOL *sol, unsigned int pretendroot, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPseparateSolCutpool$handle() {
        return SCIPseparateSolCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSolCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_SOL *sol, unsigned int pretendroot, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPseparateSolCutpool$address() {
        return SCIPseparateSolCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSolCutpool(SCIP *scip, SCIP_CUTPOOL *cutpool, SCIP_SOL *sol, unsigned int pretendroot, SCIP_RESULT *result)
     * }
     */
    public static int SCIPseparateSolCutpool(MemorySegment scip, MemorySegment cutpool, MemorySegment sol, int pretendroot, MemorySegment result) {
        var mh$ = SCIPseparateSolCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPseparateSolCutpool", scip, cutpool, sol, pretendroot, result);
            }
            return (int)mh$.invokeExact(scip, cutpool, sol, pretendroot, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDelayedPoolCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDelayedPoolCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddDelayedPoolCut$descriptor() {
        return SCIPaddDelayedPoolCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddDelayedPoolCut$handle() {
        return SCIPaddDelayedPoolCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddDelayedPoolCut$address() {
        return SCIPaddDelayedPoolCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddDelayedPoolCut(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPaddDelayedPoolCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDelayedPoolCut", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelDelayedPoolCut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelDelayedPoolCut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPdelDelayedPoolCut$descriptor() {
        return SCIPdelDelayedPoolCut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPdelDelayedPoolCut$handle() {
        return SCIPdelDelayedPoolCut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPdelDelayedPoolCut$address() {
        return SCIPdelDelayedPoolCut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelDelayedPoolCut(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPdelDelayedPoolCut(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPdelDelayedPoolCut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelDelayedPoolCut", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDelayedPoolCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDelayedPoolCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDelayedPoolCuts$descriptor() {
        return SCIPgetDelayedPoolCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDelayedPoolCuts$handle() {
        return SCIPgetDelayedPoolCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDelayedPoolCuts$address() {
        return SCIPgetDelayedPoolCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUT **SCIPgetDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDelayedPoolCuts(MemorySegment scip) {
        var mh$ = SCIPgetDelayedPoolCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDelayedPoolCuts", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDelayedPoolCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDelayedPoolCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDelayedPoolCuts$descriptor() {
        return SCIPgetNDelayedPoolCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDelayedPoolCuts$handle() {
        return SCIPgetNDelayedPoolCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDelayedPoolCuts$address() {
        return SCIPgetNDelayedPoolCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNDelayedPoolCuts(SCIP *scip)
     * }
     */
    public static int SCIPgetNDelayedPoolCuts(MemorySegment scip) {
        var mh$ = SCIPgetNDelayedPoolCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDelayedPoolCuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDelayedGlobalCutpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDelayedGlobalCutpool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetDelayedGlobalCutpool(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDelayedGlobalCutpool$descriptor() {
        return SCIPgetDelayedGlobalCutpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetDelayedGlobalCutpool(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDelayedGlobalCutpool$handle() {
        return SCIPgetDelayedGlobalCutpool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetDelayedGlobalCutpool(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDelayedGlobalCutpool$address() {
        return SCIPgetDelayedGlobalCutpool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUTPOOL *SCIPgetDelayedGlobalCutpool(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDelayedGlobalCutpool(MemorySegment scip) {
        var mh$ = SCIPgetDelayedGlobalCutpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDelayedGlobalCutpool", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPseparateSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPseparateSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSol(SCIP *scip, SCIP_SOL *sol, unsigned int pretendroot, unsigned int allowlocal, unsigned int onlydelayed, unsigned int *delayed, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPseparateSol$descriptor() {
        return SCIPseparateSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSol(SCIP *scip, SCIP_SOL *sol, unsigned int pretendroot, unsigned int allowlocal, unsigned int onlydelayed, unsigned int *delayed, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPseparateSol$handle() {
        return SCIPseparateSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSol(SCIP *scip, SCIP_SOL *sol, unsigned int pretendroot, unsigned int allowlocal, unsigned int onlydelayed, unsigned int *delayed, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPseparateSol$address() {
        return SCIPseparateSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateSol(SCIP *scip, SCIP_SOL *sol, unsigned int pretendroot, unsigned int allowlocal, unsigned int onlydelayed, unsigned int *delayed, unsigned int *cutoff)
     * }
     */
    public static int SCIPseparateSol(MemorySegment scip, MemorySegment sol, int pretendroot, int allowlocal, int onlydelayed, MemorySegment delayed, MemorySegment cutoff) {
        var mh$ = SCIPseparateSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPseparateSol", scip, sol, pretendroot, allowlocal, onlydelayed, delayed, cutoff);
            }
            return (int)mh$.invokeExact(scip, sol, pretendroot, allowlocal, onlydelayed, delayed, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCuts$descriptor() {
        return SCIPgetCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCuts$handle() {
        return SCIPgetCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCuts$address() {
        return SCIPgetCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCuts(MemorySegment scip) {
        var mh$ = SCIPgetCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCuts", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCuts$descriptor() {
        return SCIPgetNCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCuts$handle() {
        return SCIPgetNCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCuts$address() {
        return SCIPgetNCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCuts(SCIP *scip)
     * }
     */
    public static int SCIPgetNCuts(MemorySegment scip) {
        var mh$ = SCIPgetNCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPclearCuts$descriptor() {
        return SCIPclearCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPclearCuts$handle() {
        return SCIPclearCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPclearCuts$address() {
        return SCIPclearCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearCuts(SCIP *scip)
     * }
     */
    public static int SCIPclearCuts(MemorySegment scip) {
        var mh$ = SCIPclearCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearCuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPremoveInefficaciousCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPremoveInefficaciousCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveInefficaciousCuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPremoveInefficaciousCuts$descriptor() {
        return SCIPremoveInefficaciousCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveInefficaciousCuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPremoveInefficaciousCuts$handle() {
        return SCIPremoveInefficaciousCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveInefficaciousCuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPremoveInefficaciousCuts$address() {
        return SCIPremoveInefficaciousCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveInefficaciousCuts(SCIP *scip)
     * }
     */
    public static int SCIPremoveInefficaciousCuts(MemorySegment scip) {
        var mh$ = SCIPremoveInefficaciousCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPremoveInefficaciousCuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRealarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRealarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static FunctionDescriptor SCIPcreateRealarray$descriptor() {
        return SCIPcreateRealarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static MethodHandle SCIPcreateRealarray$handle() {
        return SCIPcreateRealarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static MemorySegment SCIPcreateRealarray$address() {
        return SCIPcreateRealarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static int SCIPcreateRealarray(MemorySegment scip, MemorySegment realarray) {
        var mh$ = SCIPcreateRealarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRealarray", scip, realarray);
            }
            return (int)mh$.invokeExact(scip, realarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeRealarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeRealarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static FunctionDescriptor SCIPfreeRealarray$descriptor() {
        return SCIPfreeRealarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static MethodHandle SCIPfreeRealarray$handle() {
        return SCIPfreeRealarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static MemorySegment SCIPfreeRealarray$address() {
        return SCIPfreeRealarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRealarray(SCIP *scip, SCIP_REALARRAY **realarray)
     * }
     */
    public static int SCIPfreeRealarray(MemorySegment scip, MemorySegment realarray) {
        var mh$ = SCIPfreeRealarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeRealarray", scip, realarray);
            }
            return (int)mh$.invokeExact(scip, realarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPextendRealarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPextendRealarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendRealarray(SCIP *scip, SCIP_REALARRAY *realarray, int minidx, int maxidx)
     * }
     */
    public static FunctionDescriptor SCIPextendRealarray$descriptor() {
        return SCIPextendRealarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendRealarray(SCIP *scip, SCIP_REALARRAY *realarray, int minidx, int maxidx)
     * }
     */
    public static MethodHandle SCIPextendRealarray$handle() {
        return SCIPextendRealarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendRealarray(SCIP *scip, SCIP_REALARRAY *realarray, int minidx, int maxidx)
     * }
     */
    public static MemorySegment SCIPextendRealarray$address() {
        return SCIPextendRealarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendRealarray(SCIP *scip, SCIP_REALARRAY *realarray, int minidx, int maxidx)
     * }
     */
    public static int SCIPextendRealarray(MemorySegment scip, MemorySegment realarray, int minidx, int maxidx) {
        var mh$ = SCIPextendRealarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPextendRealarray", scip, realarray, minidx, maxidx);
            }
            return (int)mh$.invokeExact(scip, realarray, minidx, maxidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearRealarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearRealarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRealarray(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static FunctionDescriptor SCIPclearRealarray$descriptor() {
        return SCIPclearRealarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRealarray(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MethodHandle SCIPclearRealarray$handle() {
        return SCIPclearRealarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRealarray(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MemorySegment SCIPclearRealarray$address() {
        return SCIPclearRealarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRealarray(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static int SCIPclearRealarray(MemorySegment scip, MemorySegment realarray) {
        var mh$ = SCIPclearRealarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearRealarray", scip, realarray);
            }
            return (int)mh$.invokeExact(scip, realarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRealarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRealarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx)
     * }
     */
    public static FunctionDescriptor SCIPgetRealarrayVal$descriptor() {
        return SCIPgetRealarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx)
     * }
     */
    public static MethodHandle SCIPgetRealarrayVal$handle() {
        return SCIPgetRealarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx)
     * }
     */
    public static MemorySegment SCIPgetRealarrayVal$address() {
        return SCIPgetRealarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx)
     * }
     */
    public static double SCIPgetRealarrayVal(MemorySegment scip, MemorySegment realarray, int idx) {
        var mh$ = SCIPgetRealarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRealarrayVal", scip, realarray, idx);
            }
            return (double)mh$.invokeExact(scip, realarray, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRealarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRealarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double val)
     * }
     */
    public static FunctionDescriptor SCIPsetRealarrayVal$descriptor() {
        return SCIPsetRealarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double val)
     * }
     */
    public static MethodHandle SCIPsetRealarrayVal$handle() {
        return SCIPsetRealarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double val)
     * }
     */
    public static MemorySegment SCIPsetRealarrayVal$address() {
        return SCIPsetRealarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double val)
     * }
     */
    public static int SCIPsetRealarrayVal(MemorySegment scip, MemorySegment realarray, int idx, double val) {
        var mh$ = SCIPsetRealarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRealarrayVal", scip, realarray, idx, val);
            }
            return (int)mh$.invokeExact(scip, realarray, idx, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincRealarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincRealarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double incval)
     * }
     */
    public static FunctionDescriptor SCIPincRealarrayVal$descriptor() {
        return SCIPincRealarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double incval)
     * }
     */
    public static MethodHandle SCIPincRealarrayVal$handle() {
        return SCIPincRealarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double incval)
     * }
     */
    public static MemorySegment SCIPincRealarrayVal$address() {
        return SCIPincRealarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincRealarrayVal(SCIP *scip, SCIP_REALARRAY *realarray, int idx, double incval)
     * }
     */
    public static int SCIPincRealarrayVal(MemorySegment scip, MemorySegment realarray, int idx, double incval) {
        var mh$ = SCIPincRealarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincRealarrayVal", scip, realarray, idx, incval);
            }
            return (int)mh$.invokeExact(scip, realarray, idx, incval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRealarrayMinIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRealarrayMinIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMinIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static FunctionDescriptor SCIPgetRealarrayMinIdx$descriptor() {
        return SCIPgetRealarrayMinIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMinIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MethodHandle SCIPgetRealarrayMinIdx$handle() {
        return SCIPgetRealarrayMinIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMinIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MemorySegment SCIPgetRealarrayMinIdx$address() {
        return SCIPgetRealarrayMinIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetRealarrayMinIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static int SCIPgetRealarrayMinIdx(MemorySegment scip, MemorySegment realarray) {
        var mh$ = SCIPgetRealarrayMinIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRealarrayMinIdx", scip, realarray);
            }
            return (int)mh$.invokeExact(scip, realarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRealarrayMaxIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRealarrayMaxIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMaxIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static FunctionDescriptor SCIPgetRealarrayMaxIdx$descriptor() {
        return SCIPgetRealarrayMaxIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMaxIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MethodHandle SCIPgetRealarrayMaxIdx$handle() {
        return SCIPgetRealarrayMaxIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetRealarrayMaxIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static MemorySegment SCIPgetRealarrayMaxIdx$address() {
        return SCIPgetRealarrayMaxIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetRealarrayMaxIdx(SCIP *scip, SCIP_REALARRAY *realarray)
     * }
     */
    public static int SCIPgetRealarrayMaxIdx(MemorySegment scip, MemorySegment realarray) {
        var mh$ = SCIPgetRealarrayMaxIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRealarrayMaxIdx", scip, realarray);
            }
            return (int)mh$.invokeExact(scip, realarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateIntarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateIntarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static FunctionDescriptor SCIPcreateIntarray$descriptor() {
        return SCIPcreateIntarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static MethodHandle SCIPcreateIntarray$handle() {
        return SCIPcreateIntarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static MemorySegment SCIPcreateIntarray$address() {
        return SCIPcreateIntarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static int SCIPcreateIntarray(MemorySegment scip, MemorySegment intarray) {
        var mh$ = SCIPcreateIntarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateIntarray", scip, intarray);
            }
            return (int)mh$.invokeExact(scip, intarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeIntarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeIntarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static FunctionDescriptor SCIPfreeIntarray$descriptor() {
        return SCIPfreeIntarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static MethodHandle SCIPfreeIntarray$handle() {
        return SCIPfreeIntarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static MemorySegment SCIPfreeIntarray$address() {
        return SCIPfreeIntarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeIntarray(SCIP *scip, SCIP_INTARRAY **intarray)
     * }
     */
    public static int SCIPfreeIntarray(MemorySegment scip, MemorySegment intarray) {
        var mh$ = SCIPfreeIntarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeIntarray", scip, intarray);
            }
            return (int)mh$.invokeExact(scip, intarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPextendIntarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPextendIntarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendIntarray(SCIP *scip, SCIP_INTARRAY *intarray, int minidx, int maxidx)
     * }
     */
    public static FunctionDescriptor SCIPextendIntarray$descriptor() {
        return SCIPextendIntarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendIntarray(SCIP *scip, SCIP_INTARRAY *intarray, int minidx, int maxidx)
     * }
     */
    public static MethodHandle SCIPextendIntarray$handle() {
        return SCIPextendIntarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendIntarray(SCIP *scip, SCIP_INTARRAY *intarray, int minidx, int maxidx)
     * }
     */
    public static MemorySegment SCIPextendIntarray$address() {
        return SCIPextendIntarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendIntarray(SCIP *scip, SCIP_INTARRAY *intarray, int minidx, int maxidx)
     * }
     */
    public static int SCIPextendIntarray(MemorySegment scip, MemorySegment intarray, int minidx, int maxidx) {
        var mh$ = SCIPextendIntarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPextendIntarray", scip, intarray, minidx, maxidx);
            }
            return (int)mh$.invokeExact(scip, intarray, minidx, maxidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearIntarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearIntarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearIntarray(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static FunctionDescriptor SCIPclearIntarray$descriptor() {
        return SCIPclearIntarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearIntarray(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MethodHandle SCIPclearIntarray$handle() {
        return SCIPclearIntarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearIntarray(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MemorySegment SCIPclearIntarray$address() {
        return SCIPclearIntarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearIntarray(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static int SCIPclearIntarray(MemorySegment scip, MemorySegment intarray) {
        var mh$ = SCIPclearIntarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearIntarray", scip, intarray);
            }
            return (int)mh$.invokeExact(scip, intarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIntarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIntarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx)
     * }
     */
    public static FunctionDescriptor SCIPgetIntarrayVal$descriptor() {
        return SCIPgetIntarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx)
     * }
     */
    public static MethodHandle SCIPgetIntarrayVal$handle() {
        return SCIPgetIntarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx)
     * }
     */
    public static MemorySegment SCIPgetIntarrayVal$address() {
        return SCIPgetIntarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx)
     * }
     */
    public static int SCIPgetIntarrayVal(MemorySegment scip, MemorySegment intarray, int idx) {
        var mh$ = SCIPgetIntarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIntarrayVal", scip, intarray, idx);
            }
            return (int)mh$.invokeExact(scip, intarray, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetIntarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetIntarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int val)
     * }
     */
    public static FunctionDescriptor SCIPsetIntarrayVal$descriptor() {
        return SCIPsetIntarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int val)
     * }
     */
    public static MethodHandle SCIPsetIntarrayVal$handle() {
        return SCIPsetIntarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int val)
     * }
     */
    public static MemorySegment SCIPsetIntarrayVal$address() {
        return SCIPsetIntarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int val)
     * }
     */
    public static int SCIPsetIntarrayVal(MemorySegment scip, MemorySegment intarray, int idx, int val) {
        var mh$ = SCIPsetIntarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetIntarrayVal", scip, intarray, idx, val);
            }
            return (int)mh$.invokeExact(scip, intarray, idx, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincIntarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincIntarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int incval)
     * }
     */
    public static FunctionDescriptor SCIPincIntarrayVal$descriptor() {
        return SCIPincIntarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int incval)
     * }
     */
    public static MethodHandle SCIPincIntarrayVal$handle() {
        return SCIPincIntarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int incval)
     * }
     */
    public static MemorySegment SCIPincIntarrayVal$address() {
        return SCIPincIntarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincIntarrayVal(SCIP *scip, SCIP_INTARRAY *intarray, int idx, int incval)
     * }
     */
    public static int SCIPincIntarrayVal(MemorySegment scip, MemorySegment intarray, int idx, int incval) {
        var mh$ = SCIPincIntarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincIntarrayVal", scip, intarray, idx, incval);
            }
            return (int)mh$.invokeExact(scip, intarray, idx, incval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIntarrayMinIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIntarrayMinIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMinIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static FunctionDescriptor SCIPgetIntarrayMinIdx$descriptor() {
        return SCIPgetIntarrayMinIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMinIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MethodHandle SCIPgetIntarrayMinIdx$handle() {
        return SCIPgetIntarrayMinIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMinIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MemorySegment SCIPgetIntarrayMinIdx$address() {
        return SCIPgetIntarrayMinIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetIntarrayMinIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static int SCIPgetIntarrayMinIdx(MemorySegment scip, MemorySegment intarray) {
        var mh$ = SCIPgetIntarrayMinIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIntarrayMinIdx", scip, intarray);
            }
            return (int)mh$.invokeExact(scip, intarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIntarrayMaxIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIntarrayMaxIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMaxIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static FunctionDescriptor SCIPgetIntarrayMaxIdx$descriptor() {
        return SCIPgetIntarrayMaxIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMaxIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MethodHandle SCIPgetIntarrayMaxIdx$handle() {
        return SCIPgetIntarrayMaxIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetIntarrayMaxIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static MemorySegment SCIPgetIntarrayMaxIdx$address() {
        return SCIPgetIntarrayMaxIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetIntarrayMaxIdx(SCIP *scip, SCIP_INTARRAY *intarray)
     * }
     */
    public static int SCIPgetIntarrayMaxIdx(MemorySegment scip, MemorySegment intarray) {
        var mh$ = SCIPgetIntarrayMaxIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIntarrayMaxIdx", scip, intarray);
            }
            return (int)mh$.invokeExact(scip, intarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateBoolarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBoolarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static FunctionDescriptor SCIPcreateBoolarray$descriptor() {
        return SCIPcreateBoolarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static MethodHandle SCIPcreateBoolarray$handle() {
        return SCIPcreateBoolarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static MemorySegment SCIPcreateBoolarray$address() {
        return SCIPcreateBoolarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static int SCIPcreateBoolarray(MemorySegment scip, MemorySegment boolarray) {
        var mh$ = SCIPcreateBoolarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBoolarray", scip, boolarray);
            }
            return (int)mh$.invokeExact(scip, boolarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeBoolarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeBoolarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static FunctionDescriptor SCIPfreeBoolarray$descriptor() {
        return SCIPfreeBoolarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static MethodHandle SCIPfreeBoolarray$handle() {
        return SCIPfreeBoolarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static MemorySegment SCIPfreeBoolarray$address() {
        return SCIPfreeBoolarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeBoolarray(SCIP *scip, SCIP_BOOLARRAY **boolarray)
     * }
     */
    public static int SCIPfreeBoolarray(MemorySegment scip, MemorySegment boolarray) {
        var mh$ = SCIPfreeBoolarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeBoolarray", scip, boolarray);
            }
            return (int)mh$.invokeExact(scip, boolarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPextendBoolarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPextendBoolarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray, int minidx, int maxidx)
     * }
     */
    public static FunctionDescriptor SCIPextendBoolarray$descriptor() {
        return SCIPextendBoolarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray, int minidx, int maxidx)
     * }
     */
    public static MethodHandle SCIPextendBoolarray$handle() {
        return SCIPextendBoolarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray, int minidx, int maxidx)
     * }
     */
    public static MemorySegment SCIPextendBoolarray$address() {
        return SCIPextendBoolarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray, int minidx, int maxidx)
     * }
     */
    public static int SCIPextendBoolarray(MemorySegment scip, MemorySegment boolarray, int minidx, int maxidx) {
        var mh$ = SCIPextendBoolarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPextendBoolarray", scip, boolarray, minidx, maxidx);
            }
            return (int)mh$.invokeExact(scip, boolarray, minidx, maxidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearBoolarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearBoolarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static FunctionDescriptor SCIPclearBoolarray$descriptor() {
        return SCIPclearBoolarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MethodHandle SCIPclearBoolarray$handle() {
        return SCIPclearBoolarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MemorySegment SCIPclearBoolarray$address() {
        return SCIPclearBoolarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearBoolarray(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static int SCIPclearBoolarray(MemorySegment scip, MemorySegment boolarray) {
        var mh$ = SCIPclearBoolarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearBoolarray", scip, boolarray);
            }
            return (int)mh$.invokeExact(scip, boolarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoolarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoolarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx)
     * }
     */
    public static FunctionDescriptor SCIPgetBoolarrayVal$descriptor() {
        return SCIPgetBoolarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx)
     * }
     */
    public static MethodHandle SCIPgetBoolarrayVal$handle() {
        return SCIPgetBoolarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx)
     * }
     */
    public static MemorySegment SCIPgetBoolarrayVal$address() {
        return SCIPgetBoolarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx)
     * }
     */
    public static int SCIPgetBoolarrayVal(MemorySegment scip, MemorySegment boolarray, int idx) {
        var mh$ = SCIPgetBoolarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoolarrayVal", scip, boolarray, idx);
            }
            return (int)mh$.invokeExact(scip, boolarray, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBoolarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBoolarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx, unsigned int val)
     * }
     */
    public static FunctionDescriptor SCIPsetBoolarrayVal$descriptor() {
        return SCIPsetBoolarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx, unsigned int val)
     * }
     */
    public static MethodHandle SCIPsetBoolarrayVal$handle() {
        return SCIPsetBoolarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx, unsigned int val)
     * }
     */
    public static MemorySegment SCIPsetBoolarrayVal$address() {
        return SCIPsetBoolarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolarrayVal(SCIP *scip, SCIP_BOOLARRAY *boolarray, int idx, unsigned int val)
     * }
     */
    public static int SCIPsetBoolarrayVal(MemorySegment scip, MemorySegment boolarray, int idx, int val) {
        var mh$ = SCIPsetBoolarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBoolarrayVal", scip, boolarray, idx, val);
            }
            return (int)mh$.invokeExact(scip, boolarray, idx, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoolarrayMinIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoolarrayMinIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMinIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static FunctionDescriptor SCIPgetBoolarrayMinIdx$descriptor() {
        return SCIPgetBoolarrayMinIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMinIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MethodHandle SCIPgetBoolarrayMinIdx$handle() {
        return SCIPgetBoolarrayMinIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMinIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MemorySegment SCIPgetBoolarrayMinIdx$address() {
        return SCIPgetBoolarrayMinIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMinIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static int SCIPgetBoolarrayMinIdx(MemorySegment scip, MemorySegment boolarray) {
        var mh$ = SCIPgetBoolarrayMinIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoolarrayMinIdx", scip, boolarray);
            }
            return (int)mh$.invokeExact(scip, boolarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoolarrayMaxIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoolarrayMaxIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMaxIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static FunctionDescriptor SCIPgetBoolarrayMaxIdx$descriptor() {
        return SCIPgetBoolarrayMaxIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMaxIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MethodHandle SCIPgetBoolarrayMaxIdx$handle() {
        return SCIPgetBoolarrayMaxIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMaxIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static MemorySegment SCIPgetBoolarrayMaxIdx$address() {
        return SCIPgetBoolarrayMaxIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetBoolarrayMaxIdx(SCIP *scip, SCIP_BOOLARRAY *boolarray)
     * }
     */
    public static int SCIPgetBoolarrayMaxIdx(MemorySegment scip, MemorySegment boolarray) {
        var mh$ = SCIPgetBoolarrayMaxIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoolarrayMaxIdx", scip, boolarray);
            }
            return (int)mh$.invokeExact(scip, boolarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreatePtrarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreatePtrarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static FunctionDescriptor SCIPcreatePtrarray$descriptor() {
        return SCIPcreatePtrarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static MethodHandle SCIPcreatePtrarray$handle() {
        return SCIPcreatePtrarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static MemorySegment SCIPcreatePtrarray$address() {
        return SCIPcreatePtrarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static int SCIPcreatePtrarray(MemorySegment scip, MemorySegment ptrarray) {
        var mh$ = SCIPcreatePtrarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreatePtrarray", scip, ptrarray);
            }
            return (int)mh$.invokeExact(scip, ptrarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreePtrarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreePtrarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static FunctionDescriptor SCIPfreePtrarray$descriptor() {
        return SCIPfreePtrarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static MethodHandle SCIPfreePtrarray$handle() {
        return SCIPfreePtrarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static MemorySegment SCIPfreePtrarray$address() {
        return SCIPfreePtrarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreePtrarray(SCIP *scip, SCIP_PTRARRAY **ptrarray)
     * }
     */
    public static int SCIPfreePtrarray(MemorySegment scip, MemorySegment ptrarray) {
        var mh$ = SCIPfreePtrarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreePtrarray", scip, ptrarray);
            }
            return (int)mh$.invokeExact(scip, ptrarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPextendPtrarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPextendPtrarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray, int minidx, int maxidx)
     * }
     */
    public static FunctionDescriptor SCIPextendPtrarray$descriptor() {
        return SCIPextendPtrarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray, int minidx, int maxidx)
     * }
     */
    public static MethodHandle SCIPextendPtrarray$handle() {
        return SCIPextendPtrarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray, int minidx, int maxidx)
     * }
     */
    public static MemorySegment SCIPextendPtrarray$address() {
        return SCIPextendPtrarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray, int minidx, int maxidx)
     * }
     */
    public static int SCIPextendPtrarray(MemorySegment scip, MemorySegment ptrarray, int minidx, int maxidx) {
        var mh$ = SCIPextendPtrarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPextendPtrarray", scip, ptrarray, minidx, maxidx);
            }
            return (int)mh$.invokeExact(scip, ptrarray, minidx, maxidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearPtrarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearPtrarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static FunctionDescriptor SCIPclearPtrarray$descriptor() {
        return SCIPclearPtrarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MethodHandle SCIPclearPtrarray$handle() {
        return SCIPclearPtrarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MemorySegment SCIPclearPtrarray$address() {
        return SCIPclearPtrarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearPtrarray(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static int SCIPclearPtrarray(MemorySegment scip, MemorySegment ptrarray) {
        var mh$ = SCIPclearPtrarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearPtrarray", scip, ptrarray);
            }
            return (int)mh$.invokeExact(scip, ptrarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPtrarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPtrarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPgetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx)
     * }
     */
    public static FunctionDescriptor SCIPgetPtrarrayVal$descriptor() {
        return SCIPgetPtrarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPgetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx)
     * }
     */
    public static MethodHandle SCIPgetPtrarrayVal$handle() {
        return SCIPgetPtrarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPgetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx)
     * }
     */
    public static MemorySegment SCIPgetPtrarrayVal$address() {
        return SCIPgetPtrarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPgetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx)
     * }
     */
    public static MemorySegment SCIPgetPtrarrayVal(MemorySegment scip, MemorySegment ptrarray, int idx) {
        var mh$ = SCIPgetPtrarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPtrarrayVal", scip, ptrarray, idx);
            }
            return (MemorySegment)mh$.invokeExact(scip, ptrarray, idx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPtrarrayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPtrarrayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx, void *val)
     * }
     */
    public static FunctionDescriptor SCIPsetPtrarrayVal$descriptor() {
        return SCIPsetPtrarrayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx, void *val)
     * }
     */
    public static MethodHandle SCIPsetPtrarrayVal$handle() {
        return SCIPsetPtrarrayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx, void *val)
     * }
     */
    public static MemorySegment SCIPsetPtrarrayVal$address() {
        return SCIPsetPtrarrayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPtrarrayVal(SCIP *scip, SCIP_PTRARRAY *ptrarray, int idx, void *val)
     * }
     */
    public static int SCIPsetPtrarrayVal(MemorySegment scip, MemorySegment ptrarray, int idx, MemorySegment val) {
        var mh$ = SCIPsetPtrarrayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPtrarrayVal", scip, ptrarray, idx, val);
            }
            return (int)mh$.invokeExact(scip, ptrarray, idx, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPtrarrayMinIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPtrarrayMinIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMinIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static FunctionDescriptor SCIPgetPtrarrayMinIdx$descriptor() {
        return SCIPgetPtrarrayMinIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMinIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MethodHandle SCIPgetPtrarrayMinIdx$handle() {
        return SCIPgetPtrarrayMinIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMinIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MemorySegment SCIPgetPtrarrayMinIdx$address() {
        return SCIPgetPtrarrayMinIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMinIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static int SCIPgetPtrarrayMinIdx(MemorySegment scip, MemorySegment ptrarray) {
        var mh$ = SCIPgetPtrarrayMinIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPtrarrayMinIdx", scip, ptrarray);
            }
            return (int)mh$.invokeExact(scip, ptrarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPtrarrayMaxIdx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPtrarrayMaxIdx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMaxIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static FunctionDescriptor SCIPgetPtrarrayMaxIdx$descriptor() {
        return SCIPgetPtrarrayMaxIdx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMaxIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MethodHandle SCIPgetPtrarrayMaxIdx$handle() {
        return SCIPgetPtrarrayMaxIdx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMaxIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static MemorySegment SCIPgetPtrarrayMaxIdx$address() {
        return SCIPgetPtrarrayMaxIdx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetPtrarrayMaxIdx(SCIP *scip, SCIP_PTRARRAY *ptrarray)
     * }
     */
    public static int SCIPgetPtrarrayMaxIdx(MemorySegment scip, MemorySegment ptrarray) {
        var mh$ = SCIPgetPtrarrayMaxIdx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPtrarrayMaxIdx", scip, ptrarray);
            }
            return (int)mh$.invokeExact(scip, ptrarray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateDisjointset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateDisjointset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset, int ncomponents)
     * }
     */
    public static FunctionDescriptor SCIPcreateDisjointset$descriptor() {
        return SCIPcreateDisjointset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset, int ncomponents)
     * }
     */
    public static MethodHandle SCIPcreateDisjointset$handle() {
        return SCIPcreateDisjointset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset, int ncomponents)
     * }
     */
    public static MemorySegment SCIPcreateDisjointset$address() {
        return SCIPcreateDisjointset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset, int ncomponents)
     * }
     */
    public static int SCIPcreateDisjointset(MemorySegment scip, MemorySegment djset, int ncomponents) {
        var mh$ = SCIPcreateDisjointset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateDisjointset", scip, djset, ncomponents);
            }
            return (int)mh$.invokeExact(scip, djset, ncomponents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeDisjointset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeDisjointset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset)
     * }
     */
    public static FunctionDescriptor SCIPfreeDisjointset$descriptor() {
        return SCIPfreeDisjointset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset)
     * }
     */
    public static MethodHandle SCIPfreeDisjointset$handle() {
        return SCIPfreeDisjointset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset)
     * }
     */
    public static MemorySegment SCIPfreeDisjointset$address() {
        return SCIPfreeDisjointset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeDisjointset(SCIP *scip, SCIP_DISJOINTSET **djset)
     * }
     */
    public static void SCIPfreeDisjointset(MemorySegment scip, MemorySegment djset) {
        var mh$ = SCIPfreeDisjointset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeDisjointset", scip, djset);
            }
            mh$.invokeExact(scip, djset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateDigraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateDigraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDigraph(SCIP *scip, SCIP_DIGRAPH **digraph, int nnodes)
     * }
     */
    public static FunctionDescriptor SCIPcreateDigraph$descriptor() {
        return SCIPcreateDigraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDigraph(SCIP *scip, SCIP_DIGRAPH **digraph, int nnodes)
     * }
     */
    public static MethodHandle SCIPcreateDigraph$handle() {
        return SCIPcreateDigraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDigraph(SCIP *scip, SCIP_DIGRAPH **digraph, int nnodes)
     * }
     */
    public static MemorySegment SCIPcreateDigraph$address() {
        return SCIPcreateDigraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDigraph(SCIP *scip, SCIP_DIGRAPH **digraph, int nnodes)
     * }
     */
    public static int SCIPcreateDigraph(MemorySegment scip, MemorySegment digraph, int nnodes) {
        var mh$ = SCIPcreateDigraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateDigraph", scip, digraph, nnodes);
            }
            return (int)mh$.invokeExact(scip, digraph, nnodes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyDigraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyDigraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyDigraph(SCIP *scip, SCIP_DIGRAPH **targetdigraph, SCIP_DIGRAPH *sourcedigraph)
     * }
     */
    public static FunctionDescriptor SCIPcopyDigraph$descriptor() {
        return SCIPcopyDigraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyDigraph(SCIP *scip, SCIP_DIGRAPH **targetdigraph, SCIP_DIGRAPH *sourcedigraph)
     * }
     */
    public static MethodHandle SCIPcopyDigraph$handle() {
        return SCIPcopyDigraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyDigraph(SCIP *scip, SCIP_DIGRAPH **targetdigraph, SCIP_DIGRAPH *sourcedigraph)
     * }
     */
    public static MemorySegment SCIPcopyDigraph$address() {
        return SCIPcopyDigraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyDigraph(SCIP *scip, SCIP_DIGRAPH **targetdigraph, SCIP_DIGRAPH *sourcedigraph)
     * }
     */
    public static int SCIPcopyDigraph(MemorySegment scip, MemorySegment targetdigraph, MemorySegment sourcedigraph) {
        var mh$ = SCIPcopyDigraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyDigraph", scip, targetdigraph, sourcedigraph);
            }
            return (int)mh$.invokeExact(scip, targetdigraph, sourcedigraph);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableDebugSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableDebugSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPenableDebugSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPenableDebugSol$descriptor() {
        return SCIPenableDebugSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPenableDebugSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPenableDebugSol$handle() {
        return SCIPenableDebugSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPenableDebugSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPenableDebugSol$address() {
        return SCIPenableDebugSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPenableDebugSol(SCIP *scip)
     * }
     */
    public static void SCIPenableDebugSol(MemorySegment scip) {
        var mh$ = SCIPenableDebugSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableDebugSol", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisableDebugSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisableDebugSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdisableDebugSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdisableDebugSol$descriptor() {
        return SCIPdisableDebugSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdisableDebugSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdisableDebugSol$handle() {
        return SCIPdisableDebugSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdisableDebugSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdisableDebugSol$address() {
        return SCIPdisableDebugSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdisableDebugSol(SCIP *scip)
     * }
     */
    public static void SCIPdisableDebugSol(MemorySegment scip) {
        var mh$ = SCIPdisableDebugSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisableDebugSol", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateDecomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateDecomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDecomp(SCIP *scip, SCIP_DECOMP **decomp, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static FunctionDescriptor SCIPcreateDecomp$descriptor() {
        return SCIPcreateDecomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDecomp(SCIP *scip, SCIP_DECOMP **decomp, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static MethodHandle SCIPcreateDecomp$handle() {
        return SCIPcreateDecomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDecomp(SCIP *scip, SCIP_DECOMP **decomp, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static MemorySegment SCIPcreateDecomp$address() {
        return SCIPcreateDecomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDecomp(SCIP *scip, SCIP_DECOMP **decomp, int nblocks, unsigned int original, unsigned int benderslabels)
     * }
     */
    public static int SCIPcreateDecomp(MemorySegment scip, MemorySegment decomp, int nblocks, int original, int benderslabels) {
        var mh$ = SCIPcreateDecomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateDecomp", scip, decomp, nblocks, original, benderslabels);
            }
            return (int)mh$.invokeExact(scip, decomp, nblocks, original, benderslabels);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeDecomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeDecomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeDecomp(SCIP *scip, SCIP_DECOMP **decomp)
     * }
     */
    public static FunctionDescriptor SCIPfreeDecomp$descriptor() {
        return SCIPfreeDecomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeDecomp(SCIP *scip, SCIP_DECOMP **decomp)
     * }
     */
    public static MethodHandle SCIPfreeDecomp$handle() {
        return SCIPfreeDecomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeDecomp(SCIP *scip, SCIP_DECOMP **decomp)
     * }
     */
    public static MemorySegment SCIPfreeDecomp$address() {
        return SCIPfreeDecomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeDecomp(SCIP *scip, SCIP_DECOMP **decomp)
     * }
     */
    public static void SCIPfreeDecomp(MemorySegment scip, MemorySegment decomp) {
        var mh$ = SCIPfreeDecomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeDecomp", scip, decomp);
            }
            mh$.invokeExact(scip, decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDecomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDecomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDecomp(SCIP *scip, SCIP_DECOMP *decomp)
     * }
     */
    public static FunctionDescriptor SCIPaddDecomp$descriptor() {
        return SCIPaddDecomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDecomp(SCIP *scip, SCIP_DECOMP *decomp)
     * }
     */
    public static MethodHandle SCIPaddDecomp$handle() {
        return SCIPaddDecomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDecomp(SCIP *scip, SCIP_DECOMP *decomp)
     * }
     */
    public static MemorySegment SCIPaddDecomp$address() {
        return SCIPaddDecomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDecomp(SCIP *scip, SCIP_DECOMP *decomp)
     * }
     */
    public static int SCIPaddDecomp(MemorySegment scip, MemorySegment decomp) {
        var mh$ = SCIPaddDecomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDecomp", scip, decomp);
            }
            return (int)mh$.invokeExact(scip, decomp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDecomps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDecomps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetDecomps(SCIP *scip, SCIP_DECOMP ***decomps, int *ndecomps, unsigned int original)
     * }
     */
    public static FunctionDescriptor SCIPgetDecomps$descriptor() {
        return SCIPgetDecomps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetDecomps(SCIP *scip, SCIP_DECOMP ***decomps, int *ndecomps, unsigned int original)
     * }
     */
    public static MethodHandle SCIPgetDecomps$handle() {
        return SCIPgetDecomps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetDecomps(SCIP *scip, SCIP_DECOMP ***decomps, int *ndecomps, unsigned int original)
     * }
     */
    public static MemorySegment SCIPgetDecomps$address() {
        return SCIPgetDecomps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetDecomps(SCIP *scip, SCIP_DECOMP ***decomps, int *ndecomps, unsigned int original)
     * }
     */
    public static void SCIPgetDecomps(MemorySegment scip, MemorySegment decomps, MemorySegment ndecomps, int original) {
        var mh$ = SCIPgetDecomps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDecomps", scip, decomps, ndecomps, original);
            }
            mh$.invokeExact(scip, decomps, ndecomps, original);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasConsOnlyLinkVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasConsOnlyLinkVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasConsOnlyLinkVars(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS *cons, unsigned int *hasonlylinkvars)
     * }
     */
    public static FunctionDescriptor SCIPhasConsOnlyLinkVars$descriptor() {
        return SCIPhasConsOnlyLinkVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasConsOnlyLinkVars(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS *cons, unsigned int *hasonlylinkvars)
     * }
     */
    public static MethodHandle SCIPhasConsOnlyLinkVars$handle() {
        return SCIPhasConsOnlyLinkVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasConsOnlyLinkVars(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS *cons, unsigned int *hasonlylinkvars)
     * }
     */
    public static MemorySegment SCIPhasConsOnlyLinkVars$address() {
        return SCIPhasConsOnlyLinkVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasConsOnlyLinkVars(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS *cons, unsigned int *hasonlylinkvars)
     * }
     */
    public static int SCIPhasConsOnlyLinkVars(MemorySegment scip, MemorySegment decomp, MemorySegment cons, MemorySegment hasonlylinkvars) {
        var mh$ = SCIPhasConsOnlyLinkVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasConsOnlyLinkVars", scip, decomp, cons, hasonlylinkvars);
            }
            return (int)mh$.invokeExact(scip, decomp, cons, hasonlylinkvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeDecompConsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeDecompConsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompConsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static FunctionDescriptor SCIPcomputeDecompConsLabels$descriptor() {
        return SCIPcomputeDecompConsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompConsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MethodHandle SCIPcomputeDecompConsLabels$handle() {
        return SCIPcomputeDecompConsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompConsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MemorySegment SCIPcomputeDecompConsLabels$address() {
        return SCIPcomputeDecompConsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompConsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static int SCIPcomputeDecompConsLabels(MemorySegment scip, MemorySegment decomp, MemorySegment conss, int nconss) {
        var mh$ = SCIPcomputeDecompConsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeDecompConsLabels", scip, decomp, conss, nconss);
            }
            return (int)mh$.invokeExact(scip, decomp, conss, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeDecompVarsLabels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeDecompVarsLabels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompVarsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static FunctionDescriptor SCIPcomputeDecompVarsLabels$descriptor() {
        return SCIPcomputeDecompVarsLabels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompVarsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MethodHandle SCIPcomputeDecompVarsLabels$handle() {
        return SCIPcomputeDecompVarsLabels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompVarsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MemorySegment SCIPcomputeDecompVarsLabels$address() {
        return SCIPcomputeDecompVarsLabels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompVarsLabels(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss)
     * }
     */
    public static int SCIPcomputeDecompVarsLabels(MemorySegment scip, MemorySegment decomp, MemorySegment conss, int nconss) {
        var mh$ = SCIPcomputeDecompVarsLabels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeDecompVarsLabels", scip, decomp, conss, nconss);
            }
            return (int)mh$.invokeExact(scip, decomp, conss, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPassignDecompLinkConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPassignDecompLinkConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPassignDecompLinkConss(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss, int *nskipconss)
     * }
     */
    public static FunctionDescriptor SCIPassignDecompLinkConss$descriptor() {
        return SCIPassignDecompLinkConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPassignDecompLinkConss(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss, int *nskipconss)
     * }
     */
    public static MethodHandle SCIPassignDecompLinkConss$handle() {
        return SCIPassignDecompLinkConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPassignDecompLinkConss(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss, int *nskipconss)
     * }
     */
    public static MemorySegment SCIPassignDecompLinkConss$address() {
        return SCIPassignDecompLinkConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPassignDecompLinkConss(SCIP *scip, SCIP_DECOMP *decomp, SCIP_CONS **conss, int nconss, int *nskipconss)
     * }
     */
    public static int SCIPassignDecompLinkConss(MemorySegment scip, MemorySegment decomp, MemorySegment conss, int nconss, MemorySegment nskipconss) {
        var mh$ = SCIPassignDecompLinkConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPassignDecompLinkConss", scip, decomp, conss, nconss, nskipconss);
            }
            return (int)mh$.invokeExact(scip, decomp, conss, nconss, nskipconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeDecompStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeDecompStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompStats(SCIP *scip, SCIP_DECOMP *decomp, unsigned int uselimits)
     * }
     */
    public static FunctionDescriptor SCIPcomputeDecompStats$descriptor() {
        return SCIPcomputeDecompStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompStats(SCIP *scip, SCIP_DECOMP *decomp, unsigned int uselimits)
     * }
     */
    public static MethodHandle SCIPcomputeDecompStats$handle() {
        return SCIPcomputeDecompStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompStats(SCIP *scip, SCIP_DECOMP *decomp, unsigned int uselimits)
     * }
     */
    public static MemorySegment SCIPcomputeDecompStats$address() {
        return SCIPcomputeDecompStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeDecompStats(SCIP *scip, SCIP_DECOMP *decomp, unsigned int uselimits)
     * }
     */
    public static int SCIPcomputeDecompStats(MemorySegment scip, MemorySegment decomp, int uselimits) {
        var mh$ = SCIPcomputeDecompStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeDecompStats", scip, decomp, uselimits);
            }
            return (int)mh$.invokeExact(scip, decomp, uselimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialog(SCIP *scip, SCIP_DIALOG **dialog, SCIP_RETCODE (*dialogcopy)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogexec)(SCIP *, SCIP_DIALOG *, SCIP_DIALOGHDLR *, SCIP_DIALOG **), SCIP_RETCODE (*dialogdesc)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogfree)(SCIP *, SCIP_DIALOG *), const char *name, const char *desc, unsigned int issubmenu, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeDialog$descriptor() {
        return SCIPincludeDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialog(SCIP *scip, SCIP_DIALOG **dialog, SCIP_RETCODE (*dialogcopy)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogexec)(SCIP *, SCIP_DIALOG *, SCIP_DIALOGHDLR *, SCIP_DIALOG **), SCIP_RETCODE (*dialogdesc)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogfree)(SCIP *, SCIP_DIALOG *), const char *name, const char *desc, unsigned int issubmenu, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static MethodHandle SCIPincludeDialog$handle() {
        return SCIPincludeDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialog(SCIP *scip, SCIP_DIALOG **dialog, SCIP_RETCODE (*dialogcopy)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogexec)(SCIP *, SCIP_DIALOG *, SCIP_DIALOGHDLR *, SCIP_DIALOG **), SCIP_RETCODE (*dialogdesc)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogfree)(SCIP *, SCIP_DIALOG *), const char *name, const char *desc, unsigned int issubmenu, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static MemorySegment SCIPincludeDialog$address() {
        return SCIPincludeDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialog(SCIP *scip, SCIP_DIALOG **dialog, SCIP_RETCODE (*dialogcopy)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogexec)(SCIP *, SCIP_DIALOG *, SCIP_DIALOGHDLR *, SCIP_DIALOG **), SCIP_RETCODE (*dialogdesc)(SCIP *, SCIP_DIALOG *), SCIP_RETCODE (*dialogfree)(SCIP *, SCIP_DIALOG *), const char *name, const char *desc, unsigned int issubmenu, SCIP_DIALOGDATA *dialogdata)
     * }
     */
    public static int SCIPincludeDialog(MemorySegment scip, MemorySegment dialog, MemorySegment dialogcopy, MemorySegment dialogexec, MemorySegment dialogdesc, MemorySegment dialogfree, MemorySegment name, MemorySegment desc, int issubmenu, MemorySegment dialogdata) {
        var mh$ = SCIPincludeDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDialog", scip, dialog, dialogcopy, dialogexec, dialogdesc, dialogfree, name, desc, issubmenu, dialogdata);
            }
            return (int)mh$.invokeExact(scip, dialog, dialogcopy, dialogexec, dialogdesc, dialogfree, name, desc, issubmenu, dialogdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexistsDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexistsDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPexistsDialog$descriptor() {
        return SCIPexistsDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPexistsDialog$handle() {
        return SCIPexistsDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPexistsDialog$address() {
        return SCIPexistsDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexistsDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPexistsDialog(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPexistsDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexistsDialog", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPcaptureDialog$descriptor() {
        return SCIPcaptureDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPcaptureDialog$handle() {
        return SCIPcaptureDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPcaptureDialog$address() {
        return SCIPcaptureDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPcaptureDialog(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPcaptureDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureDialog", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseDialog(SCIP *scip, SCIP_DIALOG **dialog)
     * }
     */
    public static FunctionDescriptor SCIPreleaseDialog$descriptor() {
        return SCIPreleaseDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseDialog(SCIP *scip, SCIP_DIALOG **dialog)
     * }
     */
    public static MethodHandle SCIPreleaseDialog$handle() {
        return SCIPreleaseDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseDialog(SCIP *scip, SCIP_DIALOG **dialog)
     * }
     */
    public static MemorySegment SCIPreleaseDialog$address() {
        return SCIPreleaseDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseDialog(SCIP *scip, SCIP_DIALOG **dialog)
     * }
     */
    public static int SCIPreleaseDialog(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPreleaseDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseDialog", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRootDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRootDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRootDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPsetRootDialog$descriptor() {
        return SCIPsetRootDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRootDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPsetRootDialog$handle() {
        return SCIPsetRootDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRootDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPsetRootDialog$address() {
        return SCIPsetRootDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRootDialog(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPsetRootDialog(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPsetRootDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRootDialog", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRootDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRootDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPgetRootDialog(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetRootDialog$descriptor() {
        return SCIPgetRootDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPgetRootDialog(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetRootDialog$handle() {
        return SCIPgetRootDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPgetRootDialog(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRootDialog$address() {
        return SCIPgetRootDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIALOG *SCIPgetRootDialog(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRootDialog(MemorySegment scip) {
        var mh$ = SCIPgetRootDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRootDialog", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDialogEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDialogEntry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogEntry(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOG *subdialog)
     * }
     */
    public static FunctionDescriptor SCIPaddDialogEntry$descriptor() {
        return SCIPaddDialogEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogEntry(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOG *subdialog)
     * }
     */
    public static MethodHandle SCIPaddDialogEntry$handle() {
        return SCIPaddDialogEntry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogEntry(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOG *subdialog)
     * }
     */
    public static MemorySegment SCIPaddDialogEntry$address() {
        return SCIPaddDialogEntry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogEntry(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOG *subdialog)
     * }
     */
    public static int SCIPaddDialogEntry(MemorySegment scip, MemorySegment dialog, MemorySegment subdialog) {
        var mh$ = SCIPaddDialogEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDialogEntry", scip, dialog, subdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, subdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDialogInputLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDialogInputLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogInputLine(SCIP *scip, const char *inputline)
     * }
     */
    public static FunctionDescriptor SCIPaddDialogInputLine$descriptor() {
        return SCIPaddDialogInputLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogInputLine(SCIP *scip, const char *inputline)
     * }
     */
    public static MethodHandle SCIPaddDialogInputLine$handle() {
        return SCIPaddDialogInputLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogInputLine(SCIP *scip, const char *inputline)
     * }
     */
    public static MemorySegment SCIPaddDialogInputLine$address() {
        return SCIPaddDialogInputLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogInputLine(SCIP *scip, const char *inputline)
     * }
     */
    public static int SCIPaddDialogInputLine(MemorySegment scip, MemorySegment inputline) {
        var mh$ = SCIPaddDialogInputLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDialogInputLine", scip, inputline);
            }
            return (int)mh$.invokeExact(scip, inputline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDialogHistoryLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDialogHistoryLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogHistoryLine(SCIP *scip, const char *inputline)
     * }
     */
    public static FunctionDescriptor SCIPaddDialogHistoryLine$descriptor() {
        return SCIPaddDialogHistoryLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogHistoryLine(SCIP *scip, const char *inputline)
     * }
     */
    public static MethodHandle SCIPaddDialogHistoryLine$handle() {
        return SCIPaddDialogHistoryLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogHistoryLine(SCIP *scip, const char *inputline)
     * }
     */
    public static MemorySegment SCIPaddDialogHistoryLine$address() {
        return SCIPaddDialogHistoryLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDialogHistoryLine(SCIP *scip, const char *inputline)
     * }
     */
    public static int SCIPaddDialogHistoryLine(MemorySegment scip, MemorySegment inputline) {
        var mh$ = SCIPaddDialogHistoryLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDialogHistoryLine", scip, inputline);
            }
            return (int)mh$.invokeExact(scip, inputline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartInteraction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartInteraction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartInteraction(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstartInteraction$descriptor() {
        return SCIPstartInteraction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartInteraction(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstartInteraction$handle() {
        return SCIPstartInteraction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartInteraction(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstartInteraction$address() {
        return SCIPstartInteraction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartInteraction(SCIP *scip)
     * }
     */
    public static int SCIPstartInteraction(MemorySegment scip) {
        var mh$ = SCIPstartInteraction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartInteraction", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDisp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDisp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDisp(SCIP *scip, const char *name, const char *desc, const char *header, SCIP_DISPSTATUS dispstatus, SCIP_RETCODE (*dispcopy)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispfree)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispoutput)(SCIP *, SCIP_DISP *, FILE *), SCIP_DISPDATA *dispdata, int width, int priority, int position, unsigned int stripline)
     * }
     */
    public static FunctionDescriptor SCIPincludeDisp$descriptor() {
        return SCIPincludeDisp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDisp(SCIP *scip, const char *name, const char *desc, const char *header, SCIP_DISPSTATUS dispstatus, SCIP_RETCODE (*dispcopy)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispfree)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispoutput)(SCIP *, SCIP_DISP *, FILE *), SCIP_DISPDATA *dispdata, int width, int priority, int position, unsigned int stripline)
     * }
     */
    public static MethodHandle SCIPincludeDisp$handle() {
        return SCIPincludeDisp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDisp(SCIP *scip, const char *name, const char *desc, const char *header, SCIP_DISPSTATUS dispstatus, SCIP_RETCODE (*dispcopy)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispfree)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispoutput)(SCIP *, SCIP_DISP *, FILE *), SCIP_DISPDATA *dispdata, int width, int priority, int position, unsigned int stripline)
     * }
     */
    public static MemorySegment SCIPincludeDisp$address() {
        return SCIPincludeDisp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDisp(SCIP *scip, const char *name, const char *desc, const char *header, SCIP_DISPSTATUS dispstatus, SCIP_RETCODE (*dispcopy)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispfree)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexit)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispinitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispexitsol)(SCIP *, SCIP_DISP *), SCIP_RETCODE (*dispoutput)(SCIP *, SCIP_DISP *, FILE *), SCIP_DISPDATA *dispdata, int width, int priority, int position, unsigned int stripline)
     * }
     */
    public static int SCIPincludeDisp(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment header, int dispstatus, MemorySegment dispcopy, MemorySegment dispfree, MemorySegment dispinit, MemorySegment dispexit, MemorySegment dispinitsol, MemorySegment dispexitsol, MemorySegment dispoutput, MemorySegment dispdata, int width, int priority, int position, int stripline) {
        var mh$ = SCIPincludeDisp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDisp", scip, name, desc, header, dispstatus, dispcopy, dispfree, dispinit, dispexit, dispinitsol, dispexitsol, dispoutput, dispdata, width, priority, position, stripline);
            }
            return (int)mh$.invokeExact(scip, name, desc, header, dispstatus, dispcopy, dispfree, dispinit, dispexit, dispinitsol, dispexitsol, dispoutput, dispdata, width, priority, position, stripline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindDisp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindDisp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DISP *SCIPfindDisp(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindDisp$descriptor() {
        return SCIPfindDisp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DISP *SCIPfindDisp(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindDisp$handle() {
        return SCIPfindDisp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DISP *SCIPfindDisp(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindDisp$address() {
        return SCIPfindDisp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DISP *SCIPfindDisp(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindDisp(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindDisp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindDisp", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDisps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDisps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DISP **SCIPgetDisps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDisps$descriptor() {
        return SCIPgetDisps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DISP **SCIPgetDisps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDisps$handle() {
        return SCIPgetDisps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DISP **SCIPgetDisps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDisps$address() {
        return SCIPgetDisps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DISP **SCIPgetDisps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDisps(MemorySegment scip) {
        var mh$ = SCIPgetDisps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDisps", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDisps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDisps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNDisps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDisps$descriptor() {
        return SCIPgetNDisps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNDisps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDisps$handle() {
        return SCIPgetNDisps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNDisps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDisps$address() {
        return SCIPgetNDisps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNDisps(SCIP *scip)
     * }
     */
    public static int SCIPgetNDisps(MemorySegment scip) {
        var mh$ = SCIPgetNDisps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDisps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPautoselectDisps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPautoselectDisps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPautoselectDisps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPautoselectDisps$descriptor() {
        return SCIPautoselectDisps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPautoselectDisps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPautoselectDisps$handle() {
        return SCIPautoselectDisps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPautoselectDisps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPautoselectDisps$address() {
        return SCIPautoselectDisps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPautoselectDisps(SCIP *scip)
     * }
     */
    public static int SCIPautoselectDisps(MemorySegment scip) {
        var mh$ = SCIPautoselectDisps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPautoselectDisps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgDispMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgDispMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPchgDispMode(SCIP_DISP *disp, SCIP_DISPMODE mode)
     * }
     */
    public static FunctionDescriptor SCIPchgDispMode$descriptor() {
        return SCIPchgDispMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPchgDispMode(SCIP_DISP *disp, SCIP_DISPMODE mode)
     * }
     */
    public static MethodHandle SCIPchgDispMode$handle() {
        return SCIPchgDispMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPchgDispMode(SCIP_DISP *disp, SCIP_DISPMODE mode)
     * }
     */
    public static MemorySegment SCIPchgDispMode$address() {
        return SCIPchgDispMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPchgDispMode(SCIP_DISP *disp, SCIP_DISPMODE mode)
     * }
     */
    public static void SCIPchgDispMode(MemorySegment disp, int mode) {
        var mh$ = SCIPchgDispMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgDispMode", disp, mode);
            }
            mh$.invokeExact(disp, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeEventhdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeEventhdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlr(SCIP *scip, const char *name, const char *desc, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **), SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeEventhdlr$descriptor() {
        return SCIPincludeEventhdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlr(SCIP *scip, const char *name, const char *desc, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **), SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeEventhdlr$handle() {
        return SCIPincludeEventhdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlr(SCIP *scip, const char *name, const char *desc, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **), SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeEventhdlr$address() {
        return SCIPincludeEventhdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlr(SCIP *scip, const char *name, const char *desc, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *), SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **), SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static int SCIPincludeEventhdlr(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment eventcopy, MemorySegment eventfree, MemorySegment eventinit, MemorySegment eventexit, MemorySegment eventinitsol, MemorySegment eventexitsol, MemorySegment eventdelete, MemorySegment eventexec, MemorySegment eventhdlrdata) {
        var mh$ = SCIPincludeEventhdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeEventhdlr", scip, name, desc, eventcopy, eventfree, eventinit, eventexit, eventinitsol, eventexitsol, eventdelete, eventexec, eventhdlrdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, eventcopy, eventfree, eventinit, eventexit, eventinitsol, eventexitsol, eventdelete, eventexec, eventhdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeEventhdlrBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeEventhdlrBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlrBasic(SCIP *scip, SCIP_EVENTHDLR **eventhdlrptr, const char *name, const char *desc, SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeEventhdlrBasic$descriptor() {
        return SCIPincludeEventhdlrBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlrBasic(SCIP *scip, SCIP_EVENTHDLR **eventhdlrptr, const char *name, const char *desc, SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeEventhdlrBasic$handle() {
        return SCIPincludeEventhdlrBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlrBasic(SCIP *scip, SCIP_EVENTHDLR **eventhdlrptr, const char *name, const char *desc, SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeEventhdlrBasic$address() {
        return SCIPincludeEventhdlrBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventhdlrBasic(SCIP *scip, SCIP_EVENTHDLR **eventhdlrptr, const char *name, const char *desc, SCIP_RETCODE (*eventexec)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENT *, SCIP_EVENTDATA *), SCIP_EVENTHDLRDATA *eventhdlrdata)
     * }
     */
    public static int SCIPincludeEventhdlrBasic(MemorySegment scip, MemorySegment eventhdlrptr, MemorySegment name, MemorySegment desc, MemorySegment eventexec, MemorySegment eventhdlrdata) {
        var mh$ = SCIPincludeEventhdlrBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeEventhdlrBasic", scip, eventhdlrptr, name, desc, eventexec, eventhdlrdata);
            }
            return (int)mh$.invokeExact(scip, eventhdlrptr, name, desc, eventexec, eventhdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrCopy(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrCopy$descriptor() {
        return SCIPsetEventhdlrCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrCopy(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrCopy$handle() {
        return SCIPsetEventhdlrCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrCopy(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrCopy$address() {
        return SCIPsetEventhdlrCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrCopy(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventcopy)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrCopy(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventcopy) {
        var mh$ = SCIPsetEventhdlrCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrCopy", scip, eventhdlr, eventcopy);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrFree(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrFree$descriptor() {
        return SCIPsetEventhdlrFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrFree(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrFree$handle() {
        return SCIPsetEventhdlrFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrFree(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrFree$address() {
        return SCIPsetEventhdlrFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrFree(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventfree)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrFree(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventfree) {
        var mh$ = SCIPsetEventhdlrFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrFree", scip, eventhdlr, eventfree);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrInit$descriptor() {
        return SCIPsetEventhdlrInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrInit$handle() {
        return SCIPsetEventhdlrInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrInit$address() {
        return SCIPsetEventhdlrInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrInit(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventinit) {
        var mh$ = SCIPsetEventhdlrInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrInit", scip, eventhdlr, eventinit);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrExit$descriptor() {
        return SCIPsetEventhdlrExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrExit$handle() {
        return SCIPsetEventhdlrExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrExit$address() {
        return SCIPsetEventhdlrExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExit(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexit)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrExit(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventexit) {
        var mh$ = SCIPsetEventhdlrExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrExit", scip, eventhdlr, eventexit);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrInitsol$descriptor() {
        return SCIPsetEventhdlrInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrInitsol$handle() {
        return SCIPsetEventhdlrInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrInitsol$address() {
        return SCIPsetEventhdlrInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrInitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventinitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrInitsol(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventinitsol) {
        var mh$ = SCIPsetEventhdlrInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrInitsol", scip, eventhdlr, eventinitsol);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrExitsol$descriptor() {
        return SCIPsetEventhdlrExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrExitsol$handle() {
        return SCIPsetEventhdlrExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrExitsol$address() {
        return SCIPsetEventhdlrExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrExitsol(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventexitsol)(SCIP *, SCIP_EVENTHDLR *))
     * }
     */
    public static int SCIPsetEventhdlrExitsol(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventexitsol) {
        var mh$ = SCIPsetEventhdlrExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrExitsol", scip, eventhdlr, eventexitsol);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEventhdlrDelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEventhdlrDelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrDelete(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **))
     * }
     */
    public static FunctionDescriptor SCIPsetEventhdlrDelete$descriptor() {
        return SCIPsetEventhdlrDelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrDelete(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **))
     * }
     */
    public static MethodHandle SCIPsetEventhdlrDelete$handle() {
        return SCIPsetEventhdlrDelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrDelete(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **))
     * }
     */
    public static MemorySegment SCIPsetEventhdlrDelete$address() {
        return SCIPsetEventhdlrDelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEventhdlrDelete(SCIP *scip, SCIP_EVENTHDLR *eventhdlr, SCIP_RETCODE (*eventdelete)(SCIP *, SCIP_EVENTHDLR *, SCIP_EVENTDATA **))
     * }
     */
    public static int SCIPsetEventhdlrDelete(MemorySegment scip, MemorySegment eventhdlr, MemorySegment eventdelete) {
        var mh$ = SCIPsetEventhdlrDelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEventhdlrDelete", scip, eventhdlr, eventdelete);
            }
            return (int)mh$.invokeExact(scip, eventhdlr, eventdelete);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindEventhdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindEventhdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR *SCIPfindEventhdlr(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindEventhdlr$descriptor() {
        return SCIPfindEventhdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR *SCIPfindEventhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindEventhdlr$handle() {
        return SCIPfindEventhdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR *SCIPfindEventhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindEventhdlr$address() {
        return SCIPfindEventhdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EVENTHDLR *SCIPfindEventhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindEventhdlr(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindEventhdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindEventhdlr", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetEventhdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetEventhdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR **SCIPgetEventhdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetEventhdlrs$descriptor() {
        return SCIPgetEventhdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR **SCIPgetEventhdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetEventhdlrs$handle() {
        return SCIPgetEventhdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EVENTHDLR **SCIPgetEventhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetEventhdlrs$address() {
        return SCIPgetEventhdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EVENTHDLR **SCIPgetEventhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetEventhdlrs(MemorySegment scip) {
        var mh$ = SCIPgetEventhdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetEventhdlrs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNEventhdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNEventhdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNEventhdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNEventhdlrs$descriptor() {
        return SCIPgetNEventhdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNEventhdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNEventhdlrs$handle() {
        return SCIPgetNEventhdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNEventhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNEventhdlrs$address() {
        return SCIPgetNEventhdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNEventhdlrs(SCIP *scip)
     * }
     */
    public static int SCIPgetNEventhdlrs(MemorySegment scip) {
        var mh$ = SCIPgetNEventhdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNEventhdlrs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcatchEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcatchEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static FunctionDescriptor SCIPcatchEvent$descriptor() {
        return SCIPcatchEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MethodHandle SCIPcatchEvent$handle() {
        return SCIPcatchEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MemorySegment SCIPcatchEvent$address() {
        return SCIPcatchEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static int SCIPcatchEvent(MemorySegment scip, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, MemorySegment filterpos) {
        var mh$ = SCIPcatchEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcatchEvent", scip, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdropEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdropEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static FunctionDescriptor SCIPdropEvent$descriptor() {
        return SCIPdropEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MethodHandle SCIPdropEvent$handle() {
        return SCIPdropEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MemorySegment SCIPdropEvent$address() {
        return SCIPdropEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropEvent(SCIP *scip, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static int SCIPdropEvent(MemorySegment scip, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, int filterpos) {
        var mh$ = SCIPdropEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdropEvent", scip, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcatchVarEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcatchVarEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static FunctionDescriptor SCIPcatchVarEvent$descriptor() {
        return SCIPcatchVarEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MethodHandle SCIPcatchVarEvent$handle() {
        return SCIPcatchVarEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MemorySegment SCIPcatchVarEvent$address() {
        return SCIPcatchVarEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static int SCIPcatchVarEvent(MemorySegment scip, MemorySegment var_, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, MemorySegment filterpos) {
        var mh$ = SCIPcatchVarEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcatchVarEvent", scip, var_, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, var_, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdropVarEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdropVarEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static FunctionDescriptor SCIPdropVarEvent$descriptor() {
        return SCIPdropVarEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MethodHandle SCIPdropVarEvent$handle() {
        return SCIPdropVarEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MemorySegment SCIPdropVarEvent$address() {
        return SCIPdropVarEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropVarEvent(SCIP *scip, SCIP_VAR *var, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static int SCIPdropVarEvent(MemorySegment scip, MemorySegment var_, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, int filterpos) {
        var mh$ = SCIPdropVarEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdropVarEvent", scip, var_, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, var_, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcatchRowEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcatchRowEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static FunctionDescriptor SCIPcatchRowEvent$descriptor() {
        return SCIPcatchRowEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MethodHandle SCIPcatchRowEvent$handle() {
        return SCIPcatchRowEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static MemorySegment SCIPcatchRowEvent$address() {
        return SCIPcatchRowEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcatchRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int *filterpos)
     * }
     */
    public static int SCIPcatchRowEvent(MemorySegment scip, MemorySegment row, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, MemorySegment filterpos) {
        var mh$ = SCIPcatchRowEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcatchRowEvent", scip, row, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, row, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdropRowEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdropRowEvent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static FunctionDescriptor SCIPdropRowEvent$descriptor() {
        return SCIPdropRowEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MethodHandle SCIPdropRowEvent$handle() {
        return SCIPdropRowEvent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static MemorySegment SCIPdropRowEvent$address() {
        return SCIPdropRowEvent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdropRowEvent(SCIP *scip, SCIP_ROW *row, SCIP_EVENTTYPE eventtype, SCIP_EVENTHDLR *eventhdlr, SCIP_EVENTDATA *eventdata, int filterpos)
     * }
     */
    public static int SCIPdropRowEvent(MemorySegment scip, MemorySegment row, long eventtype, MemorySegment eventhdlr, MemorySegment eventdata, int filterpos) {
        var mh$ = SCIPdropRowEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdropRowEvent", scip, row, eventtype, eventhdlr, eventdata, filterpos);
            }
            return (int)mh$.invokeExact(scip, row, eventtype, eventhdlr, eventdata, filterpos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlr(SCIP *scip, SCIP_EXPRHDLR **exprhdlr, const char *name, const char *desc, unsigned int precedence, SCIP_RETCODE (*eval)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_EXPRHDLRDATA *data)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlr$descriptor() {
        return SCIPincludeExprhdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlr(SCIP *scip, SCIP_EXPRHDLR **exprhdlr, const char *name, const char *desc, unsigned int precedence, SCIP_RETCODE (*eval)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_EXPRHDLRDATA *data)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlr$handle() {
        return SCIPincludeExprhdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlr(SCIP *scip, SCIP_EXPRHDLR **exprhdlr, const char *name, const char *desc, unsigned int precedence, SCIP_RETCODE (*eval)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_EXPRHDLRDATA *data)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlr$address() {
        return SCIPincludeExprhdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlr(SCIP *scip, SCIP_EXPRHDLR **exprhdlr, const char *name, const char *desc, unsigned int precedence, SCIP_RETCODE (*eval)(SCIP *, SCIP_EXPR *, double *, SCIP_SOL *), SCIP_EXPRHDLRDATA *data)
     * }
     */
    public static int SCIPincludeExprhdlr(MemorySegment scip, MemorySegment exprhdlr, MemorySegment name, MemorySegment desc, int precedence, MemorySegment eval, MemorySegment data) {
        var mh$ = SCIPincludeExprhdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlr", scip, exprhdlr, name, desc, precedence, eval, data);
            }
            return (int)mh$.invokeExact(scip, exprhdlr, name, desc, precedence, eval, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR **SCIPgetExprhdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrs$descriptor() {
        return SCIPgetExprhdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR **SCIPgetExprhdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrs$handle() {
        return SCIPgetExprhdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR **SCIPgetExprhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrs$address() {
        return SCIPgetExprhdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR **SCIPgetExprhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrs(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNExprhdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNExprhdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNExprhdlrs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNExprhdlrs$descriptor() {
        return SCIPgetNExprhdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNExprhdlrs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNExprhdlrs$handle() {
        return SCIPgetNExprhdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNExprhdlrs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNExprhdlrs$address() {
        return SCIPgetNExprhdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNExprhdlrs(SCIP *scip)
     * }
     */
    public static int SCIPgetNExprhdlrs(MemorySegment scip) {
        var mh$ = SCIPgetNExprhdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNExprhdlrs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindExprhdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindExprhdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPfindExprhdlr(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindExprhdlr$descriptor() {
        return SCIPfindExprhdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPfindExprhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindExprhdlr$handle() {
        return SCIPfindExprhdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPfindExprhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindExprhdlr$address() {
        return SCIPfindExprhdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPfindExprhdlr(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindExprhdlr(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindExprhdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindExprhdlr", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrVar(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrVar$descriptor() {
        return SCIPgetExprhdlrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrVar(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrVar$handle() {
        return SCIPgetExprhdlrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrVar(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrVar$address() {
        return SCIPgetExprhdlrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrVar(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrVar(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrVar", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrValue(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrValue$descriptor() {
        return SCIPgetExprhdlrValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrValue(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrValue$handle() {
        return SCIPgetExprhdlrValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrValue(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrValue$address() {
        return SCIPgetExprhdlrValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrValue(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrValue(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrValue", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrSum(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrSum$descriptor() {
        return SCIPgetExprhdlrSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrSum(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrSum$handle() {
        return SCIPgetExprhdlrSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrSum(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrSum$address() {
        return SCIPgetExprhdlrSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrSum(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrSum(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrSum", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrProduct(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrProduct$descriptor() {
        return SCIPgetExprhdlrProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrProduct(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrProduct$handle() {
        return SCIPgetExprhdlrProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrProduct(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrProduct$address() {
        return SCIPgetExprhdlrProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrProduct(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrProduct(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrProduct", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprhdlrPower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprhdlrPower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrPower(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprhdlrPower$descriptor() {
        return SCIPgetExprhdlrPower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrPower(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprhdlrPower$handle() {
        return SCIPgetExprhdlrPower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrPower(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrPower$address() {
        return SCIPgetExprhdlrPower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRHDLR *SCIPgetExprhdlrPower(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprhdlrPower(MemorySegment scip) {
        var mh$ = SCIPgetExprhdlrPower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprhdlrPower", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, int nchildren, SCIP_EXPR **children, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExpr$descriptor() {
        return SCIPcreateExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, int nchildren, SCIP_EXPR **children, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExpr$handle() {
        return SCIPcreateExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, int nchildren, SCIP_EXPR **children, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExpr$address() {
        return SCIPcreateExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, int nchildren, SCIP_EXPR **children, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExpr(MemorySegment scip, MemorySegment expr, MemorySegment exprhdlr, MemorySegment exprdata, int nchildren, MemorySegment children, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExpr", scip, expr, exprhdlr, exprdata, nchildren, children, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, exprhdlr, exprdata, nchildren, children, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExpr2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExpr2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr2(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, SCIP_EXPR *child1, SCIP_EXPR *child2, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExpr2$descriptor() {
        return SCIPcreateExpr2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr2(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, SCIP_EXPR *child1, SCIP_EXPR *child2, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExpr2$handle() {
        return SCIPcreateExpr2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr2(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, SCIP_EXPR *child1, SCIP_EXPR *child2, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExpr2$address() {
        return SCIPcreateExpr2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpr2(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPRHDLR *exprhdlr, SCIP_EXPRDATA *exprdata, SCIP_EXPR *child1, SCIP_EXPR *child2, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExpr2(MemorySegment scip, MemorySegment expr, MemorySegment exprhdlr, MemorySegment exprdata, MemorySegment child1, MemorySegment child2, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExpr2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExpr2", scip, expr, exprhdlr, exprdata, child1, child2, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, exprhdlr, exprdata, child1, child2, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprQuadratic(SCIP *scip, SCIP_EXPR **expr, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprQuadratic$descriptor() {
        return SCIPcreateExprQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprQuadratic(SCIP *scip, SCIP_EXPR **expr, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprQuadratic$handle() {
        return SCIPcreateExprQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprQuadratic(SCIP *scip, SCIP_EXPR **expr, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprQuadratic$address() {
        return SCIPcreateExprQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprQuadratic(SCIP *scip, SCIP_EXPR **expr, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprQuadratic(MemorySegment scip, MemorySegment expr, int nlinvars, MemorySegment linvars, MemorySegment lincoefs, int nquadterms, MemorySegment quadvars1, MemorySegment quadvars2, MemorySegment quadcoefs, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprQuadratic", scip, expr, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprMonomial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprMonomial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprMonomial(SCIP *scip, SCIP_EXPR **expr, int nfactors, SCIP_VAR **vars, double *exponents, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprMonomial$descriptor() {
        return SCIPcreateExprMonomial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprMonomial(SCIP *scip, SCIP_EXPR **expr, int nfactors, SCIP_VAR **vars, double *exponents, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprMonomial$handle() {
        return SCIPcreateExprMonomial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprMonomial(SCIP *scip, SCIP_EXPR **expr, int nfactors, SCIP_VAR **vars, double *exponents, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprMonomial$address() {
        return SCIPcreateExprMonomial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprMonomial(SCIP *scip, SCIP_EXPR **expr, int nfactors, SCIP_VAR **vars, double *exponents, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprMonomial(MemorySegment scip, MemorySegment expr, int nfactors, MemorySegment vars, MemorySegment exponents, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprMonomial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprMonomial", scip, expr, nfactors, vars, exponents, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, nfactors, vars, exponents, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPappendExprChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPappendExprChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprChild(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child)
     * }
     */
    public static FunctionDescriptor SCIPappendExprChild$descriptor() {
        return SCIPappendExprChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprChild(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child)
     * }
     */
    public static MethodHandle SCIPappendExprChild$handle() {
        return SCIPappendExprChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprChild(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child)
     * }
     */
    public static MemorySegment SCIPappendExprChild$address() {
        return SCIPappendExprChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprChild(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child)
     * }
     */
    public static int SCIPappendExprChild(MemorySegment scip, MemorySegment expr, MemorySegment child) {
        var mh$ = SCIPappendExprChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPappendExprChild", scip, expr, child);
            }
            return (int)mh$.invokeExact(scip, expr, child);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreplaceExprChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreplaceExprChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceExprChild(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_EXPR *newchild)
     * }
     */
    public static FunctionDescriptor SCIPreplaceExprChild$descriptor() {
        return SCIPreplaceExprChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceExprChild(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_EXPR *newchild)
     * }
     */
    public static MethodHandle SCIPreplaceExprChild$handle() {
        return SCIPreplaceExprChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceExprChild(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_EXPR *newchild)
     * }
     */
    public static MemorySegment SCIPreplaceExprChild$address() {
        return SCIPreplaceExprChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceExprChild(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_EXPR *newchild)
     * }
     */
    public static int SCIPreplaceExprChild(MemorySegment scip, MemorySegment expr, int childidx, MemorySegment newchild) {
        var mh$ = SCIPreplaceExprChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreplaceExprChild", scip, expr, childidx, newchild);
            }
            return (int)mh$.invokeExact(scip, expr, childidx, newchild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPremoveExprChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPremoveExprChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveExprChildren(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPremoveExprChildren$descriptor() {
        return SCIPremoveExprChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveExprChildren(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPremoveExprChildren$handle() {
        return SCIPremoveExprChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveExprChildren(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPremoveExprChildren$address() {
        return SCIPremoveExprChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveExprChildren(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPremoveExprChildren(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPremoveExprChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPremoveExprChildren", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

