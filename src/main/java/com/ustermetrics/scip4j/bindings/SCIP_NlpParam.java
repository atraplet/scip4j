// Generated by jextract

package com.ustermetrics.scip4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct SCIP_NlpParam {
 *     double lobjlimit;
 *     double feastol;
 *     double opttol;
 *     double solvertol;
 *     double timelimit;
 *     int iterlimit;
 *     unsigned short verblevel;
 *     SCIP_NLPPARAM_FASTFAIL fastfail;
 *     unsigned int expectinfeas;
 *     unsigned int warmstart;
 *     const char *caller;
 * }
 * }
 */
public class SCIP_NlpParam {

    SCIP_NlpParam() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        scip_h.C_DOUBLE.withName("lobjlimit"),
        scip_h.C_DOUBLE.withName("feastol"),
        scip_h.C_DOUBLE.withName("opttol"),
        scip_h.C_DOUBLE.withName("solvertol"),
        scip_h.C_DOUBLE.withName("timelimit"),
        scip_h.C_INT.withName("iterlimit"),
        scip_h.C_SHORT.withName("verblevel"),
        MemoryLayout.paddingLayout(2),
        scip_h.C_INT.withName("fastfail"),
        scip_h.C_INT.withName("expectinfeas"),
        scip_h.C_INT.withName("warmstart"),
        MemoryLayout.paddingLayout(4),
        scip_h.C_POINTER.withName("caller")
    ).withName("SCIP_NlpParam");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfDouble lobjlimit$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("lobjlimit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double lobjlimit
     * }
     */
    public static final OfDouble lobjlimit$layout() {
        return lobjlimit$LAYOUT;
    }

    private static final long lobjlimit$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double lobjlimit
     * }
     */
    public static final long lobjlimit$offset() {
        return lobjlimit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double lobjlimit
     * }
     */
    public static double lobjlimit(MemorySegment struct) {
        return struct.get(lobjlimit$LAYOUT, lobjlimit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double lobjlimit
     * }
     */
    public static void lobjlimit(MemorySegment struct, double fieldValue) {
        struct.set(lobjlimit$LAYOUT, lobjlimit$OFFSET, fieldValue);
    }

    private static final OfDouble feastol$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("feastol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double feastol
     * }
     */
    public static final OfDouble feastol$layout() {
        return feastol$LAYOUT;
    }

    private static final long feastol$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double feastol
     * }
     */
    public static final long feastol$offset() {
        return feastol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double feastol
     * }
     */
    public static double feastol(MemorySegment struct) {
        return struct.get(feastol$LAYOUT, feastol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double feastol
     * }
     */
    public static void feastol(MemorySegment struct, double fieldValue) {
        struct.set(feastol$LAYOUT, feastol$OFFSET, fieldValue);
    }

    private static final OfDouble opttol$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("opttol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double opttol
     * }
     */
    public static final OfDouble opttol$layout() {
        return opttol$LAYOUT;
    }

    private static final long opttol$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double opttol
     * }
     */
    public static final long opttol$offset() {
        return opttol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double opttol
     * }
     */
    public static double opttol(MemorySegment struct) {
        return struct.get(opttol$LAYOUT, opttol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double opttol
     * }
     */
    public static void opttol(MemorySegment struct, double fieldValue) {
        struct.set(opttol$LAYOUT, opttol$OFFSET, fieldValue);
    }

    private static final OfDouble solvertol$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("solvertol"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double solvertol
     * }
     */
    public static final OfDouble solvertol$layout() {
        return solvertol$LAYOUT;
    }

    private static final long solvertol$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double solvertol
     * }
     */
    public static final long solvertol$offset() {
        return solvertol$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double solvertol
     * }
     */
    public static double solvertol(MemorySegment struct) {
        return struct.get(solvertol$LAYOUT, solvertol$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double solvertol
     * }
     */
    public static void solvertol(MemorySegment struct, double fieldValue) {
        struct.set(solvertol$LAYOUT, solvertol$OFFSET, fieldValue);
    }

    private static final OfDouble timelimit$LAYOUT = (OfDouble)$LAYOUT.select(groupElement("timelimit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * double timelimit
     * }
     */
    public static final OfDouble timelimit$layout() {
        return timelimit$LAYOUT;
    }

    private static final long timelimit$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * double timelimit
     * }
     */
    public static final long timelimit$offset() {
        return timelimit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * double timelimit
     * }
     */
    public static double timelimit(MemorySegment struct) {
        return struct.get(timelimit$LAYOUT, timelimit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * double timelimit
     * }
     */
    public static void timelimit(MemorySegment struct, double fieldValue) {
        struct.set(timelimit$LAYOUT, timelimit$OFFSET, fieldValue);
    }

    private static final OfInt iterlimit$LAYOUT = (OfInt)$LAYOUT.select(groupElement("iterlimit"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int iterlimit
     * }
     */
    public static final OfInt iterlimit$layout() {
        return iterlimit$LAYOUT;
    }

    private static final long iterlimit$OFFSET = 40;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int iterlimit
     * }
     */
    public static final long iterlimit$offset() {
        return iterlimit$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int iterlimit
     * }
     */
    public static int iterlimit(MemorySegment struct) {
        return struct.get(iterlimit$LAYOUT, iterlimit$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int iterlimit
     * }
     */
    public static void iterlimit(MemorySegment struct, int fieldValue) {
        struct.set(iterlimit$LAYOUT, iterlimit$OFFSET, fieldValue);
    }

    private static final OfShort verblevel$LAYOUT = (OfShort)$LAYOUT.select(groupElement("verblevel"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned short verblevel
     * }
     */
    public static final OfShort verblevel$layout() {
        return verblevel$LAYOUT;
    }

    private static final long verblevel$OFFSET = 44;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned short verblevel
     * }
     */
    public static final long verblevel$offset() {
        return verblevel$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned short verblevel
     * }
     */
    public static short verblevel(MemorySegment struct) {
        return struct.get(verblevel$LAYOUT, verblevel$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned short verblevel
     * }
     */
    public static void verblevel(MemorySegment struct, short fieldValue) {
        struct.set(verblevel$LAYOUT, verblevel$OFFSET, fieldValue);
    }

    private static final OfInt fastfail$LAYOUT = (OfInt)$LAYOUT.select(groupElement("fastfail"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * SCIP_NLPPARAM_FASTFAIL fastfail
     * }
     */
    public static final OfInt fastfail$layout() {
        return fastfail$LAYOUT;
    }

    private static final long fastfail$OFFSET = 48;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * SCIP_NLPPARAM_FASTFAIL fastfail
     * }
     */
    public static final long fastfail$offset() {
        return fastfail$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * SCIP_NLPPARAM_FASTFAIL fastfail
     * }
     */
    public static int fastfail(MemorySegment struct) {
        return struct.get(fastfail$LAYOUT, fastfail$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * SCIP_NLPPARAM_FASTFAIL fastfail
     * }
     */
    public static void fastfail(MemorySegment struct, int fieldValue) {
        struct.set(fastfail$LAYOUT, fastfail$OFFSET, fieldValue);
    }

    private static final OfInt expectinfeas$LAYOUT = (OfInt)$LAYOUT.select(groupElement("expectinfeas"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int expectinfeas
     * }
     */
    public static final OfInt expectinfeas$layout() {
        return expectinfeas$LAYOUT;
    }

    private static final long expectinfeas$OFFSET = 52;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int expectinfeas
     * }
     */
    public static final long expectinfeas$offset() {
        return expectinfeas$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int expectinfeas
     * }
     */
    public static int expectinfeas(MemorySegment struct) {
        return struct.get(expectinfeas$LAYOUT, expectinfeas$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int expectinfeas
     * }
     */
    public static void expectinfeas(MemorySegment struct, int fieldValue) {
        struct.set(expectinfeas$LAYOUT, expectinfeas$OFFSET, fieldValue);
    }

    private static final OfInt warmstart$LAYOUT = (OfInt)$LAYOUT.select(groupElement("warmstart"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int warmstart
     * }
     */
    public static final OfInt warmstart$layout() {
        return warmstart$LAYOUT;
    }

    private static final long warmstart$OFFSET = 56;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int warmstart
     * }
     */
    public static final long warmstart$offset() {
        return warmstart$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int warmstart
     * }
     */
    public static int warmstart(MemorySegment struct) {
        return struct.get(warmstart$LAYOUT, warmstart$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int warmstart
     * }
     */
    public static void warmstart(MemorySegment struct, int fieldValue) {
        struct.set(warmstart$LAYOUT, warmstart$OFFSET, fieldValue);
    }

    private static final AddressLayout caller$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("caller"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *caller
     * }
     */
    public static final AddressLayout caller$layout() {
        return caller$LAYOUT;
    }

    private static final long caller$OFFSET = 64;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *caller
     * }
     */
    public static final long caller$offset() {
        return caller$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *caller
     * }
     */
    public static MemorySegment caller(MemorySegment struct) {
        return struct.get(caller$LAYOUT, caller$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *caller
     * }
     */
    public static void caller(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(caller$LAYOUT, caller$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

