// Generated by jextract

package com.ustermetrics.scip4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class scip_h_1 extends scip_h_2 {

    scip_h_1() {
        // Should not be called directly
    }

    private static class SCIPgetVarSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarSol(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarSol$descriptor() {
        return SCIPgetVarSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarSol(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarSol$handle() {
        return SCIPgetVarSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarSol(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarSol$address() {
        return SCIPgetVarSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarSol(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarSol(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarSol", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarSols(SCIP *scip, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPgetVarSols$descriptor() {
        return SCIPgetVarSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarSols(SCIP *scip, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MethodHandle SCIPgetVarSols$handle() {
        return SCIPgetVarSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarSols(SCIP *scip, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MemorySegment SCIPgetVarSols$address() {
        return SCIPgetVarSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarSols(SCIP *scip, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static int SCIPgetVarSols(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment vals) {
        var mh$ = SCIPgetVarSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarSols", scip, nvars, vars, vals);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearRelaxSolVals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearRelaxSolVals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRelaxSolVals(SCIP *scip, SCIP_RELAX *relax)
     * }
     */
    public static FunctionDescriptor SCIPclearRelaxSolVals$descriptor() {
        return SCIPclearRelaxSolVals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRelaxSolVals(SCIP *scip, SCIP_RELAX *relax)
     * }
     */
    public static MethodHandle SCIPclearRelaxSolVals$handle() {
        return SCIPclearRelaxSolVals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRelaxSolVals(SCIP *scip, SCIP_RELAX *relax)
     * }
     */
    public static MemorySegment SCIPclearRelaxSolVals$address() {
        return SCIPclearRelaxSolVals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearRelaxSolVals(SCIP *scip, SCIP_RELAX *relax)
     * }
     */
    public static int SCIPclearRelaxSolVals(MemorySegment scip, MemorySegment relax) {
        var mh$ = SCIPclearRelaxSolVals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearRelaxSolVals", scip, relax);
            }
            return (int)mh$.invokeExact(scip, relax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVal(SCIP *scip, SCIP_RELAX *relax, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxSolVal$descriptor() {
        return SCIPsetRelaxSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVal(SCIP *scip, SCIP_RELAX *relax, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPsetRelaxSolVal$handle() {
        return SCIPsetRelaxSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVal(SCIP *scip, SCIP_RELAX *relax, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPsetRelaxSolVal$address() {
        return SCIPsetRelaxSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVal(SCIP *scip, SCIP_RELAX *relax, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPsetRelaxSolVal(MemorySegment scip, MemorySegment relax, MemorySegment var_, double val) {
        var mh$ = SCIPsetRelaxSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxSolVal", scip, relax, var_, val);
            }
            return (int)mh$.invokeExact(scip, relax, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxSolVals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxSolVals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVals(SCIP *scip, SCIP_RELAX *relax, int nvars, SCIP_VAR **vars, double *vals, unsigned int includeslp)
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxSolVals$descriptor() {
        return SCIPsetRelaxSolVals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVals(SCIP *scip, SCIP_RELAX *relax, int nvars, SCIP_VAR **vars, double *vals, unsigned int includeslp)
     * }
     */
    public static MethodHandle SCIPsetRelaxSolVals$handle() {
        return SCIPsetRelaxSolVals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVals(SCIP *scip, SCIP_RELAX *relax, int nvars, SCIP_VAR **vars, double *vals, unsigned int includeslp)
     * }
     */
    public static MemorySegment SCIPsetRelaxSolVals$address() {
        return SCIPsetRelaxSolVals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolVals(SCIP *scip, SCIP_RELAX *relax, int nvars, SCIP_VAR **vars, double *vals, unsigned int includeslp)
     * }
     */
    public static int SCIPsetRelaxSolVals(MemorySegment scip, MemorySegment relax, int nvars, MemorySegment vars, MemorySegment vals, int includeslp) {
        var mh$ = SCIPsetRelaxSolVals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxSolVals", scip, relax, nvars, vars, vals, includeslp);
            }
            return (int)mh$.invokeExact(scip, relax, nvars, vars, vals, includeslp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxSolValsSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxSolValsSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolValsSol(SCIP *scip, SCIP_RELAX *relax, SCIP_SOL *sol, unsigned int includeslp)
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxSolValsSol$descriptor() {
        return SCIPsetRelaxSolValsSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolValsSol(SCIP *scip, SCIP_RELAX *relax, SCIP_SOL *sol, unsigned int includeslp)
     * }
     */
    public static MethodHandle SCIPsetRelaxSolValsSol$handle() {
        return SCIPsetRelaxSolValsSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolValsSol(SCIP *scip, SCIP_RELAX *relax, SCIP_SOL *sol, unsigned int includeslp)
     * }
     */
    public static MemorySegment SCIPsetRelaxSolValsSol$address() {
        return SCIPsetRelaxSolValsSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxSolValsSol(SCIP *scip, SCIP_RELAX *relax, SCIP_SOL *sol, unsigned int includeslp)
     * }
     */
    public static int SCIPsetRelaxSolValsSol(MemorySegment scip, MemorySegment relax, MemorySegment sol, int includeslp) {
        var mh$ = SCIPsetRelaxSolValsSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxSolValsSol", scip, relax, sol, includeslp);
            }
            return (int)mh$.invokeExact(scip, relax, sol, includeslp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelaxSolValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelaxSolValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelaxSolValid(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisRelaxSolValid$descriptor() {
        return SCIPisRelaxSolValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelaxSolValid(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisRelaxSolValid$handle() {
        return SCIPisRelaxSolValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelaxSolValid(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisRelaxSolValid$address() {
        return SCIPisRelaxSolValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelaxSolValid(SCIP *scip)
     * }
     */
    public static int SCIPisRelaxSolValid(MemorySegment scip) {
        var mh$ = SCIPisRelaxSolValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelaxSolValid", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkRelaxSolValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkRelaxSolValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolValid(SCIP *scip, SCIP_RELAX *relax, unsigned int includeslp)
     * }
     */
    public static FunctionDescriptor SCIPmarkRelaxSolValid$descriptor() {
        return SCIPmarkRelaxSolValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolValid(SCIP *scip, SCIP_RELAX *relax, unsigned int includeslp)
     * }
     */
    public static MethodHandle SCIPmarkRelaxSolValid$handle() {
        return SCIPmarkRelaxSolValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolValid(SCIP *scip, SCIP_RELAX *relax, unsigned int includeslp)
     * }
     */
    public static MemorySegment SCIPmarkRelaxSolValid$address() {
        return SCIPmarkRelaxSolValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolValid(SCIP *scip, SCIP_RELAX *relax, unsigned int includeslp)
     * }
     */
    public static int SCIPmarkRelaxSolValid(MemorySegment scip, MemorySegment relax, int includeslp) {
        var mh$ = SCIPmarkRelaxSolValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkRelaxSolValid", scip, relax, includeslp);
            }
            return (int)mh$.invokeExact(scip, relax, includeslp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkRelaxSolInvalid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkRelaxSolInvalid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolInvalid(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPmarkRelaxSolInvalid$descriptor() {
        return SCIPmarkRelaxSolInvalid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolInvalid(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPmarkRelaxSolInvalid$handle() {
        return SCIPmarkRelaxSolInvalid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolInvalid(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPmarkRelaxSolInvalid$address() {
        return SCIPmarkRelaxSolInvalid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkRelaxSolInvalid(SCIP *scip)
     * }
     */
    public static int SCIPmarkRelaxSolInvalid(MemorySegment scip) {
        var mh$ = SCIPmarkRelaxSolInvalid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkRelaxSolInvalid", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRelaxSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRelaxSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetRelaxSolVal$descriptor() {
        return SCIPgetRelaxSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetRelaxSolVal$handle() {
        return SCIPgetRelaxSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetRelaxSolVal$address() {
        return SCIPgetRelaxSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRelaxSolVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetRelaxSolVal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetRelaxSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRelaxSolVal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRelaxSolObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRelaxSolObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolObj(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetRelaxSolObj$descriptor() {
        return SCIPgetRelaxSolObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolObj(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetRelaxSolObj$handle() {
        return SCIPgetRelaxSolObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRelaxSolObj(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRelaxSolObj$address() {
        return SCIPgetRelaxSolObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRelaxSolObj(SCIP *scip)
     * }
     */
    public static double SCIPgetRelaxSolObj(MemorySegment scip) {
        var mh$ = SCIPgetRelaxSolObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRelaxSolObj", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisStrongbranchDownFirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisStrongbranchDownFirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisStrongbranchDownFirst(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPisStrongbranchDownFirst$descriptor() {
        return SCIPisStrongbranchDownFirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisStrongbranchDownFirst(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPisStrongbranchDownFirst$handle() {
        return SCIPisStrongbranchDownFirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisStrongbranchDownFirst(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPisStrongbranchDownFirst$address() {
        return SCIPisStrongbranchDownFirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisStrongbranchDownFirst(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPisStrongbranchDownFirst(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPisStrongbranchDownFirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisStrongbranchDownFirst", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartStrongbranch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartStrongbranch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartStrongbranch(SCIP *scip, unsigned int enablepropagation)
     * }
     */
    public static FunctionDescriptor SCIPstartStrongbranch$descriptor() {
        return SCIPstartStrongbranch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartStrongbranch(SCIP *scip, unsigned int enablepropagation)
     * }
     */
    public static MethodHandle SCIPstartStrongbranch$handle() {
        return SCIPstartStrongbranch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartStrongbranch(SCIP *scip, unsigned int enablepropagation)
     * }
     */
    public static MemorySegment SCIPstartStrongbranch$address() {
        return SCIPstartStrongbranch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartStrongbranch(SCIP *scip, unsigned int enablepropagation)
     * }
     */
    public static int SCIPstartStrongbranch(MemorySegment scip, int enablepropagation) {
        var mh$ = SCIPstartStrongbranch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartStrongbranch", scip, enablepropagation);
            }
            return (int)mh$.invokeExact(scip, enablepropagation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPendStrongbranch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPendStrongbranch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendStrongbranch(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPendStrongbranch$descriptor() {
        return SCIPendStrongbranch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendStrongbranch(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPendStrongbranch$handle() {
        return SCIPendStrongbranch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendStrongbranch(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPendStrongbranch$address() {
        return SCIPendStrongbranch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendStrongbranch(SCIP *scip)
     * }
     */
    public static int SCIPendStrongbranch(MemorySegment scip) {
        var mh$ = SCIPendStrongbranch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPendStrongbranch", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchFrac(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchFrac$descriptor() {
        return SCIPgetVarStrongbranchFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchFrac(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchFrac$handle() {
        return SCIPgetVarStrongbranchFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchFrac(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchFrac$address() {
        return SCIPgetVarStrongbranchFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchFrac(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static int SCIPgetVarStrongbranchFrac(MemorySegment scip, MemorySegment var_, int itlim, int idempotent, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment downinf, MemorySegment upinf, MemorySegment downconflict, MemorySegment upconflict, MemorySegment lperror) {
        var mh$ = SCIPgetVarStrongbranchFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchFrac", scip, var_, itlim, idempotent, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
            }
            return (int)mh$.invokeExact(scip, var_, itlim, idempotent, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchWithPropagation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchWithPropagation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchWithPropagation(SCIP *scip, SCIP_VAR *var, double solval, double lpobjval, int itlim, int maxproprounds, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, long long *ndomredsdown, long long *ndomredsup, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror, double *newlbs, double *newubs)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchWithPropagation$descriptor() {
        return SCIPgetVarStrongbranchWithPropagation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchWithPropagation(SCIP *scip, SCIP_VAR *var, double solval, double lpobjval, int itlim, int maxproprounds, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, long long *ndomredsdown, long long *ndomredsup, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror, double *newlbs, double *newubs)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchWithPropagation$handle() {
        return SCIPgetVarStrongbranchWithPropagation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchWithPropagation(SCIP *scip, SCIP_VAR *var, double solval, double lpobjval, int itlim, int maxproprounds, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, long long *ndomredsdown, long long *ndomredsup, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror, double *newlbs, double *newubs)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchWithPropagation$address() {
        return SCIPgetVarStrongbranchWithPropagation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchWithPropagation(SCIP *scip, SCIP_VAR *var, double solval, double lpobjval, int itlim, int maxproprounds, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, long long *ndomredsdown, long long *ndomredsup, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror, double *newlbs, double *newubs)
     * }
     */
    public static int SCIPgetVarStrongbranchWithPropagation(MemorySegment scip, MemorySegment var_, double solval, double lpobjval, int itlim, int maxproprounds, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment ndomredsdown, MemorySegment ndomredsup, MemorySegment downinf, MemorySegment upinf, MemorySegment downconflict, MemorySegment upconflict, MemorySegment lperror, MemorySegment newlbs, MemorySegment newubs) {
        var mh$ = SCIPgetVarStrongbranchWithPropagation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchWithPropagation", scip, var_, solval, lpobjval, itlim, maxproprounds, down, up, downvalid, upvalid, ndomredsdown, ndomredsup, downinf, upinf, downconflict, upconflict, lperror, newlbs, newubs);
            }
            return (int)mh$.invokeExact(scip, var_, solval, lpobjval, itlim, maxproprounds, down, up, downvalid, upvalid, ndomredsdown, ndomredsup, downinf, upinf, downconflict, upconflict, lperror, newlbs, newubs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchInt(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchInt$descriptor() {
        return SCIPgetVarStrongbranchInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchInt(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchInt$handle() {
        return SCIPgetVarStrongbranchInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchInt(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchInt$address() {
        return SCIPgetVarStrongbranchInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchInt(SCIP *scip, SCIP_VAR *var, int itlim, unsigned int idempotent, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static int SCIPgetVarStrongbranchInt(MemorySegment scip, MemorySegment var_, int itlim, int idempotent, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment downinf, MemorySegment upinf, MemorySegment downconflict, MemorySegment upconflict, MemorySegment lperror) {
        var mh$ = SCIPgetVarStrongbranchInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchInt", scip, var_, itlim, idempotent, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
            }
            return (int)mh$.invokeExact(scip, var_, itlim, idempotent, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsStrongbranchesFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsStrongbranchesFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesFrac(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsStrongbranchesFrac$descriptor() {
        return SCIPgetVarsStrongbranchesFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesFrac(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MethodHandle SCIPgetVarsStrongbranchesFrac$handle() {
        return SCIPgetVarsStrongbranchesFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesFrac(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MemorySegment SCIPgetVarsStrongbranchesFrac$address() {
        return SCIPgetVarsStrongbranchesFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesFrac(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static int SCIPgetVarsStrongbranchesFrac(MemorySegment scip, MemorySegment vars, int nvars, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment downinf, MemorySegment upinf, MemorySegment downconflict, MemorySegment upconflict, MemorySegment lperror) {
        var mh$ = SCIPgetVarsStrongbranchesFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsStrongbranchesFrac", scip, vars, nvars, itlim, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, itlim, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsStrongbranchesInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsStrongbranchesInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesInt(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsStrongbranchesInt$descriptor() {
        return SCIPgetVarsStrongbranchesInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesInt(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MethodHandle SCIPgetVarsStrongbranchesInt$handle() {
        return SCIPgetVarsStrongbranchesInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesInt(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static MemorySegment SCIPgetVarsStrongbranchesInt$address() {
        return SCIPgetVarsStrongbranchesInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsStrongbranchesInt(SCIP *scip, SCIP_VAR **vars, int nvars, int itlim, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, unsigned int *downinf, unsigned int *upinf, unsigned int *downconflict, unsigned int *upconflict, unsigned int *lperror)
     * }
     */
    public static int SCIPgetVarsStrongbranchesInt(MemorySegment scip, MemorySegment vars, int nvars, int itlim, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment downinf, MemorySegment upinf, MemorySegment downconflict, MemorySegment upconflict, MemorySegment lperror) {
        var mh$ = SCIPgetVarsStrongbranchesInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsStrongbranchesInt", scip, vars, nvars, itlim, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, itlim, down, up, downvalid, upvalid, downinf, upinf, downconflict, upconflict, lperror);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLastStrongbranchLPSolStat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLastStrongbranchLPSolStat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLastStrongbranchLPSolStat(SCIP *scip, SCIP_BRANCHDIR branchdir)
     * }
     */
    public static FunctionDescriptor SCIPgetLastStrongbranchLPSolStat$descriptor() {
        return SCIPgetLastStrongbranchLPSolStat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLastStrongbranchLPSolStat(SCIP *scip, SCIP_BRANCHDIR branchdir)
     * }
     */
    public static MethodHandle SCIPgetLastStrongbranchLPSolStat$handle() {
        return SCIPgetLastStrongbranchLPSolStat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLastStrongbranchLPSolStat(SCIP *scip, SCIP_BRANCHDIR branchdir)
     * }
     */
    public static MemorySegment SCIPgetLastStrongbranchLPSolStat$address() {
        return SCIPgetLastStrongbranchLPSolStat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLastStrongbranchLPSolStat(SCIP *scip, SCIP_BRANCHDIR branchdir)
     * }
     */
    public static int SCIPgetLastStrongbranchLPSolStat(MemorySegment scip, int branchdir) {
        var mh$ = SCIPgetLastStrongbranchLPSolStat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLastStrongbranchLPSolStat", scip, branchdir);
            }
            return (int)mh$.invokeExact(scip, branchdir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchLast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchLast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchLast(SCIP *scip, SCIP_VAR *var, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, double *solval, double *lpobjval)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchLast$descriptor() {
        return SCIPgetVarStrongbranchLast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchLast(SCIP *scip, SCIP_VAR *var, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, double *solval, double *lpobjval)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchLast$handle() {
        return SCIPgetVarStrongbranchLast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchLast(SCIP *scip, SCIP_VAR *var, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, double *solval, double *lpobjval)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchLast$address() {
        return SCIPgetVarStrongbranchLast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarStrongbranchLast(SCIP *scip, SCIP_VAR *var, double *down, double *up, unsigned int *downvalid, unsigned int *upvalid, double *solval, double *lpobjval)
     * }
     */
    public static int SCIPgetVarStrongbranchLast(MemorySegment scip, MemorySegment var_, MemorySegment down, MemorySegment up, MemorySegment downvalid, MemorySegment upvalid, MemorySegment solval, MemorySegment lpobjval) {
        var mh$ = SCIPgetVarStrongbranchLast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchLast", scip, var_, down, up, downvalid, upvalid, solval, lpobjval);
            }
            return (int)mh$.invokeExact(scip, var_, down, up, downvalid, upvalid, solval, lpobjval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetVarStrongbranchData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_LONG_LONG,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetVarStrongbranchData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarStrongbranchData(SCIP *scip, SCIP_VAR *var, double lpobjval, double primsol, double down, double up, unsigned int downvalid, unsigned int upvalid, long long iter, int itlim)
     * }
     */
    public static FunctionDescriptor SCIPsetVarStrongbranchData$descriptor() {
        return SCIPsetVarStrongbranchData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarStrongbranchData(SCIP *scip, SCIP_VAR *var, double lpobjval, double primsol, double down, double up, unsigned int downvalid, unsigned int upvalid, long long iter, int itlim)
     * }
     */
    public static MethodHandle SCIPsetVarStrongbranchData$handle() {
        return SCIPsetVarStrongbranchData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarStrongbranchData(SCIP *scip, SCIP_VAR *var, double lpobjval, double primsol, double down, double up, unsigned int downvalid, unsigned int upvalid, long long iter, int itlim)
     * }
     */
    public static MemorySegment SCIPsetVarStrongbranchData$address() {
        return SCIPsetVarStrongbranchData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarStrongbranchData(SCIP *scip, SCIP_VAR *var, double lpobjval, double primsol, double down, double up, unsigned int downvalid, unsigned int upvalid, long long iter, int itlim)
     * }
     */
    public static int SCIPsetVarStrongbranchData(MemorySegment scip, MemorySegment var_, double lpobjval, double primsol, double down, double up, int downvalid, int upvalid, long iter, int itlim) {
        var mh$ = SCIPsetVarStrongbranchData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetVarStrongbranchData", scip, var_, lpobjval, primsol, down, up, downvalid, upvalid, iter, itlim);
            }
            return (int)mh$.invokeExact(scip, var_, lpobjval, primsol, down, up, downvalid, upvalid, iter, itlim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtryStrongbranchLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtryStrongbranchLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryStrongbranchLPSol(SCIP *scip, unsigned int *foundsol, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPtryStrongbranchLPSol$descriptor() {
        return SCIPtryStrongbranchLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryStrongbranchLPSol(SCIP *scip, unsigned int *foundsol, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPtryStrongbranchLPSol$handle() {
        return SCIPtryStrongbranchLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryStrongbranchLPSol(SCIP *scip, unsigned int *foundsol, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPtryStrongbranchLPSol$address() {
        return SCIPtryStrongbranchLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryStrongbranchLPSol(SCIP *scip, unsigned int *foundsol, unsigned int *cutoff)
     * }
     */
    public static int SCIPtryStrongbranchLPSol(MemorySegment scip, MemorySegment foundsol, MemorySegment cutoff) {
        var mh$ = SCIPtryStrongbranchLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtryStrongbranchLPSol", scip, foundsol, cutoff);
            }
            return (int)mh$.invokeExact(scip, foundsol, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchNode(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchNode$descriptor() {
        return SCIPgetVarStrongbranchNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchNode(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchNode$handle() {
        return SCIPgetVarStrongbranchNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchNode(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchNode$address() {
        return SCIPgetVarStrongbranchNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchNode(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static long SCIPgetVarStrongbranchNode(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarStrongbranchNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchNode", scip, var_);
            }
            return (long)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarStrongbranchLPAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarStrongbranchLPAge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchLPAge(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarStrongbranchLPAge$descriptor() {
        return SCIPgetVarStrongbranchLPAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchLPAge(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarStrongbranchLPAge$handle() {
        return SCIPgetVarStrongbranchLPAge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchLPAge(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarStrongbranchLPAge$address() {
        return SCIPgetVarStrongbranchLPAge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetVarStrongbranchLPAge(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static long SCIPgetVarStrongbranchLPAge(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarStrongbranchLPAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarStrongbranchLPAge", scip, var_);
            }
            return (long)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarNStrongbranchs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarNStrongbranchs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetVarNStrongbranchs(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarNStrongbranchs$descriptor() {
        return SCIPgetVarNStrongbranchs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetVarNStrongbranchs(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarNStrongbranchs$handle() {
        return SCIPgetVarNStrongbranchs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetVarNStrongbranchs(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarNStrongbranchs$address() {
        return SCIPgetVarNStrongbranchs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetVarNStrongbranchs(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPgetVarNStrongbranchs(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarNStrongbranchs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarNStrongbranchs", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarLocksType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarLocksType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocksType(SCIP *scip, SCIP_VAR *var, SCIP_LOCKTYPE locktype, int nlocksdown, int nlocksup)
     * }
     */
    public static FunctionDescriptor SCIPaddVarLocksType$descriptor() {
        return SCIPaddVarLocksType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocksType(SCIP *scip, SCIP_VAR *var, SCIP_LOCKTYPE locktype, int nlocksdown, int nlocksup)
     * }
     */
    public static MethodHandle SCIPaddVarLocksType$handle() {
        return SCIPaddVarLocksType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocksType(SCIP *scip, SCIP_VAR *var, SCIP_LOCKTYPE locktype, int nlocksdown, int nlocksup)
     * }
     */
    public static MemorySegment SCIPaddVarLocksType$address() {
        return SCIPaddVarLocksType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocksType(SCIP *scip, SCIP_VAR *var, SCIP_LOCKTYPE locktype, int nlocksdown, int nlocksup)
     * }
     */
    public static int SCIPaddVarLocksType(MemorySegment scip, MemorySegment var_, int locktype, int nlocksdown, int nlocksup) {
        var mh$ = SCIPaddVarLocksType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarLocksType", scip, var_, locktype, nlocksdown, nlocksup);
            }
            return (int)mh$.invokeExact(scip, var_, locktype, nlocksdown, nlocksup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarLocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarLocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocks(SCIP *scip, SCIP_VAR *var, int nlocksdown, int nlocksup)
     * }
     */
    public static FunctionDescriptor SCIPaddVarLocks$descriptor() {
        return SCIPaddVarLocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocks(SCIP *scip, SCIP_VAR *var, int nlocksdown, int nlocksup)
     * }
     */
    public static MethodHandle SCIPaddVarLocks$handle() {
        return SCIPaddVarLocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocks(SCIP *scip, SCIP_VAR *var, int nlocksdown, int nlocksup)
     * }
     */
    public static MemorySegment SCIPaddVarLocks$address() {
        return SCIPaddVarLocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarLocks(SCIP *scip, SCIP_VAR *var, int nlocksdown, int nlocksup)
     * }
     */
    public static int SCIPaddVarLocks(MemorySegment scip, MemorySegment var_, int nlocksdown, int nlocksup) {
        var mh$ = SCIPaddVarLocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarLocks", scip, var_, nlocksdown, nlocksup);
            }
            return (int)mh$.invokeExact(scip, var_, nlocksdown, nlocksup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlockVarCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlockVarCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static FunctionDescriptor SCIPlockVarCons$descriptor() {
        return SCIPlockVarCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static MethodHandle SCIPlockVarCons$handle() {
        return SCIPlockVarCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static MemorySegment SCIPlockVarCons$address() {
        return SCIPlockVarCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static int SCIPlockVarCons(MemorySegment scip, MemorySegment var_, MemorySegment cons, int lockdown, int lockup) {
        var mh$ = SCIPlockVarCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlockVarCons", scip, var_, cons, lockdown, lockup);
            }
            return (int)mh$.invokeExact(scip, var_, cons, lockdown, lockup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPunlockVarCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPunlockVarCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static FunctionDescriptor SCIPunlockVarCons$descriptor() {
        return SCIPunlockVarCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static MethodHandle SCIPunlockVarCons$handle() {
        return SCIPunlockVarCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static MemorySegment SCIPunlockVarCons$address() {
        return SCIPunlockVarCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlockVarCons(SCIP *scip, SCIP_VAR *var, SCIP_CONS *cons, unsigned int lockdown, unsigned int lockup)
     * }
     */
    public static int SCIPunlockVarCons(MemorySegment scip, MemorySegment var_, MemorySegment cons, int lockdown, int lockup) {
        var mh$ = SCIPunlockVarCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPunlockVarCons", scip, var_, cons, lockdown, lockup);
            }
            return (int)mh$.invokeExact(scip, var_, cons, lockdown, lockup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObj(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static FunctionDescriptor SCIPchgVarObj$descriptor() {
        return SCIPchgVarObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObj(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MethodHandle SCIPchgVarObj$handle() {
        return SCIPchgVarObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObj(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MemorySegment SCIPchgVarObj$address() {
        return SCIPchgVarObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObj(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static int SCIPchgVarObj(MemorySegment scip, MemorySegment var_, double newobj) {
        var mh$ = SCIPchgVarObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarObj", scip, var_, newobj);
            }
            return (int)mh$.invokeExact(scip, var_, newobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarObj(SCIP *scip, SCIP_VAR *var, double addobj)
     * }
     */
    public static FunctionDescriptor SCIPaddVarObj$descriptor() {
        return SCIPaddVarObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarObj(SCIP *scip, SCIP_VAR *var, double addobj)
     * }
     */
    public static MethodHandle SCIPaddVarObj$handle() {
        return SCIPaddVarObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarObj(SCIP *scip, SCIP_VAR *var, double addobj)
     * }
     */
    public static MemorySegment SCIPaddVarObj$address() {
        return SCIPaddVarObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarObj(SCIP *scip, SCIP_VAR *var, double addobj)
     * }
     */
    public static int SCIPaddVarObj(MemorySegment scip, MemorySegment var_, double addobj) {
        var mh$ = SCIPaddVarObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarObj", scip, var_, addobj);
            }
            return (int)mh$.invokeExact(scip, var_, addobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPadjustedVarLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPadjustedVarLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPadjustedVarLb(SCIP *scip, SCIP_VAR *var, double lb)
     * }
     */
    public static FunctionDescriptor SCIPadjustedVarLb$descriptor() {
        return SCIPadjustedVarLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPadjustedVarLb(SCIP *scip, SCIP_VAR *var, double lb)
     * }
     */
    public static MethodHandle SCIPadjustedVarLb$handle() {
        return SCIPadjustedVarLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPadjustedVarLb(SCIP *scip, SCIP_VAR *var, double lb)
     * }
     */
    public static MemorySegment SCIPadjustedVarLb$address() {
        return SCIPadjustedVarLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPadjustedVarLb(SCIP *scip, SCIP_VAR *var, double lb)
     * }
     */
    public static double SCIPadjustedVarLb(MemorySegment scip, MemorySegment var_, double lb) {
        var mh$ = SCIPadjustedVarLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPadjustedVarLb", scip, var_, lb);
            }
            return (double)mh$.invokeExact(scip, var_, lb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPadjustedVarUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPadjustedVarUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPadjustedVarUb(SCIP *scip, SCIP_VAR *var, double ub)
     * }
     */
    public static FunctionDescriptor SCIPadjustedVarUb$descriptor() {
        return SCIPadjustedVarUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPadjustedVarUb(SCIP *scip, SCIP_VAR *var, double ub)
     * }
     */
    public static MethodHandle SCIPadjustedVarUb$handle() {
        return SCIPadjustedVarUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPadjustedVarUb(SCIP *scip, SCIP_VAR *var, double ub)
     * }
     */
    public static MemorySegment SCIPadjustedVarUb$address() {
        return SCIPadjustedVarUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPadjustedVarUb(SCIP *scip, SCIP_VAR *var, double ub)
     * }
     */
    public static double SCIPadjustedVarUb(MemorySegment scip, MemorySegment var_, double ub) {
        var mh$ = SCIPadjustedVarUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPadjustedVarUb", scip, var_, ub);
            }
            return (double)mh$.invokeExact(scip, var_, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLb$descriptor() {
        return SCIPchgVarLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarLb$handle() {
        return SCIPchgVarLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarLb$address() {
        return SCIPchgVarLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarLb(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLb", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUb$descriptor() {
        return SCIPchgVarUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarUb$handle() {
        return SCIPchgVarUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarUb$address() {
        return SCIPchgVarUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUb(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarUb(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUb", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLbNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLbNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLbNode$descriptor() {
        return SCIPchgVarLbNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarLbNode$handle() {
        return SCIPchgVarLbNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarLbNode$address() {
        return SCIPchgVarLbNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarLbNode(MemorySegment scip, MemorySegment node, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarLbNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLbNode", scip, node, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, node, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUbNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUbNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUbNode$descriptor() {
        return SCIPchgVarUbNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarUbNode$handle() {
        return SCIPchgVarUbNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarUbNode$address() {
        return SCIPchgVarUbNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbNode(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarUbNode(MemorySegment scip, MemorySegment node, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarUbNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUbNode", scip, node, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, node, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLbGlobal$descriptor() {
        return SCIPchgVarLbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarLbGlobal$handle() {
        return SCIPchgVarLbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarLbGlobal$address() {
        return SCIPchgVarLbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarLbGlobal(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarLbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLbGlobal", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUbGlobal$descriptor() {
        return SCIPchgVarUbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarUbGlobal$handle() {
        return SCIPchgVarUbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarUbGlobal$address() {
        return SCIPchgVarUbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarUbGlobal(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarUbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUbGlobal", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLbLazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLbLazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbLazy(SCIP *scip, SCIP_VAR *var, double lazylb)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLbLazy$descriptor() {
        return SCIPchgVarLbLazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbLazy(SCIP *scip, SCIP_VAR *var, double lazylb)
     * }
     */
    public static MethodHandle SCIPchgVarLbLazy$handle() {
        return SCIPchgVarLbLazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbLazy(SCIP *scip, SCIP_VAR *var, double lazylb)
     * }
     */
    public static MemorySegment SCIPchgVarLbLazy$address() {
        return SCIPchgVarLbLazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbLazy(SCIP *scip, SCIP_VAR *var, double lazylb)
     * }
     */
    public static int SCIPchgVarLbLazy(MemorySegment scip, MemorySegment var_, double lazylb) {
        var mh$ = SCIPchgVarLbLazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLbLazy", scip, var_, lazylb);
            }
            return (int)mh$.invokeExact(scip, var_, lazylb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUbLazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUbLazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbLazy(SCIP *scip, SCIP_VAR *var, double lazyub)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUbLazy$descriptor() {
        return SCIPchgVarUbLazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbLazy(SCIP *scip, SCIP_VAR *var, double lazyub)
     * }
     */
    public static MethodHandle SCIPchgVarUbLazy$handle() {
        return SCIPchgVarUbLazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbLazy(SCIP *scip, SCIP_VAR *var, double lazyub)
     * }
     */
    public static MemorySegment SCIPchgVarUbLazy$address() {
        return SCIPchgVarUbLazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbLazy(SCIP *scip, SCIP_VAR *var, double lazyub)
     * }
     */
    public static int SCIPchgVarUbLazy(MemorySegment scip, MemorySegment var_, double lazyub) {
        var mh$ = SCIPchgVarUbLazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUbLazy", scip, var_, lazyub);
            }
            return (int)mh$.invokeExact(scip, var_, lazyub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtightenVarLb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtightenVarLb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPtightenVarLb$descriptor() {
        return SCIPtightenVarLb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPtightenVarLb$handle() {
        return SCIPtightenVarLb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPtightenVarLb$address() {
        return SCIPtightenVarLb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPtightenVarLb(MemorySegment scip, MemorySegment var_, double newbound, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPtightenVarLb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtightenVarLb", scip, var_, newbound, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtightenVarUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtightenVarUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPtightenVarUb$descriptor() {
        return SCIPtightenVarUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPtightenVarUb$handle() {
        return SCIPtightenVarUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPtightenVarUb$address() {
        return SCIPtightenVarUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUb(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPtightenVarUb(MemorySegment scip, MemorySegment var_, double newbound, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPtightenVarUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtightenVarUb", scip, var_, newbound, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarFixCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarFixCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixCons(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarFixCons$descriptor() {
        return SCIPinferVarFixCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixCons(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarFixCons$handle() {
        return SCIPinferVarFixCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixCons(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarFixCons$address() {
        return SCIPinferVarFixCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixCons(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarFixCons(MemorySegment scip, MemorySegment var_, double fixedval, MemorySegment infercons, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarFixCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarFixCons", scip, var_, fixedval, infercons, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval, infercons, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarLbCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarLbCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarLbCons$descriptor() {
        return SCIPinferVarLbCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarLbCons$handle() {
        return SCIPinferVarLbCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarLbCons$address() {
        return SCIPinferVarLbCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarLbCons(MemorySegment scip, MemorySegment var_, double newbound, MemorySegment infercons, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarLbCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarLbCons", scip, var_, newbound, infercons, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, infercons, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarUbCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarUbCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarUbCons$descriptor() {
        return SCIPinferVarUbCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarUbCons$handle() {
        return SCIPinferVarUbCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarUbCons$address() {
        return SCIPinferVarUbCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbCons(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_CONS *infercons, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarUbCons(MemorySegment scip, MemorySegment var_, double newbound, MemorySegment infercons, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarUbCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarUbCons", scip, var_, newbound, infercons, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, infercons, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferBinvarCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferBinvarCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarCons(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferBinvarCons$descriptor() {
        return SCIPinferBinvarCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarCons(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferBinvarCons$handle() {
        return SCIPinferBinvarCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarCons(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferBinvarCons$address() {
        return SCIPinferBinvarCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarCons(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_CONS *infercons, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferBinvarCons(MemorySegment scip, MemorySegment var_, int fixedval, MemorySegment infercons, int inferinfo, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferBinvarCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferBinvarCons", scip, var_, fixedval, infercons, inferinfo, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval, infercons, inferinfo, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarFixProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarFixProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixProp(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarFixProp$descriptor() {
        return SCIPinferVarFixProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixProp(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarFixProp$handle() {
        return SCIPinferVarFixProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixProp(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarFixProp$address() {
        return SCIPinferVarFixProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarFixProp(SCIP *scip, SCIP_VAR *var, double fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarFixProp(MemorySegment scip, MemorySegment var_, double fixedval, MemorySegment inferprop, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarFixProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarFixProp", scip, var_, fixedval, inferprop, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval, inferprop, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarLbProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarLbProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarLbProp$descriptor() {
        return SCIPinferVarLbProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarLbProp$handle() {
        return SCIPinferVarLbProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarLbProp$address() {
        return SCIPinferVarLbProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarLbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarLbProp(MemorySegment scip, MemorySegment var_, double newbound, MemorySegment inferprop, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarLbProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarLbProp", scip, var_, newbound, inferprop, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, inferprop, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferVarUbProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferVarUbProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferVarUbProp$descriptor() {
        return SCIPinferVarUbProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferVarUbProp$handle() {
        return SCIPinferVarUbProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferVarUbProp$address() {
        return SCIPinferVarUbProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferVarUbProp(SCIP *scip, SCIP_VAR *var, double newbound, SCIP_PROP *inferprop, int inferinfo, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferVarUbProp(MemorySegment scip, MemorySegment var_, double newbound, MemorySegment inferprop, int inferinfo, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferVarUbProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferVarUbProp", scip, var_, newbound, inferprop, inferinfo, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, inferprop, inferinfo, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinferBinvarProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinferBinvarProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarProp(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPinferBinvarProp$descriptor() {
        return SCIPinferBinvarProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarProp(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPinferBinvarProp$handle() {
        return SCIPinferBinvarProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarProp(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPinferBinvarProp$address() {
        return SCIPinferBinvarProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinferBinvarProp(SCIP *scip, SCIP_VAR *var, unsigned int fixedval, SCIP_PROP *inferprop, int inferinfo, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPinferBinvarProp(MemorySegment scip, MemorySegment var_, int fixedval, MemorySegment inferprop, int inferinfo, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPinferBinvarProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinferBinvarProp", scip, var_, fixedval, inferprop, inferinfo, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval, inferprop, inferinfo, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtightenVarLbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtightenVarLbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPtightenVarLbGlobal$descriptor() {
        return SCIPtightenVarLbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPtightenVarLbGlobal$handle() {
        return SCIPtightenVarLbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPtightenVarLbGlobal$address() {
        return SCIPtightenVarLbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarLbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPtightenVarLbGlobal(MemorySegment scip, MemorySegment var_, double newbound, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPtightenVarLbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtightenVarLbGlobal", scip, var_, newbound, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtightenVarUbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtightenVarUbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPtightenVarUbGlobal$descriptor() {
        return SCIPtightenVarUbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPtightenVarUbGlobal$handle() {
        return SCIPtightenVarUbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPtightenVarUbGlobal$address() {
        return SCIPtightenVarUbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenVarUbGlobal(SCIP *scip, SCIP_VAR *var, double newbound, unsigned int force, unsigned int *infeasible, unsigned int *tightened)
     * }
     */
    public static int SCIPtightenVarUbGlobal(MemorySegment scip, MemorySegment var_, double newbound, int force, MemorySegment infeasible, MemorySegment tightened) {
        var mh$ = SCIPtightenVarUbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtightenVarUbGlobal", scip, var_, newbound, force, infeasible, tightened);
            }
            return (int)mh$.invokeExact(scip, var_, newbound, force, infeasible, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeVarLbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeVarLbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcomputeVarLbGlobal$descriptor() {
        return SCIPcomputeVarLbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcomputeVarLbGlobal$handle() {
        return SCIPcomputeVarLbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcomputeVarLbGlobal$address() {
        return SCIPcomputeVarLbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomputeVarLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPcomputeVarLbGlobal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcomputeVarLbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeVarLbGlobal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeVarUbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeVarUbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcomputeVarUbGlobal$descriptor() {
        return SCIPcomputeVarUbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcomputeVarUbGlobal$handle() {
        return SCIPcomputeVarUbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcomputeVarUbGlobal$address() {
        return SCIPcomputeVarUbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomputeVarUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPcomputeVarUbGlobal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcomputeVarUbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeVarUbGlobal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeVarLbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeVarLbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcomputeVarLbLocal$descriptor() {
        return SCIPcomputeVarLbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcomputeVarLbLocal$handle() {
        return SCIPcomputeVarLbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomputeVarLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcomputeVarLbLocal$address() {
        return SCIPcomputeVarLbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomputeVarLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPcomputeVarLbLocal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcomputeVarLbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeVarLbLocal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeVarUbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeVarUbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcomputeVarUbLocal$descriptor() {
        return SCIPcomputeVarUbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcomputeVarUbLocal$handle() {
        return SCIPcomputeVarUbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcomputeVarUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcomputeVarUbLocal$address() {
        return SCIPcomputeVarUbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcomputeVarUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPcomputeVarUbLocal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcomputeVarUbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeVarUbLocal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarMultaggrLbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarMultaggrLbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarMultaggrLbGlobal$descriptor() {
        return SCIPgetVarMultaggrLbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarMultaggrLbGlobal$handle() {
        return SCIPgetVarMultaggrLbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarMultaggrLbGlobal$address() {
        return SCIPgetVarMultaggrLbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarMultaggrLbGlobal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarMultaggrLbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarMultaggrLbGlobal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarMultaggrUbGlobal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarMultaggrUbGlobal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarMultaggrUbGlobal$descriptor() {
        return SCIPgetVarMultaggrUbGlobal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarMultaggrUbGlobal$handle() {
        return SCIPgetVarMultaggrUbGlobal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarMultaggrUbGlobal$address() {
        return SCIPgetVarMultaggrUbGlobal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbGlobal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarMultaggrUbGlobal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarMultaggrUbGlobal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarMultaggrUbGlobal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarMultaggrLbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarMultaggrLbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarMultaggrLbLocal$descriptor() {
        return SCIPgetVarMultaggrLbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarMultaggrLbLocal$handle() {
        return SCIPgetVarMultaggrLbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarMultaggrLbLocal$address() {
        return SCIPgetVarMultaggrLbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrLbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarMultaggrLbLocal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarMultaggrLbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarMultaggrLbLocal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarMultaggrUbLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarMultaggrUbLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarMultaggrUbLocal$descriptor() {
        return SCIPgetVarMultaggrUbLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarMultaggrUbLocal$handle() {
        return SCIPgetVarMultaggrUbLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarMultaggrUbLocal$address() {
        return SCIPgetVarMultaggrUbLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarMultaggrUbLocal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarMultaggrUbLocal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarMultaggrUbLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarMultaggrUbLocal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarClosestVlb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarClosestVlb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVlb(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvlb, int *closestvlbidx)
     * }
     */
    public static FunctionDescriptor SCIPgetVarClosestVlb$descriptor() {
        return SCIPgetVarClosestVlb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVlb(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvlb, int *closestvlbidx)
     * }
     */
    public static MethodHandle SCIPgetVarClosestVlb$handle() {
        return SCIPgetVarClosestVlb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVlb(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvlb, int *closestvlbidx)
     * }
     */
    public static MemorySegment SCIPgetVarClosestVlb$address() {
        return SCIPgetVarClosestVlb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVlb(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvlb, int *closestvlbidx)
     * }
     */
    public static int SCIPgetVarClosestVlb(MemorySegment scip, MemorySegment var_, MemorySegment sol, MemorySegment closestvlb, MemorySegment closestvlbidx) {
        var mh$ = SCIPgetVarClosestVlb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarClosestVlb", scip, var_, sol, closestvlb, closestvlbidx);
            }
            return (int)mh$.invokeExact(scip, var_, sol, closestvlb, closestvlbidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarClosestVub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarClosestVub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVub(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvub, int *closestvubidx)
     * }
     */
    public static FunctionDescriptor SCIPgetVarClosestVub$descriptor() {
        return SCIPgetVarClosestVub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVub(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvub, int *closestvubidx)
     * }
     */
    public static MethodHandle SCIPgetVarClosestVub$handle() {
        return SCIPgetVarClosestVub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVub(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvub, int *closestvubidx)
     * }
     */
    public static MemorySegment SCIPgetVarClosestVub$address() {
        return SCIPgetVarClosestVub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarClosestVub(SCIP *scip, SCIP_VAR *var, SCIP_SOL *sol, double *closestvub, int *closestvubidx)
     * }
     */
    public static int SCIPgetVarClosestVub(MemorySegment scip, MemorySegment var_, MemorySegment sol, MemorySegment closestvub, MemorySegment closestvubidx) {
        var mh$ = SCIPgetVarClosestVub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarClosestVub", scip, var_, sol, closestvub, closestvubidx);
            }
            return (int)mh$.invokeExact(scip, var_, sol, closestvub, closestvubidx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarVlb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarVlb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVlb(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vlbvar, double vlbcoef, double vlbconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static FunctionDescriptor SCIPaddVarVlb$descriptor() {
        return SCIPaddVarVlb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVlb(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vlbvar, double vlbcoef, double vlbconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MethodHandle SCIPaddVarVlb$handle() {
        return SCIPaddVarVlb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVlb(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vlbvar, double vlbcoef, double vlbconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MemorySegment SCIPaddVarVlb$address() {
        return SCIPaddVarVlb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVlb(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vlbvar, double vlbcoef, double vlbconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static int SCIPaddVarVlb(MemorySegment scip, MemorySegment var_, MemorySegment vlbvar, double vlbcoef, double vlbconstant, MemorySegment infeasible, MemorySegment nbdchgs) {
        var mh$ = SCIPaddVarVlb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarVlb", scip, var_, vlbvar, vlbcoef, vlbconstant, infeasible, nbdchgs);
            }
            return (int)mh$.invokeExact(scip, var_, vlbvar, vlbcoef, vlbconstant, infeasible, nbdchgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarVub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarVub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVub(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vubvar, double vubcoef, double vubconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static FunctionDescriptor SCIPaddVarVub$descriptor() {
        return SCIPaddVarVub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVub(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vubvar, double vubcoef, double vubconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MethodHandle SCIPaddVarVub$handle() {
        return SCIPaddVarVub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVub(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vubvar, double vubcoef, double vubconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MemorySegment SCIPaddVarVub$address() {
        return SCIPaddVarVub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarVub(SCIP *scip, SCIP_VAR *var, SCIP_VAR *vubvar, double vubcoef, double vubconstant, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static int SCIPaddVarVub(MemorySegment scip, MemorySegment var_, MemorySegment vubvar, double vubcoef, double vubconstant, MemorySegment infeasible, MemorySegment nbdchgs) {
        var mh$ = SCIPaddVarVub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarVub", scip, var_, vubvar, vubcoef, vubconstant, infeasible, nbdchgs);
            }
            return (int)mh$.invokeExact(scip, var_, vubvar, vubcoef, vubconstant, infeasible, nbdchgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarImplication {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarImplication");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarImplication(SCIP *scip, SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype, double implbound, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static FunctionDescriptor SCIPaddVarImplication$descriptor() {
        return SCIPaddVarImplication.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarImplication(SCIP *scip, SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype, double implbound, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MethodHandle SCIPaddVarImplication$handle() {
        return SCIPaddVarImplication.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarImplication(SCIP *scip, SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype, double implbound, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MemorySegment SCIPaddVarImplication$address() {
        return SCIPaddVarImplication.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarImplication(SCIP *scip, SCIP_VAR *var, unsigned int varfixing, SCIP_VAR *implvar, SCIP_BOUNDTYPE impltype, double implbound, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static int SCIPaddVarImplication(MemorySegment scip, MemorySegment var_, int varfixing, MemorySegment implvar, int impltype, double implbound, MemorySegment infeasible, MemorySegment nbdchgs) {
        var mh$ = SCIPaddVarImplication.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarImplication", scip, var_, varfixing, implvar, impltype, implbound, infeasible, nbdchgs);
            }
            return (int)mh$.invokeExact(scip, var_, varfixing, implvar, impltype, implbound, infeasible, nbdchgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddClique {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddClique");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddClique(SCIP *scip, SCIP_VAR **vars, unsigned int *values, int nvars, unsigned int isequation, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static FunctionDescriptor SCIPaddClique$descriptor() {
        return SCIPaddClique.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddClique(SCIP *scip, SCIP_VAR **vars, unsigned int *values, int nvars, unsigned int isequation, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MethodHandle SCIPaddClique$handle() {
        return SCIPaddClique.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddClique(SCIP *scip, SCIP_VAR **vars, unsigned int *values, int nvars, unsigned int isequation, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static MemorySegment SCIPaddClique$address() {
        return SCIPaddClique.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddClique(SCIP *scip, SCIP_VAR **vars, unsigned int *values, int nvars, unsigned int isequation, unsigned int *infeasible, int *nbdchgs)
     * }
     */
    public static int SCIPaddClique(MemorySegment scip, MemorySegment vars, MemorySegment values, int nvars, int isequation, MemorySegment infeasible, MemorySegment nbdchgs) {
        var mh$ = SCIPaddClique.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddClique", scip, vars, values, nvars, isequation, infeasible, nbdchgs);
            }
            return (int)mh$.invokeExact(scip, vars, values, nvars, isequation, infeasible, nbdchgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcCliquePartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcCliquePartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static FunctionDescriptor SCIPcalcCliquePartition$descriptor() {
        return SCIPcalcCliquePartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static MethodHandle SCIPcalcCliquePartition$handle() {
        return SCIPcalcCliquePartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static MemorySegment SCIPcalcCliquePartition$address() {
        return SCIPcalcCliquePartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static int SCIPcalcCliquePartition(MemorySegment scip, MemorySegment vars, int nvars, MemorySegment cliquepartition, MemorySegment ncliques) {
        var mh$ = SCIPcalcCliquePartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcCliquePartition", scip, vars, nvars, cliquepartition, ncliques);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, cliquepartition, ncliques);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcNegatedCliquePartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcNegatedCliquePartition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcNegatedCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static FunctionDescriptor SCIPcalcNegatedCliquePartition$descriptor() {
        return SCIPcalcNegatedCliquePartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcNegatedCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static MethodHandle SCIPcalcNegatedCliquePartition$handle() {
        return SCIPcalcNegatedCliquePartition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcNegatedCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static MemorySegment SCIPcalcNegatedCliquePartition$address() {
        return SCIPcalcNegatedCliquePartition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcNegatedCliquePartition(SCIP *const scip, SCIP_VAR **const vars, const int nvars, int *const cliquepartition, int *const ncliques)
     * }
     */
    public static int SCIPcalcNegatedCliquePartition(MemorySegment scip, MemorySegment vars, int nvars, MemorySegment cliquepartition, MemorySegment ncliques) {
        var mh$ = SCIPcalcNegatedCliquePartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcNegatedCliquePartition", scip, vars, nvars, cliquepartition, ncliques);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, cliquepartition, ncliques);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupCliques(SCIP *scip, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPcleanupCliques$descriptor() {
        return SCIPcleanupCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupCliques(SCIP *scip, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPcleanupCliques$handle() {
        return SCIPcleanupCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupCliques(SCIP *scip, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPcleanupCliques$address() {
        return SCIPcleanupCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupCliques(SCIP *scip, unsigned int *infeasible)
     * }
     */
    public static int SCIPcleanupCliques(MemorySegment scip, MemorySegment infeasible) {
        var mh$ = SCIPcleanupCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupCliques", scip, infeasible);
            }
            return (int)mh$.invokeExact(scip, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCliques(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCliques$descriptor() {
        return SCIPgetNCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCliques(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCliques$handle() {
        return SCIPgetNCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCliques(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCliques$address() {
        return SCIPgetNCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCliques(SCIP *scip)
     * }
     */
    public static int SCIPgetNCliques(MemorySegment scip) {
        var mh$ = SCIPgetNCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCliques", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCliquesCreated {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCliquesCreated");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCliquesCreated(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCliquesCreated$descriptor() {
        return SCIPgetNCliquesCreated.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCliquesCreated(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCliquesCreated$handle() {
        return SCIPgetNCliquesCreated.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCliquesCreated(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCliquesCreated$address() {
        return SCIPgetNCliquesCreated.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCliquesCreated(SCIP *scip)
     * }
     */
    public static int SCIPgetNCliquesCreated(MemorySegment scip) {
        var mh$ = SCIPgetNCliquesCreated.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCliquesCreated", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCliques {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCliques");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPgetCliques(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCliques$descriptor() {
        return SCIPgetCliques.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPgetCliques(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCliques$handle() {
        return SCIPgetCliques.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPgetCliques(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCliques$address() {
        return SCIPgetCliques.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CLIQUE **SCIPgetCliques(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCliques(MemorySegment scip) {
        var mh$ = SCIPgetCliques.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCliques", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhaveVarsCommonClique {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhaveVarsCommonClique");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPhaveVarsCommonClique(SCIP *scip, SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static FunctionDescriptor SCIPhaveVarsCommonClique$descriptor() {
        return SCIPhaveVarsCommonClique.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPhaveVarsCommonClique(SCIP *scip, SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static MethodHandle SCIPhaveVarsCommonClique$handle() {
        return SCIPhaveVarsCommonClique.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPhaveVarsCommonClique(SCIP *scip, SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static MemorySegment SCIPhaveVarsCommonClique$address() {
        return SCIPhaveVarsCommonClique.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPhaveVarsCommonClique(SCIP *scip, SCIP_VAR *var1, unsigned int value1, SCIP_VAR *var2, unsigned int value2, unsigned int regardimplics)
     * }
     */
    public static int SCIPhaveVarsCommonClique(MemorySegment scip, MemorySegment var1, int value1, MemorySegment var2, int value2, int regardimplics) {
        var mh$ = SCIPhaveVarsCommonClique.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhaveVarsCommonClique", scip, var1, value1, var2, value2, regardimplics);
            }
            return (int)mh$.invokeExact(scip, var1, value1, var2, value2, regardimplics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteCliqueGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteCliqueGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCliqueGraph(SCIP *scip, const char *fname, unsigned int writenodeweights)
     * }
     */
    public static FunctionDescriptor SCIPwriteCliqueGraph$descriptor() {
        return SCIPwriteCliqueGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCliqueGraph(SCIP *scip, const char *fname, unsigned int writenodeweights)
     * }
     */
    public static MethodHandle SCIPwriteCliqueGraph$handle() {
        return SCIPwriteCliqueGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCliqueGraph(SCIP *scip, const char *fname, unsigned int writenodeweights)
     * }
     */
    public static MemorySegment SCIPwriteCliqueGraph$address() {
        return SCIPwriteCliqueGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCliqueGraph(SCIP *scip, const char *fname, unsigned int writenodeweights)
     * }
     */
    public static int SCIPwriteCliqueGraph(MemorySegment scip, MemorySegment fname, int writenodeweights) {
        var mh$ = SCIPwriteCliqueGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteCliqueGraph", scip, fname, writenodeweights);
            }
            return (int)mh$.invokeExact(scip, fname, writenodeweights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPremoveVarFromGlobalStructures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPremoveVarFromGlobalStructures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveVarFromGlobalStructures(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPremoveVarFromGlobalStructures$descriptor() {
        return SCIPremoveVarFromGlobalStructures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveVarFromGlobalStructures(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPremoveVarFromGlobalStructures$handle() {
        return SCIPremoveVarFromGlobalStructures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveVarFromGlobalStructures(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPremoveVarFromGlobalStructures$address() {
        return SCIPremoveVarFromGlobalStructures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPremoveVarFromGlobalStructures(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPremoveVarFromGlobalStructures(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPremoveVarFromGlobalStructures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPremoveVarFromGlobalStructures", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarBranchFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarBranchFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchFactor(SCIP *scip, SCIP_VAR *var, double branchfactor)
     * }
     */
    public static FunctionDescriptor SCIPchgVarBranchFactor$descriptor() {
        return SCIPchgVarBranchFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchFactor(SCIP *scip, SCIP_VAR *var, double branchfactor)
     * }
     */
    public static MethodHandle SCIPchgVarBranchFactor$handle() {
        return SCIPchgVarBranchFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchFactor(SCIP *scip, SCIP_VAR *var, double branchfactor)
     * }
     */
    public static MemorySegment SCIPchgVarBranchFactor$address() {
        return SCIPchgVarBranchFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchFactor(SCIP *scip, SCIP_VAR *var, double branchfactor)
     * }
     */
    public static int SCIPchgVarBranchFactor(MemorySegment scip, MemorySegment var_, double branchfactor) {
        var mh$ = SCIPchgVarBranchFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarBranchFactor", scip, var_, branchfactor);
            }
            return (int)mh$.invokeExact(scip, var_, branchfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPscaleVarBranchFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPscaleVarBranchFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPscaleVarBranchFactor(SCIP *scip, SCIP_VAR *var, double scale)
     * }
     */
    public static FunctionDescriptor SCIPscaleVarBranchFactor$descriptor() {
        return SCIPscaleVarBranchFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPscaleVarBranchFactor(SCIP *scip, SCIP_VAR *var, double scale)
     * }
     */
    public static MethodHandle SCIPscaleVarBranchFactor$handle() {
        return SCIPscaleVarBranchFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPscaleVarBranchFactor(SCIP *scip, SCIP_VAR *var, double scale)
     * }
     */
    public static MemorySegment SCIPscaleVarBranchFactor$address() {
        return SCIPscaleVarBranchFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPscaleVarBranchFactor(SCIP *scip, SCIP_VAR *var, double scale)
     * }
     */
    public static int SCIPscaleVarBranchFactor(MemorySegment scip, MemorySegment var_, double scale) {
        var mh$ = SCIPscaleVarBranchFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPscaleVarBranchFactor", scip, var_, scale);
            }
            return (int)mh$.invokeExact(scip, var_, scale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarBranchFactor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarBranchFactor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchFactor(SCIP *scip, SCIP_VAR *var, double addfactor)
     * }
     */
    public static FunctionDescriptor SCIPaddVarBranchFactor$descriptor() {
        return SCIPaddVarBranchFactor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchFactor(SCIP *scip, SCIP_VAR *var, double addfactor)
     * }
     */
    public static MethodHandle SCIPaddVarBranchFactor$handle() {
        return SCIPaddVarBranchFactor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchFactor(SCIP *scip, SCIP_VAR *var, double addfactor)
     * }
     */
    public static MemorySegment SCIPaddVarBranchFactor$address() {
        return SCIPaddVarBranchFactor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchFactor(SCIP *scip, SCIP_VAR *var, double addfactor)
     * }
     */
    public static int SCIPaddVarBranchFactor(MemorySegment scip, MemorySegment var_, double addfactor) {
        var mh$ = SCIPaddVarBranchFactor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarBranchFactor", scip, var_, addfactor);
            }
            return (int)mh$.invokeExact(scip, var_, addfactor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarBranchPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarBranchPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static FunctionDescriptor SCIPchgVarBranchPriority$descriptor() {
        return SCIPchgVarBranchPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static MethodHandle SCIPchgVarBranchPriority$handle() {
        return SCIPchgVarBranchPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static MemorySegment SCIPchgVarBranchPriority$address() {
        return SCIPchgVarBranchPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static int SCIPchgVarBranchPriority(MemorySegment scip, MemorySegment var_, int branchpriority) {
        var mh$ = SCIPchgVarBranchPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarBranchPriority", scip, var_, branchpriority);
            }
            return (int)mh$.invokeExact(scip, var_, branchpriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateVarBranchPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateVarBranchPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static FunctionDescriptor SCIPupdateVarBranchPriority$descriptor() {
        return SCIPupdateVarBranchPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static MethodHandle SCIPupdateVarBranchPriority$handle() {
        return SCIPupdateVarBranchPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static MemorySegment SCIPupdateVarBranchPriority$address() {
        return SCIPupdateVarBranchPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarBranchPriority(SCIP *scip, SCIP_VAR *var, int branchpriority)
     * }
     */
    public static int SCIPupdateVarBranchPriority(MemorySegment scip, MemorySegment var_, int branchpriority) {
        var mh$ = SCIPupdateVarBranchPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateVarBranchPriority", scip, var_, branchpriority);
            }
            return (int)mh$.invokeExact(scip, var_, branchpriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarBranchPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarBranchPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchPriority(SCIP *scip, SCIP_VAR *var, int addpriority)
     * }
     */
    public static FunctionDescriptor SCIPaddVarBranchPriority$descriptor() {
        return SCIPaddVarBranchPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchPriority(SCIP *scip, SCIP_VAR *var, int addpriority)
     * }
     */
    public static MethodHandle SCIPaddVarBranchPriority$handle() {
        return SCIPaddVarBranchPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchPriority(SCIP *scip, SCIP_VAR *var, int addpriority)
     * }
     */
    public static MemorySegment SCIPaddVarBranchPriority$address() {
        return SCIPaddVarBranchPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarBranchPriority(SCIP *scip, SCIP_VAR *var, int addpriority)
     * }
     */
    public static int SCIPaddVarBranchPriority(MemorySegment scip, MemorySegment var_, int addpriority) {
        var mh$ = SCIPaddVarBranchPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarBranchPriority", scip, var_, addpriority);
            }
            return (int)mh$.invokeExact(scip, var_, addpriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarBranchDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarBranchDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchDirection(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdirection)
     * }
     */
    public static FunctionDescriptor SCIPchgVarBranchDirection$descriptor() {
        return SCIPchgVarBranchDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchDirection(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdirection)
     * }
     */
    public static MethodHandle SCIPchgVarBranchDirection$handle() {
        return SCIPchgVarBranchDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchDirection(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdirection)
     * }
     */
    public static MemorySegment SCIPchgVarBranchDirection$address() {
        return SCIPchgVarBranchDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBranchDirection(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR branchdirection)
     * }
     */
    public static int SCIPchgVarBranchDirection(MemorySegment scip, MemorySegment var_, int branchdirection) {
        var mh$ = SCIPchgVarBranchDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarBranchDirection", scip, var_, branchdirection);
            }
            return (int)mh$.invokeExact(scip, var_, branchdirection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarType(SCIP *scip, SCIP_VAR *var, SCIP_VARTYPE vartype, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPchgVarType$descriptor() {
        return SCIPchgVarType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarType(SCIP *scip, SCIP_VAR *var, SCIP_VARTYPE vartype, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPchgVarType$handle() {
        return SCIPchgVarType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarType(SCIP *scip, SCIP_VAR *var, SCIP_VARTYPE vartype, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPchgVarType$address() {
        return SCIPchgVarType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarType(SCIP *scip, SCIP_VAR *var, SCIP_VARTYPE vartype, unsigned int *infeasible)
     * }
     */
    public static int SCIPchgVarType(MemorySegment scip, MemorySegment var_, int vartype, MemorySegment infeasible) {
        var mh$ = SCIPchgVarType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarType", scip, var_, vartype, infeasible);
            }
            return (int)mh$.invokeExact(scip, var_, vartype, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfixVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfixVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVar(SCIP *scip, SCIP_VAR *var, double fixedval, unsigned int *infeasible, unsigned int *fixed)
     * }
     */
    public static FunctionDescriptor SCIPfixVar$descriptor() {
        return SCIPfixVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVar(SCIP *scip, SCIP_VAR *var, double fixedval, unsigned int *infeasible, unsigned int *fixed)
     * }
     */
    public static MethodHandle SCIPfixVar$handle() {
        return SCIPfixVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVar(SCIP *scip, SCIP_VAR *var, double fixedval, unsigned int *infeasible, unsigned int *fixed)
     * }
     */
    public static MemorySegment SCIPfixVar$address() {
        return SCIPfixVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVar(SCIP *scip, SCIP_VAR *var, double fixedval, unsigned int *infeasible, unsigned int *fixed)
     * }
     */
    public static int SCIPfixVar(MemorySegment scip, MemorySegment var_, double fixedval, MemorySegment infeasible, MemorySegment fixed) {
        var mh$ = SCIPfixVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfixVar", scip, var_, fixedval, infeasible, fixed);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval, infeasible, fixed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaggregateVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaggregateVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggregateVars(SCIP *scip, SCIP_VAR *varx, SCIP_VAR *vary, double scalarx, double scalary, double rhs, unsigned int *infeasible, unsigned int *redundant, unsigned int *aggregated)
     * }
     */
    public static FunctionDescriptor SCIPaggregateVars$descriptor() {
        return SCIPaggregateVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggregateVars(SCIP *scip, SCIP_VAR *varx, SCIP_VAR *vary, double scalarx, double scalary, double rhs, unsigned int *infeasible, unsigned int *redundant, unsigned int *aggregated)
     * }
     */
    public static MethodHandle SCIPaggregateVars$handle() {
        return SCIPaggregateVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggregateVars(SCIP *scip, SCIP_VAR *varx, SCIP_VAR *vary, double scalarx, double scalary, double rhs, unsigned int *infeasible, unsigned int *redundant, unsigned int *aggregated)
     * }
     */
    public static MemorySegment SCIPaggregateVars$address() {
        return SCIPaggregateVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaggregateVars(SCIP *scip, SCIP_VAR *varx, SCIP_VAR *vary, double scalarx, double scalary, double rhs, unsigned int *infeasible, unsigned int *redundant, unsigned int *aggregated)
     * }
     */
    public static int SCIPaggregateVars(MemorySegment scip, MemorySegment varx, MemorySegment vary, double scalarx, double scalary, double rhs, MemorySegment infeasible, MemorySegment redundant, MemorySegment aggregated) {
        var mh$ = SCIPaggregateVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaggregateVars", scip, varx, vary, scalarx, scalary, rhs, infeasible, redundant, aggregated);
            }
            return (int)mh$.invokeExact(scip, varx, vary, scalarx, scalary, rhs, infeasible, redundant, aggregated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmultiaggregateVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmultiaggregateVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiaggregateVar(SCIP *scip, SCIP_VAR *var, int naggvars, SCIP_VAR **aggvars, double *scalars, double constant, unsigned int *infeasible, unsigned int *aggregated)
     * }
     */
    public static FunctionDescriptor SCIPmultiaggregateVar$descriptor() {
        return SCIPmultiaggregateVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiaggregateVar(SCIP *scip, SCIP_VAR *var, int naggvars, SCIP_VAR **aggvars, double *scalars, double constant, unsigned int *infeasible, unsigned int *aggregated)
     * }
     */
    public static MethodHandle SCIPmultiaggregateVar$handle() {
        return SCIPmultiaggregateVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiaggregateVar(SCIP *scip, SCIP_VAR *var, int naggvars, SCIP_VAR **aggvars, double *scalars, double constant, unsigned int *infeasible, unsigned int *aggregated)
     * }
     */
    public static MemorySegment SCIPmultiaggregateVar$address() {
        return SCIPmultiaggregateVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiaggregateVar(SCIP *scip, SCIP_VAR *var, int naggvars, SCIP_VAR **aggvars, double *scalars, double constant, unsigned int *infeasible, unsigned int *aggregated)
     * }
     */
    public static int SCIPmultiaggregateVar(MemorySegment scip, MemorySegment var_, int naggvars, MemorySegment aggvars, MemorySegment scalars, double constant, MemorySegment infeasible, MemorySegment aggregated) {
        var mh$ = SCIPmultiaggregateVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmultiaggregateVar", scip, var_, naggvars, aggvars, scalars, constant, infeasible, aggregated);
            }
            return (int)mh$.invokeExact(scip, var_, naggvars, aggvars, scalars, constant, infeasible, aggregated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdoNotAggr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdoNotAggr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdoNotAggr$descriptor() {
        return SCIPdoNotAggr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdoNotAggr$handle() {
        return SCIPdoNotAggr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdoNotAggr$address() {
        return SCIPdoNotAggr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggr(SCIP *scip)
     * }
     */
    public static int SCIPdoNotAggr(MemorySegment scip) {
        var mh$ = SCIPdoNotAggr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdoNotAggr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdoNotMultaggr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdoNotMultaggr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdoNotMultaggr$descriptor() {
        return SCIPdoNotMultaggr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdoNotMultaggr$handle() {
        return SCIPdoNotMultaggr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdoNotMultaggr$address() {
        return SCIPdoNotMultaggr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggr(SCIP *scip)
     * }
     */
    public static int SCIPdoNotMultaggr(MemorySegment scip) {
        var mh$ = SCIPdoNotMultaggr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdoNotMultaggr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdoNotAggrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdoNotAggrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPdoNotAggrVar$descriptor() {
        return SCIPdoNotAggrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPdoNotAggrVar$handle() {
        return SCIPdoNotAggrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPdoNotAggrVar$address() {
        return SCIPdoNotAggrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPdoNotAggrVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPdoNotAggrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdoNotAggrVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdoNotMultaggrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdoNotMultaggrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPdoNotMultaggrVar$descriptor() {
        return SCIPdoNotMultaggrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPdoNotMultaggrVar$handle() {
        return SCIPdoNotMultaggrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPdoNotMultaggrVar$address() {
        return SCIPdoNotMultaggrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPdoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPdoNotMultaggrVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPdoNotMultaggrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdoNotMultaggrVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallowDualReds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallowDualReds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallowDualReds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallowDualReds$descriptor() {
        return SCIPallowDualReds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallowDualReds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallowDualReds$handle() {
        return SCIPallowDualReds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallowDualReds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallowDualReds$address() {
        return SCIPallowDualReds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallowDualReds(SCIP *scip)
     * }
     */
    public static int SCIPallowDualReds(MemorySegment scip) {
        var mh$ = SCIPallowDualReds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallowDualReds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallowStrongDualReds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallowStrongDualReds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallowStrongDualReds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallowStrongDualReds$descriptor() {
        return SCIPallowStrongDualReds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallowStrongDualReds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallowStrongDualReds$handle() {
        return SCIPallowStrongDualReds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallowStrongDualReds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallowStrongDualReds$address() {
        return SCIPallowStrongDualReds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallowStrongDualReds(SCIP *scip)
     * }
     */
    public static int SCIPallowStrongDualReds(MemorySegment scip) {
        var mh$ = SCIPallowStrongDualReds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallowStrongDualReds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallowObjProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallowObjProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallowObjProp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallowObjProp$descriptor() {
        return SCIPallowObjProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallowObjProp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallowObjProp$handle() {
        return SCIPallowObjProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallowObjProp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallowObjProp$address() {
        return SCIPallowObjProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallowObjProp(SCIP *scip)
     * }
     */
    public static int SCIPallowObjProp(MemorySegment scip) {
        var mh$ = SCIPallowObjProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallowObjProp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallowWeakDualReds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallowWeakDualReds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallowWeakDualReds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallowWeakDualReds$descriptor() {
        return SCIPallowWeakDualReds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallowWeakDualReds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallowWeakDualReds$handle() {
        return SCIPallowWeakDualReds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallowWeakDualReds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallowWeakDualReds$address() {
        return SCIPallowWeakDualReds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallowWeakDualReds(SCIP *scip)
     * }
     */
    public static int SCIPallowWeakDualReds(MemorySegment scip) {
        var mh$ = SCIPallowWeakDualReds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallowWeakDualReds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkDoNotAggrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkDoNotAggrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPmarkDoNotAggrVar$descriptor() {
        return SCIPmarkDoNotAggrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPmarkDoNotAggrVar$handle() {
        return SCIPmarkDoNotAggrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPmarkDoNotAggrVar$address() {
        return SCIPmarkDoNotAggrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotAggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPmarkDoNotAggrVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPmarkDoNotAggrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkDoNotAggrVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkDoNotMultaggrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkDoNotMultaggrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPmarkDoNotMultaggrVar$descriptor() {
        return SCIPmarkDoNotMultaggrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPmarkDoNotMultaggrVar$handle() {
        return SCIPmarkDoNotMultaggrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPmarkDoNotMultaggrVar$address() {
        return SCIPmarkDoNotMultaggrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkDoNotMultaggrVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPmarkDoNotMultaggrVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPmarkDoNotMultaggrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkDoNotMultaggrVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableVarHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableVarHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPenableVarHistory(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPenableVarHistory$descriptor() {
        return SCIPenableVarHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPenableVarHistory(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPenableVarHistory$handle() {
        return SCIPenableVarHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPenableVarHistory(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPenableVarHistory$address() {
        return SCIPenableVarHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPenableVarHistory(SCIP *scip)
     * }
     */
    public static void SCIPenableVarHistory(MemorySegment scip) {
        var mh$ = SCIPenableVarHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableVarHistory", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdisableVarHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdisableVarHistory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdisableVarHistory(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdisableVarHistory$descriptor() {
        return SCIPdisableVarHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdisableVarHistory(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdisableVarHistory$handle() {
        return SCIPdisableVarHistory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdisableVarHistory(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdisableVarHistory$address() {
        return SCIPdisableVarHistory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdisableVarHistory(SCIP *scip)
     * }
     */
    public static void SCIPdisableVarHistory(MemorySegment scip) {
        var mh$ = SCIPdisableVarHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdisableVarHistory", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateVarPseudocost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateVarPseudocost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarPseudocost(SCIP *scip, SCIP_VAR *var, double solvaldelta, double objdelta, double weight)
     * }
     */
    public static FunctionDescriptor SCIPupdateVarPseudocost$descriptor() {
        return SCIPupdateVarPseudocost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarPseudocost(SCIP *scip, SCIP_VAR *var, double solvaldelta, double objdelta, double weight)
     * }
     */
    public static MethodHandle SCIPupdateVarPseudocost$handle() {
        return SCIPupdateVarPseudocost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarPseudocost(SCIP *scip, SCIP_VAR *var, double solvaldelta, double objdelta, double weight)
     * }
     */
    public static MemorySegment SCIPupdateVarPseudocost$address() {
        return SCIPupdateVarPseudocost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateVarPseudocost(SCIP *scip, SCIP_VAR *var, double solvaldelta, double objdelta, double weight)
     * }
     */
    public static int SCIPupdateVarPseudocost(MemorySegment scip, MemorySegment var_, double solvaldelta, double objdelta, double weight) {
        var mh$ = SCIPupdateVarPseudocost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateVarPseudocost", scip, var_, solvaldelta, objdelta, weight);
            }
            return (int)mh$.invokeExact(scip, var_, solvaldelta, objdelta, weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVal(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostVal$descriptor() {
        return SCIPgetVarPseudocostVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVal(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostVal$handle() {
        return SCIPgetVarPseudocostVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVal(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostVal$address() {
        return SCIPgetVarPseudocostVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVal(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static double SCIPgetVarPseudocostVal(MemorySegment scip, MemorySegment var_, double solvaldelta) {
        var mh$ = SCIPgetVarPseudocostVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostVal", scip, var_, solvaldelta);
            }
            return (double)mh$.invokeExact(scip, var_, solvaldelta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostValCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostValCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostValCurrentRun(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostValCurrentRun$descriptor() {
        return SCIPgetVarPseudocostValCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostValCurrentRun(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostValCurrentRun$handle() {
        return SCIPgetVarPseudocostValCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostValCurrentRun(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostValCurrentRun$address() {
        return SCIPgetVarPseudocostValCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostValCurrentRun(SCIP *scip, SCIP_VAR *var, double solvaldelta)
     * }
     */
    public static double SCIPgetVarPseudocostValCurrentRun(MemorySegment scip, MemorySegment var_, double solvaldelta) {
        var mh$ = SCIPgetVarPseudocostValCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostValCurrentRun", scip, var_, solvaldelta);
            }
            return (double)mh$.invokeExact(scip, var_, solvaldelta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocost(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocost$descriptor() {
        return SCIPgetVarPseudocost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocost(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocost$handle() {
        return SCIPgetVarPseudocost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocost(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocost$address() {
        return SCIPgetVarPseudocost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocost(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarPseudocost(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarPseudocost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocost", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostCurrentRun$descriptor() {
        return SCIPgetVarPseudocostCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostCurrentRun$handle() {
        return SCIPgetVarPseudocostCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostCurrentRun$address() {
        return SCIPgetVarPseudocostCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarPseudocostCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarPseudocostCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCount(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostCount$descriptor() {
        return SCIPgetVarPseudocostCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCount(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostCount$handle() {
        return SCIPgetVarPseudocostCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCount(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostCount$address() {
        return SCIPgetVarPseudocostCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCount(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarPseudocostCount(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarPseudocostCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostCount", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostCountCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostCountCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCountCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostCountCurrentRun$descriptor() {
        return SCIPgetVarPseudocostCountCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCountCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostCountCurrentRun$handle() {
        return SCIPgetVarPseudocostCountCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCountCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostCountCurrentRun$address() {
        return SCIPgetVarPseudocostCountCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostCountCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarPseudocostCountCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarPseudocostCountCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostCountCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostVariance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostVariance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVariance(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostVariance$descriptor() {
        return SCIPgetVarPseudocostVariance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVariance(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostVariance$handle() {
        return SCIPgetVarPseudocostVariance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVariance(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostVariance$address() {
        return SCIPgetVarPseudocostVariance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostVariance(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static double SCIPgetVarPseudocostVariance(MemorySegment scip, MemorySegment var_, int dir, int onlycurrentrun) {
        var mh$ = SCIPgetVarPseudocostVariance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostVariance", scip, var_, dir, onlycurrentrun);
            }
            return (double)mh$.invokeExact(scip, var_, dir, onlycurrentrun);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalculatePscostConfidenceBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalculatePscostConfidenceBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalculatePscostConfidenceBound(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static FunctionDescriptor SCIPcalculatePscostConfidenceBound$descriptor() {
        return SCIPcalculatePscostConfidenceBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalculatePscostConfidenceBound(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MethodHandle SCIPcalculatePscostConfidenceBound$handle() {
        return SCIPcalculatePscostConfidenceBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalculatePscostConfidenceBound(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MemorySegment SCIPcalculatePscostConfidenceBound$address() {
        return SCIPcalculatePscostConfidenceBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalculatePscostConfidenceBound(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static double SCIPcalculatePscostConfidenceBound(MemorySegment scip, MemorySegment var_, int dir, int onlycurrentrun, int clevel) {
        var mh$ = SCIPcalculatePscostConfidenceBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalculatePscostConfidenceBound", scip, var_, dir, onlycurrentrun, clevel);
            }
            return (double)mh$.invokeExact(scip, var_, dir, onlycurrentrun, clevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsignificantVarPscostDifference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsignificantVarPscostDifference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsignificantVarPscostDifference(SCIP *scip, SCIP_VAR *varx, double fracx, SCIP_VAR *vary, double fracy, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel, unsigned int onesided)
     * }
     */
    public static FunctionDescriptor SCIPsignificantVarPscostDifference$descriptor() {
        return SCIPsignificantVarPscostDifference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsignificantVarPscostDifference(SCIP *scip, SCIP_VAR *varx, double fracx, SCIP_VAR *vary, double fracy, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel, unsigned int onesided)
     * }
     */
    public static MethodHandle SCIPsignificantVarPscostDifference$handle() {
        return SCIPsignificantVarPscostDifference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsignificantVarPscostDifference(SCIP *scip, SCIP_VAR *varx, double fracx, SCIP_VAR *vary, double fracy, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel, unsigned int onesided)
     * }
     */
    public static MemorySegment SCIPsignificantVarPscostDifference$address() {
        return SCIPsignificantVarPscostDifference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsignificantVarPscostDifference(SCIP *scip, SCIP_VAR *varx, double fracx, SCIP_VAR *vary, double fracy, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel, unsigned int onesided)
     * }
     */
    public static int SCIPsignificantVarPscostDifference(MemorySegment scip, MemorySegment varx, double fracx, MemorySegment vary, double fracy, int dir, int clevel, int onesided) {
        var mh$ = SCIPsignificantVarPscostDifference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsignificantVarPscostDifference", scip, varx, fracx, vary, fracy, dir, clevel, onesided);
            }
            return (int)mh$.invokeExact(scip, varx, fracx, vary, fracy, dir, clevel, onesided);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpscostThresholdProbabilityTest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpscostThresholdProbabilityTest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpscostThresholdProbabilityTest(SCIP *scip, SCIP_VAR *var, double frac, double threshold, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static FunctionDescriptor SCIPpscostThresholdProbabilityTest$descriptor() {
        return SCIPpscostThresholdProbabilityTest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpscostThresholdProbabilityTest(SCIP *scip, SCIP_VAR *var, double frac, double threshold, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MethodHandle SCIPpscostThresholdProbabilityTest$handle() {
        return SCIPpscostThresholdProbabilityTest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpscostThresholdProbabilityTest(SCIP *scip, SCIP_VAR *var, double frac, double threshold, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MemorySegment SCIPpscostThresholdProbabilityTest$address() {
        return SCIPpscostThresholdProbabilityTest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpscostThresholdProbabilityTest(SCIP *scip, SCIP_VAR *var, double frac, double threshold, SCIP_BRANCHDIR dir, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static int SCIPpscostThresholdProbabilityTest(MemorySegment scip, MemorySegment var_, double frac, double threshold, int dir, int clevel) {
        var mh$ = SCIPpscostThresholdProbabilityTest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpscostThresholdProbabilityTest", scip, var_, frac, threshold, dir, clevel);
            }
            return (int)mh$.invokeExact(scip, var_, frac, threshold, dir, clevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisVarPscostRelerrorReliable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisVarPscostRelerrorReliable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisVarPscostRelerrorReliable(SCIP *scip, SCIP_VAR *var, double threshold, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static FunctionDescriptor SCIPisVarPscostRelerrorReliable$descriptor() {
        return SCIPisVarPscostRelerrorReliable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisVarPscostRelerrorReliable(SCIP *scip, SCIP_VAR *var, double threshold, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MethodHandle SCIPisVarPscostRelerrorReliable$handle() {
        return SCIPisVarPscostRelerrorReliable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisVarPscostRelerrorReliable(SCIP *scip, SCIP_VAR *var, double threshold, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static MemorySegment SCIPisVarPscostRelerrorReliable$address() {
        return SCIPisVarPscostRelerrorReliable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisVarPscostRelerrorReliable(SCIP *scip, SCIP_VAR *var, double threshold, SCIP_CONFIDENCELEVEL clevel)
     * }
     */
    public static int SCIPisVarPscostRelerrorReliable(MemorySegment scip, MemorySegment var_, double threshold, int clevel) {
        var mh$ = SCIPisVarPscostRelerrorReliable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisVarPscostRelerrorReliable", scip, var_, threshold, clevel);
            }
            return (int)mh$.invokeExact(scip, var_, threshold, clevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScore(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostScore$descriptor() {
        return SCIPgetVarPseudocostScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScore(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostScore$handle() {
        return SCIPgetVarPseudocostScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScore(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostScore$address() {
        return SCIPgetVarPseudocostScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScore(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static double SCIPgetVarPseudocostScore(MemorySegment scip, MemorySegment var_, double solval) {
        var mh$ = SCIPgetVarPseudocostScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostScore", scip, var_, solval);
            }
            return (double)mh$.invokeExact(scip, var_, solval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarPseudocostScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarPseudocostScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static FunctionDescriptor SCIPgetVarPseudocostScoreCurrentRun$descriptor() {
        return SCIPgetVarPseudocostScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static MethodHandle SCIPgetVarPseudocostScoreCurrentRun$handle() {
        return SCIPgetVarPseudocostScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static MemorySegment SCIPgetVarPseudocostScoreCurrentRun$address() {
        return SCIPgetVarPseudocostScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarPseudocostScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double solval)
     * }
     */
    public static double SCIPgetVarPseudocostScoreCurrentRun(MemorySegment scip, MemorySegment var_, double solval) {
        var mh$ = SCIPgetVarPseudocostScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarPseudocostScoreCurrentRun", scip, var_, solval);
            }
            return (double)mh$.invokeExact(scip, var_, solval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarVSIDS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarVSIDS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDS(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarVSIDS$descriptor() {
        return SCIPgetVarVSIDS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDS(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarVSIDS$handle() {
        return SCIPgetVarVSIDS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDS(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarVSIDS$address() {
        return SCIPgetVarVSIDS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarVSIDS(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarVSIDS(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarVSIDS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarVSIDS", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarVSIDSCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarVSIDSCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDSCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarVSIDSCurrentRun$descriptor() {
        return SCIPgetVarVSIDSCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDSCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarVSIDSCurrentRun$handle() {
        return SCIPgetVarVSIDSCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarVSIDSCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarVSIDSCurrentRun$address() {
        return SCIPgetVarVSIDSCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarVSIDSCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarVSIDSCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarVSIDSCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarVSIDSCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarConflictScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarConflictScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarConflictScore$descriptor() {
        return SCIPgetVarConflictScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarConflictScore$handle() {
        return SCIPgetVarConflictScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarConflictScore$address() {
        return SCIPgetVarConflictScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarConflictScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarConflictScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarConflictScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarConflictScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarConflictScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarConflictScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarConflictScoreCurrentRun$descriptor() {
        return SCIPgetVarConflictScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarConflictScoreCurrentRun$handle() {
        return SCIPgetVarConflictScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarConflictScoreCurrentRun$address() {
        return SCIPgetVarConflictScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarConflictScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarConflictScoreCurrentRun(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarConflictScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarConflictScoreCurrentRun", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarConflictlengthScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarConflictlengthScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarConflictlengthScore$descriptor() {
        return SCIPgetVarConflictlengthScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarConflictlengthScore$handle() {
        return SCIPgetVarConflictlengthScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarConflictlengthScore$address() {
        return SCIPgetVarConflictlengthScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarConflictlengthScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarConflictlengthScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarConflictlengthScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarConflictlengthScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarConflictlengthScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarConflictlengthScoreCurrentRun$descriptor() {
        return SCIPgetVarConflictlengthScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarConflictlengthScoreCurrentRun$handle() {
        return SCIPgetVarConflictlengthScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarConflictlengthScoreCurrentRun$address() {
        return SCIPgetVarConflictlengthScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarConflictlengthScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarConflictlengthScoreCurrentRun(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarConflictlengthScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarConflictlengthScoreCurrentRun", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgConflictlength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgConflictlength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlength(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgConflictlength$descriptor() {
        return SCIPgetVarAvgConflictlength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlength(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgConflictlength$handle() {
        return SCIPgetVarAvgConflictlength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlength(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgConflictlength$address() {
        return SCIPgetVarAvgConflictlength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlength(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgConflictlength(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgConflictlength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgConflictlength", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgConflictlengthCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgConflictlengthCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlengthCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgConflictlengthCurrentRun$descriptor() {
        return SCIPgetVarAvgConflictlengthCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlengthCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgConflictlengthCurrentRun$handle() {
        return SCIPgetVarAvgConflictlengthCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlengthCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgConflictlengthCurrentRun$address() {
        return SCIPgetVarAvgConflictlengthCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgConflictlengthCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgConflictlengthCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgConflictlengthCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgConflictlengthCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferences(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferences$descriptor() {
        return SCIPgetVarAvgInferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferences(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferences$handle() {
        return SCIPgetVarAvgInferences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferences(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferences$address() {
        return SCIPgetVarAvgInferences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferences(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgInferences(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgInferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferences", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferencesCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferencesCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferencesCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferencesCurrentRun$descriptor() {
        return SCIPgetVarAvgInferencesCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferencesCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferencesCurrentRun$handle() {
        return SCIPgetVarAvgInferencesCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferencesCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferencesCurrentRun$address() {
        return SCIPgetVarAvgInferencesCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferencesCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgInferencesCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgInferencesCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferencesCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferenceScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferenceScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferenceScore$descriptor() {
        return SCIPgetVarAvgInferenceScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferenceScore$handle() {
        return SCIPgetVarAvgInferenceScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferenceScore$address() {
        return SCIPgetVarAvgInferenceScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarAvgInferenceScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarAvgInferenceScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferenceScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferenceScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferenceScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferenceScoreCurrentRun$descriptor() {
        return SCIPgetVarAvgInferenceScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferenceScoreCurrentRun$handle() {
        return SCIPgetVarAvgInferenceScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferenceScoreCurrentRun$address() {
        return SCIPgetVarAvgInferenceScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarAvgInferenceScoreCurrentRun(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarAvgInferenceScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferenceScoreCurrentRun", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitVarBranchStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitVarBranchStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarBranchStats(SCIP *scip, SCIP_VAR *var, double downpscost, double uppscost, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static FunctionDescriptor SCIPinitVarBranchStats$descriptor() {
        return SCIPinitVarBranchStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarBranchStats(SCIP *scip, SCIP_VAR *var, double downpscost, double uppscost, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static MethodHandle SCIPinitVarBranchStats$handle() {
        return SCIPinitVarBranchStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarBranchStats(SCIP *scip, SCIP_VAR *var, double downpscost, double uppscost, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static MemorySegment SCIPinitVarBranchStats$address() {
        return SCIPinitVarBranchStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarBranchStats(SCIP *scip, SCIP_VAR *var, double downpscost, double uppscost, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static int SCIPinitVarBranchStats(MemorySegment scip, MemorySegment var_, double downpscost, double uppscost, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff) {
        var mh$ = SCIPinitVarBranchStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitVarBranchStats", scip, var_, downpscost, uppscost, downvsids, upvsids, downconflen, upconflen, downinfer, upinfer, downcutoff, upcutoff);
            }
            return (int)mh$.invokeExact(scip, var_, downpscost, uppscost, downvsids, upvsids, downconflen, upconflen, downinfer, upinfer, downcutoff, upcutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitVarValueBranchStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitVarValueBranchStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarValueBranchStats(SCIP *scip, SCIP_VAR *var, double value, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static FunctionDescriptor SCIPinitVarValueBranchStats$descriptor() {
        return SCIPinitVarValueBranchStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarValueBranchStats(SCIP *scip, SCIP_VAR *var, double value, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static MethodHandle SCIPinitVarValueBranchStats$handle() {
        return SCIPinitVarValueBranchStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarValueBranchStats(SCIP *scip, SCIP_VAR *var, double value, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static MemorySegment SCIPinitVarValueBranchStats$address() {
        return SCIPinitVarValueBranchStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitVarValueBranchStats(SCIP *scip, SCIP_VAR *var, double value, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff)
     * }
     */
    public static int SCIPinitVarValueBranchStats(MemorySegment scip, MemorySegment var_, double value, double downvsids, double upvsids, double downconflen, double upconflen, double downinfer, double upinfer, double downcutoff, double upcutoff) {
        var mh$ = SCIPinitVarValueBranchStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitVarValueBranchStats", scip, var_, value, downvsids, upvsids, downconflen, upconflen, downinfer, upinfer, downcutoff, upcutoff);
            }
            return (int)mh$.invokeExact(scip, var_, value, downvsids, upvsids, downconflen, upconflen, downinfer, upinfer, downcutoff, upcutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffs(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgCutoffs$descriptor() {
        return SCIPgetVarAvgCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffs(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgCutoffs$handle() {
        return SCIPgetVarAvgCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffs(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgCutoffs$address() {
        return SCIPgetVarAvgCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffs(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgCutoffs(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgCutoffs", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgCutoffsCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgCutoffsCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffsCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgCutoffsCurrentRun$descriptor() {
        return SCIPgetVarAvgCutoffsCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffsCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetVarAvgCutoffsCurrentRun$handle() {
        return SCIPgetVarAvgCutoffsCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffsCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetVarAvgCutoffsCurrentRun$address() {
        return SCIPgetVarAvgCutoffsCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffsCurrentRun(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetVarAvgCutoffsCurrentRun(MemorySegment scip, MemorySegment var_, int dir) {
        var mh$ = SCIPgetVarAvgCutoffsCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgCutoffsCurrentRun", scip, var_, dir);
            }
            return (double)mh$.invokeExact(scip, var_, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgCutoffScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgCutoffScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgCutoffScore$descriptor() {
        return SCIPgetVarAvgCutoffScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarAvgCutoffScore$handle() {
        return SCIPgetVarAvgCutoffScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarAvgCutoffScore$address() {
        return SCIPgetVarAvgCutoffScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarAvgCutoffScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarAvgCutoffScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgCutoffScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgCutoffScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgCutoffScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgCutoffScoreCurrentRun$descriptor() {
        return SCIPgetVarAvgCutoffScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarAvgCutoffScoreCurrentRun$handle() {
        return SCIPgetVarAvgCutoffScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarAvgCutoffScoreCurrentRun$address() {
        return SCIPgetVarAvgCutoffScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarAvgCutoffScoreCurrentRun(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarAvgCutoffScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgCutoffScoreCurrentRun", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferenceCutoffScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferenceCutoffScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScore(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferenceCutoffScore$descriptor() {
        return SCIPgetVarAvgInferenceCutoffScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScore(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferenceCutoffScore$handle() {
        return SCIPgetVarAvgInferenceCutoffScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScore(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferenceCutoffScore$address() {
        return SCIPgetVarAvgInferenceCutoffScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScore(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static double SCIPgetVarAvgInferenceCutoffScore(MemorySegment scip, MemorySegment var_, double cutoffweight) {
        var mh$ = SCIPgetVarAvgInferenceCutoffScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferenceCutoffScore", scip, var_, cutoffweight);
            }
            return (double)mh$.invokeExact(scip, var_, cutoffweight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgInferenceCutoffScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgInferenceCutoffScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgInferenceCutoffScoreCurrentRun$descriptor() {
        return SCIPgetVarAvgInferenceCutoffScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static MethodHandle SCIPgetVarAvgInferenceCutoffScoreCurrentRun$handle() {
        return SCIPgetVarAvgInferenceCutoffScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static MemorySegment SCIPgetVarAvgInferenceCutoffScoreCurrentRun$address() {
        return SCIPgetVarAvgInferenceCutoffScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgInferenceCutoffScoreCurrentRun(SCIP *scip, SCIP_VAR *var, double cutoffweight)
     * }
     */
    public static double SCIPgetVarAvgInferenceCutoffScoreCurrentRun(MemorySegment scip, MemorySegment var_, double cutoffweight) {
        var mh$ = SCIPgetVarAvgInferenceCutoffScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgInferenceCutoffScoreCurrentRun", scip, var_, cutoffweight);
            }
            return (double)mh$.invokeExact(scip, var_, cutoffweight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarAvgGMIScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarAvgGMIScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarAvgGMIScore$descriptor() {
        return SCIPgetVarAvgGMIScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarAvgGMIScore$handle() {
        return SCIPgetVarAvgGMIScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarAvgGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarAvgGMIScore$address() {
        return SCIPgetVarAvgGMIScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarAvgGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarAvgGMIScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarAvgGMIScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarAvgGMIScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincVarGMISumScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincVarGMISumScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincVarGMISumScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static FunctionDescriptor SCIPincVarGMISumScore$descriptor() {
        return SCIPincVarGMISumScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincVarGMISumScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static MethodHandle SCIPincVarGMISumScore$handle() {
        return SCIPincVarGMISumScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincVarGMISumScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static MemorySegment SCIPincVarGMISumScore$address() {
        return SCIPincVarGMISumScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincVarGMISumScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static int SCIPincVarGMISumScore(MemorySegment scip, MemorySegment var_, double gmieff) {
        var mh$ = SCIPincVarGMISumScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincVarGMISumScore", scip, var_, gmieff);
            }
            return (int)mh$.invokeExact(scip, var_, gmieff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarLastGMIScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarLastGMIScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarLastGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarLastGMIScore$descriptor() {
        return SCIPgetVarLastGMIScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarLastGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarLastGMIScore$handle() {
        return SCIPgetVarLastGMIScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarLastGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarLastGMIScore$address() {
        return SCIPgetVarLastGMIScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarLastGMIScore(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarLastGMIScore(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarLastGMIScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarLastGMIScore", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetVarLastGMIScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetVarLastGMIScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarLastGMIScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static FunctionDescriptor SCIPsetVarLastGMIScore$descriptor() {
        return SCIPsetVarLastGMIScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarLastGMIScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static MethodHandle SCIPsetVarLastGMIScore$handle() {
        return SCIPsetVarLastGMIScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarLastGMIScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static MemorySegment SCIPsetVarLastGMIScore$address() {
        return SCIPsetVarLastGMIScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetVarLastGMIScore(SCIP *scip, SCIP_VAR *var, double gmieff)
     * }
     */
    public static int SCIPsetVarLastGMIScore(MemorySegment scip, MemorySegment var_, double gmieff) {
        var mh$ = SCIPsetVarLastGMIScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetVarLastGMIScore", scip, var_, gmieff);
            }
            return (int)mh$.invokeExact(scip, var_, gmieff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintVar(SCIP *scip, SCIP_VAR *var, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintVar$descriptor() {
        return SCIPprintVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintVar(SCIP *scip, SCIP_VAR *var, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintVar$handle() {
        return SCIPprintVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintVar(SCIP *scip, SCIP_VAR *var, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintVar$address() {
        return SCIPprintVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintVar(SCIP *scip, SCIP_VAR *var, FILE *file)
     * }
     */
    public static int SCIPprintVar(MemorySegment scip, MemorySegment var_, MemorySegment file) {
        var mh$ = SCIPprintVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintVar", scip, var_, file);
            }
            return (int)mh$.invokeExact(scip, var_, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectVarPseudoStrongBranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectVarPseudoStrongBranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarPseudoStrongBranching(SCIP *scip, SCIP_VAR **pseudocands, unsigned int *skipdown, unsigned int *skipup, int npseudocands, int npriopseudocands, int *bestpseudocand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPselectVarPseudoStrongBranching$descriptor() {
        return SCIPselectVarPseudoStrongBranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarPseudoStrongBranching(SCIP *scip, SCIP_VAR **pseudocands, unsigned int *skipdown, unsigned int *skipup, int npseudocands, int npriopseudocands, int *bestpseudocand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPselectVarPseudoStrongBranching$handle() {
        return SCIPselectVarPseudoStrongBranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarPseudoStrongBranching(SCIP *scip, SCIP_VAR **pseudocands, unsigned int *skipdown, unsigned int *skipup, int npseudocands, int npriopseudocands, int *bestpseudocand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPselectVarPseudoStrongBranching$address() {
        return SCIPselectVarPseudoStrongBranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarPseudoStrongBranching(SCIP *scip, SCIP_VAR **pseudocands, unsigned int *skipdown, unsigned int *skipup, int npseudocands, int npriopseudocands, int *bestpseudocand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static int SCIPselectVarPseudoStrongBranching(MemorySegment scip, MemorySegment pseudocands, MemorySegment skipdown, MemorySegment skipup, int npseudocands, int npriopseudocands, MemorySegment bestpseudocand, MemorySegment bestdown, MemorySegment bestup, MemorySegment bestscore, MemorySegment bestdownvalid, MemorySegment bestupvalid, MemorySegment provedbound, MemorySegment result) {
        var mh$ = SCIPselectVarPseudoStrongBranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectVarPseudoStrongBranching", scip, pseudocands, skipdown, skipup, npseudocands, npriopseudocands, bestpseudocand, bestdown, bestup, bestscore, bestdownvalid, bestupvalid, provedbound, result);
            }
            return (int)mh$.invokeExact(scip, pseudocands, skipdown, skipup, npseudocands, npriopseudocands, bestpseudocand, bestdown, bestup, bestscore, bestdownvalid, bestupvalid, provedbound, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleAllfullstrong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleAllfullstrong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleAllfullstrong(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleAllfullstrong$descriptor() {
        return SCIPincludeBranchruleAllfullstrong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleAllfullstrong(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleAllfullstrong$handle() {
        return SCIPincludeBranchruleAllfullstrong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleAllfullstrong(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleAllfullstrong$address() {
        return SCIPincludeBranchruleAllfullstrong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleAllfullstrong(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleAllfullstrong(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleAllfullstrong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleAllfullstrong", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleCloud {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleCloud");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleCloud(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleCloud$descriptor() {
        return SCIPincludeBranchruleCloud.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleCloud(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleCloud$handle() {
        return SCIPincludeBranchruleCloud.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleCloud(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleCloud$address() {
        return SCIPincludeBranchruleCloud.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleCloud(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleCloud(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleCloud.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleCloud", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleDistribution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleDistribution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleDistribution(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleDistribution$descriptor() {
        return SCIPincludeBranchruleDistribution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleDistribution(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleDistribution$handle() {
        return SCIPincludeBranchruleDistribution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleDistribution(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleDistribution$address() {
        return SCIPincludeBranchruleDistribution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleDistribution(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleDistribution(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleDistribution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleDistribution", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarCalcDistributionParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarCalcDistributionParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPvarCalcDistributionParameters(SCIP *scip, double varlb, double varub, SCIP_VARTYPE vartype, double *mean, double *variance)
     * }
     */
    public static FunctionDescriptor SCIPvarCalcDistributionParameters$descriptor() {
        return SCIPvarCalcDistributionParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPvarCalcDistributionParameters(SCIP *scip, double varlb, double varub, SCIP_VARTYPE vartype, double *mean, double *variance)
     * }
     */
    public static MethodHandle SCIPvarCalcDistributionParameters$handle() {
        return SCIPvarCalcDistributionParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPvarCalcDistributionParameters(SCIP *scip, double varlb, double varub, SCIP_VARTYPE vartype, double *mean, double *variance)
     * }
     */
    public static MemorySegment SCIPvarCalcDistributionParameters$address() {
        return SCIPvarCalcDistributionParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPvarCalcDistributionParameters(SCIP *scip, double varlb, double varub, SCIP_VARTYPE vartype, double *mean, double *variance)
     * }
     */
    public static void SCIPvarCalcDistributionParameters(MemorySegment scip, double varlb, double varub, int vartype, MemorySegment mean, MemorySegment variance) {
        var mh$ = SCIPvarCalcDistributionParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarCalcDistributionParameters", scip, varlb, varub, vartype, mean, variance);
            }
            mh$.invokeExact(scip, varlb, varub, vartype, mean, variance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcCumulativeDistribution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcCumulativeDistribution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcalcCumulativeDistribution(SCIP *scip, double mean, double variance, double value)
     * }
     */
    public static FunctionDescriptor SCIPcalcCumulativeDistribution$descriptor() {
        return SCIPcalcCumulativeDistribution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcalcCumulativeDistribution(SCIP *scip, double mean, double variance, double value)
     * }
     */
    public static MethodHandle SCIPcalcCumulativeDistribution$handle() {
        return SCIPcalcCumulativeDistribution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcalcCumulativeDistribution(SCIP *scip, double mean, double variance, double value)
     * }
     */
    public static MemorySegment SCIPcalcCumulativeDistribution$address() {
        return SCIPcalcCumulativeDistribution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcalcCumulativeDistribution(SCIP *scip, double mean, double variance, double value)
     * }
     */
    public static double SCIPcalcCumulativeDistribution(MemorySegment scip, double mean, double variance, double value) {
        var mh$ = SCIPcalcCumulativeDistribution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcCumulativeDistribution", scip, mean, variance, value);
            }
            return (double)mh$.invokeExact(scip, mean, variance, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIProwCalcProbability {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIProwCalcProbability");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIProwCalcProbability(SCIP *scip, SCIP_ROW *row, double mu, double sigma2, int rowinfinitiesdown, int rowinfinitiesup)
     * }
     */
    public static FunctionDescriptor SCIProwCalcProbability$descriptor() {
        return SCIProwCalcProbability.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIProwCalcProbability(SCIP *scip, SCIP_ROW *row, double mu, double sigma2, int rowinfinitiesdown, int rowinfinitiesup)
     * }
     */
    public static MethodHandle SCIProwCalcProbability$handle() {
        return SCIProwCalcProbability.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIProwCalcProbability(SCIP *scip, SCIP_ROW *row, double mu, double sigma2, int rowinfinitiesdown, int rowinfinitiesup)
     * }
     */
    public static MemorySegment SCIProwCalcProbability$address() {
        return SCIProwCalcProbability.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIProwCalcProbability(SCIP *scip, SCIP_ROW *row, double mu, double sigma2, int rowinfinitiesdown, int rowinfinitiesup)
     * }
     */
    public static double SCIProwCalcProbability(MemorySegment scip, MemorySegment row, double mu, double sigma2, int rowinfinitiesdown, int rowinfinitiesup) {
        var mh$ = SCIProwCalcProbability.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIProwCalcProbability", scip, row, mu, sigma2, rowinfinitiesdown, rowinfinitiesup);
            }
            return (double)mh$.invokeExact(scip, row, mu, sigma2, rowinfinitiesdown, rowinfinitiesup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateDistributionScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateDistributionScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateDistributionScore(SCIP *scip, double currentprob, double newprobup, double newprobdown, double *upscore, double *downscore, char scoreparam)
     * }
     */
    public static FunctionDescriptor SCIPupdateDistributionScore$descriptor() {
        return SCIPupdateDistributionScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateDistributionScore(SCIP *scip, double currentprob, double newprobup, double newprobdown, double *upscore, double *downscore, char scoreparam)
     * }
     */
    public static MethodHandle SCIPupdateDistributionScore$handle() {
        return SCIPupdateDistributionScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateDistributionScore(SCIP *scip, double currentprob, double newprobup, double newprobdown, double *upscore, double *downscore, char scoreparam)
     * }
     */
    public static MemorySegment SCIPupdateDistributionScore$address() {
        return SCIPupdateDistributionScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateDistributionScore(SCIP *scip, double currentprob, double newprobup, double newprobdown, double *upscore, double *downscore, char scoreparam)
     * }
     */
    public static int SCIPupdateDistributionScore(MemorySegment scip, double currentprob, double newprobup, double newprobdown, MemorySegment upscore, MemorySegment downscore, byte scoreparam) {
        var mh$ = SCIPupdateDistributionScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateDistributionScore", scip, currentprob, newprobup, newprobdown, upscore, downscore, scoreparam);
            }
            return (int)mh$.invokeExact(scip, currentprob, newprobup, newprobdown, upscore, downscore, scoreparam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleFullstrong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleFullstrong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleFullstrong(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleFullstrong$descriptor() {
        return SCIPincludeBranchruleFullstrong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleFullstrong(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleFullstrong$handle() {
        return SCIPincludeBranchruleFullstrong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleFullstrong(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleFullstrong$address() {
        return SCIPincludeBranchruleFullstrong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleFullstrong(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleFullstrong(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleFullstrong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleFullstrong", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectVarStrongBranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectVarStrongBranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarStrongBranching(SCIP *scip, SCIP_VAR **lpcands, double *lpcandssol, double *lpcandsfrac, unsigned int *skipdown, unsigned int *skipup, int nlpcands, int npriolpcands, int ncomplete, int *start, int maxproprounds, unsigned int probingbounds, unsigned int forcestrongbranch, int *bestcand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPselectVarStrongBranching$descriptor() {
        return SCIPselectVarStrongBranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarStrongBranching(SCIP *scip, SCIP_VAR **lpcands, double *lpcandssol, double *lpcandsfrac, unsigned int *skipdown, unsigned int *skipup, int nlpcands, int npriolpcands, int ncomplete, int *start, int maxproprounds, unsigned int probingbounds, unsigned int forcestrongbranch, int *bestcand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPselectVarStrongBranching$handle() {
        return SCIPselectVarStrongBranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarStrongBranching(SCIP *scip, SCIP_VAR **lpcands, double *lpcandssol, double *lpcandsfrac, unsigned int *skipdown, unsigned int *skipup, int nlpcands, int npriolpcands, int ncomplete, int *start, int maxproprounds, unsigned int probingbounds, unsigned int forcestrongbranch, int *bestcand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPselectVarStrongBranching$address() {
        return SCIPselectVarStrongBranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectVarStrongBranching(SCIP *scip, SCIP_VAR **lpcands, double *lpcandssol, double *lpcandsfrac, unsigned int *skipdown, unsigned int *skipup, int nlpcands, int npriolpcands, int ncomplete, int *start, int maxproprounds, unsigned int probingbounds, unsigned int forcestrongbranch, int *bestcand, double *bestdown, double *bestup, double *bestscore, unsigned int *bestdownvalid, unsigned int *bestupvalid, double *provedbound, SCIP_RESULT *result)
     * }
     */
    public static int SCIPselectVarStrongBranching(MemorySegment scip, MemorySegment lpcands, MemorySegment lpcandssol, MemorySegment lpcandsfrac, MemorySegment skipdown, MemorySegment skipup, int nlpcands, int npriolpcands, int ncomplete, MemorySegment start, int maxproprounds, int probingbounds, int forcestrongbranch, MemorySegment bestcand, MemorySegment bestdown, MemorySegment bestup, MemorySegment bestscore, MemorySegment bestdownvalid, MemorySegment bestupvalid, MemorySegment provedbound, MemorySegment result) {
        var mh$ = SCIPselectVarStrongBranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectVarStrongBranching", scip, lpcands, lpcandssol, lpcandsfrac, skipdown, skipup, nlpcands, npriolpcands, ncomplete, start, maxproprounds, probingbounds, forcestrongbranch, bestcand, bestdown, bestup, bestscore, bestdownvalid, bestupvalid, provedbound, result);
            }
            return (int)mh$.invokeExact(scip, lpcands, lpcandssol, lpcandsfrac, skipdown, skipup, nlpcands, npriolpcands, ncomplete, start, maxproprounds, probingbounds, forcestrongbranch, bestcand, bestdown, bestup, bestscore, bestdownvalid, bestupvalid, provedbound, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleGomory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleGomory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleGomory(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleGomory$descriptor() {
        return SCIPincludeBranchruleGomory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleGomory(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleGomory$handle() {
        return SCIPincludeBranchruleGomory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleGomory(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleGomory$address() {
        return SCIPincludeBranchruleGomory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleGomory(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleGomory(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleGomory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleGomory", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleInference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleInference");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleInference(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleInference$descriptor() {
        return SCIPincludeBranchruleInference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleInference(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleInference$handle() {
        return SCIPincludeBranchruleInference.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleInference(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleInference$address() {
        return SCIPincludeBranchruleInference.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleInference(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleInference(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleInference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleInference", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleLeastinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleLeastinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLeastinf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleLeastinf$descriptor() {
        return SCIPincludeBranchruleLeastinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLeastinf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleLeastinf$handle() {
        return SCIPincludeBranchruleLeastinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLeastinf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleLeastinf$address() {
        return SCIPincludeBranchruleLeastinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLeastinf(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleLeastinf(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleLeastinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleLeastinf", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleLookahead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleLookahead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLookahead(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleLookahead$descriptor() {
        return SCIPincludeBranchruleLookahead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLookahead(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleLookahead$handle() {
        return SCIPincludeBranchruleLookahead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLookahead(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleLookahead$address() {
        return SCIPincludeBranchruleLookahead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleLookahead(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleLookahead(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleLookahead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleLookahead", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleMostinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleMostinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMostinf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleMostinf$descriptor() {
        return SCIPincludeBranchruleMostinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMostinf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleMostinf$handle() {
        return SCIPincludeBranchruleMostinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMostinf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleMostinf$address() {
        return SCIPincludeBranchruleMostinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMostinf(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleMostinf(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleMostinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleMostinf", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleMultAggr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleMultAggr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMultAggr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleMultAggr$descriptor() {
        return SCIPincludeBranchruleMultAggr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMultAggr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleMultAggr$handle() {
        return SCIPincludeBranchruleMultAggr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMultAggr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleMultAggr$address() {
        return SCIPincludeBranchruleMultAggr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleMultAggr(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleMultAggr(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleMultAggr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleMultAggr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleNodereopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleNodereopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleNodereopt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleNodereopt$descriptor() {
        return SCIPincludeBranchruleNodereopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleNodereopt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleNodereopt$handle() {
        return SCIPincludeBranchruleNodereopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleNodereopt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleNodereopt$address() {
        return SCIPincludeBranchruleNodereopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleNodereopt(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleNodereopt(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleNodereopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleNodereopt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchrulePscost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchrulePscost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrulePscost(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchrulePscost$descriptor() {
        return SCIPincludeBranchrulePscost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrulePscost(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchrulePscost$handle() {
        return SCIPincludeBranchrulePscost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrulePscost(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchrulePscost$address() {
        return SCIPincludeBranchrulePscost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchrulePscost(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchrulePscost(MemorySegment scip) {
        var mh$ = SCIPincludeBranchrulePscost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchrulePscost", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectBranchVarPscost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectBranchVarPscost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectBranchVarPscost(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsscore, int nbranchcands, SCIP_VAR **var, double *brpoint)
     * }
     */
    public static FunctionDescriptor SCIPselectBranchVarPscost$descriptor() {
        return SCIPselectBranchVarPscost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectBranchVarPscost(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsscore, int nbranchcands, SCIP_VAR **var, double *brpoint)
     * }
     */
    public static MethodHandle SCIPselectBranchVarPscost$handle() {
        return SCIPselectBranchVarPscost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectBranchVarPscost(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsscore, int nbranchcands, SCIP_VAR **var, double *brpoint)
     * }
     */
    public static MemorySegment SCIPselectBranchVarPscost$address() {
        return SCIPselectBranchVarPscost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectBranchVarPscost(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsscore, int nbranchcands, SCIP_VAR **var, double *brpoint)
     * }
     */
    public static int SCIPselectBranchVarPscost(MemorySegment scip, MemorySegment branchcands, MemorySegment branchcandssol, MemorySegment branchcandsscore, int nbranchcands, MemorySegment var_, MemorySegment brpoint) {
        var mh$ = SCIPselectBranchVarPscost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectBranchVarPscost", scip, branchcands, branchcandssol, branchcandsscore, nbranchcands, var_, brpoint);
            }
            return (int)mh$.invokeExact(scip, branchcands, branchcandssol, branchcandsscore, nbranchcands, var_, brpoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleRandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRandom(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleRandom$descriptor() {
        return SCIPincludeBranchruleRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRandom(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleRandom$handle() {
        return SCIPincludeBranchruleRandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRandom(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleRandom$address() {
        return SCIPincludeBranchruleRandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRandom(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleRandom(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleRandom", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleRelpscost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleRelpscost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRelpscost(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleRelpscost$descriptor() {
        return SCIPincludeBranchruleRelpscost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRelpscost(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleRelpscost$handle() {
        return SCIPincludeBranchruleRelpscost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRelpscost(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleRelpscost$address() {
        return SCIPincludeBranchruleRelpscost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleRelpscost(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleRelpscost(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleRelpscost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleRelpscost", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexecRelpscostBranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexecRelpscostBranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecRelpscostBranching(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsfrac, int nbranchcands, unsigned int executebranching, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPexecRelpscostBranching$descriptor() {
        return SCIPexecRelpscostBranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecRelpscostBranching(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsfrac, int nbranchcands, unsigned int executebranching, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPexecRelpscostBranching$handle() {
        return SCIPexecRelpscostBranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecRelpscostBranching(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsfrac, int nbranchcands, unsigned int executebranching, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPexecRelpscostBranching$address() {
        return SCIPexecRelpscostBranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecRelpscostBranching(SCIP *scip, SCIP_VAR **branchcands, double *branchcandssol, double *branchcandsfrac, int nbranchcands, unsigned int executebranching, SCIP_RESULT *result)
     * }
     */
    public static int SCIPexecRelpscostBranching(MemorySegment scip, MemorySegment branchcands, MemorySegment branchcandssol, MemorySegment branchcandsfrac, int nbranchcands, int executebranching, MemorySegment result) {
        var mh$ = SCIPexecRelpscostBranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexecRelpscostBranching", scip, branchcands, branchcandssol, branchcandsfrac, nbranchcands, executebranching, result);
            }
            return (int)mh$.invokeExact(scip, branchcands, branchcandssol, branchcandsfrac, nbranchcands, executebranching, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBranchruleVanillafullstrong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBranchruleVanillafullstrong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleVanillafullstrong(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBranchruleVanillafullstrong$descriptor() {
        return SCIPincludeBranchruleVanillafullstrong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleVanillafullstrong(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBranchruleVanillafullstrong$handle() {
        return SCIPincludeBranchruleVanillafullstrong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleVanillafullstrong(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBranchruleVanillafullstrong$address() {
        return SCIPincludeBranchruleVanillafullstrong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBranchruleVanillafullstrong(SCIP *scip)
     * }
     */
    public static int SCIPincludeBranchruleVanillafullstrong(MemorySegment scip) {
        var mh$ = SCIPincludeBranchruleVanillafullstrong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBranchruleVanillafullstrong", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVanillafullstrongData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVanillafullstrongData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVanillafullstrongData(SCIP *scip, SCIP_VAR ***cands, double **candscores, int *ncands, int *npriocands, int *bestcand)
     * }
     */
    public static FunctionDescriptor SCIPgetVanillafullstrongData$descriptor() {
        return SCIPgetVanillafullstrongData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVanillafullstrongData(SCIP *scip, SCIP_VAR ***cands, double **candscores, int *ncands, int *npriocands, int *bestcand)
     * }
     */
    public static MethodHandle SCIPgetVanillafullstrongData$handle() {
        return SCIPgetVanillafullstrongData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVanillafullstrongData(SCIP *scip, SCIP_VAR ***cands, double **candscores, int *ncands, int *npriocands, int *bestcand)
     * }
     */
    public static MemorySegment SCIPgetVanillafullstrongData$address() {
        return SCIPgetVanillafullstrongData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVanillafullstrongData(SCIP *scip, SCIP_VAR ***cands, double **candscores, int *ncands, int *npriocands, int *bestcand)
     * }
     */
    public static int SCIPgetVanillafullstrongData(MemorySegment scip, MemorySegment cands, MemorySegment candscores, MemorySegment ncands, MemorySegment npriocands, MemorySegment bestcand) {
        var mh$ = SCIPgetVanillafullstrongData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVanillafullstrongData", scip, cands, candscores, ncands, npriocands, bestcand);
            }
            return (int)mh$.invokeExact(scip, cands, candscores, ncands, npriocands, bestcand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeComprLargestrepr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeComprLargestrepr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprLargestrepr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeComprLargestrepr$descriptor() {
        return SCIPincludeComprLargestrepr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprLargestrepr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeComprLargestrepr$handle() {
        return SCIPincludeComprLargestrepr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprLargestrepr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeComprLargestrepr$address() {
        return SCIPincludeComprLargestrepr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprLargestrepr(SCIP *scip)
     * }
     */
    public static int SCIPincludeComprLargestrepr(MemorySegment scip) {
        var mh$ = SCIPincludeComprLargestrepr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeComprLargestrepr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeComprWeakcompr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeComprWeakcompr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprWeakcompr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeComprWeakcompr$descriptor() {
        return SCIPincludeComprWeakcompr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprWeakcompr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeComprWeakcompr$handle() {
        return SCIPincludeComprWeakcompr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprWeakcompr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeComprWeakcompr$address() {
        return SCIPincludeComprWeakcompr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeComprWeakcompr(SCIP *scip)
     * }
     */
    public static int SCIPincludeComprWeakcompr(MemorySegment scip) {
        var mh$ = SCIPincludeComprWeakcompr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeComprWeakcompr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrAnd(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrAnd$descriptor() {
        return SCIPincludeConshdlrAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrAnd(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrAnd$handle() {
        return SCIPincludeConshdlrAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrAnd(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrAnd$address() {
        return SCIPincludeConshdlrAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrAnd(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrAnd(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrAnd", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsAnd$descriptor() {
        return SCIPcreateConsAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsAnd$handle() {
        return SCIPcreateConsAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsAnd$address() {
        return SCIPcreateConsAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsAnd(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment resvar, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsAnd", scip, cons, name, resvar, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, resvar, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicAnd$descriptor() {
        return SCIPcreateConsBasicAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicAnd$handle() {
        return SCIPcreateConsBasicAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicAnd$address() {
        return SCIPcreateConsBasicAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicAnd(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicAnd(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment resvar, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicAnd", scip, cons, name, resvar, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, resvar, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsAnd$descriptor() {
        return SCIPgetNVarsAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsAnd$handle() {
        return SCIPgetNVarsAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsAnd$address() {
        return SCIPgetNVarsAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsAnd(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsAnd", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsAnd$descriptor() {
        return SCIPgetVarsAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsAnd$handle() {
        return SCIPgetVarsAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsAnd$address() {
        return SCIPgetVarsAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsAnd(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsAnd", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetResultantAnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetResultantAnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetResultantAnd$descriptor() {
        return SCIPgetResultantAnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetResultantAnd$handle() {
        return SCIPgetResultantAnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetResultantAnd$address() {
        return SCIPgetResultantAnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantAnd(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetResultantAnd(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetResultantAnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetResultantAnd", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisAndConsSorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisAndConsSorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisAndConsSorted(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPisAndConsSorted$descriptor() {
        return SCIPisAndConsSorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisAndConsSorted(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPisAndConsSorted$handle() {
        return SCIPisAndConsSorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisAndConsSorted(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPisAndConsSorted$address() {
        return SCIPisAndConsSorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisAndConsSorted(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPisAndConsSorted(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPisAndConsSorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisAndConsSorted", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsortAndCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsortAndCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsortAndCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPsortAndCons$descriptor() {
        return SCIPsortAndCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsortAndCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPsortAndCons$handle() {
        return SCIPsortAndCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsortAndCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPsortAndCons$address() {
        return SCIPsortAndCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsortAndCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPsortAndCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPsortAndCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsortAndCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgAndConsCheckFlagWhenUpgr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgAndConsCheckFlagWhenUpgr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsCheckFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static FunctionDescriptor SCIPchgAndConsCheckFlagWhenUpgr$descriptor() {
        return SCIPchgAndConsCheckFlagWhenUpgr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsCheckFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static MethodHandle SCIPchgAndConsCheckFlagWhenUpgr$handle() {
        return SCIPchgAndConsCheckFlagWhenUpgr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsCheckFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static MemorySegment SCIPchgAndConsCheckFlagWhenUpgr$address() {
        return SCIPchgAndConsCheckFlagWhenUpgr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsCheckFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static int SCIPchgAndConsCheckFlagWhenUpgr(MemorySegment scip, MemorySegment cons, int flag) {
        var mh$ = SCIPchgAndConsCheckFlagWhenUpgr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgAndConsCheckFlagWhenUpgr", scip, cons, flag);
            }
            return (int)mh$.invokeExact(scip, cons, flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgAndConsRemovableFlagWhenUpgr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgAndConsRemovableFlagWhenUpgr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsRemovableFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static FunctionDescriptor SCIPchgAndConsRemovableFlagWhenUpgr$descriptor() {
        return SCIPchgAndConsRemovableFlagWhenUpgr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsRemovableFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static MethodHandle SCIPchgAndConsRemovableFlagWhenUpgr$handle() {
        return SCIPchgAndConsRemovableFlagWhenUpgr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsRemovableFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static MemorySegment SCIPchgAndConsRemovableFlagWhenUpgr$address() {
        return SCIPchgAndConsRemovableFlagWhenUpgr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgAndConsRemovableFlagWhenUpgr(SCIP *scip, SCIP_CONS *cons, unsigned int flag)
     * }
     */
    public static int SCIPchgAndConsRemovableFlagWhenUpgr(MemorySegment scip, MemorySegment cons, int flag) {
        var mh$ = SCIPchgAndConsRemovableFlagWhenUpgr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgAndConsRemovableFlagWhenUpgr", scip, cons, flag);
            }
            return (int)mh$.invokeExact(scip, cons, flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrBenders$descriptor() {
        return SCIPincludeConshdlrBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrBenders$handle() {
        return SCIPincludeConshdlrBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrBenders$address() {
        return SCIPincludeConshdlrBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenders(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrBenders(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrBenders", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconsBendersEnforceSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconsBendersEnforceSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconsBendersEnforceSolution(SCIP *scip, SCIP_SOL *sol, SCIP_CONSHDLR *conshdlr, SCIP_RESULT *result, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static FunctionDescriptor SCIPconsBendersEnforceSolution$descriptor() {
        return SCIPconsBendersEnforceSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconsBendersEnforceSolution(SCIP *scip, SCIP_SOL *sol, SCIP_CONSHDLR *conshdlr, SCIP_RESULT *result, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static MethodHandle SCIPconsBendersEnforceSolution$handle() {
        return SCIPconsBendersEnforceSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconsBendersEnforceSolution(SCIP *scip, SCIP_SOL *sol, SCIP_CONSHDLR *conshdlr, SCIP_RESULT *result, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static MemorySegment SCIPconsBendersEnforceSolution$address() {
        return SCIPconsBendersEnforceSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconsBendersEnforceSolution(SCIP *scip, SCIP_SOL *sol, SCIP_CONSHDLR *conshdlr, SCIP_RESULT *result, SCIP_BENDERSENFOTYPE type, unsigned int checkint)
     * }
     */
    public static int SCIPconsBendersEnforceSolution(MemorySegment scip, MemorySegment sol, MemorySegment conshdlr, MemorySegment result, int type, int checkint) {
        var mh$ = SCIPconsBendersEnforceSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconsBendersEnforceSolution", scip, sol, conshdlr, result, type, checkint);
            }
            return (int)mh$.invokeExact(scip, sol, conshdlr, result, type, checkint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrBenderslp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrBenderslp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenderslp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrBenderslp$descriptor() {
        return SCIPincludeConshdlrBenderslp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenderslp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrBenderslp$handle() {
        return SCIPincludeConshdlrBenderslp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenderslp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrBenderslp$address() {
        return SCIPincludeConshdlrBenderslp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBenderslp(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrBenderslp(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrBenderslp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrBenderslp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBounddisjunction(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrBounddisjunction$descriptor() {
        return SCIPincludeConshdlrBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBounddisjunction(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrBounddisjunction$handle() {
        return SCIPincludeConshdlrBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBounddisjunction(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrBounddisjunction$address() {
        return SCIPincludeConshdlrBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrBounddisjunction(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrBounddisjunction(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrBounddisjunction", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBounddisjunction$descriptor() {
        return SCIPcreateConsBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsBounddisjunction$handle() {
        return SCIPcreateConsBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsBounddisjunction$address() {
        return SCIPcreateConsBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsBounddisjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment boundtypes, MemorySegment bounds, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBounddisjunction", scip, cons, name, nvars, vars, boundtypes, bounds, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, boundtypes, bounds, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicBounddisjunction$descriptor() {
        return SCIPcreateConsBasicBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicBounddisjunction$handle() {
        return SCIPcreateConsBasicBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicBounddisjunction$address() {
        return SCIPcreateConsBasicBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static int SCIPcreateConsBasicBounddisjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment boundtypes, MemorySegment bounds) {
        var mh$ = SCIPcreateConsBasicBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicBounddisjunction", scip, cons, name, nvars, vars, boundtypes, bounds);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, boundtypes, bounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBounddisjunctionRedundant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBounddisjunctionRedundant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBounddisjunctionRedundant$descriptor() {
        return SCIPcreateConsBounddisjunctionRedundant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsBounddisjunctionRedundant$handle() {
        return SCIPcreateConsBounddisjunctionRedundant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsBounddisjunctionRedundant$address() {
        return SCIPcreateConsBounddisjunctionRedundant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsBounddisjunctionRedundant(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment boundtypes, MemorySegment bounds, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsBounddisjunctionRedundant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBounddisjunctionRedundant", scip, cons, name, nvars, vars, boundtypes, bounds, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, boundtypes, bounds, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicBounddisjunctionRedundant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicBounddisjunctionRedundant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicBounddisjunctionRedundant$descriptor() {
        return SCIPcreateConsBasicBounddisjunctionRedundant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicBounddisjunctionRedundant$handle() {
        return SCIPcreateConsBasicBounddisjunctionRedundant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicBounddisjunctionRedundant$address() {
        return SCIPcreateConsBasicBounddisjunctionRedundant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicBounddisjunctionRedundant(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, SCIP_BOUNDTYPE *boundtypes, double *bounds)
     * }
     */
    public static int SCIPcreateConsBasicBounddisjunctionRedundant(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment boundtypes, MemorySegment bounds) {
        var mh$ = SCIPcreateConsBasicBounddisjunctionRedundant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicBounddisjunctionRedundant", scip, cons, name, nvars, vars, boundtypes, bounds);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, boundtypes, bounds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsBounddisjunction$descriptor() {
        return SCIPgetNVarsBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsBounddisjunction$handle() {
        return SCIPgetNVarsBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsBounddisjunction$address() {
        return SCIPgetNVarsBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsBounddisjunction(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsBounddisjunction", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsBounddisjunction$descriptor() {
        return SCIPgetVarsBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsBounddisjunction$handle() {
        return SCIPgetVarsBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsBounddisjunction$address() {
        return SCIPgetVarsBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsBounddisjunction(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsBounddisjunction", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoundtypesBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoundtypesBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPgetBoundtypesBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetBoundtypesBounddisjunction$descriptor() {
        return SCIPgetBoundtypesBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPgetBoundtypesBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetBoundtypesBounddisjunction$handle() {
        return SCIPgetBoundtypesBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPgetBoundtypesBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBoundtypesBounddisjunction$address() {
        return SCIPgetBoundtypesBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_BOUNDTYPE *SCIPgetBoundtypesBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBoundtypesBounddisjunction(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetBoundtypesBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoundtypesBounddisjunction", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoundsBounddisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoundsBounddisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetBoundsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetBoundsBounddisjunction$descriptor() {
        return SCIPgetBoundsBounddisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetBoundsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetBoundsBounddisjunction$handle() {
        return SCIPgetBoundsBounddisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetBoundsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBoundsBounddisjunction$address() {
        return SCIPgetBoundsBounddisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetBoundsBounddisjunction(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBoundsBounddisjunction(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetBoundsBounddisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoundsBounddisjunction", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCardinality(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrCardinality$descriptor() {
        return SCIPincludeConshdlrCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCardinality(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrCardinality$handle() {
        return SCIPincludeConshdlrCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCardinality(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrCardinality$address() {
        return SCIPincludeConshdlrCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCardinality(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrCardinality(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrCardinality", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsCardinality$descriptor() {
        return SCIPcreateConsCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsCardinality$handle() {
        return SCIPcreateConsCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsCardinality$address() {
        return SCIPcreateConsCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsCardinality(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int cardval, MemorySegment indvars, MemorySegment weights, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsCardinality", scip, cons, name, nvars, vars, cardval, indvars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, cardval, indvars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicCardinality$descriptor() {
        return SCIPcreateConsBasicCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicCardinality$handle() {
        return SCIPcreateConsBasicCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicCardinality$address() {
        return SCIPcreateConsBasicCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCardinality(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int cardval, SCIP_VAR **indvars, double *weights)
     * }
     */
    public static int SCIPcreateConsBasicCardinality(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int cardval, MemorySegment indvars, MemorySegment weights) {
        var mh$ = SCIPcreateConsBasicCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicCardinality", scip, cons, name, nvars, vars, cardval, indvars, weights);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, cardval, indvars, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgCardvalCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgCardvalCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCardvalCardinality(SCIP *scip, SCIP_CONS *cons, int cardval)
     * }
     */
    public static FunctionDescriptor SCIPchgCardvalCardinality$descriptor() {
        return SCIPchgCardvalCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCardvalCardinality(SCIP *scip, SCIP_CONS *cons, int cardval)
     * }
     */
    public static MethodHandle SCIPchgCardvalCardinality$handle() {
        return SCIPchgCardvalCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCardvalCardinality(SCIP *scip, SCIP_CONS *cons, int cardval)
     * }
     */
    public static MemorySegment SCIPchgCardvalCardinality$address() {
        return SCIPchgCardvalCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCardvalCardinality(SCIP *scip, SCIP_CONS *cons, int cardval)
     * }
     */
    public static int SCIPchgCardvalCardinality(MemorySegment scip, MemorySegment cons, int cardval) {
        var mh$ = SCIPchgCardvalCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgCardvalCardinality", scip, cons, cardval);
            }
            return (int)mh$.invokeExact(scip, cons, cardval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar, double weight)
     * }
     */
    public static FunctionDescriptor SCIPaddVarCardinality$descriptor() {
        return SCIPaddVarCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar, double weight)
     * }
     */
    public static MethodHandle SCIPaddVarCardinality$handle() {
        return SCIPaddVarCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar, double weight)
     * }
     */
    public static MemorySegment SCIPaddVarCardinality$address() {
        return SCIPaddVarCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar, double weight)
     * }
     */
    public static int SCIPaddVarCardinality(MemorySegment scip, MemorySegment cons, MemorySegment var_, MemorySegment indvar, double weight) {
        var mh$ = SCIPaddVarCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarCardinality", scip, cons, var_, indvar, weight);
            }
            return (int)mh$.invokeExact(scip, cons, var_, indvar, weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPappendVarCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPappendVarCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar)
     * }
     */
    public static FunctionDescriptor SCIPappendVarCardinality$descriptor() {
        return SCIPappendVarCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar)
     * }
     */
    public static MethodHandle SCIPappendVarCardinality$handle() {
        return SCIPappendVarCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar)
     * }
     */
    public static MemorySegment SCIPappendVarCardinality$address() {
        return SCIPappendVarCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarCardinality(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, SCIP_VAR *indvar)
     * }
     */
    public static int SCIPappendVarCardinality(MemorySegment scip, MemorySegment cons, MemorySegment var_, MemorySegment indvar) {
        var mh$ = SCIPappendVarCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPappendVarCardinality", scip, cons, var_, indvar);
            }
            return (int)mh$.invokeExact(scip, cons, var_, indvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsCardinality$descriptor() {
        return SCIPgetNVarsCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsCardinality$handle() {
        return SCIPgetNVarsCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsCardinality$address() {
        return SCIPgetNVarsCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsCardinality(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsCardinality", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsCardinality$descriptor() {
        return SCIPgetVarsCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsCardinality$handle() {
        return SCIPgetVarsCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsCardinality$address() {
        return SCIPgetVarsCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsCardinality(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsCardinality", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCardvalCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCardvalCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetCardvalCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetCardvalCardinality$descriptor() {
        return SCIPgetCardvalCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetCardvalCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetCardvalCardinality$handle() {
        return SCIPgetCardvalCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetCardvalCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetCardvalCardinality$address() {
        return SCIPgetCardvalCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetCardvalCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetCardvalCardinality(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetCardvalCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCardvalCardinality", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetWeightsCardinality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetWeightsCardinality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetWeightsCardinality$descriptor() {
        return SCIPgetWeightsCardinality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetWeightsCardinality$handle() {
        return SCIPgetWeightsCardinality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsCardinality$address() {
        return SCIPgetWeightsCardinality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetWeightsCardinality(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsCardinality(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetWeightsCardinality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetWeightsCardinality", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrConjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrConjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrConjunction(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrConjunction$descriptor() {
        return SCIPincludeConshdlrConjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrConjunction(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrConjunction$handle() {
        return SCIPincludeConshdlrConjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrConjunction(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrConjunction$address() {
        return SCIPincludeConshdlrConjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrConjunction(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrConjunction(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrConjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrConjunction", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsConjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsConjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsConjunction$descriptor() {
        return SCIPcreateConsConjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static MethodHandle SCIPcreateConsConjunction$handle() {
        return SCIPcreateConsConjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static MemorySegment SCIPcreateConsConjunction$address() {
        return SCIPcreateConsConjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static int SCIPcreateConsConjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nconss, MemorySegment conss, int enforce, int check, int local, int modifiable, int dynamic) {
        var mh$ = SCIPcreateConsConjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsConjunction", scip, cons, name, nconss, conss, enforce, check, local, modifiable, dynamic);
            }
            return (int)mh$.invokeExact(scip, cons, name, nconss, conss, enforce, check, local, modifiable, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicConjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicConjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicConjunction$descriptor() {
        return SCIPcreateConsBasicConjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicConjunction$handle() {
        return SCIPcreateConsBasicConjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicConjunction$address() {
        return SCIPcreateConsBasicConjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicConjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss)
     * }
     */
    public static int SCIPcreateConsBasicConjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nconss, MemorySegment conss) {
        var mh$ = SCIPcreateConsBasicConjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicConjunction", scip, cons, name, nconss, conss);
            }
            return (int)mh$.invokeExact(scip, cons, name, nconss, conss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsElemConjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsElemConjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemConjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static FunctionDescriptor SCIPaddConsElemConjunction$descriptor() {
        return SCIPaddConsElemConjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemConjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static MethodHandle SCIPaddConsElemConjunction$handle() {
        return SCIPaddConsElemConjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemConjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static MemorySegment SCIPaddConsElemConjunction$address() {
        return SCIPaddConsElemConjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemConjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static int SCIPaddConsElemConjunction(MemorySegment scip, MemorySegment cons, MemorySegment addcons) {
        var mh$ = SCIPaddConsElemConjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsElemConjunction", scip, cons, addcons);
            }
            return (int)mh$.invokeExact(scip, cons, addcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrCountsols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrCountsols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCountsols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrCountsols$descriptor() {
        return SCIPincludeConshdlrCountsols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCountsols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrCountsols$handle() {
        return SCIPincludeConshdlrCountsols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCountsols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrCountsols$address() {
        return SCIPincludeConshdlrCountsols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCountsols(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrCountsols(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrCountsols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrCountsols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecCountPresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecCountPresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCountPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecCountPresolve$descriptor() {
        return SCIPdialogExecCountPresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCountPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecCountPresolve$handle() {
        return SCIPdialogExecCountPresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCountPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecCountPresolve$address() {
        return SCIPdialogExecCountPresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCountPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecCountPresolve(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecCountPresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecCountPresolve", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCount(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecCount$descriptor() {
        return SCIPdialogExecCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCount(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecCount$handle() {
        return SCIPdialogExecCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCount(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecCount$address() {
        return SCIPdialogExecCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCount(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecCount(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecCount", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecWriteAllsolutions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecWriteAllsolutions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecWriteAllsolutions(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecWriteAllsolutions$descriptor() {
        return SCIPdialogExecWriteAllsolutions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecWriteAllsolutions(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecWriteAllsolutions$handle() {
        return SCIPdialogExecWriteAllsolutions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecWriteAllsolutions(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecWriteAllsolutions$address() {
        return SCIPdialogExecWriteAllsolutions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecWriteAllsolutions(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecWriteAllsolutions(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecWriteAllsolutions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecWriteAllsolutions", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcount(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPcount$descriptor() {
        return SCIPcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcount(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPcount$handle() {
        return SCIPcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcount(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPcount$address() {
        return SCIPcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcount(SCIP *scip)
     * }
     */
    public static int SCIPcount(MemorySegment scip) {
        var mh$ = SCIPcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcount", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCountedSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCountedSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedSols(SCIP *scip, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPgetNCountedSols$descriptor() {
        return SCIPgetNCountedSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedSols(SCIP *scip, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPgetNCountedSols$handle() {
        return SCIPgetNCountedSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedSols(SCIP *scip, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPgetNCountedSols$address() {
        return SCIPgetNCountedSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNCountedSols(SCIP *scip, unsigned int *valid)
     * }
     */
    public static long SCIPgetNCountedSols(MemorySegment scip, MemorySegment valid) {
        var mh$ = SCIPgetNCountedSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCountedSols", scip, valid);
            }
            return (long)mh$.invokeExact(scip, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCountedSolsstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCountedSolsstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetNCountedSolsstr(SCIP *scip, char **buffer, int buffersize, int *requiredsize)
     * }
     */
    public static FunctionDescriptor SCIPgetNCountedSolsstr$descriptor() {
        return SCIPgetNCountedSolsstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetNCountedSolsstr(SCIP *scip, char **buffer, int buffersize, int *requiredsize)
     * }
     */
    public static MethodHandle SCIPgetNCountedSolsstr$handle() {
        return SCIPgetNCountedSolsstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetNCountedSolsstr(SCIP *scip, char **buffer, int buffersize, int *requiredsize)
     * }
     */
    public static MemorySegment SCIPgetNCountedSolsstr$address() {
        return SCIPgetNCountedSolsstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetNCountedSolsstr(SCIP *scip, char **buffer, int buffersize, int *requiredsize)
     * }
     */
    public static void SCIPgetNCountedSolsstr(MemorySegment scip, MemorySegment buffer, int buffersize, MemorySegment requiredsize) {
        var mh$ = SCIPgetNCountedSolsstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCountedSolsstr", scip, buffer, buffersize, requiredsize);
            }
            mh$.invokeExact(scip, buffer, buffersize, requiredsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCountedFeasSubtrees {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCountedFeasSubtrees");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedFeasSubtrees(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCountedFeasSubtrees$descriptor() {
        return SCIPgetNCountedFeasSubtrees.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedFeasSubtrees(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCountedFeasSubtrees$handle() {
        return SCIPgetNCountedFeasSubtrees.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNCountedFeasSubtrees(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCountedFeasSubtrees$address() {
        return SCIPgetNCountedFeasSubtrees.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNCountedFeasSubtrees(SCIP *scip)
     * }
     */
    public static long SCIPgetNCountedFeasSubtrees(MemorySegment scip) {
        var mh$ = SCIPgetNCountedFeasSubtrees.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCountedFeasSubtrees", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCountedSparseSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCountedSparseSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetCountedSparseSols(SCIP *scip, SCIP_VAR ***vars, int *nvars, SCIP_SPARSESOL ***sols, int *nsols)
     * }
     */
    public static FunctionDescriptor SCIPgetCountedSparseSols$descriptor() {
        return SCIPgetCountedSparseSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetCountedSparseSols(SCIP *scip, SCIP_VAR ***vars, int *nvars, SCIP_SPARSESOL ***sols, int *nsols)
     * }
     */
    public static MethodHandle SCIPgetCountedSparseSols$handle() {
        return SCIPgetCountedSparseSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetCountedSparseSols(SCIP *scip, SCIP_VAR ***vars, int *nvars, SCIP_SPARSESOL ***sols, int *nsols)
     * }
     */
    public static MemorySegment SCIPgetCountedSparseSols$address() {
        return SCIPgetCountedSparseSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetCountedSparseSols(SCIP *scip, SCIP_VAR ***vars, int *nvars, SCIP_SPARSESOL ***sols, int *nsols)
     * }
     */
    public static void SCIPgetCountedSparseSols(MemorySegment scip, MemorySegment vars, MemorySegment nvars, MemorySegment sols, MemorySegment nsols) {
        var mh$ = SCIPgetCountedSparseSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCountedSparseSols", scip, vars, nvars, sols, nsols);
            }
            mh$.invokeExact(scip, vars, nvars, sols, nsols);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetParamsCountsols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetParamsCountsols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParamsCountsols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsetParamsCountsols$descriptor() {
        return SCIPsetParamsCountsols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParamsCountsols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsetParamsCountsols$handle() {
        return SCIPsetParamsCountsols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParamsCountsols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsetParamsCountsols$address() {
        return SCIPsetParamsCountsols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParamsCountsols(SCIP *scip)
     * }
     */
    public static int SCIPsetParamsCountsols(MemorySegment scip) {
        var mh$ = SCIPsetParamsCountsols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetParamsCountsols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCumulative(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrCumulative$descriptor() {
        return SCIPincludeConshdlrCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCumulative(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrCumulative$handle() {
        return SCIPincludeConshdlrCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCumulative(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrCumulative$address() {
        return SCIPincludeConshdlrCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrCumulative(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrCumulative(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrCumulative", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsCumulative$descriptor() {
        return SCIPcreateConsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsCumulative$handle() {
        return SCIPcreateConsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsCumulative$address() {
        return SCIPcreateConsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsCumulative(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsCumulative", scip, cons, name, nvars, vars, durations, demands, capacity, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, durations, demands, capacity, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicCumulative$descriptor() {
        return SCIPcreateConsBasicCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicCumulative$handle() {
        return SCIPcreateConsBasicCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicCumulative$address() {
        return SCIPcreateConsBasicCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicCumulative(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity)
     * }
     */
    public static int SCIPcreateConsBasicCumulative(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity) {
        var mh$ = SCIPcreateConsBasicCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicCumulative", scip, cons, name, nvars, vars, durations, demands, capacity);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, durations, demands, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHminCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHminCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHminCumulative(SCIP *scip, SCIP_CONS *cons, int hmin)
     * }
     */
    public static FunctionDescriptor SCIPsetHminCumulative$descriptor() {
        return SCIPsetHminCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHminCumulative(SCIP *scip, SCIP_CONS *cons, int hmin)
     * }
     */
    public static MethodHandle SCIPsetHminCumulative$handle() {
        return SCIPsetHminCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHminCumulative(SCIP *scip, SCIP_CONS *cons, int hmin)
     * }
     */
    public static MemorySegment SCIPsetHminCumulative$address() {
        return SCIPsetHminCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHminCumulative(SCIP *scip, SCIP_CONS *cons, int hmin)
     * }
     */
    public static int SCIPsetHminCumulative(MemorySegment scip, MemorySegment cons, int hmin) {
        var mh$ = SCIPsetHminCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHminCumulative", scip, cons, hmin);
            }
            return (int)mh$.invokeExact(scip, cons, hmin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetHminCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetHminCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetHminCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetHminCumulative$descriptor() {
        return SCIPgetHminCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetHminCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetHminCumulative$handle() {
        return SCIPgetHminCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetHminCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetHminCumulative$address() {
        return SCIPgetHminCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetHminCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetHminCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetHminCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetHminCumulative", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHmaxCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHmaxCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHmaxCumulative(SCIP *scip, SCIP_CONS *cons, int hmax)
     * }
     */
    public static FunctionDescriptor SCIPsetHmaxCumulative$descriptor() {
        return SCIPsetHmaxCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHmaxCumulative(SCIP *scip, SCIP_CONS *cons, int hmax)
     * }
     */
    public static MethodHandle SCIPsetHmaxCumulative$handle() {
        return SCIPsetHmaxCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHmaxCumulative(SCIP *scip, SCIP_CONS *cons, int hmax)
     * }
     */
    public static MemorySegment SCIPsetHmaxCumulative$address() {
        return SCIPsetHmaxCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHmaxCumulative(SCIP *scip, SCIP_CONS *cons, int hmax)
     * }
     */
    public static int SCIPsetHmaxCumulative(MemorySegment scip, MemorySegment cons, int hmax) {
        var mh$ = SCIPsetHmaxCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHmaxCumulative", scip, cons, hmax);
            }
            return (int)mh$.invokeExact(scip, cons, hmax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetHmaxCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetHmaxCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetHmaxCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetHmaxCumulative$descriptor() {
        return SCIPgetHmaxCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetHmaxCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetHmaxCumulative$handle() {
        return SCIPgetHmaxCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetHmaxCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetHmaxCumulative$address() {
        return SCIPgetHmaxCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetHmaxCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetHmaxCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetHmaxCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetHmaxCumulative", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsCumulative$descriptor() {
        return SCIPgetVarsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsCumulative$handle() {
        return SCIPgetVarsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsCumulative$address() {
        return SCIPgetVarsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsCumulative", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsCumulative$descriptor() {
        return SCIPgetNVarsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsCumulative$handle() {
        return SCIPgetNVarsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsCumulative$address() {
        return SCIPgetNVarsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsCumulative", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCapacityCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCapacityCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetCapacityCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetCapacityCumulative$descriptor() {
        return SCIPgetCapacityCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetCapacityCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetCapacityCumulative$handle() {
        return SCIPgetCapacityCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetCapacityCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetCapacityCumulative$address() {
        return SCIPgetCapacityCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetCapacityCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetCapacityCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetCapacityCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCapacityCumulative", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDurationsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDurationsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPgetDurationsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDurationsCumulative$descriptor() {
        return SCIPgetDurationsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPgetDurationsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDurationsCumulative$handle() {
        return SCIPgetDurationsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPgetDurationsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDurationsCumulative$address() {
        return SCIPgetDurationsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPgetDurationsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDurationsCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDurationsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDurationsCumulative", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDemandsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDemandsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *SCIPgetDemandsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDemandsCumulative$descriptor() {
        return SCIPgetDemandsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *SCIPgetDemandsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDemandsCumulative$handle() {
        return SCIPgetDemandsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int *SCIPgetDemandsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDemandsCumulative$address() {
        return SCIPgetDemandsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int *SCIPgetDemandsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDemandsCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDemandsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDemandsCumulative", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCumulativeCondition(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, unsigned int *violated, SCIP_CONS *cons, unsigned int printreason)
     * }
     */
    public static FunctionDescriptor SCIPcheckCumulativeCondition$descriptor() {
        return SCIPcheckCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCumulativeCondition(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, unsigned int *violated, SCIP_CONS *cons, unsigned int printreason)
     * }
     */
    public static MethodHandle SCIPcheckCumulativeCondition$handle() {
        return SCIPcheckCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCumulativeCondition(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, unsigned int *violated, SCIP_CONS *cons, unsigned int printreason)
     * }
     */
    public static MemorySegment SCIPcheckCumulativeCondition$address() {
        return SCIPcheckCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckCumulativeCondition(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, unsigned int *violated, SCIP_CONS *cons, unsigned int printreason)
     * }
     */
    public static int SCIPcheckCumulativeCondition(MemorySegment scip, MemorySegment sol, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity, int hmin, int hmax, MemorySegment violated, MemorySegment cons, int printreason) {
        var mh$ = SCIPcheckCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckCumulativeCondition", scip, sol, nvars, vars, durations, demands, capacity, hmin, hmax, violated, cons, printreason);
            }
            return (int)mh$.invokeExact(scip, sol, nvars, vars, durations, demands, capacity, hmin, hmax, violated, cons, printreason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnormalizeCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnormalizeCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnormalizeCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int *capacity, int *nchgcoefs, int *nchgsides)
     * }
     */
    public static FunctionDescriptor SCIPnormalizeCumulativeCondition$descriptor() {
        return SCIPnormalizeCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnormalizeCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int *capacity, int *nchgcoefs, int *nchgsides)
     * }
     */
    public static MethodHandle SCIPnormalizeCumulativeCondition$handle() {
        return SCIPnormalizeCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnormalizeCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int *capacity, int *nchgcoefs, int *nchgsides)
     * }
     */
    public static MemorySegment SCIPnormalizeCumulativeCondition$address() {
        return SCIPnormalizeCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnormalizeCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int *capacity, int *nchgcoefs, int *nchgsides)
     * }
     */
    public static int SCIPnormalizeCumulativeCondition(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, MemorySegment capacity, MemorySegment nchgcoefs, MemorySegment nchgsides) {
        var mh$ = SCIPnormalizeCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnormalizeCumulativeCondition", scip, nvars, vars, durations, demands, capacity, nchgcoefs, nchgsides);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, durations, demands, capacity, nchgcoefs, nchgsides);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsplitCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsplitCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int *hmin, int *hmax, int *split)
     * }
     */
    public static FunctionDescriptor SCIPsplitCumulativeCondition$descriptor() {
        return SCIPsplitCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int *hmin, int *hmax, int *split)
     * }
     */
    public static MethodHandle SCIPsplitCumulativeCondition$handle() {
        return SCIPsplitCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int *hmin, int *hmax, int *split)
     * }
     */
    public static MemorySegment SCIPsplitCumulativeCondition$address() {
        return SCIPsplitCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int *hmin, int *hmax, int *split)
     * }
     */
    public static int SCIPsplitCumulativeCondition(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity, MemorySegment hmin, MemorySegment hmax, MemorySegment split) {
        var mh$ = SCIPsplitCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsplitCumulativeCondition", scip, nvars, vars, durations, demands, capacity, hmin, hmax, split);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, durations, demands, capacity, hmin, hmax, split);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolveCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolveCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolveCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int hmin, int hmax, unsigned int *downlocks, unsigned int *uplocks, SCIP_CONS *cons, unsigned int *delvars, int *nfixedvars, int *nchgsides, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPpresolveCumulativeCondition$descriptor() {
        return SCIPpresolveCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolveCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int hmin, int hmax, unsigned int *downlocks, unsigned int *uplocks, SCIP_CONS *cons, unsigned int *delvars, int *nfixedvars, int *nchgsides, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPpresolveCumulativeCondition$handle() {
        return SCIPpresolveCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolveCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int hmin, int hmax, unsigned int *downlocks, unsigned int *uplocks, SCIP_CONS *cons, unsigned int *delvars, int *nfixedvars, int *nchgsides, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPpresolveCumulativeCondition$address() {
        return SCIPpresolveCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolveCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int hmin, int hmax, unsigned int *downlocks, unsigned int *uplocks, SCIP_CONS *cons, unsigned int *delvars, int *nfixedvars, int *nchgsides, unsigned int *cutoff)
     * }
     */
    public static int SCIPpresolveCumulativeCondition(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment durations, int hmin, int hmax, MemorySegment downlocks, MemorySegment uplocks, MemorySegment cons, MemorySegment delvars, MemorySegment nfixedvars, MemorySegment nchgsides, MemorySegment cutoff) {
        var mh$ = SCIPpresolveCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolveCumulativeCondition", scip, nvars, vars, durations, hmin, hmax, downlocks, uplocks, cons, delvars, nfixedvars, nchgsides, cutoff);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, durations, hmin, hmax, downlocks, uplocks, cons, delvars, nfixedvars, nchgsides, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCumulativeCondition(SCIP *scip, SCIP_PRESOLTIMING presoltiming, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_CONS *cons, int *nchgbds, unsigned int *initialized, unsigned int *explanation, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPpropCumulativeCondition$descriptor() {
        return SCIPpropCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCumulativeCondition(SCIP *scip, SCIP_PRESOLTIMING presoltiming, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_CONS *cons, int *nchgbds, unsigned int *initialized, unsigned int *explanation, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPpropCumulativeCondition$handle() {
        return SCIPpropCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCumulativeCondition(SCIP *scip, SCIP_PRESOLTIMING presoltiming, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_CONS *cons, int *nchgbds, unsigned int *initialized, unsigned int *explanation, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPpropCumulativeCondition$address() {
        return SCIPpropCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropCumulativeCondition(SCIP *scip, SCIP_PRESOLTIMING presoltiming, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_CONS *cons, int *nchgbds, unsigned int *initialized, unsigned int *explanation, unsigned int *cutoff)
     * }
     */
    public static int SCIPpropCumulativeCondition(MemorySegment scip, int presoltiming, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity, int hmin, int hmax, MemorySegment cons, MemorySegment nchgbds, MemorySegment initialized, MemorySegment explanation, MemorySegment cutoff) {
        var mh$ = SCIPpropCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropCumulativeCondition", scip, presoltiming, nvars, vars, durations, demands, capacity, hmin, hmax, cons, nchgbds, initialized, explanation, cutoff);
            }
            return (int)mh$.invokeExact(scip, presoltiming, nvars, vars, durations, demands, capacity, hmin, hmax, cons, nchgbds, initialized, explanation, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrespropCumulativeCondition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrespropCumulativeCondition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, unsigned int *explanation, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPrespropCumulativeCondition$descriptor() {
        return SCIPrespropCumulativeCondition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, unsigned int *explanation, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPrespropCumulativeCondition$handle() {
        return SCIPrespropCumulativeCondition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, unsigned int *explanation, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPrespropCumulativeCondition$address() {
        return SCIPrespropCumulativeCondition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrespropCumulativeCondition(SCIP *scip, int nvars, SCIP_VAR **vars, int *durations, int *demands, int capacity, int hmin, int hmax, SCIP_VAR *infervar, int inferinfo, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, double relaxedbd, unsigned int *explanation, SCIP_RESULT *result)
     * }
     */
    public static int SCIPrespropCumulativeCondition(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands, int capacity, int hmin, int hmax, MemorySegment infervar, int inferinfo, int boundtype, MemorySegment bdchgidx, double relaxedbd, MemorySegment explanation, MemorySegment result) {
        var mh$ = SCIPrespropCumulativeCondition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrespropCumulativeCondition", scip, nvars, vars, durations, demands, capacity, hmin, hmax, infervar, inferinfo, boundtype, bdchgidx, relaxedbd, explanation, result);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, durations, demands, capacity, hmin, hmax, infervar, inferinfo, boundtype, bdchgidx, relaxedbd, explanation, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvisualizeConsCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvisualizeConsCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvisualizeConsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPvisualizeConsCumulative$descriptor() {
        return SCIPvisualizeConsCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvisualizeConsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPvisualizeConsCumulative$handle() {
        return SCIPvisualizeConsCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvisualizeConsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPvisualizeConsCumulative$address() {
        return SCIPvisualizeConsCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvisualizeConsCumulative(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPvisualizeConsCumulative(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPvisualizeConsCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvisualizeConsCumulative", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSolveCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSolveCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolveCumulative(SCIP *scip, SCIP_RETCODE (*solveCumulative)(int, double *, double *, double *, int *, int *, int, int, int, double, double, long long, unsigned int *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetSolveCumulative$descriptor() {
        return SCIPsetSolveCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolveCumulative(SCIP *scip, SCIP_RETCODE (*solveCumulative)(int, double *, double *, double *, int *, int *, int, int, int, double, double, long long, unsigned int *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetSolveCumulative$handle() {
        return SCIPsetSolveCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolveCumulative(SCIP *scip, SCIP_RETCODE (*solveCumulative)(int, double *, double *, double *, int *, int *, int, int, int, double, double, long long, unsigned int *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetSolveCumulative$address() {
        return SCIPsetSolveCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolveCumulative(SCIP *scip, SCIP_RETCODE (*solveCumulative)(int, double *, double *, double *, int *, int *, int, int, int, double, double, long long, unsigned int *, unsigned int *, unsigned int *, unsigned int *))
     * }
     */
    public static int SCIPsetSolveCumulative(MemorySegment scip, MemorySegment solveCumulative) {
        var mh$ = SCIPsetSolveCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSolveCumulative", scip, solveCumulative);
            }
            return (int)mh$.invokeExact(scip, solveCumulative);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveCumulative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveCumulative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveCumulative(SCIP *scip, int njobs, double *ests, double *lsts, double *objvals, int *durations, int *demands, int capacity, int hmin, int hmax, double timelimit, double memorylimit, long long maxnodes, unsigned int *solved, unsigned int *infeasible, unsigned int *unbounded, unsigned int *error)
     * }
     */
    public static FunctionDescriptor SCIPsolveCumulative$descriptor() {
        return SCIPsolveCumulative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveCumulative(SCIP *scip, int njobs, double *ests, double *lsts, double *objvals, int *durations, int *demands, int capacity, int hmin, int hmax, double timelimit, double memorylimit, long long maxnodes, unsigned int *solved, unsigned int *infeasible, unsigned int *unbounded, unsigned int *error)
     * }
     */
    public static MethodHandle SCIPsolveCumulative$handle() {
        return SCIPsolveCumulative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveCumulative(SCIP *scip, int njobs, double *ests, double *lsts, double *objvals, int *durations, int *demands, int capacity, int hmin, int hmax, double timelimit, double memorylimit, long long maxnodes, unsigned int *solved, unsigned int *infeasible, unsigned int *unbounded, unsigned int *error)
     * }
     */
    public static MemorySegment SCIPsolveCumulative$address() {
        return SCIPsolveCumulative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveCumulative(SCIP *scip, int njobs, double *ests, double *lsts, double *objvals, int *durations, int *demands, int capacity, int hmin, int hmax, double timelimit, double memorylimit, long long maxnodes, unsigned int *solved, unsigned int *infeasible, unsigned int *unbounded, unsigned int *error)
     * }
     */
    public static int SCIPsolveCumulative(MemorySegment scip, int njobs, MemorySegment ests, MemorySegment lsts, MemorySegment objvals, MemorySegment durations, MemorySegment demands, int capacity, int hmin, int hmax, double timelimit, double memorylimit, long maxnodes, MemorySegment solved, MemorySegment infeasible, MemorySegment unbounded, MemorySegment error) {
        var mh$ = SCIPsolveCumulative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveCumulative", scip, njobs, ests, lsts, objvals, durations, demands, capacity, hmin, hmax, timelimit, memorylimit, maxnodes, solved, infeasible, unbounded, error);
            }
            return (int)mh$.invokeExact(scip, njobs, ests, lsts, objvals, durations, demands, capacity, hmin, hmax, timelimit, memorylimit, maxnodes, solved, infeasible, unbounded, error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateWorstCaseProfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateWorstCaseProfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWorstCaseProfile(SCIP *scip, SCIP_PROFILE *profile, int nvars, SCIP_VAR **vars, int *durations, int *demands)
     * }
     */
    public static FunctionDescriptor SCIPcreateWorstCaseProfile$descriptor() {
        return SCIPcreateWorstCaseProfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWorstCaseProfile(SCIP *scip, SCIP_PROFILE *profile, int nvars, SCIP_VAR **vars, int *durations, int *demands)
     * }
     */
    public static MethodHandle SCIPcreateWorstCaseProfile$handle() {
        return SCIPcreateWorstCaseProfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWorstCaseProfile(SCIP *scip, SCIP_PROFILE *profile, int nvars, SCIP_VAR **vars, int *durations, int *demands)
     * }
     */
    public static MemorySegment SCIPcreateWorstCaseProfile$address() {
        return SCIPcreateWorstCaseProfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWorstCaseProfile(SCIP *scip, SCIP_PROFILE *profile, int nvars, SCIP_VAR **vars, int *durations, int *demands)
     * }
     */
    public static int SCIPcreateWorstCaseProfile(MemorySegment scip, MemorySegment profile, int nvars, MemorySegment vars, MemorySegment durations, MemorySegment demands) {
        var mh$ = SCIPcreateWorstCaseProfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateWorstCaseProfile", scip, profile, nvars, vars, durations, demands);
            }
            return (int)mh$.invokeExact(scip, profile, nvars, vars, durations, demands);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeHmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeHmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomputeHmin(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static FunctionDescriptor SCIPcomputeHmin$descriptor() {
        return SCIPcomputeHmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomputeHmin(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static MethodHandle SCIPcomputeHmin$handle() {
        return SCIPcomputeHmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomputeHmin(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static MemorySegment SCIPcomputeHmin$address() {
        return SCIPcomputeHmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomputeHmin(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static int SCIPcomputeHmin(MemorySegment scip, MemorySegment profile, int capacity) {
        var mh$ = SCIPcomputeHmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeHmin", scip, profile, capacity);
            }
            return (int)mh$.invokeExact(scip, profile, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeHmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeHmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcomputeHmax(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static FunctionDescriptor SCIPcomputeHmax$descriptor() {
        return SCIPcomputeHmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcomputeHmax(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static MethodHandle SCIPcomputeHmax$handle() {
        return SCIPcomputeHmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcomputeHmax(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static MemorySegment SCIPcomputeHmax$address() {
        return SCIPcomputeHmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcomputeHmax(SCIP *scip, SCIP_PROFILE *profile, int capacity)
     * }
     */
    public static int SCIPcomputeHmax(MemorySegment scip, MemorySegment profile, int capacity) {
        var mh$ = SCIPcomputeHmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeHmax", scip, profile, capacity);
            }
            return (int)mh$.invokeExact(scip, profile, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrDisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrDisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrDisjunction(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrDisjunction$descriptor() {
        return SCIPincludeConshdlrDisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrDisjunction(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrDisjunction$handle() {
        return SCIPincludeConshdlrDisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrDisjunction(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrDisjunction$address() {
        return SCIPincludeConshdlrDisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrDisjunction(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrDisjunction(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrDisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrDisjunction", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsDisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsDisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons, unsigned int initial, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsDisjunction$descriptor() {
        return SCIPcreateConsDisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons, unsigned int initial, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static MethodHandle SCIPcreateConsDisjunction$handle() {
        return SCIPcreateConsDisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons, unsigned int initial, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static MemorySegment SCIPcreateConsDisjunction$address() {
        return SCIPcreateConsDisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons, unsigned int initial, unsigned int enforce, unsigned int check, unsigned int local, unsigned int modifiable, unsigned int dynamic)
     * }
     */
    public static int SCIPcreateConsDisjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nconss, MemorySegment conss, MemorySegment relaxcons, int initial, int enforce, int check, int local, int modifiable, int dynamic) {
        var mh$ = SCIPcreateConsDisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsDisjunction", scip, cons, name, nconss, conss, relaxcons, initial, enforce, check, local, modifiable, dynamic);
            }
            return (int)mh$.invokeExact(scip, cons, name, nconss, conss, relaxcons, initial, enforce, check, local, modifiable, dynamic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicDisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicDisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicDisjunction$descriptor() {
        return SCIPcreateConsBasicDisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicDisjunction$handle() {
        return SCIPcreateConsBasicDisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicDisjunction$address() {
        return SCIPcreateConsBasicDisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicDisjunction(SCIP *scip, SCIP_CONS **cons, const char *name, int nconss, SCIP_CONS **conss, SCIP_CONS *relaxcons)
     * }
     */
    public static int SCIPcreateConsBasicDisjunction(MemorySegment scip, MemorySegment cons, MemorySegment name, int nconss, MemorySegment conss, MemorySegment relaxcons) {
        var mh$ = SCIPcreateConsBasicDisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicDisjunction", scip, cons, name, nconss, conss, relaxcons);
            }
            return (int)mh$.invokeExact(scip, cons, name, nconss, conss, relaxcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsElemDisjunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsElemDisjunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemDisjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static FunctionDescriptor SCIPaddConsElemDisjunction$descriptor() {
        return SCIPaddConsElemDisjunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemDisjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static MethodHandle SCIPaddConsElemDisjunction$handle() {
        return SCIPaddConsElemDisjunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemDisjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static MemorySegment SCIPaddConsElemDisjunction$address() {
        return SCIPaddConsElemDisjunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsElemDisjunction(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *addcons)
     * }
     */
    public static int SCIPaddConsElemDisjunction(MemorySegment scip, MemorySegment cons, MemorySegment addcons) {
        var mh$ = SCIPaddConsElemDisjunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsElemDisjunction", scip, cons, addcons);
            }
            return (int)mh$.invokeExact(scip, cons, addcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrFixedvar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrFixedvar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrFixedvar(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrFixedvar$descriptor() {
        return SCIPincludeConshdlrFixedvar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrFixedvar(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrFixedvar$handle() {
        return SCIPincludeConshdlrFixedvar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrFixedvar(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrFixedvar$address() {
        return SCIPincludeConshdlrFixedvar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrFixedvar(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrFixedvar(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrFixedvar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrFixedvar", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIndicator(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrIndicator$descriptor() {
        return SCIPincludeConshdlrIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIndicator(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrIndicator$handle() {
        return SCIPincludeConshdlrIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIndicator(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrIndicator$address() {
        return SCIPincludeConshdlrIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIndicator(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrIndicator(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrIndicator", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicator$descriptor() {
        return SCIPcreateConsIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicator$handle() {
        return SCIPcreateConsIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicator$address() {
        return SCIPcreateConsIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicator(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, int nvars, MemorySegment vars, MemorySegment vals, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicator", scip, cons, name, binvar, nvars, vars, vals, rhs, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, nvars, vars, vals, rhs, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicIndicator$descriptor() {
        return SCIPcreateConsBasicIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicIndicator$handle() {
        return SCIPcreateConsBasicIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicIndicator$address() {
        return SCIPcreateConsBasicIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicIndicator(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, int nvars, MemorySegment vars, MemorySegment vals, double rhs) {
        var mh$ = SCIPcreateConsBasicIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicIndicator", scip, cons, name, binvar, nvars, vars, vals, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, nvars, vars, vals, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicatorGeneric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicatorGeneric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGeneric(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int activeone, unsigned int lessthanineq, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicatorGeneric$descriptor() {
        return SCIPcreateConsIndicatorGeneric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGeneric(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int activeone, unsigned int lessthanineq, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicatorGeneric$handle() {
        return SCIPcreateConsIndicatorGeneric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGeneric(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int activeone, unsigned int lessthanineq, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicatorGeneric$address() {
        return SCIPcreateConsIndicatorGeneric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGeneric(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, int nvars, SCIP_VAR **vars, double *vals, double rhs, unsigned int activeone, unsigned int lessthanineq, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicatorGeneric(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, int nvars, MemorySegment vars, MemorySegment vals, double rhs, int activeone, int lessthanineq, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicatorGeneric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicatorGeneric", scip, cons, name, binvar, nvars, vars, vals, rhs, activeone, lessthanineq, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, nvars, vars, vals, rhs, activeone, lessthanineq, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicatorLinCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicatorLinCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicatorLinCons$descriptor() {
        return SCIPcreateConsIndicatorLinCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicatorLinCons$handle() {
        return SCIPcreateConsIndicatorLinCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicatorLinCons$address() {
        return SCIPcreateConsIndicatorLinCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicatorLinCons(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment lincons, MemorySegment slackvar, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicatorLinCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicatorLinCons", scip, cons, name, binvar, lincons, slackvar, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, lincons, slackvar, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicatorGenericLinCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicatorGenericLinCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicatorGenericLinCons$descriptor() {
        return SCIPcreateConsIndicatorGenericLinCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicatorGenericLinCons$handle() {
        return SCIPcreateConsIndicatorGenericLinCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicatorGenericLinCons$address() {
        return SCIPcreateConsIndicatorGenericLinCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicatorGenericLinCons(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment lincons, MemorySegment slackvar, int activeone, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicatorGenericLinCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicatorGenericLinCons", scip, cons, name, binvar, lincons, slackvar, activeone, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, lincons, slackvar, activeone, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicIndicatorLinCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicIndicatorLinCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicIndicatorLinCons$descriptor() {
        return SCIPcreateConsBasicIndicatorLinCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicIndicatorLinCons$handle() {
        return SCIPcreateConsBasicIndicatorLinCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicIndicatorLinCons$address() {
        return SCIPcreateConsBasicIndicatorLinCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicIndicatorLinCons(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, SCIP_VAR *slackvar)
     * }
     */
    public static int SCIPcreateConsBasicIndicatorLinCons(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment lincons, MemorySegment slackvar) {
        var mh$ = SCIPcreateConsBasicIndicatorLinCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicIndicatorLinCons", scip, cons, name, binvar, lincons, slackvar);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, lincons, slackvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicatorGenericLinConsPure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicatorGenericLinConsPure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicatorGenericLinConsPure$descriptor() {
        return SCIPcreateConsIndicatorGenericLinConsPure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicatorGenericLinConsPure$handle() {
        return SCIPcreateConsIndicatorGenericLinConsPure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicatorGenericLinConsPure$address() {
        return SCIPcreateConsIndicatorGenericLinConsPure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorGenericLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int activeone, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicatorGenericLinConsPure(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment lincons, int activeone, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicatorGenericLinConsPure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicatorGenericLinConsPure", scip, cons, name, binvar, lincons, activeone, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, lincons, activeone, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsIndicatorLinConsPure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsIndicatorLinConsPure");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsIndicatorLinConsPure$descriptor() {
        return SCIPcreateConsIndicatorLinConsPure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsIndicatorLinConsPure$handle() {
        return SCIPcreateConsIndicatorLinConsPure.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsIndicatorLinConsPure$address() {
        return SCIPcreateConsIndicatorLinConsPure.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsIndicatorLinConsPure(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *lincons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsIndicatorLinConsPure(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment lincons, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsIndicatorLinConsPure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsIndicatorLinConsPure", scip, cons, name, binvar, lincons, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, lincons, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPaddVarIndicator$descriptor() {
        return SCIPaddVarIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPaddVarIndicator$handle() {
        return SCIPaddVarIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPaddVarIndicator$address() {
        return SCIPaddVarIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPaddVarIndicator(MemorySegment scip, MemorySegment cons, MemorySegment var_, double val) {
        var mh$ = SCIPaddVarIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarIndicator", scip, cons, var_, val);
            }
            return (int)mh$.invokeExact(scip, cons, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinearConsIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinearConsIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsIndicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLinearConsIndicator$descriptor() {
        return SCIPgetLinearConsIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsIndicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetLinearConsIndicator$handle() {
        return SCIPgetLinearConsIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLinearConsIndicator$address() {
        return SCIPgetLinearConsIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLinearConsIndicator(MemorySegment cons) {
        var mh$ = SCIPgetLinearConsIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinearConsIndicator", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetLinearConsIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetLinearConsIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLinearConsIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *lincons)
     * }
     */
    public static FunctionDescriptor SCIPsetLinearConsIndicator$descriptor() {
        return SCIPsetLinearConsIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLinearConsIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *lincons)
     * }
     */
    public static MethodHandle SCIPsetLinearConsIndicator$handle() {
        return SCIPsetLinearConsIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLinearConsIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *lincons)
     * }
     */
    public static MemorySegment SCIPsetLinearConsIndicator$address() {
        return SCIPsetLinearConsIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLinearConsIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_CONS *lincons)
     * }
     */
    public static int SCIPsetLinearConsIndicator(MemorySegment scip, MemorySegment cons, MemorySegment lincons) {
        var mh$ = SCIPsetLinearConsIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetLinearConsIndicator", scip, cons, lincons);
            }
            return (int)mh$.invokeExact(scip, cons, lincons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBinaryVarIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBinaryVarIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBinaryVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *binvar)
     * }
     */
    public static FunctionDescriptor SCIPsetBinaryVarIndicator$descriptor() {
        return SCIPsetBinaryVarIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBinaryVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *binvar)
     * }
     */
    public static MethodHandle SCIPsetBinaryVarIndicator$handle() {
        return SCIPsetBinaryVarIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBinaryVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *binvar)
     * }
     */
    public static MemorySegment SCIPsetBinaryVarIndicator$address() {
        return SCIPsetBinaryVarIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBinaryVarIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *binvar)
     * }
     */
    public static int SCIPsetBinaryVarIndicator(MemorySegment scip, MemorySegment cons, MemorySegment binvar) {
        var mh$ = SCIPsetBinaryVarIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBinaryVarIndicator", scip, cons, binvar);
            }
            return (int)mh$.invokeExact(scip, cons, binvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetActiveOnIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetActiveOnIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetActiveOnIndicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetActiveOnIndicator$descriptor() {
        return SCIPgetActiveOnIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetActiveOnIndicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetActiveOnIndicator$handle() {
        return SCIPgetActiveOnIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetActiveOnIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetActiveOnIndicator$address() {
        return SCIPgetActiveOnIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetActiveOnIndicator(SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetActiveOnIndicator(MemorySegment cons) {
        var mh$ = SCIPgetActiveOnIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetActiveOnIndicator", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinaryVarIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinaryVarIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetBinaryVarIndicator$descriptor() {
        return SCIPgetBinaryVarIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetBinaryVarIndicator$handle() {
        return SCIPgetBinaryVarIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarIndicator$address() {
        return SCIPgetBinaryVarIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarIndicator(MemorySegment cons) {
        var mh$ = SCIPgetBinaryVarIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinaryVarIndicator", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinaryVarIndicatorGeneric {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinaryVarIndicatorGeneric");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicatorGeneric(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetBinaryVarIndicatorGeneric$descriptor() {
        return SCIPgetBinaryVarIndicatorGeneric.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicatorGeneric(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetBinaryVarIndicatorGeneric$handle() {
        return SCIPgetBinaryVarIndicatorGeneric.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicatorGeneric(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarIndicatorGeneric$address() {
        return SCIPgetBinaryVarIndicatorGeneric.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarIndicatorGeneric(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarIndicatorGeneric(MemorySegment cons) {
        var mh$ = SCIPgetBinaryVarIndicatorGeneric.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinaryVarIndicatorGeneric", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSlackVarIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSlackVarIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetSlackVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetSlackVarIndicator$descriptor() {
        return SCIPgetSlackVarIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetSlackVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetSlackVarIndicator$handle() {
        return SCIPgetSlackVarIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetSlackVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetSlackVarIndicator$address() {
        return SCIPgetSlackVarIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetSlackVarIndicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetSlackVarIndicator(MemorySegment cons) {
        var mh$ = SCIPgetSlackVarIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSlackVarIndicator", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSlackVarUb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSlackVarUb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSlackVarUb(SCIP *scip, SCIP_CONS *cons, double ub)
     * }
     */
    public static FunctionDescriptor SCIPsetSlackVarUb$descriptor() {
        return SCIPsetSlackVarUb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSlackVarUb(SCIP *scip, SCIP_CONS *cons, double ub)
     * }
     */
    public static MethodHandle SCIPsetSlackVarUb$handle() {
        return SCIPsetSlackVarUb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSlackVarUb(SCIP *scip, SCIP_CONS *cons, double ub)
     * }
     */
    public static MemorySegment SCIPsetSlackVarUb$address() {
        return SCIPsetSlackVarUb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSlackVarUb(SCIP *scip, SCIP_CONS *cons, double ub)
     * }
     */
    public static int SCIPsetSlackVarUb(MemorySegment scip, MemorySegment cons, double ub) {
        var mh$ = SCIPsetSlackVarUb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSlackVarUb", scip, cons, ub);
            }
            return (int)mh$.invokeExact(scip, cons, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisViolatedIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisViolatedIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisViolatedIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPisViolatedIndicator$descriptor() {
        return SCIPisViolatedIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisViolatedIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPisViolatedIndicator$handle() {
        return SCIPisViolatedIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisViolatedIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPisViolatedIndicator$address() {
        return SCIPisViolatedIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisViolatedIndicator(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static int SCIPisViolatedIndicator(MemorySegment scip, MemorySegment cons, MemorySegment sol) {
        var mh$ = SCIPisViolatedIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisViolatedIndicator", scip, cons, sol);
            }
            return (int)mh$.invokeExact(scip, cons, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmakeIndicatorFeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmakeIndicatorFeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorFeasible(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static FunctionDescriptor SCIPmakeIndicatorFeasible$descriptor() {
        return SCIPmakeIndicatorFeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorFeasible(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static MethodHandle SCIPmakeIndicatorFeasible$handle() {
        return SCIPmakeIndicatorFeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorFeasible(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static MemorySegment SCIPmakeIndicatorFeasible$address() {
        return SCIPmakeIndicatorFeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorFeasible(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static int SCIPmakeIndicatorFeasible(MemorySegment scip, MemorySegment cons, MemorySegment sol, MemorySegment changed) {
        var mh$ = SCIPmakeIndicatorFeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmakeIndicatorFeasible", scip, cons, sol, changed);
            }
            return (int)mh$.invokeExact(scip, cons, sol, changed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmakeIndicatorsFeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmakeIndicatorsFeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorsFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static FunctionDescriptor SCIPmakeIndicatorsFeasible$descriptor() {
        return SCIPmakeIndicatorsFeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorsFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static MethodHandle SCIPmakeIndicatorsFeasible$handle() {
        return SCIPmakeIndicatorsFeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorsFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static MemorySegment SCIPmakeIndicatorsFeasible$address() {
        return SCIPmakeIndicatorsFeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeIndicatorsFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed)
     * }
     */
    public static int SCIPmakeIndicatorsFeasible(MemorySegment scip, MemorySegment conshdlr, MemorySegment sol, MemorySegment changed) {
        var mh$ = SCIPmakeIndicatorsFeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmakeIndicatorsFeasible", scip, conshdlr, sol, changed);
            }
            return (int)mh$.invokeExact(scip, conshdlr, sol, changed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddLinearConsIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddLinearConsIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearConsIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS *lincons)
     * }
     */
    public static FunctionDescriptor SCIPaddLinearConsIndicator$descriptor() {
        return SCIPaddLinearConsIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearConsIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS *lincons)
     * }
     */
    public static MethodHandle SCIPaddLinearConsIndicator$handle() {
        return SCIPaddLinearConsIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearConsIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS *lincons)
     * }
     */
    public static MemorySegment SCIPaddLinearConsIndicator$address() {
        return SCIPaddLinearConsIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearConsIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS *lincons)
     * }
     */
    public static int SCIPaddLinearConsIndicator(MemorySegment scip, MemorySegment conshdlr, MemorySegment lincons) {
        var mh$ = SCIPaddLinearConsIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddLinearConsIndicator", scip, conshdlr, lincons);
            }
            return (int)mh$.invokeExact(scip, conshdlr, lincons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRowIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRowIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddRowIndicator$descriptor() {
        return SCIPaddRowIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddRowIndicator$handle() {
        return SCIPaddRowIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddRowIndicator$address() {
        return SCIPaddRowIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowIndicator(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddRowIndicator(MemorySegment scip, MemorySegment conshdlr, MemorySegment row) {
        var mh$ = SCIPaddRowIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRowIndicator", scip, conshdlr, row);
            }
            return (int)mh$.invokeExact(scip, conshdlr, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIntegral(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrIntegral$descriptor() {
        return SCIPincludeConshdlrIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIntegral(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrIntegral$handle() {
        return SCIPincludeConshdlrIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIntegral(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrIntegral$address() {
        return SCIPincludeConshdlrIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrIntegral(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrIntegral(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrIntegral", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrKnapsack(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrKnapsack$descriptor() {
        return SCIPincludeConshdlrKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrKnapsack(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrKnapsack$handle() {
        return SCIPincludeConshdlrKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrKnapsack(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrKnapsack$address() {
        return SCIPincludeConshdlrKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrKnapsack(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrKnapsack(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrKnapsack", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsKnapsack$descriptor() {
        return SCIPcreateConsKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsKnapsack$handle() {
        return SCIPcreateConsKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsKnapsack$address() {
        return SCIPcreateConsKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsKnapsack(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights, long capacity, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsKnapsack", scip, cons, name, nvars, vars, weights, capacity, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights, capacity, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicKnapsack$descriptor() {
        return SCIPcreateConsBasicKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicKnapsack$handle() {
        return SCIPcreateConsBasicKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicKnapsack$address() {
        return SCIPcreateConsBasicKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicKnapsack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, long long *weights, long long capacity)
     * }
     */
    public static int SCIPcreateConsBasicKnapsack(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights, long capacity) {
        var mh$ = SCIPcreateConsBasicKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicKnapsack", scip, cons, name, nvars, vars, weights, capacity);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCoefKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCoefKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, long long weight)
     * }
     */
    public static FunctionDescriptor SCIPaddCoefKnapsack$descriptor() {
        return SCIPaddCoefKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, long long weight)
     * }
     */
    public static MethodHandle SCIPaddCoefKnapsack$handle() {
        return SCIPaddCoefKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, long long weight)
     * }
     */
    public static MemorySegment SCIPaddCoefKnapsack$address() {
        return SCIPaddCoefKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, long long weight)
     * }
     */
    public static int SCIPaddCoefKnapsack(MemorySegment scip, MemorySegment cons, MemorySegment var_, long weight) {
        var mh$ = SCIPaddCoefKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCoefKnapsack", scip, cons, var_, weight);
            }
            return (int)mh$.invokeExact(scip, cons, var_, weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCapacityKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCapacityKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetCapacityKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetCapacityKnapsack$descriptor() {
        return SCIPgetCapacityKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetCapacityKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetCapacityKnapsack$handle() {
        return SCIPgetCapacityKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetCapacityKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetCapacityKnapsack$address() {
        return SCIPgetCapacityKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetCapacityKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static long SCIPgetCapacityKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetCapacityKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCapacityKnapsack", scip, cons);
            }
            return (long)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgCapacityKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgCapacityKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCapacityKnapsack(SCIP *scip, SCIP_CONS *cons, long long capacity)
     * }
     */
    public static FunctionDescriptor SCIPchgCapacityKnapsack$descriptor() {
        return SCIPchgCapacityKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCapacityKnapsack(SCIP *scip, SCIP_CONS *cons, long long capacity)
     * }
     */
    public static MethodHandle SCIPchgCapacityKnapsack$handle() {
        return SCIPchgCapacityKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCapacityKnapsack(SCIP *scip, SCIP_CONS *cons, long long capacity)
     * }
     */
    public static MemorySegment SCIPchgCapacityKnapsack$address() {
        return SCIPchgCapacityKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCapacityKnapsack(SCIP *scip, SCIP_CONS *cons, long long capacity)
     * }
     */
    public static int SCIPchgCapacityKnapsack(MemorySegment scip, MemorySegment cons, long capacity) {
        var mh$ = SCIPchgCapacityKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgCapacityKnapsack", scip, cons, capacity);
            }
            return (int)mh$.invokeExact(scip, cons, capacity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsKnapsack$descriptor() {
        return SCIPgetNVarsKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsKnapsack$handle() {
        return SCIPgetNVarsKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsKnapsack$address() {
        return SCIPgetNVarsKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsKnapsack", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsKnapsack$descriptor() {
        return SCIPgetVarsKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsKnapsack$handle() {
        return SCIPgetVarsKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsKnapsack$address() {
        return SCIPgetVarsKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsKnapsack", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetWeightsKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetWeightsKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long *SCIPgetWeightsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetWeightsKnapsack$descriptor() {
        return SCIPgetWeightsKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long *SCIPgetWeightsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetWeightsKnapsack$handle() {
        return SCIPgetWeightsKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long *SCIPgetWeightsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsKnapsack$address() {
        return SCIPgetWeightsKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long *SCIPgetWeightsKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetWeightsKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetWeightsKnapsack", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualsolKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualsolKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualsolKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualsolKnapsack$descriptor() {
        return SCIPgetDualsolKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualsolKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualsolKnapsack$handle() {
        return SCIPgetDualsolKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualsolKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualsolKnapsack$address() {
        return SCIPgetDualsolKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualsolKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualsolKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualsolKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualsolKnapsack", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualfarkasKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualfarkasKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualfarkasKnapsack$descriptor() {
        return SCIPgetDualfarkasKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualfarkasKnapsack$handle() {
        return SCIPgetDualfarkasKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualfarkasKnapsack$address() {
        return SCIPgetDualfarkasKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualfarkasKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualfarkasKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualfarkasKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualfarkasKnapsack", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRowKnapsack$descriptor() {
        return SCIPgetRowKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRowKnapsack$handle() {
        return SCIPgetRowKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowKnapsack$address() {
        return SCIPgetRowKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowKnapsack(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowKnapsack(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRowKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowKnapsack", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveKnapsackExactly {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveKnapsackExactly");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackExactly(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPsolveKnapsackExactly$descriptor() {
        return SCIPsolveKnapsackExactly.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackExactly(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPsolveKnapsackExactly$handle() {
        return SCIPsolveKnapsackExactly.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackExactly(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPsolveKnapsackExactly$address() {
        return SCIPsolveKnapsackExactly.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackExactly(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval, unsigned int *success)
     * }
     */
    public static int SCIPsolveKnapsackExactly(MemorySegment scip, int nitems, MemorySegment weights, MemorySegment profits, long capacity, MemorySegment items, MemorySegment solitems, MemorySegment nonsolitems, MemorySegment nsolitems, MemorySegment nnonsolitems, MemorySegment solval, MemorySegment success) {
        var mh$ = SCIPsolveKnapsackExactly.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveKnapsackExactly", scip, nitems, weights, profits, capacity, items, solitems, nonsolitems, nsolitems, nnonsolitems, solval, success);
            }
            return (int)mh$.invokeExact(scip, nitems, weights, profits, capacity, items, solitems, nonsolitems, nsolitems, nnonsolitems, solval, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveKnapsackApproximately {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveKnapsackApproximately");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackApproximately(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval)
     * }
     */
    public static FunctionDescriptor SCIPsolveKnapsackApproximately$descriptor() {
        return SCIPsolveKnapsackApproximately.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackApproximately(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval)
     * }
     */
    public static MethodHandle SCIPsolveKnapsackApproximately$handle() {
        return SCIPsolveKnapsackApproximately.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackApproximately(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval)
     * }
     */
    public static MemorySegment SCIPsolveKnapsackApproximately$address() {
        return SCIPsolveKnapsackApproximately.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveKnapsackApproximately(SCIP *scip, int nitems, long long *weights, double *profits, long long capacity, int *items, int *solitems, int *nonsolitems, int *nsolitems, int *nnonsolitems, double *solval)
     * }
     */
    public static int SCIPsolveKnapsackApproximately(MemorySegment scip, int nitems, MemorySegment weights, MemorySegment profits, long capacity, MemorySegment items, MemorySegment solitems, MemorySegment nonsolitems, MemorySegment nsolitems, MemorySegment nnonsolitems, MemorySegment solval) {
        var mh$ = SCIPsolveKnapsackApproximately.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveKnapsackApproximately", scip, nitems, weights, profits, capacity, items, solitems, nonsolitems, nsolitems, nnonsolitems, solval);
            }
            return (int)mh$.invokeExact(scip, nitems, weights, profits, capacity, items, solitems, nonsolitems, nsolitems, nnonsolitems, solval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPseparateKnapsackCuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPseparateKnapsackCuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateKnapsackCuts(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, SCIP_VAR **vars, int nvars, long long *weights, long long capacity, SCIP_SOL *sol, unsigned int usegubs, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static FunctionDescriptor SCIPseparateKnapsackCuts$descriptor() {
        return SCIPseparateKnapsackCuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateKnapsackCuts(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, SCIP_VAR **vars, int nvars, long long *weights, long long capacity, SCIP_SOL *sol, unsigned int usegubs, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static MethodHandle SCIPseparateKnapsackCuts$handle() {
        return SCIPseparateKnapsackCuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateKnapsackCuts(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, SCIP_VAR **vars, int nvars, long long *weights, long long capacity, SCIP_SOL *sol, unsigned int usegubs, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static MemorySegment SCIPseparateKnapsackCuts$address() {
        return SCIPseparateKnapsackCuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateKnapsackCuts(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, SCIP_VAR **vars, int nvars, long long *weights, long long capacity, SCIP_SOL *sol, unsigned int usegubs, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static int SCIPseparateKnapsackCuts(MemorySegment scip, MemorySegment cons, MemorySegment sepa, MemorySegment vars, int nvars, MemorySegment weights, long capacity, MemorySegment sol, int usegubs, MemorySegment cutoff, MemorySegment ncuts) {
        var mh$ = SCIPseparateKnapsackCuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPseparateKnapsackCuts", scip, cons, sepa, vars, nvars, weights, capacity, sol, usegubs, cutoff, ncuts);
            }
            return (int)mh$.invokeExact(scip, cons, sepa, vars, nvars, weights, capacity, sol, usegubs, cutoff, ncuts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPseparateRelaxedKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPseparateRelaxedKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateRelaxedKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, int nknapvars, SCIP_VAR **knapvars, double *knapvals, double valscale, double rhs, SCIP_SOL *sol, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static FunctionDescriptor SCIPseparateRelaxedKnapsack$descriptor() {
        return SCIPseparateRelaxedKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateRelaxedKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, int nknapvars, SCIP_VAR **knapvars, double *knapvals, double valscale, double rhs, SCIP_SOL *sol, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static MethodHandle SCIPseparateRelaxedKnapsack$handle() {
        return SCIPseparateRelaxedKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateRelaxedKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, int nknapvars, SCIP_VAR **knapvars, double *knapvals, double valscale, double rhs, SCIP_SOL *sol, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static MemorySegment SCIPseparateRelaxedKnapsack$address() {
        return SCIPseparateRelaxedKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPseparateRelaxedKnapsack(SCIP *scip, SCIP_CONS *cons, SCIP_SEPA *sepa, int nknapvars, SCIP_VAR **knapvars, double *knapvals, double valscale, double rhs, SCIP_SOL *sol, unsigned int *cutoff, int *ncuts)
     * }
     */
    public static int SCIPseparateRelaxedKnapsack(MemorySegment scip, MemorySegment cons, MemorySegment sepa, int nknapvars, MemorySegment knapvars, MemorySegment knapvals, double valscale, double rhs, MemorySegment sol, MemorySegment cutoff, MemorySegment ncuts) {
        var mh$ = SCIPseparateRelaxedKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPseparateRelaxedKnapsack", scip, cons, sepa, nknapvars, knapvars, knapvals, valscale, rhs, sol, cutoff, ncuts);
            }
            return (int)mh$.invokeExact(scip, cons, sepa, nknapvars, knapvars, knapvals, valscale, rhs, sol, cutoff, ncuts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupConssKnapsack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupConssKnapsack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssKnapsack(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPcleanupConssKnapsack$descriptor() {
        return SCIPcleanupConssKnapsack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssKnapsack(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPcleanupConssKnapsack$handle() {
        return SCIPcleanupConssKnapsack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssKnapsack(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPcleanupConssKnapsack$address() {
        return SCIPcleanupConssKnapsack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssKnapsack(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static int SCIPcleanupConssKnapsack(MemorySegment scip, int onlychecked, MemorySegment infeasible) {
        var mh$ = SCIPcleanupConssKnapsack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupConssKnapsack", scip, onlychecked, infeasible);
            }
            return (int)mh$.invokeExact(scip, onlychecked, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinear(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrLinear$descriptor() {
        return SCIPincludeConshdlrLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinear(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrLinear$handle() {
        return SCIPincludeConshdlrLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinear(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrLinear$address() {
        return SCIPincludeConshdlrLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinear(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrLinear(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrLinear", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeLinconsUpgrade {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeLinconsUpgrade");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeLinconsUpgrade(SCIP *scip, SCIP_RETCODE (*linconsupgd)(SCIP *, SCIP_CONS *, int, SCIP_VAR **, double *, double, double, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, double, double, unsigned int, SCIP_CONS **), int priority, const char *conshdlrname)
     * }
     */
    public static FunctionDescriptor SCIPincludeLinconsUpgrade$descriptor() {
        return SCIPincludeLinconsUpgrade.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeLinconsUpgrade(SCIP *scip, SCIP_RETCODE (*linconsupgd)(SCIP *, SCIP_CONS *, int, SCIP_VAR **, double *, double, double, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, double, double, unsigned int, SCIP_CONS **), int priority, const char *conshdlrname)
     * }
     */
    public static MethodHandle SCIPincludeLinconsUpgrade$handle() {
        return SCIPincludeLinconsUpgrade.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeLinconsUpgrade(SCIP *scip, SCIP_RETCODE (*linconsupgd)(SCIP *, SCIP_CONS *, int, SCIP_VAR **, double *, double, double, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, double, double, unsigned int, SCIP_CONS **), int priority, const char *conshdlrname)
     * }
     */
    public static MemorySegment SCIPincludeLinconsUpgrade$address() {
        return SCIPincludeLinconsUpgrade.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeLinconsUpgrade(SCIP *scip, SCIP_RETCODE (*linconsupgd)(SCIP *, SCIP_CONS *, int, SCIP_VAR **, double *, double, double, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, double, double, unsigned int, SCIP_CONS **), int priority, const char *conshdlrname)
     * }
     */
    public static int SCIPincludeLinconsUpgrade(MemorySegment scip, MemorySegment linconsupgd, int priority, MemorySegment conshdlrname) {
        var mh$ = SCIPincludeLinconsUpgrade.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeLinconsUpgrade", scip, linconsupgd, priority, conshdlrname);
            }
            return (int)mh$.invokeExact(scip, linconsupgd, priority, conshdlrname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsLinear$descriptor() {
        return SCIPcreateConsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsLinear$handle() {
        return SCIPcreateConsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsLinear$address() {
        return SCIPcreateConsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsLinear(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment vals, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsLinear", scip, cons, name, nvars, vars, vals, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, vals, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicLinear$descriptor() {
        return SCIPcreateConsBasicLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicLinear$handle() {
        return SCIPcreateConsBasicLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicLinear$address() {
        return SCIPcreateConsBasicLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *vals, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicLinear(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment vals, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicLinear", scip, cons, name, nvars, vars, vals, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, vals, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyConsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyConsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsLinear(SCIP *scip, SCIP_CONS **cons, SCIP *sourcescip, const char *name, int nvars, SCIP_VAR **sourcevars, double *sourcecoefs, double lhs, double rhs, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyConsLinear$descriptor() {
        return SCIPcopyConsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsLinear(SCIP *scip, SCIP_CONS **cons, SCIP *sourcescip, const char *name, int nvars, SCIP_VAR **sourcevars, double *sourcecoefs, double lhs, double rhs, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyConsLinear$handle() {
        return SCIPcopyConsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsLinear(SCIP *scip, SCIP_CONS **cons, SCIP *sourcescip, const char *name, int nvars, SCIP_VAR **sourcevars, double *sourcecoefs, double lhs, double rhs, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyConsLinear$address() {
        return SCIPcopyConsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyConsLinear(SCIP *scip, SCIP_CONS **cons, SCIP *sourcescip, const char *name, int nvars, SCIP_VAR **sourcevars, double *sourcecoefs, double lhs, double rhs, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode, unsigned int global, unsigned int *valid)
     * }
     */
    public static int SCIPcopyConsLinear(MemorySegment scip, MemorySegment cons, MemorySegment sourcescip, MemorySegment name, int nvars, MemorySegment sourcevars, MemorySegment sourcecoefs, double lhs, double rhs, MemorySegment varmap, MemorySegment consmap, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode, int global, MemorySegment valid) {
        var mh$ = SCIPcopyConsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyConsLinear", scip, cons, sourcescip, name, nvars, sourcevars, sourcecoefs, lhs, rhs, varmap, consmap, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, global, valid);
            }
            return (int)mh$.invokeExact(scip, cons, sourcescip, name, nvars, sourcevars, sourcecoefs, lhs, rhs, varmap, consmap, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode, global, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCoefLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCoefLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPaddCoefLinear$descriptor() {
        return SCIPaddCoefLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPaddCoefLinear$handle() {
        return SCIPaddCoefLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPaddCoefLinear$address() {
        return SCIPaddCoefLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPaddCoefLinear(MemorySegment scip, MemorySegment cons, MemorySegment var_, double val) {
        var mh$ = SCIPaddCoefLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCoefLinear", scip, cons, var_, val);
            }
            return (int)mh$.invokeExact(scip, cons, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgCoefLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgCoefLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPchgCoefLinear$descriptor() {
        return SCIPchgCoefLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPchgCoefLinear$handle() {
        return SCIPchgCoefLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPchgCoefLinear$address() {
        return SCIPchgCoefLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPchgCoefLinear(MemorySegment scip, MemorySegment cons, MemorySegment var_, double val) {
        var mh$ = SCIPchgCoefLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgCoefLinear", scip, cons, var_, val);
            }
            return (int)mh$.invokeExact(scip, cons, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelCoefLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelCoefLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPdelCoefLinear$descriptor() {
        return SCIPdelCoefLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPdelCoefLinear$handle() {
        return SCIPdelCoefLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPdelCoefLinear$address() {
        return SCIPdelCoefLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCoefLinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static int SCIPdelCoefLinear(MemorySegment scip, MemorySegment cons, MemorySegment var_) {
        var mh$ = SCIPdelCoefLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelCoefLinear", scip, cons, var_);
            }
            return (int)mh$.invokeExact(scip, cons, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLhsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLhsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLhsLinear$descriptor() {
        return SCIPgetLhsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetLhsLinear$handle() {
        return SCIPgetLhsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLhsLinear$address() {
        return SCIPgetLhsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetLhsLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLhsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLhsLinear", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRhsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRhsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRhsLinear$descriptor() {
        return SCIPgetRhsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRhsLinear$handle() {
        return SCIPgetRhsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRhsLinear$address() {
        return SCIPgetRhsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRhsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetRhsLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRhsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRhsLinear", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgLhsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgLhsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsLinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static FunctionDescriptor SCIPchgLhsLinear$descriptor() {
        return SCIPchgLhsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsLinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static MethodHandle SCIPchgLhsLinear$handle() {
        return SCIPchgLhsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsLinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static MemorySegment SCIPchgLhsLinear$address() {
        return SCIPchgLhsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsLinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static int SCIPchgLhsLinear(MemorySegment scip, MemorySegment cons, double lhs) {
        var mh$ = SCIPchgLhsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgLhsLinear", scip, cons, lhs);
            }
            return (int)mh$.invokeExact(scip, cons, lhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRhsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRhsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsLinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRhsLinear$descriptor() {
        return SCIPchgRhsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsLinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static MethodHandle SCIPchgRhsLinear$handle() {
        return SCIPchgRhsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsLinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static MemorySegment SCIPchgRhsLinear$address() {
        return SCIPchgRhsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsLinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static int SCIPchgRhsLinear(MemorySegment scip, MemorySegment cons, double rhs) {
        var mh$ = SCIPchgRhsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRhsLinear", scip, cons, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsLinear$descriptor() {
        return SCIPgetNVarsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsLinear$handle() {
        return SCIPgetNVarsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsLinear$address() {
        return SCIPgetNVarsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsLinear", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsLinear$descriptor() {
        return SCIPgetVarsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsLinear$handle() {
        return SCIPgetVarsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsLinear$address() {
        return SCIPgetVarsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsLinear", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetValsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetValsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetValsLinear$descriptor() {
        return SCIPgetValsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetValsLinear$handle() {
        return SCIPgetValsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetValsLinear$address() {
        return SCIPgetValsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetValsLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetValsLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetValsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetValsLinear", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetActivityLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetActivityLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetActivityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetActivityLinear$descriptor() {
        return SCIPgetActivityLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetActivityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetActivityLinear$handle() {
        return SCIPgetActivityLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetActivityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetActivityLinear$address() {
        return SCIPgetActivityLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetActivityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetActivityLinear(MemorySegment scip, MemorySegment cons, MemorySegment sol) {
        var mh$ = SCIPgetActivityLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetActivityLinear", scip, cons, sol);
            }
            return (double)mh$.invokeExact(scip, cons, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFeasibilityLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFeasibilityLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetFeasibilityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetFeasibilityLinear$descriptor() {
        return SCIPgetFeasibilityLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetFeasibilityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetFeasibilityLinear$handle() {
        return SCIPgetFeasibilityLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetFeasibilityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetFeasibilityLinear$address() {
        return SCIPgetFeasibilityLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetFeasibilityLinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetFeasibilityLinear(MemorySegment scip, MemorySegment cons, MemorySegment sol) {
        var mh$ = SCIPgetFeasibilityLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFeasibilityLinear", scip, cons, sol);
            }
            return (double)mh$.invokeExact(scip, cons, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualsolLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualsolLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualsolLinear$descriptor() {
        return SCIPgetDualsolLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualsolLinear$handle() {
        return SCIPgetDualsolLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualsolLinear$address() {
        return SCIPgetDualsolLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualsolLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualsolLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualsolLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualsolLinear", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualfarkasLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualfarkasLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualfarkasLinear$descriptor() {
        return SCIPgetDualfarkasLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualfarkasLinear$handle() {
        return SCIPgetDualfarkasLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualfarkasLinear$address() {
        return SCIPgetDualfarkasLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualfarkasLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualfarkasLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualfarkasLinear", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRowLinear$descriptor() {
        return SCIPgetRowLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRowLinear$handle() {
        return SCIPgetRowLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowLinear$address() {
        return SCIPgetRowLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLinear(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowLinear(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRowLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowLinear", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupgradeConsLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupgradeConsLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupgradeConsLinear(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **upgdcons)
     * }
     */
    public static FunctionDescriptor SCIPupgradeConsLinear$descriptor() {
        return SCIPupgradeConsLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupgradeConsLinear(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **upgdcons)
     * }
     */
    public static MethodHandle SCIPupgradeConsLinear$handle() {
        return SCIPupgradeConsLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupgradeConsLinear(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **upgdcons)
     * }
     */
    public static MemorySegment SCIPupgradeConsLinear$address() {
        return SCIPupgradeConsLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupgradeConsLinear(SCIP *scip, SCIP_CONS *cons, SCIP_CONS **upgdcons)
     * }
     */
    public static int SCIPupgradeConsLinear(MemorySegment scip, MemorySegment cons, MemorySegment upgdcons) {
        var mh$ = SCIPupgradeConsLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupgradeConsLinear", scip, cons, upgdcons);
            }
            return (int)mh$.invokeExact(scip, cons, upgdcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclassifyConstraintTypesLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclassifyConstraintTypesLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclassifyConstraintTypesLinear(SCIP *scip, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static FunctionDescriptor SCIPclassifyConstraintTypesLinear$descriptor() {
        return SCIPclassifyConstraintTypesLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclassifyConstraintTypesLinear(SCIP *scip, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MethodHandle SCIPclassifyConstraintTypesLinear$handle() {
        return SCIPclassifyConstraintTypesLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclassifyConstraintTypesLinear(SCIP *scip, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static MemorySegment SCIPclassifyConstraintTypesLinear$address() {
        return SCIPclassifyConstraintTypesLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclassifyConstraintTypesLinear(SCIP *scip, SCIP_LINCONSSTATS *linconsstats)
     * }
     */
    public static int SCIPclassifyConstraintTypesLinear(MemorySegment scip, MemorySegment linconsstats) {
        var mh$ = SCIPclassifyConstraintTypesLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclassifyConstraintTypesLinear", scip, linconsstats);
            }
            return (int)mh$.invokeExact(scip, linconsstats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupConssLinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupConssLinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLinear(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPcleanupConssLinear$descriptor() {
        return SCIPcleanupConssLinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLinear(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPcleanupConssLinear$handle() {
        return SCIPcleanupConssLinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLinear(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPcleanupConssLinear$address() {
        return SCIPcleanupConssLinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLinear(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible)
     * }
     */
    public static int SCIPcleanupConssLinear(MemorySegment scip, int onlychecked, MemorySegment infeasible) {
        var mh$ = SCIPcleanupConssLinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupConssLinear", scip, onlychecked, infeasible);
            }
            return (int)mh$.invokeExact(scip, onlychecked, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinking(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrLinking$descriptor() {
        return SCIPincludeConshdlrLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinking(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrLinking$handle() {
        return SCIPincludeConshdlrLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinking(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrLinking$address() {
        return SCIPincludeConshdlrLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLinking(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrLinking(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrLinking", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsLinking$descriptor() {
        return SCIPcreateConsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsLinking$handle() {
        return SCIPcreateConsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsLinking$address() {
        return SCIPcreateConsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsLinking(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment linkvar, MemorySegment binvars, MemorySegment vals, int nbinvars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsLinking", scip, cons, name, linkvar, binvars, vals, nbinvars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, linkvar, binvars, vals, nbinvars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicLinking$descriptor() {
        return SCIPcreateConsBasicLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicLinking$handle() {
        return SCIPcreateConsBasicLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicLinking$address() {
        return SCIPcreateConsBasicLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLinking(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *linkvar, SCIP_VAR **binvars, double *vals, int nbinvars)
     * }
     */
    public static int SCIPcreateConsBasicLinking(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment linkvar, MemorySegment binvars, MemorySegment vals, int nbinvars) {
        var mh$ = SCIPcreateConsBasicLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicLinking", scip, cons, name, linkvar, binvars, vals, nbinvars);
            }
            return (int)mh$.invokeExact(scip, cons, name, linkvar, binvars, vals, nbinvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexistsConsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexistsConsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static FunctionDescriptor SCIPexistsConsLinking$descriptor() {
        return SCIPexistsConsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static MethodHandle SCIPexistsConsLinking$handle() {
        return SCIPexistsConsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPexistsConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static MemorySegment SCIPexistsConsLinking$address() {
        return SCIPexistsConsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPexistsConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static int SCIPexistsConsLinking(MemorySegment scip, MemorySegment linkvar) {
        var mh$ = SCIPexistsConsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexistsConsLinking", scip, linkvar);
            }
            return (int)mh$.invokeExact(scip, linkvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static FunctionDescriptor SCIPgetConsLinking$descriptor() {
        return SCIPgetConsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static MethodHandle SCIPgetConsLinking$handle() {
        return SCIPgetConsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static MemorySegment SCIPgetConsLinking$address() {
        return SCIPgetConsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetConsLinking(SCIP *scip, SCIP_VAR *linkvar)
     * }
     */
    public static MemorySegment SCIPgetConsLinking(MemorySegment scip, MemorySegment linkvar) {
        var mh$ = SCIPgetConsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConsLinking", scip, linkvar);
            }
            return (MemorySegment)mh$.invokeExact(scip, linkvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinkvarLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinkvarLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetLinkvarLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLinkvarLinking$descriptor() {
        return SCIPgetLinkvarLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetLinkvarLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetLinkvarLinking$handle() {
        return SCIPgetLinkvarLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetLinkvarLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLinkvarLinking$address() {
        return SCIPgetLinkvarLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetLinkvarLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLinkvarLinking(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLinkvarLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinkvarLinking", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinvarsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinvarsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsLinking(SCIP *scip, SCIP_CONS *cons, SCIP_VAR ***binvars, int *nbinvars)
     * }
     */
    public static FunctionDescriptor SCIPgetBinvarsLinking$descriptor() {
        return SCIPgetBinvarsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsLinking(SCIP *scip, SCIP_CONS *cons, SCIP_VAR ***binvars, int *nbinvars)
     * }
     */
    public static MethodHandle SCIPgetBinvarsLinking$handle() {
        return SCIPgetBinvarsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsLinking(SCIP *scip, SCIP_CONS *cons, SCIP_VAR ***binvars, int *nbinvars)
     * }
     */
    public static MemorySegment SCIPgetBinvarsLinking$address() {
        return SCIPgetBinvarsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsLinking(SCIP *scip, SCIP_CONS *cons, SCIP_VAR ***binvars, int *nbinvars)
     * }
     */
    public static int SCIPgetBinvarsLinking(MemorySegment scip, MemorySegment cons, MemorySegment binvars, MemorySegment nbinvars) {
        var mh$ = SCIPgetBinvarsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinvarsLinking", scip, cons, binvars, nbinvars);
            }
            return (int)mh$.invokeExact(scip, cons, binvars, nbinvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBinvarsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBinvarsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNBinvarsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNBinvarsLinking$descriptor() {
        return SCIPgetNBinvarsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNBinvarsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNBinvarsLinking$handle() {
        return SCIPgetNBinvarsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNBinvarsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNBinvarsLinking$address() {
        return SCIPgetNBinvarsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNBinvarsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNBinvarsLinking(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNBinvarsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBinvarsLinking", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetValsLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetValsLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetValsLinking$descriptor() {
        return SCIPgetValsLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetValsLinking$handle() {
        return SCIPgetValsLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetValsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetValsLinking$address() {
        return SCIPgetValsLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetValsLinking(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetValsLinking(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetValsLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetValsLinking", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinvarsDataLinking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinvarsDataLinking");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsDataLinking(SCIP_CONS *cons, SCIP_VAR ***binvars, double **vals, int *nbinvars)
     * }
     */
    public static FunctionDescriptor SCIPgetBinvarsDataLinking$descriptor() {
        return SCIPgetBinvarsDataLinking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsDataLinking(SCIP_CONS *cons, SCIP_VAR ***binvars, double **vals, int *nbinvars)
     * }
     */
    public static MethodHandle SCIPgetBinvarsDataLinking$handle() {
        return SCIPgetBinvarsDataLinking.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsDataLinking(SCIP_CONS *cons, SCIP_VAR ***binvars, double **vals, int *nbinvars)
     * }
     */
    public static MemorySegment SCIPgetBinvarsDataLinking$address() {
        return SCIPgetBinvarsDataLinking.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarsDataLinking(SCIP_CONS *cons, SCIP_VAR ***binvars, double **vals, int *nbinvars)
     * }
     */
    public static int SCIPgetBinvarsDataLinking(MemorySegment cons, MemorySegment binvars, MemorySegment vals, MemorySegment nbinvars) {
        var mh$ = SCIPgetBinvarsDataLinking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinvarsDataLinking", cons, binvars, vals, nbinvars);
            }
            return (int)mh$.invokeExact(cons, binvars, vals, nbinvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLogicor(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrLogicor$descriptor() {
        return SCIPincludeConshdlrLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLogicor(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrLogicor$handle() {
        return SCIPincludeConshdlrLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLogicor(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrLogicor$address() {
        return SCIPincludeConshdlrLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrLogicor(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrLogicor(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrLogicor", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsLogicor$descriptor() {
        return SCIPcreateConsLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsLogicor$handle() {
        return SCIPcreateConsLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsLogicor$address() {
        return SCIPcreateConsLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsLogicor(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsLogicor", scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicLogicor$descriptor() {
        return SCIPcreateConsBasicLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicLogicor$handle() {
        return SCIPcreateConsBasicLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicLogicor$address() {
        return SCIPcreateConsBasicLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicLogicor(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicLogicor(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicLogicor", scip, cons, name, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCoefLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCoefLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLogicor(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPaddCoefLogicor$descriptor() {
        return SCIPaddCoefLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLogicor(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPaddCoefLogicor$handle() {
        return SCIPaddCoefLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLogicor(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPaddCoefLogicor$address() {
        return SCIPaddCoefLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefLogicor(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static int SCIPaddCoefLogicor(MemorySegment scip, MemorySegment cons, MemorySegment var_) {
        var mh$ = SCIPaddCoefLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCoefLogicor", scip, cons, var_);
            }
            return (int)mh$.invokeExact(scip, cons, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsLogicor$descriptor() {
        return SCIPgetNVarsLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsLogicor$handle() {
        return SCIPgetNVarsLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsLogicor$address() {
        return SCIPgetNVarsLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsLogicor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsLogicor", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsLogicor$descriptor() {
        return SCIPgetVarsLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsLogicor$handle() {
        return SCIPgetVarsLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsLogicor$address() {
        return SCIPgetVarsLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsLogicor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsLogicor", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualsolLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualsolLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualsolLogicor$descriptor() {
        return SCIPgetDualsolLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualsolLogicor$handle() {
        return SCIPgetDualsolLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualsolLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualsolLogicor$address() {
        return SCIPgetDualsolLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualsolLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualsolLogicor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualsolLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualsolLogicor", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualfarkasLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualfarkasLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualfarkasLogicor$descriptor() {
        return SCIPgetDualfarkasLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualfarkasLogicor$handle() {
        return SCIPgetDualfarkasLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualfarkasLogicor$address() {
        return SCIPgetDualfarkasLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualfarkasLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualfarkasLogicor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualfarkasLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualfarkasLogicor", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRowLogicor$descriptor() {
        return SCIPgetRowLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRowLogicor$handle() {
        return SCIPgetRowLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowLogicor$address() {
        return SCIPgetRowLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowLogicor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowLogicor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRowLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowLogicor", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupConssLogicor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupConssLogicor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLogicor(SCIP *scip, unsigned int onlychecked, int *naddconss, int *ndelconss, int *nchgcoefs)
     * }
     */
    public static FunctionDescriptor SCIPcleanupConssLogicor$descriptor() {
        return SCIPcleanupConssLogicor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLogicor(SCIP *scip, unsigned int onlychecked, int *naddconss, int *ndelconss, int *nchgcoefs)
     * }
     */
    public static MethodHandle SCIPcleanupConssLogicor$handle() {
        return SCIPcleanupConssLogicor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLogicor(SCIP *scip, unsigned int onlychecked, int *naddconss, int *ndelconss, int *nchgcoefs)
     * }
     */
    public static MemorySegment SCIPcleanupConssLogicor$address() {
        return SCIPcleanupConssLogicor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssLogicor(SCIP *scip, unsigned int onlychecked, int *naddconss, int *ndelconss, int *nchgcoefs)
     * }
     */
    public static int SCIPcleanupConssLogicor(MemorySegment scip, int onlychecked, MemorySegment naddconss, MemorySegment ndelconss, MemorySegment nchgcoefs) {
        var mh$ = SCIPcleanupConssLogicor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupConssLogicor", scip, onlychecked, naddconss, ndelconss, nchgcoefs);
            }
            return (int)mh$.invokeExact(scip, onlychecked, naddconss, ndelconss, nchgcoefs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int SCIP_NLHDLR_METHOD
     * }
     */
    public static final OfInt SCIP_NLHDLR_METHOD = scip_h.C_INT;

    private static class SCIPincludeConshdlrNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrNonlinear(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrNonlinear$descriptor() {
        return SCIPincludeConshdlrNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrNonlinear(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrNonlinear$handle() {
        return SCIPincludeConshdlrNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrNonlinear(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrNonlinear$address() {
        return SCIPincludeConshdlrNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrNonlinear(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrNonlinear(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrNonlinear", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConsUpgradeNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConsUpgradeNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConsUpgradeNonlinear(SCIP *scip, SCIP_RETCODE (*nlconsupgd)(SCIP *, SCIP_CONS *, int, int *, SCIP_CONS **, int), int priority, unsigned int active, const char *conshdlrname)
     * }
     */
    public static FunctionDescriptor SCIPincludeConsUpgradeNonlinear$descriptor() {
        return SCIPincludeConsUpgradeNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConsUpgradeNonlinear(SCIP *scip, SCIP_RETCODE (*nlconsupgd)(SCIP *, SCIP_CONS *, int, int *, SCIP_CONS **, int), int priority, unsigned int active, const char *conshdlrname)
     * }
     */
    public static MethodHandle SCIPincludeConsUpgradeNonlinear$handle() {
        return SCIPincludeConsUpgradeNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConsUpgradeNonlinear(SCIP *scip, SCIP_RETCODE (*nlconsupgd)(SCIP *, SCIP_CONS *, int, int *, SCIP_CONS **, int), int priority, unsigned int active, const char *conshdlrname)
     * }
     */
    public static MemorySegment SCIPincludeConsUpgradeNonlinear$address() {
        return SCIPincludeConsUpgradeNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConsUpgradeNonlinear(SCIP *scip, SCIP_RETCODE (*nlconsupgd)(SCIP *, SCIP_CONS *, int, int *, SCIP_CONS **, int), int priority, unsigned int active, const char *conshdlrname)
     * }
     */
    public static int SCIPincludeConsUpgradeNonlinear(MemorySegment scip, MemorySegment nlconsupgd, int priority, int active, MemorySegment conshdlrname) {
        var mh$ = SCIPincludeConsUpgradeNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConsUpgradeNonlinear", scip, nlconsupgd, priority, active, conshdlrname);
            }
            return (int)mh$.invokeExact(scip, nlconsupgd, priority, active, conshdlrname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsNonlinear$descriptor() {
        return SCIPcreateConsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateConsNonlinear$handle() {
        return SCIPcreateConsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateConsNonlinear$address() {
        return SCIPcreateConsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static int SCIPcreateConsNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment expr, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable) {
        var mh$ = SCIPcreateConsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsNonlinear", scip, cons, name, expr, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable);
            }
            return (int)mh$.invokeExact(scip, cons, name, expr, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicNonlinear$descriptor() {
        return SCIPcreateConsBasicNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicNonlinear$handle() {
        return SCIPcreateConsBasicNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicNonlinear$address() {
        return SCIPcreateConsBasicNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_EXPR *expr, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment expr, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicNonlinear", scip, cons, name, expr, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, expr, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsQuadraticNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsQuadraticNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsQuadraticNonlinear$descriptor() {
        return SCIPcreateConsQuadraticNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateConsQuadraticNonlinear$handle() {
        return SCIPcreateConsQuadraticNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateConsQuadraticNonlinear$address() {
        return SCIPcreateConsQuadraticNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable)
     * }
     */
    public static int SCIPcreateConsQuadraticNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, int nlinvars, MemorySegment linvars, MemorySegment lincoefs, int nquadterms, MemorySegment quadvars1, MemorySegment quadvars2, MemorySegment quadcoefs, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable) {
        var mh$ = SCIPcreateConsQuadraticNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsQuadraticNonlinear", scip, cons, name, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable);
            }
            return (int)mh$.invokeExact(scip, cons, name, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicQuadraticNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicQuadraticNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicQuadraticNonlinear$descriptor() {
        return SCIPcreateConsBasicQuadraticNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicQuadraticNonlinear$handle() {
        return SCIPcreateConsBasicQuadraticNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicQuadraticNonlinear$address() {
        return SCIPcreateConsBasicQuadraticNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicQuadraticNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nlinvars, SCIP_VAR **linvars, double *lincoefs, int nquadterms, SCIP_VAR **quadvars1, SCIP_VAR **quadvars2, double *quadcoefs, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicQuadraticNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, int nlinvars, MemorySegment linvars, MemorySegment lincoefs, int nquadterms, MemorySegment quadvars1, MemorySegment quadvars2, MemorySegment quadcoefs, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicQuadraticNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicQuadraticNonlinear", scip, cons, name, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, nlinvars, linvars, lincoefs, nquadterms, quadvars1, quadvars2, quadcoefs, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSOCNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSOCNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOCNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *coefs, double *offsets, double constant, SCIP_VAR *rhsvar, double rhscoeff, double rhsoffset)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSOCNonlinear$descriptor() {
        return SCIPcreateConsBasicSOCNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOCNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *coefs, double *offsets, double constant, SCIP_VAR *rhsvar, double rhscoeff, double rhsoffset)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSOCNonlinear$handle() {
        return SCIPcreateConsBasicSOCNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOCNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *coefs, double *offsets, double constant, SCIP_VAR *rhsvar, double rhscoeff, double rhsoffset)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSOCNonlinear$address() {
        return SCIPcreateConsBasicSOCNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOCNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *coefs, double *offsets, double constant, SCIP_VAR *rhsvar, double rhscoeff, double rhsoffset)
     * }
     */
    public static int SCIPcreateConsBasicSOCNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment coefs, MemorySegment offsets, double constant, MemorySegment rhsvar, double rhscoeff, double rhsoffset) {
        var mh$ = SCIPcreateConsBasicSOCNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSOCNonlinear", scip, cons, name, nvars, vars, coefs, offsets, constant, rhsvar, rhscoeff, rhsoffset);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, coefs, offsets, constant, rhsvar, rhscoeff, rhsoffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSignpowerNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSignpowerNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSignpowerNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *x, SCIP_VAR *z, double exponent, double xoffset, double zcoef, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSignpowerNonlinear$descriptor() {
        return SCIPcreateConsBasicSignpowerNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSignpowerNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *x, SCIP_VAR *z, double exponent, double xoffset, double zcoef, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSignpowerNonlinear$handle() {
        return SCIPcreateConsBasicSignpowerNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSignpowerNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *x, SCIP_VAR *z, double exponent, double xoffset, double zcoef, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSignpowerNonlinear$address() {
        return SCIPcreateConsBasicSignpowerNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSignpowerNonlinear(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *x, SCIP_VAR *z, double exponent, double xoffset, double zcoef, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicSignpowerNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment x, MemorySegment z, double exponent, double xoffset, double zcoef, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicSignpowerNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSignpowerNonlinear", scip, cons, name, x, z, exponent, xoffset, zcoef, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, x, z, exponent, xoffset, zcoef, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCurBoundsTagNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCurBoundsTagNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetCurBoundsTagNonlinear$descriptor() {
        return SCIPgetCurBoundsTagNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetCurBoundsTagNonlinear$handle() {
        return SCIPgetCurBoundsTagNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetCurBoundsTagNonlinear$address() {
        return SCIPgetCurBoundsTagNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPgetCurBoundsTagNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetCurBoundsTagNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCurBoundsTagNonlinear", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLastBoundRelaxTagNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLastBoundRelaxTagNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetLastBoundRelaxTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetLastBoundRelaxTagNonlinear$descriptor() {
        return SCIPgetLastBoundRelaxTagNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetLastBoundRelaxTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetLastBoundRelaxTagNonlinear$handle() {
        return SCIPgetLastBoundRelaxTagNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetLastBoundRelaxTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetLastBoundRelaxTagNonlinear$address() {
        return SCIPgetLastBoundRelaxTagNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetLastBoundRelaxTagNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static long SCIPgetLastBoundRelaxTagNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetLastBoundRelaxTagNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLastBoundRelaxTagNonlinear", conshdlr);
            }
            return (long)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincrementCurBoundsTagNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincrementCurBoundsTagNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPincrementCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr, unsigned int boundrelax)
     * }
     */
    public static FunctionDescriptor SCIPincrementCurBoundsTagNonlinear$descriptor() {
        return SCIPincrementCurBoundsTagNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPincrementCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr, unsigned int boundrelax)
     * }
     */
    public static MethodHandle SCIPincrementCurBoundsTagNonlinear$handle() {
        return SCIPincrementCurBoundsTagNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPincrementCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr, unsigned int boundrelax)
     * }
     */
    public static MemorySegment SCIPincrementCurBoundsTagNonlinear$address() {
        return SCIPincrementCurBoundsTagNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPincrementCurBoundsTagNonlinear(SCIP_CONSHDLR *conshdlr, unsigned int boundrelax)
     * }
     */
    public static void SCIPincrementCurBoundsTagNonlinear(MemorySegment conshdlr, int boundrelax) {
        var mh$ = SCIPincrementCurBoundsTagNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincrementCurBoundsTagNonlinear", conshdlr, boundrelax);
            }
            mh$.invokeExact(conshdlr, boundrelax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarExprHashmapNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarExprHashmapNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HASHMAP *SCIPgetVarExprHashmapNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetVarExprHashmapNonlinear$descriptor() {
        return SCIPgetVarExprHashmapNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HASHMAP *SCIPgetVarExprHashmapNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetVarExprHashmapNonlinear$handle() {
        return SCIPgetVarExprHashmapNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HASHMAP *SCIPgetVarExprHashmapNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetVarExprHashmapNonlinear$address() {
        return SCIPgetVarExprHashmapNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HASHMAP *SCIPgetVarExprHashmapNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetVarExprHashmapNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetVarExprHashmapNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarExprHashmapNonlinear", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprocessRowprepNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprocessRowprepNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessRowprepNonlinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_CONS *cons, SCIP_EXPR *expr, SCIP_ROWPREP *rowprep, unsigned int overestimate, SCIP_VAR *auxvar, double auxvalue, unsigned int allowweakcuts, unsigned int branchscoresuccess, unsigned int inenforcement, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPprocessRowprepNonlinear$descriptor() {
        return SCIPprocessRowprepNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessRowprepNonlinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_CONS *cons, SCIP_EXPR *expr, SCIP_ROWPREP *rowprep, unsigned int overestimate, SCIP_VAR *auxvar, double auxvalue, unsigned int allowweakcuts, unsigned int branchscoresuccess, unsigned int inenforcement, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPprocessRowprepNonlinear$handle() {
        return SCIPprocessRowprepNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessRowprepNonlinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_CONS *cons, SCIP_EXPR *expr, SCIP_ROWPREP *rowprep, unsigned int overestimate, SCIP_VAR *auxvar, double auxvalue, unsigned int allowweakcuts, unsigned int branchscoresuccess, unsigned int inenforcement, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPprocessRowprepNonlinear$address() {
        return SCIPprocessRowprepNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessRowprepNonlinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_CONS *cons, SCIP_EXPR *expr, SCIP_ROWPREP *rowprep, unsigned int overestimate, SCIP_VAR *auxvar, double auxvalue, unsigned int allowweakcuts, unsigned int branchscoresuccess, unsigned int inenforcement, SCIP_SOL *sol, SCIP_RESULT *result)
     * }
     */
    public static int SCIPprocessRowprepNonlinear(MemorySegment scip, MemorySegment nlhdlr, MemorySegment cons, MemorySegment expr, MemorySegment rowprep, int overestimate, MemorySegment auxvar, double auxvalue, int allowweakcuts, int branchscoresuccess, int inenforcement, MemorySegment sol, MemorySegment result) {
        var mh$ = SCIPprocessRowprepNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprocessRowprepNonlinear", scip, nlhdlr, cons, expr, rowprep, overestimate, auxvar, auxvalue, allowweakcuts, branchscoresuccess, inenforcement, sol, result);
            }
            return (int)mh$.invokeExact(scip, nlhdlr, cons, expr, rowprep, overestimate, auxvar, auxvalue, allowweakcuts, branchscoresuccess, inenforcement, sol, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPassumeConvexNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPassumeConvexNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPassumeConvexNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPassumeConvexNonlinear$descriptor() {
        return SCIPassumeConvexNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPassumeConvexNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPassumeConvexNonlinear$handle() {
        return SCIPassumeConvexNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPassumeConvexNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPassumeConvexNonlinear$address() {
        return SCIPassumeConvexNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPassumeConvexNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPassumeConvexNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPassumeConvexNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPassumeConvexNonlinear", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcollectBilinTermsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcollectBilinTermsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcollectBilinTermsNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS **conss, int nconss)
     * }
     */
    public static FunctionDescriptor SCIPcollectBilinTermsNonlinear$descriptor() {
        return SCIPcollectBilinTermsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcollectBilinTermsNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MethodHandle SCIPcollectBilinTermsNonlinear$handle() {
        return SCIPcollectBilinTermsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcollectBilinTermsNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS **conss, int nconss)
     * }
     */
    public static MemorySegment SCIPcollectBilinTermsNonlinear$address() {
        return SCIPcollectBilinTermsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcollectBilinTermsNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_CONS **conss, int nconss)
     * }
     */
    public static int SCIPcollectBilinTermsNonlinear(MemorySegment scip, MemorySegment conshdlr, MemorySegment conss, int nconss) {
        var mh$ = SCIPcollectBilinTermsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcollectBilinTermsNonlinear", scip, conshdlr, conss, nconss);
            }
            return (int)mh$.invokeExact(scip, conshdlr, conss, nconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBilinTermsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBilinTermsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetNBilinTermsNonlinear$descriptor() {
        return SCIPgetNBilinTermsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetNBilinTermsNonlinear$handle() {
        return SCIPgetNBilinTermsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetNBilinTermsNonlinear$address() {
        return SCIPgetNBilinTermsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPgetNBilinTermsNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetNBilinTermsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBilinTermsNonlinear", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBilinTermsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBilinTermsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetBilinTermsNonlinear$descriptor() {
        return SCIPgetBilinTermsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetBilinTermsNonlinear$handle() {
        return SCIPgetBilinTermsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetBilinTermsNonlinear$address() {
        return SCIPgetBilinTermsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetBilinTermsNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetBilinTermsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBilinTermsNonlinear", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBilinTermIdxNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBilinTermIdxNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetBilinTermIdxNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static FunctionDescriptor SCIPgetBilinTermIdxNonlinear$descriptor() {
        return SCIPgetBilinTermIdxNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetBilinTermIdxNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static MethodHandle SCIPgetBilinTermIdxNonlinear$handle() {
        return SCIPgetBilinTermIdxNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetBilinTermIdxNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static MemorySegment SCIPgetBilinTermIdxNonlinear$address() {
        return SCIPgetBilinTermIdxNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetBilinTermIdxNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static int SCIPgetBilinTermIdxNonlinear(MemorySegment conshdlr, MemorySegment x, MemorySegment y) {
        var mh$ = SCIPgetBilinTermIdxNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBilinTermIdxNonlinear", conshdlr, x, y);
            }
            return (int)mh$.invokeExact(conshdlr, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBilinTermNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBilinTermNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static FunctionDescriptor SCIPgetBilinTermNonlinear$descriptor() {
        return SCIPgetBilinTermNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static MethodHandle SCIPgetBilinTermNonlinear$handle() {
        return SCIPgetBilinTermNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static MemorySegment SCIPgetBilinTermNonlinear$address() {
        return SCIPgetBilinTermNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONSNONLINEAR_BILINTERM *SCIPgetBilinTermNonlinear(SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y)
     * }
     */
    public static MemorySegment SCIPgetBilinTermNonlinear(MemorySegment conshdlr, MemorySegment x, MemorySegment y) {
        var mh$ = SCIPgetBilinTermNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBilinTermNonlinear", conshdlr, x, y);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalBilinAuxExprNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalBilinAuxExprNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPevalBilinAuxExprNonlinear(SCIP *scip, SCIP_VAR *x, SCIP_VAR *y, SCIP_CONSNONLINEAR_AUXEXPR *auxexpr, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPevalBilinAuxExprNonlinear$descriptor() {
        return SCIPevalBilinAuxExprNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPevalBilinAuxExprNonlinear(SCIP *scip, SCIP_VAR *x, SCIP_VAR *y, SCIP_CONSNONLINEAR_AUXEXPR *auxexpr, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPevalBilinAuxExprNonlinear$handle() {
        return SCIPevalBilinAuxExprNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPevalBilinAuxExprNonlinear(SCIP *scip, SCIP_VAR *x, SCIP_VAR *y, SCIP_CONSNONLINEAR_AUXEXPR *auxexpr, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPevalBilinAuxExprNonlinear$address() {
        return SCIPevalBilinAuxExprNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPevalBilinAuxExprNonlinear(SCIP *scip, SCIP_VAR *x, SCIP_VAR *y, SCIP_CONSNONLINEAR_AUXEXPR *auxexpr, SCIP_SOL *sol)
     * }
     */
    public static double SCIPevalBilinAuxExprNonlinear(MemorySegment scip, MemorySegment x, MemorySegment y, MemorySegment auxexpr, MemorySegment sol) {
        var mh$ = SCIPevalBilinAuxExprNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalBilinAuxExprNonlinear", scip, x, y, auxexpr, sol);
            }
            return (double)mh$.invokeExact(scip, x, y, auxexpr, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinsertBilinearTermExistingNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinsertBilinearTermExistingNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermExistingNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, int nlockspos, int nlocksneg)
     * }
     */
    public static FunctionDescriptor SCIPinsertBilinearTermExistingNonlinear$descriptor() {
        return SCIPinsertBilinearTermExistingNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermExistingNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, int nlockspos, int nlocksneg)
     * }
     */
    public static MethodHandle SCIPinsertBilinearTermExistingNonlinear$handle() {
        return SCIPinsertBilinearTermExistingNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermExistingNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, int nlockspos, int nlocksneg)
     * }
     */
    public static MemorySegment SCIPinsertBilinearTermExistingNonlinear$address() {
        return SCIPinsertBilinearTermExistingNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermExistingNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, int nlockspos, int nlocksneg)
     * }
     */
    public static int SCIPinsertBilinearTermExistingNonlinear(MemorySegment scip, MemorySegment conshdlr, MemorySegment x, MemorySegment y, MemorySegment auxvar, int nlockspos, int nlocksneg) {
        var mh$ = SCIPinsertBilinearTermExistingNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinsertBilinearTermExistingNonlinear", scip, conshdlr, x, y, auxvar, nlockspos, nlocksneg);
            }
            return (int)mh$.invokeExact(scip, conshdlr, x, y, auxvar, nlockspos, nlocksneg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinsertBilinearTermImplicitNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinsertBilinearTermImplicitNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermImplicitNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, double coefx, double coefy, double coefaux, double cst, unsigned int overestimate)
     * }
     */
    public static FunctionDescriptor SCIPinsertBilinearTermImplicitNonlinear$descriptor() {
        return SCIPinsertBilinearTermImplicitNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermImplicitNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, double coefx, double coefy, double coefaux, double cst, unsigned int overestimate)
     * }
     */
    public static MethodHandle SCIPinsertBilinearTermImplicitNonlinear$handle() {
        return SCIPinsertBilinearTermImplicitNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermImplicitNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, double coefx, double coefy, double coefaux, double cst, unsigned int overestimate)
     * }
     */
    public static MemorySegment SCIPinsertBilinearTermImplicitNonlinear$address() {
        return SCIPinsertBilinearTermImplicitNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinsertBilinearTermImplicitNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_VAR *x, SCIP_VAR *y, SCIP_VAR *auxvar, double coefx, double coefy, double coefaux, double cst, unsigned int overestimate)
     * }
     */
    public static int SCIPinsertBilinearTermImplicitNonlinear(MemorySegment scip, MemorySegment conshdlr, MemorySegment x, MemorySegment y, MemorySegment auxvar, double coefx, double coefy, double coefaux, double cst, int overestimate) {
        var mh$ = SCIPinsertBilinearTermImplicitNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinsertBilinearTermImplicitNonlinear", scip, conshdlr, x, y, auxvar, coefx, coefy, coefaux, cst, overestimate);
            }
            return (int)mh$.invokeExact(scip, conshdlr, x, y, auxvar, coefx, coefy, coefaux, cst, overestimate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeFacetVertexPolyhedralNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeFacetVertexPolyhedralNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeFacetVertexPolyhedralNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, unsigned int overestimate, double (*function)(double *, int, void *), void *fundata, double *xstar, double *box, int nallvars, double targetvalue, unsigned int *success, double *facetcoefs, double *facetconstant)
     * }
     */
    public static FunctionDescriptor SCIPcomputeFacetVertexPolyhedralNonlinear$descriptor() {
        return SCIPcomputeFacetVertexPolyhedralNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeFacetVertexPolyhedralNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, unsigned int overestimate, double (*function)(double *, int, void *), void *fundata, double *xstar, double *box, int nallvars, double targetvalue, unsigned int *success, double *facetcoefs, double *facetconstant)
     * }
     */
    public static MethodHandle SCIPcomputeFacetVertexPolyhedralNonlinear$handle() {
        return SCIPcomputeFacetVertexPolyhedralNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeFacetVertexPolyhedralNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, unsigned int overestimate, double (*function)(double *, int, void *), void *fundata, double *xstar, double *box, int nallvars, double targetvalue, unsigned int *success, double *facetcoefs, double *facetconstant)
     * }
     */
    public static MemorySegment SCIPcomputeFacetVertexPolyhedralNonlinear$address() {
        return SCIPcomputeFacetVertexPolyhedralNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeFacetVertexPolyhedralNonlinear(SCIP *scip, SCIP_CONSHDLR *conshdlr, unsigned int overestimate, double (*function)(double *, int, void *), void *fundata, double *xstar, double *box, int nallvars, double targetvalue, unsigned int *success, double *facetcoefs, double *facetconstant)
     * }
     */
    public static int SCIPcomputeFacetVertexPolyhedralNonlinear(MemorySegment scip, MemorySegment conshdlr, int overestimate, MemorySegment function, MemorySegment fundata, MemorySegment xstar, MemorySegment box, int nallvars, double targetvalue, MemorySegment success, MemorySegment facetcoefs, MemorySegment facetconstant) {
        var mh$ = SCIPcomputeFacetVertexPolyhedralNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeFacetVertexPolyhedralNonlinear", scip, conshdlr, overestimate, function, fundata, xstar, box, nallvars, targetvalue, success, facetcoefs, facetconstant);
            }
            return (int)mh$.invokeExact(scip, conshdlr, overestimate, function, fundata, xstar, box, nallvars, targetvalue, success, facetcoefs, facetconstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPgetExprNonlinear(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNonlinear$descriptor() {
        return SCIPgetExprNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPgetExprNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetExprNonlinear$handle() {
        return SCIPgetExprNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPgetExprNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetExprNonlinear$address() {
        return SCIPgetExprNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR *SCIPgetExprNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetExprNonlinear(MemorySegment cons) {
        var mh$ = SCIPgetExprNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNonlinear", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLhsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLhsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLhsNonlinear$descriptor() {
        return SCIPgetLhsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetLhsNonlinear$handle() {
        return SCIPgetLhsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLhsNonlinear$address() {
        return SCIPgetLhsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetLhsNonlinear(MemorySegment cons) {
        var mh$ = SCIPgetLhsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLhsNonlinear", cons);
            }
            return (double)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRhsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRhsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRhsNonlinear$descriptor() {
        return SCIPgetRhsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRhsNonlinear$handle() {
        return SCIPgetRhsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRhsNonlinear$address() {
        return SCIPgetRhsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRhsNonlinear(SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetRhsNonlinear(MemorySegment cons) {
        var mh$ = SCIPgetRhsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRhsNonlinear", cons);
            }
            return (double)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_NLROW **nlrow)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowNonlinear$descriptor() {
        return SCIPgetNlRowNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_NLROW **nlrow)
     * }
     */
    public static MethodHandle SCIPgetNlRowNonlinear$handle() {
        return SCIPgetNlRowNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_NLROW **nlrow)
     * }
     */
    public static MemorySegment SCIPgetNlRowNonlinear$address() {
        return SCIPgetNlRowNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_NLROW **nlrow)
     * }
     */
    public static int SCIPgetNlRowNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment nlrow) {
        var mh$ = SCIPgetNlRowNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowNonlinear", scip, cons, nlrow);
            }
            return (int)mh$.invokeExact(scip, cons, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCurvatureNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCurvatureNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPgetCurvatureNonlinear(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetCurvatureNonlinear$descriptor() {
        return SCIPgetCurvatureNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPgetCurvatureNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetCurvatureNonlinear$handle() {
        return SCIPgetCurvatureNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPgetCurvatureNonlinear(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetCurvatureNonlinear$address() {
        return SCIPgetCurvatureNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPRCURV SCIPgetCurvatureNonlinear(SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetCurvatureNonlinear(MemorySegment cons) {
        var mh$ = SCIPgetCurvatureNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCurvatureNonlinear", cons);
            }
            return (int)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckQuadraticNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckQuadraticNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckQuadraticNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int *isquadratic)
     * }
     */
    public static FunctionDescriptor SCIPcheckQuadraticNonlinear$descriptor() {
        return SCIPcheckQuadraticNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckQuadraticNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int *isquadratic)
     * }
     */
    public static MethodHandle SCIPcheckQuadraticNonlinear$handle() {
        return SCIPcheckQuadraticNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckQuadraticNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int *isquadratic)
     * }
     */
    public static MemorySegment SCIPcheckQuadraticNonlinear$address() {
        return SCIPcheckQuadraticNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckQuadraticNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int *isquadratic)
     * }
     */
    public static int SCIPcheckQuadraticNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment isquadratic) {
        var mh$ = SCIPcheckQuadraticNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckQuadraticNonlinear", scip, cons, isquadratic);
            }
            return (int)mh$.invokeExact(scip, cons, isquadratic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgLhsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgLhsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsNonlinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static FunctionDescriptor SCIPchgLhsNonlinear$descriptor() {
        return SCIPchgLhsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsNonlinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static MethodHandle SCIPchgLhsNonlinear$handle() {
        return SCIPchgLhsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsNonlinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static MemorySegment SCIPchgLhsNonlinear$address() {
        return SCIPchgLhsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsNonlinear(SCIP *scip, SCIP_CONS *cons, double lhs)
     * }
     */
    public static int SCIPchgLhsNonlinear(MemorySegment scip, MemorySegment cons, double lhs) {
        var mh$ = SCIPchgLhsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgLhsNonlinear", scip, cons, lhs);
            }
            return (int)mh$.invokeExact(scip, cons, lhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRhsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRhsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsNonlinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRhsNonlinear$descriptor() {
        return SCIPchgRhsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsNonlinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static MethodHandle SCIPchgRhsNonlinear$handle() {
        return SCIPchgRhsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsNonlinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static MemorySegment SCIPchgRhsNonlinear$address() {
        return SCIPchgRhsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsNonlinear(SCIP *scip, SCIP_CONS *cons, double rhs)
     * }
     */
    public static int SCIPchgRhsNonlinear(MemorySegment scip, MemorySegment cons, double rhs) {
        var mh$ = SCIPchgRhsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRhsNonlinear", scip, cons, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgExprNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgExprNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPchgExprNonlinear$descriptor() {
        return SCIPchgExprNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPchgExprNonlinear$handle() {
        return SCIPchgExprNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPchgExprNonlinear$address() {
        return SCIPchgExprNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPchgExprNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment expr) {
        var mh$ = SCIPchgExprNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgExprNonlinear", scip, cons, expr);
            }
            return (int)mh$.invokeExact(scip, cons, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddLinearVarNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddLinearVarNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearVarNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double coef)
     * }
     */
    public static FunctionDescriptor SCIPaddLinearVarNonlinear$descriptor() {
        return SCIPaddLinearVarNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearVarNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double coef)
     * }
     */
    public static MethodHandle SCIPaddLinearVarNonlinear$handle() {
        return SCIPaddLinearVarNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearVarNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double coef)
     * }
     */
    public static MemorySegment SCIPaddLinearVarNonlinear$address() {
        return SCIPaddLinearVarNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearVarNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double coef)
     * }
     */
    public static int SCIPaddLinearVarNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment var_, double coef) {
        var mh$ = SCIPaddLinearVarNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddLinearVarNonlinear", scip, cons, var_, coef);
            }
            return (int)mh$.invokeExact(scip, cons, var_, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddExprNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddExprNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr, double coef)
     * }
     */
    public static FunctionDescriptor SCIPaddExprNonlinear$descriptor() {
        return SCIPaddExprNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr, double coef)
     * }
     */
    public static MethodHandle SCIPaddExprNonlinear$handle() {
        return SCIPaddExprNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr, double coef)
     * }
     */
    public static MemorySegment SCIPaddExprNonlinear$address() {
        return SCIPaddExprNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_EXPR *expr, double coef)
     * }
     */
    public static int SCIPaddExprNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment expr, double coef) {
        var mh$ = SCIPaddExprNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddExprNonlinear", scip, cons, expr, coef);
            }
            return (int)mh$.invokeExact(scip, cons, expr, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAbsViolationNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAbsViolationNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAbsViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static FunctionDescriptor SCIPgetAbsViolationNonlinear$descriptor() {
        return SCIPgetAbsViolationNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAbsViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static MethodHandle SCIPgetAbsViolationNonlinear$handle() {
        return SCIPgetAbsViolationNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAbsViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static MemorySegment SCIPgetAbsViolationNonlinear$address() {
        return SCIPgetAbsViolationNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAbsViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static int SCIPgetAbsViolationNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment sol, MemorySegment viol) {
        var mh$ = SCIPgetAbsViolationNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAbsViolationNonlinear", scip, cons, sol, viol);
            }
            return (int)mh$.invokeExact(scip, cons, sol, viol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRelViolationNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRelViolationNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRelViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static FunctionDescriptor SCIPgetRelViolationNonlinear$descriptor() {
        return SCIPgetRelViolationNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRelViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static MethodHandle SCIPgetRelViolationNonlinear$handle() {
        return SCIPgetRelViolationNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRelViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static MemorySegment SCIPgetRelViolationNonlinear$address() {
        return SCIPgetRelViolationNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRelViolationNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *viol)
     * }
     */
    public static int SCIPgetRelViolationNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment sol, MemorySegment viol) {
        var mh$ = SCIPgetRelViolationNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRelViolationNonlinear", scip, cons, sol, viol);
            }
            return (int)mh$.invokeExact(scip, cons, sol, viol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinvarMayDecreaseNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinvarMayDecreaseNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayDecreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static FunctionDescriptor SCIPgetLinvarMayDecreaseNonlinear$descriptor() {
        return SCIPgetLinvarMayDecreaseNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayDecreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static MethodHandle SCIPgetLinvarMayDecreaseNonlinear$handle() {
        return SCIPgetLinvarMayDecreaseNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayDecreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static MemorySegment SCIPgetLinvarMayDecreaseNonlinear$address() {
        return SCIPgetLinvarMayDecreaseNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetLinvarMayDecreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static void SCIPgetLinvarMayDecreaseNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment var_, MemorySegment coef) {
        var mh$ = SCIPgetLinvarMayDecreaseNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinvarMayDecreaseNonlinear", scip, cons, var_, coef);
            }
            mh$.invokeExact(scip, cons, var_, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinvarMayIncreaseNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinvarMayIncreaseNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayIncreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static FunctionDescriptor SCIPgetLinvarMayIncreaseNonlinear$descriptor() {
        return SCIPgetLinvarMayIncreaseNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayIncreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static MethodHandle SCIPgetLinvarMayIncreaseNonlinear$handle() {
        return SCIPgetLinvarMayIncreaseNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetLinvarMayIncreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static MemorySegment SCIPgetLinvarMayIncreaseNonlinear$address() {
        return SCIPgetLinvarMayIncreaseNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetLinvarMayIncreaseNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_VAR **var, double *coef)
     * }
     */
    public static void SCIPgetLinvarMayIncreaseNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment var_, MemorySegment coef) {
        var mh$ = SCIPgetLinvarMayIncreaseNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinvarMayIncreaseNonlinear", scip, cons, var_, coef);
            }
            mh$.invokeExact(scip, cons, var_, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNLocksPosNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNLocksPosNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksPosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNLocksPosNonlinear$descriptor() {
        return SCIPgetExprNLocksPosNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksPosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNLocksPosNonlinear$handle() {
        return SCIPgetExprNLocksPosNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksPosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNLocksPosNonlinear$address() {
        return SCIPgetExprNLocksPosNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetExprNLocksPosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNLocksPosNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNLocksPosNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNLocksPosNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNLocksNegNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNLocksNegNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksNegNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNLocksNegNonlinear$descriptor() {
        return SCIPgetExprNLocksNegNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksNegNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNLocksNegNonlinear$handle() {
        return SCIPgetExprNLocksNegNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetExprNLocksNegNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNLocksNegNonlinear$address() {
        return SCIPgetExprNLocksNegNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetExprNLocksNegNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNLocksNegNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNLocksNegNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNLocksNegNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprAuxVarNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprAuxVarNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetExprAuxVarNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprAuxVarNonlinear$descriptor() {
        return SCIPgetExprAuxVarNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetExprAuxVarNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprAuxVarNonlinear$handle() {
        return SCIPgetExprAuxVarNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetExprAuxVarNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprAuxVarNonlinear$address() {
        return SCIPgetExprAuxVarNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetExprAuxVarNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprAuxVarNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprAuxVarNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprAuxVarNonlinear", expr);
            }
            return (MemorySegment)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNEnfosNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNEnfosNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetExprNEnfosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNEnfosNonlinear$descriptor() {
        return SCIPgetExprNEnfosNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetExprNEnfosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNEnfosNonlinear$handle() {
        return SCIPgetExprNEnfosNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetExprNEnfosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNEnfosNonlinear$address() {
        return SCIPgetExprNEnfosNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetExprNEnfosNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNEnfosNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNEnfosNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNEnfosNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprEnfoDataNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprEnfoDataNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetExprEnfoDataNonlinear(SCIP_EXPR *expr, int idx, SCIP_NLHDLR **nlhdlr, SCIP_NLHDLREXPRDATA **nlhdlrexprdata, SCIP_NLHDLR_METHOD *nlhdlrparticipation, unsigned int *sepabelowusesactivity, unsigned int *sepaaboveusesactivity, double *auxvalue)
     * }
     */
    public static FunctionDescriptor SCIPgetExprEnfoDataNonlinear$descriptor() {
        return SCIPgetExprEnfoDataNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetExprEnfoDataNonlinear(SCIP_EXPR *expr, int idx, SCIP_NLHDLR **nlhdlr, SCIP_NLHDLREXPRDATA **nlhdlrexprdata, SCIP_NLHDLR_METHOD *nlhdlrparticipation, unsigned int *sepabelowusesactivity, unsigned int *sepaaboveusesactivity, double *auxvalue)
     * }
     */
    public static MethodHandle SCIPgetExprEnfoDataNonlinear$handle() {
        return SCIPgetExprEnfoDataNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetExprEnfoDataNonlinear(SCIP_EXPR *expr, int idx, SCIP_NLHDLR **nlhdlr, SCIP_NLHDLREXPRDATA **nlhdlrexprdata, SCIP_NLHDLR_METHOD *nlhdlrparticipation, unsigned int *sepabelowusesactivity, unsigned int *sepaaboveusesactivity, double *auxvalue)
     * }
     */
    public static MemorySegment SCIPgetExprEnfoDataNonlinear$address() {
        return SCIPgetExprEnfoDataNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetExprEnfoDataNonlinear(SCIP_EXPR *expr, int idx, SCIP_NLHDLR **nlhdlr, SCIP_NLHDLREXPRDATA **nlhdlrexprdata, SCIP_NLHDLR_METHOD *nlhdlrparticipation, unsigned int *sepabelowusesactivity, unsigned int *sepaaboveusesactivity, double *auxvalue)
     * }
     */
    public static void SCIPgetExprEnfoDataNonlinear(MemorySegment expr, int idx, MemorySegment nlhdlr, MemorySegment nlhdlrexprdata, MemorySegment nlhdlrparticipation, MemorySegment sepabelowusesactivity, MemorySegment sepaaboveusesactivity, MemorySegment auxvalue) {
        var mh$ = SCIPgetExprEnfoDataNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprEnfoDataNonlinear", expr, idx, nlhdlr, nlhdlrexprdata, nlhdlrparticipation, sepabelowusesactivity, sepaaboveusesactivity, auxvalue);
            }
            mh$.invokeExact(expr, idx, nlhdlr, nlhdlrexprdata, nlhdlrparticipation, sepabelowusesactivity, sepaaboveusesactivity, auxvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetExprEnfoAuxValueNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetExprEnfoAuxValueNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetExprEnfoAuxValueNonlinear(SCIP_EXPR *expr, int idx, double auxvalue)
     * }
     */
    public static FunctionDescriptor SCIPsetExprEnfoAuxValueNonlinear$descriptor() {
        return SCIPsetExprEnfoAuxValueNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetExprEnfoAuxValueNonlinear(SCIP_EXPR *expr, int idx, double auxvalue)
     * }
     */
    public static MethodHandle SCIPsetExprEnfoAuxValueNonlinear$handle() {
        return SCIPsetExprEnfoAuxValueNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetExprEnfoAuxValueNonlinear(SCIP_EXPR *expr, int idx, double auxvalue)
     * }
     */
    public static MemorySegment SCIPsetExprEnfoAuxValueNonlinear$address() {
        return SCIPsetExprEnfoAuxValueNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetExprEnfoAuxValueNonlinear(SCIP_EXPR *expr, int idx, double auxvalue)
     * }
     */
    public static void SCIPsetExprEnfoAuxValueNonlinear(MemorySegment expr, int idx, double auxvalue) {
        var mh$ = SCIPsetExprEnfoAuxValueNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetExprEnfoAuxValueNonlinear", expr, idx, auxvalue);
            }
            mh$.invokeExact(expr, idx, auxvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNPropUsesActivityNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNPropUsesActivityNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNPropUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNPropUsesActivityNonlinear$descriptor() {
        return SCIPgetExprNPropUsesActivityNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNPropUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNPropUsesActivityNonlinear$handle() {
        return SCIPgetExprNPropUsesActivityNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNPropUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNPropUsesActivityNonlinear$address() {
        return SCIPgetExprNPropUsesActivityNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNPropUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNPropUsesActivityNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNPropUsesActivityNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNPropUsesActivityNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNSepaUsesActivityNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNSepaUsesActivityNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNSepaUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNSepaUsesActivityNonlinear$descriptor() {
        return SCIPgetExprNSepaUsesActivityNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNSepaUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNSepaUsesActivityNonlinear$handle() {
        return SCIPgetExprNSepaUsesActivityNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNSepaUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNSepaUsesActivityNonlinear$address() {
        return SCIPgetExprNSepaUsesActivityNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNSepaUsesActivityNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNSepaUsesActivityNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNSepaUsesActivityNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNSepaUsesActivityNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNAuxvarUsesNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNAuxvarUsesNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNAuxvarUsesNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNAuxvarUsesNonlinear$descriptor() {
        return SCIPgetExprNAuxvarUsesNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNAuxvarUsesNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprNAuxvarUsesNonlinear$handle() {
        return SCIPgetExprNAuxvarUsesNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNAuxvarUsesNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprNAuxvarUsesNonlinear$address() {
        return SCIPgetExprNAuxvarUsesNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetExprNAuxvarUsesNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetExprNAuxvarUsesNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprNAuxvarUsesNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNAuxvarUsesNonlinear", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPregisterExprUsageNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPregisterExprUsageNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPregisterExprUsageNonlinear(SCIP *scip, SCIP_EXPR *expr, unsigned int useauxvar, unsigned int useactivityforprop, unsigned int useactivityforsepabelow, unsigned int useactivityforsepaabove)
     * }
     */
    public static FunctionDescriptor SCIPregisterExprUsageNonlinear$descriptor() {
        return SCIPregisterExprUsageNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPregisterExprUsageNonlinear(SCIP *scip, SCIP_EXPR *expr, unsigned int useauxvar, unsigned int useactivityforprop, unsigned int useactivityforsepabelow, unsigned int useactivityforsepaabove)
     * }
     */
    public static MethodHandle SCIPregisterExprUsageNonlinear$handle() {
        return SCIPregisterExprUsageNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPregisterExprUsageNonlinear(SCIP *scip, SCIP_EXPR *expr, unsigned int useauxvar, unsigned int useactivityforprop, unsigned int useactivityforsepabelow, unsigned int useactivityforsepaabove)
     * }
     */
    public static MemorySegment SCIPregisterExprUsageNonlinear$address() {
        return SCIPregisterExprUsageNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPregisterExprUsageNonlinear(SCIP *scip, SCIP_EXPR *expr, unsigned int useauxvar, unsigned int useactivityforprop, unsigned int useactivityforsepabelow, unsigned int useactivityforsepaabove)
     * }
     */
    public static int SCIPregisterExprUsageNonlinear(MemorySegment scip, MemorySegment expr, int useauxvar, int useactivityforprop, int useactivityforsepabelow, int useactivityforsepaabove) {
        var mh$ = SCIPregisterExprUsageNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPregisterExprUsageNonlinear", scip, expr, useauxvar, useactivityforprop, useactivityforsepabelow, useactivityforsepaabove);
            }
            return (int)mh$.invokeExact(scip, expr, useauxvar, useactivityforprop, useactivityforsepabelow, useactivityforsepaabove);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprActivityNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprActivityNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprActivityNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *activity)
     * }
     */
    public static FunctionDescriptor SCIPgetExprActivityNonlinear$descriptor() {
        return SCIPgetExprActivityNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprActivityNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *activity)
     * }
     */
    public static MethodHandle SCIPgetExprActivityNonlinear$handle() {
        return SCIPgetExprActivityNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprActivityNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *activity)
     * }
     */
    public static MemorySegment SCIPgetExprActivityNonlinear$address() {
        return SCIPgetExprActivityNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprActivityNonlinear(SCIP *scip, SCIP_CONS *cons, SCIP_SOL *sol, double *activity)
     * }
     */
    public static int SCIPgetExprActivityNonlinear(MemorySegment scip, MemorySegment cons, MemorySegment sol, MemorySegment activity) {
        var mh$ = SCIPgetExprActivityNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprActivityNonlinear", scip, cons, sol, activity);
            }
            return (int)mh$.invokeExact(scip, cons, sol, activity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprAbsOrigViolationNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprAbsOrigViolationNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsOrigViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static FunctionDescriptor SCIPgetExprAbsOrigViolationNonlinear$descriptor() {
        return SCIPgetExprAbsOrigViolationNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsOrigViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MethodHandle SCIPgetExprAbsOrigViolationNonlinear$handle() {
        return SCIPgetExprAbsOrigViolationNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsOrigViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MemorySegment SCIPgetExprAbsOrigViolationNonlinear$address() {
        return SCIPgetExprAbsOrigViolationNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsOrigViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static int SCIPgetExprAbsOrigViolationNonlinear(MemorySegment scip, MemorySegment expr, MemorySegment sol, long soltag, MemorySegment viol, MemorySegment violunder, MemorySegment violover) {
        var mh$ = SCIPgetExprAbsOrigViolationNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprAbsOrigViolationNonlinear", scip, expr, sol, soltag, viol, violunder, violover);
            }
            return (int)mh$.invokeExact(scip, expr, sol, soltag, viol, violunder, violover);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprAbsAuxViolationNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprAbsAuxViolationNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static FunctionDescriptor SCIPgetExprAbsAuxViolationNonlinear$descriptor() {
        return SCIPgetExprAbsAuxViolationNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MethodHandle SCIPgetExprAbsAuxViolationNonlinear$handle() {
        return SCIPgetExprAbsAuxViolationNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MemorySegment SCIPgetExprAbsAuxViolationNonlinear$address() {
        return SCIPgetExprAbsAuxViolationNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprAbsAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static int SCIPgetExprAbsAuxViolationNonlinear(MemorySegment scip, MemorySegment expr, double auxvalue, MemorySegment sol, MemorySegment viol, MemorySegment violunder, MemorySegment violover) {
        var mh$ = SCIPgetExprAbsAuxViolationNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprAbsAuxViolationNonlinear", scip, expr, auxvalue, sol, viol, violunder, violover);
            }
            return (int)mh$.invokeExact(scip, expr, auxvalue, sol, viol, violunder, violover);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprRelAuxViolationNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprRelAuxViolationNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprRelAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static FunctionDescriptor SCIPgetExprRelAuxViolationNonlinear$descriptor() {
        return SCIPgetExprRelAuxViolationNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprRelAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MethodHandle SCIPgetExprRelAuxViolationNonlinear$handle() {
        return SCIPgetExprRelAuxViolationNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprRelAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static MemorySegment SCIPgetExprRelAuxViolationNonlinear$address() {
        return SCIPgetExprRelAuxViolationNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprRelAuxViolationNonlinear(SCIP *scip, SCIP_EXPR *expr, double auxvalue, SCIP_SOL *sol, double *viol, unsigned int *violunder, unsigned int *violover)
     * }
     */
    public static int SCIPgetExprRelAuxViolationNonlinear(MemorySegment scip, MemorySegment expr, double auxvalue, MemorySegment sol, MemorySegment viol, MemorySegment violunder, MemorySegment violover) {
        var mh$ = SCIPgetExprRelAuxViolationNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprRelAuxViolationNonlinear", scip, expr, auxvalue, sol, viol, violunder, violover);
            }
            return (int)mh$.invokeExact(scip, expr, auxvalue, sol, viol, violunder, violover);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprBoundsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            SCIP_Interval.layout(),
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprBoundsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPgetExprBoundsNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprBoundsNonlinear$descriptor() {
        return SCIPgetExprBoundsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPgetExprBoundsNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprBoundsNonlinear$handle() {
        return SCIPgetExprBoundsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPgetExprBoundsNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprBoundsNonlinear$address() {
        return SCIPgetExprBoundsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_INTERVAL SCIPgetExprBoundsNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprBoundsNonlinear(SegmentAllocator allocator, MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPgetExprBoundsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprBoundsNonlinear", allocator, scip, expr);
            }
            return (MemorySegment)mh$.invokeExact(allocator, scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtightenExprIntervalNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtightenExprIntervalNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenExprIntervalNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL newbounds, unsigned int *cutoff, int *ntightenings)
     * }
     */
    public static FunctionDescriptor SCIPtightenExprIntervalNonlinear$descriptor() {
        return SCIPtightenExprIntervalNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenExprIntervalNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL newbounds, unsigned int *cutoff, int *ntightenings)
     * }
     */
    public static MethodHandle SCIPtightenExprIntervalNonlinear$handle() {
        return SCIPtightenExprIntervalNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenExprIntervalNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL newbounds, unsigned int *cutoff, int *ntightenings)
     * }
     */
    public static MemorySegment SCIPtightenExprIntervalNonlinear$address() {
        return SCIPtightenExprIntervalNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtightenExprIntervalNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL newbounds, unsigned int *cutoff, int *ntightenings)
     * }
     */
    public static int SCIPtightenExprIntervalNonlinear(MemorySegment scip, MemorySegment expr, MemorySegment newbounds, MemorySegment cutoff, MemorySegment ntightenings) {
        var mh$ = SCIPtightenExprIntervalNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtightenExprIntervalNonlinear", scip, expr, newbounds, cutoff, ntightenings);
            }
            return (int)mh$.invokeExact(scip, expr, newbounds, cutoff, ntightenings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkExprPropagateNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkExprPropagateNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkExprPropagateNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPmarkExprPropagateNonlinear$descriptor() {
        return SCIPmarkExprPropagateNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkExprPropagateNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPmarkExprPropagateNonlinear$handle() {
        return SCIPmarkExprPropagateNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkExprPropagateNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPmarkExprPropagateNonlinear$address() {
        return SCIPmarkExprPropagateNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmarkExprPropagateNonlinear(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPmarkExprPropagateNonlinear(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPmarkExprPropagateNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkExprPropagateNonlinear", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddExprViolScoreNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddExprViolScoreNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddExprViolScoreNonlinear(SCIP *scip, SCIP_EXPR *expr, double violscore)
     * }
     */
    public static FunctionDescriptor SCIPaddExprViolScoreNonlinear$descriptor() {
        return SCIPaddExprViolScoreNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddExprViolScoreNonlinear(SCIP *scip, SCIP_EXPR *expr, double violscore)
     * }
     */
    public static MethodHandle SCIPaddExprViolScoreNonlinear$handle() {
        return SCIPaddExprViolScoreNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddExprViolScoreNonlinear(SCIP *scip, SCIP_EXPR *expr, double violscore)
     * }
     */
    public static MemorySegment SCIPaddExprViolScoreNonlinear$address() {
        return SCIPaddExprViolScoreNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddExprViolScoreNonlinear(SCIP *scip, SCIP_EXPR *expr, double violscore)
     * }
     */
    public static void SCIPaddExprViolScoreNonlinear(MemorySegment scip, MemorySegment expr, double violscore) {
        var mh$ = SCIPaddExprViolScoreNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddExprViolScoreNonlinear", scip, expr, violscore);
            }
            mh$.invokeExact(scip, expr, violscore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddExprsViolScoreNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddExprsViolScoreNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprsViolScoreNonlinear(SCIP *scip, SCIP_EXPR **exprs, int nexprs, double violscore, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddExprsViolScoreNonlinear$descriptor() {
        return SCIPaddExprsViolScoreNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprsViolScoreNonlinear(SCIP *scip, SCIP_EXPR **exprs, int nexprs, double violscore, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddExprsViolScoreNonlinear$handle() {
        return SCIPaddExprsViolScoreNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprsViolScoreNonlinear(SCIP *scip, SCIP_EXPR **exprs, int nexprs, double violscore, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddExprsViolScoreNonlinear$address() {
        return SCIPaddExprsViolScoreNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddExprsViolScoreNonlinear(SCIP *scip, SCIP_EXPR **exprs, int nexprs, double violscore, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static int SCIPaddExprsViolScoreNonlinear(MemorySegment scip, MemorySegment exprs, int nexprs, double violscore, MemorySegment sol, MemorySegment success) {
        var mh$ = SCIPaddExprsViolScoreNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddExprsViolScoreNonlinear", scip, exprs, nexprs, violscore, sol, success);
            }
            return (int)mh$.invokeExact(scip, exprs, nexprs, violscore, sol, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprViolScoreNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprViolScoreNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetExprViolScoreNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprViolScoreNonlinear$descriptor() {
        return SCIPgetExprViolScoreNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetExprViolScoreNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetExprViolScoreNonlinear$handle() {
        return SCIPgetExprViolScoreNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetExprViolScoreNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetExprViolScoreNonlinear$address() {
        return SCIPgetExprViolScoreNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetExprViolScoreNonlinear(SCIP_EXPR *expr)
     * }
     */
    public static double SCIPgetExprViolScoreNonlinear(MemorySegment expr) {
        var mh$ = SCIPgetExprViolScoreNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprViolScoreNonlinear", expr);
            }
            return (double)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprPartialDiffNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprPartialDiffNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetExprPartialDiffNonlinear$descriptor() {
        return SCIPgetExprPartialDiffNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetExprPartialDiffNonlinear$handle() {
        return SCIPgetExprPartialDiffNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetExprPartialDiffNonlinear$address() {
        return SCIPgetExprPartialDiffNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetExprPartialDiffNonlinear(MemorySegment scip, MemorySegment expr, MemorySegment var_) {
        var mh$ = SCIPgetExprPartialDiffNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprPartialDiffNonlinear", scip, expr, var_);
            }
            return (double)mh$.invokeExact(scip, expr, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprPartialDiffGradientDirNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprPartialDiffGradientDirNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffGradientDirNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetExprPartialDiffGradientDirNonlinear$descriptor() {
        return SCIPgetExprPartialDiffGradientDirNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffGradientDirNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetExprPartialDiffGradientDirNonlinear$handle() {
        return SCIPgetExprPartialDiffGradientDirNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffGradientDirNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetExprPartialDiffGradientDirNonlinear$address() {
        return SCIPgetExprPartialDiffGradientDirNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetExprPartialDiffGradientDirNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetExprPartialDiffGradientDirNonlinear(MemorySegment scip, MemorySegment expr, MemorySegment var_) {
        var mh$ = SCIPgetExprPartialDiffGradientDirNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprPartialDiffGradientDirNonlinear", scip, expr, var_);
            }
            return (double)mh$.invokeExact(scip, expr, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExprQuadraticAuxNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExprQuadraticAuxNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadraticAuxNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPevalExprQuadraticAuxNonlinear$descriptor() {
        return SCIPevalExprQuadraticAuxNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadraticAuxNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPevalExprQuadraticAuxNonlinear$handle() {
        return SCIPevalExprQuadraticAuxNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadraticAuxNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPevalExprQuadraticAuxNonlinear$address() {
        return SCIPevalExprQuadraticAuxNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPevalExprQuadraticAuxNonlinear(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static double SCIPevalExprQuadraticAuxNonlinear(MemorySegment scip, MemorySegment expr, MemorySegment sol) {
        var mh$ = SCIPevalExprQuadraticAuxNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExprQuadraticAuxNonlinear", scip, expr, sol);
            }
            return (double)mh$.invokeExact(scip, expr, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrNonlinear(SCIP *scip, SCIP_NLHDLR **nlhdlr, const char *name, const char *desc, int detectpriority, int enfopriority, SCIP_RETCODE (*detect)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_CONS *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLREXPRDATA **), SCIP_RETCODE (*evalaux)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, double *, SCIP_SOL *), SCIP_NLHDLRDATA *nlhdlrdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrNonlinear$descriptor() {
        return SCIPincludeNlhdlrNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrNonlinear(SCIP *scip, SCIP_NLHDLR **nlhdlr, const char *name, const char *desc, int detectpriority, int enfopriority, SCIP_RETCODE (*detect)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_CONS *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLREXPRDATA **), SCIP_RETCODE (*evalaux)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, double *, SCIP_SOL *), SCIP_NLHDLRDATA *nlhdlrdata)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrNonlinear$handle() {
        return SCIPincludeNlhdlrNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrNonlinear(SCIP *scip, SCIP_NLHDLR **nlhdlr, const char *name, const char *desc, int detectpriority, int enfopriority, SCIP_RETCODE (*detect)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_CONS *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLREXPRDATA **), SCIP_RETCODE (*evalaux)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, double *, SCIP_SOL *), SCIP_NLHDLRDATA *nlhdlrdata)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrNonlinear$address() {
        return SCIPincludeNlhdlrNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrNonlinear(SCIP *scip, SCIP_NLHDLR **nlhdlr, const char *name, const char *desc, int detectpriority, int enfopriority, SCIP_RETCODE (*detect)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_CONS *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLR_METHOD *, SCIP_NLHDLREXPRDATA **), SCIP_RETCODE (*evalaux)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, double *, SCIP_SOL *), SCIP_NLHDLRDATA *nlhdlrdata)
     * }
     */
    public static int SCIPincludeNlhdlrNonlinear(MemorySegment scip, MemorySegment nlhdlr, MemorySegment name, MemorySegment desc, int detectpriority, int enfopriority, MemorySegment detect, MemorySegment evalaux, MemorySegment nlhdlrdata) {
        var mh$ = SCIPincludeNlhdlrNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrNonlinear", scip, nlhdlr, name, desc, detectpriority, enfopriority, detect, evalaux, nlhdlrdata);
            }
            return (int)mh$.invokeExact(scip, nlhdlr, name, desc, detectpriority, enfopriority, detect, evalaux, nlhdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNlhdlrsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNlhdlrsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetNNlhdlrsNonlinear$descriptor() {
        return SCIPgetNNlhdlrsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetNNlhdlrsNonlinear$handle() {
        return SCIPgetNNlhdlrsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetNNlhdlrsNonlinear$address() {
        return SCIPgetNNlhdlrsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPgetNNlhdlrsNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetNNlhdlrsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNlhdlrsNonlinear", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlhdlrsNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlhdlrsNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLHDLR **SCIPgetNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetNlhdlrsNonlinear$descriptor() {
        return SCIPgetNlhdlrsNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLHDLR **SCIPgetNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetNlhdlrsNonlinear$handle() {
        return SCIPgetNlhdlrsNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLHDLR **SCIPgetNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetNlhdlrsNonlinear$address() {
        return SCIPgetNlhdlrsNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLHDLR **SCIPgetNlhdlrsNonlinear(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetNlhdlrsNonlinear(MemorySegment conshdlr) {
        var mh$ = SCIPgetNlhdlrsNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlhdlrsNonlinear", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindNlhdlrNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindNlhdlrNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLHDLR *SCIPfindNlhdlrNonlinear(SCIP_CONSHDLR *conshdlr, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindNlhdlrNonlinear$descriptor() {
        return SCIPfindNlhdlrNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLHDLR *SCIPfindNlhdlrNonlinear(SCIP_CONSHDLR *conshdlr, const char *name)
     * }
     */
    public static MethodHandle SCIPfindNlhdlrNonlinear$handle() {
        return SCIPfindNlhdlrNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLHDLR *SCIPfindNlhdlrNonlinear(SCIP_CONSHDLR *conshdlr, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNlhdlrNonlinear$address() {
        return SCIPfindNlhdlrNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLHDLR *SCIPfindNlhdlrNonlinear(SCIP_CONSHDLR *conshdlr, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNlhdlrNonlinear(MemorySegment conshdlr, MemorySegment name) {
        var mh$ = SCIPfindNlhdlrNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindNlhdlrNonlinear", conshdlr, name);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlhdlrExprDataNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlhdlrExprDataNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA *SCIPgetNlhdlrExprDataNonlinear(SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetNlhdlrExprDataNonlinear$descriptor() {
        return SCIPgetNlhdlrExprDataNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA *SCIPgetNlhdlrExprDataNonlinear(SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetNlhdlrExprDataNonlinear$handle() {
        return SCIPgetNlhdlrExprDataNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA *SCIPgetNlhdlrExprDataNonlinear(SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetNlhdlrExprDataNonlinear$address() {
        return SCIPgetNlhdlrExprDataNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA *SCIPgetNlhdlrExprDataNonlinear(SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetNlhdlrExprDataNonlinear(MemorySegment nlhdlr, MemorySegment expr) {
        var mh$ = SCIPgetNlhdlrExprDataNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlhdlrExprDataNonlinear", nlhdlr, expr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrOr$descriptor() {
        return SCIPincludeConshdlrOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrOr$handle() {
        return SCIPincludeConshdlrOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrOr$address() {
        return SCIPincludeConshdlrOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOr(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrOr(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrOr", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsOr$descriptor() {
        return SCIPcreateConsOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsOr$handle() {
        return SCIPcreateConsOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsOr$address() {
        return SCIPcreateConsOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsOr(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment resvar, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsOr", scip, cons, name, resvar, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, resvar, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicOr$descriptor() {
        return SCIPcreateConsBasicOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicOr$handle() {
        return SCIPcreateConsBasicOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicOr$address() {
        return SCIPcreateConsBasicOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOr(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *resvar, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicOr(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment resvar, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicOr", scip, cons, name, resvar, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, resvar, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsOr$descriptor() {
        return SCIPgetNVarsOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsOr$handle() {
        return SCIPgetNVarsOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsOr$address() {
        return SCIPgetNVarsOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsOr(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsOr", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsOr$descriptor() {
        return SCIPgetVarsOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsOr$handle() {
        return SCIPgetVarsOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsOr$address() {
        return SCIPgetVarsOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsOr(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsOr", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetResultantOr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetResultantOr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetResultantOr$descriptor() {
        return SCIPgetResultantOr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetResultantOr$handle() {
        return SCIPgetResultantOr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetResultantOr$address() {
        return SCIPgetResultantOr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetResultantOr(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetResultantOr(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetResultantOr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetResultantOr", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrOrbisack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrOrbisack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbisack(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrOrbisack$descriptor() {
        return SCIPincludeConshdlrOrbisack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbisack(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrOrbisack$handle() {
        return SCIPincludeConshdlrOrbisack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbisack(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrOrbisack$address() {
        return SCIPincludeConshdlrOrbisack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbisack(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrOrbisack(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrOrbisack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrOrbisack", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckSolutionOrbisack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckSolutionOrbisack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolutionOrbisack(SCIP *scip, SCIP_SOL *sol, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int printreason, unsigned int *feasible)
     * }
     */
    public static FunctionDescriptor SCIPcheckSolutionOrbisack$descriptor() {
        return SCIPcheckSolutionOrbisack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolutionOrbisack(SCIP *scip, SCIP_SOL *sol, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int printreason, unsigned int *feasible)
     * }
     */
    public static MethodHandle SCIPcheckSolutionOrbisack$handle() {
        return SCIPcheckSolutionOrbisack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolutionOrbisack(SCIP *scip, SCIP_SOL *sol, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int printreason, unsigned int *feasible)
     * }
     */
    public static MemorySegment SCIPcheckSolutionOrbisack$address() {
        return SCIPcheckSolutionOrbisack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolutionOrbisack(SCIP *scip, SCIP_SOL *sol, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int printreason, unsigned int *feasible)
     * }
     */
    public static int SCIPcheckSolutionOrbisack(MemorySegment scip, MemorySegment sol, MemorySegment vars1, MemorySegment vars2, int nrows, int printreason, MemorySegment feasible) {
        var mh$ = SCIPcheckSolutionOrbisack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckSolutionOrbisack", scip, sol, vars1, vars2, nrows, printreason, feasible);
            }
            return (int)mh$.invokeExact(scip, sol, vars1, vars2, nrows, printreason, feasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsOrbisack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsOrbisack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *const *vars1, SCIP_VAR *const *vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsOrbisack$descriptor() {
        return SCIPcreateConsOrbisack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *const *vars1, SCIP_VAR *const *vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsOrbisack$handle() {
        return SCIPcreateConsOrbisack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *const *vars1, SCIP_VAR *const *vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsOrbisack$address() {
        return SCIPcreateConsOrbisack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *const *vars1, SCIP_VAR *const *vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsOrbisack(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment vars1, MemorySegment vars2, int nrows, int ispporbisack, int isparttype, int ismodelcons, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsOrbisack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsOrbisack", scip, cons, name, vars1, vars2, nrows, ispporbisack, isparttype, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, vars1, vars2, nrows, ispporbisack, isparttype, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicOrbisack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicOrbisack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicOrbisack$descriptor() {
        return SCIPcreateConsBasicOrbisack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicOrbisack$handle() {
        return SCIPcreateConsBasicOrbisack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicOrbisack$address() {
        return SCIPcreateConsBasicOrbisack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbisack(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **vars1, SCIP_VAR **vars2, int nrows, unsigned int ispporbisack, unsigned int isparttype, unsigned int ismodelcons)
     * }
     */
    public static int SCIPcreateConsBasicOrbisack(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment vars1, MemorySegment vars2, int nrows, int ispporbisack, int isparttype, int ismodelcons) {
        var mh$ = SCIPcreateConsBasicOrbisack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicOrbisack", scip, cons, name, vars1, vars2, nrows, ispporbisack, isparttype, ismodelcons);
            }
            return (int)mh$.invokeExact(scip, cons, name, vars1, vars2, nrows, ispporbisack, isparttype, ismodelcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t SYM_SPEC
     * }
     */
    public static final OfInt SYM_SPEC = scip_h.C_INT;
    private static final int SYM_SYMTYPE_PERM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYM_Symtype.SYM_SYMTYPE_PERM = 0
     * }
     */
    public static int SYM_SYMTYPE_PERM() {
        return SYM_SYMTYPE_PERM;
    }
    private static final int SYM_SYMTYPE_SIGNPERM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYM_Symtype.SYM_SYMTYPE_SIGNPERM = 1
     * }
     */
    public static int SYM_SYMTYPE_SIGNPERM() {
        return SYM_SYMTYPE_SIGNPERM;
    }
    private static final int SYM_NODETYPE_OPERATOR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYM_Nodetype.SYM_NODETYPE_OPERATOR = 0
     * }
     */
    public static int SYM_NODETYPE_OPERATOR() {
        return SYM_NODETYPE_OPERATOR;
    }
    private static final int SYM_NODETYPE_VAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYM_Nodetype.SYM_NODETYPE_VAL = 1
     * }
     */
    public static int SYM_NODETYPE_VAL() {
        return SYM_NODETYPE_VAL;
    }
    private static final int SYM_NODETYPE_CONS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SYM_Nodetype.SYM_NODETYPE_CONS = 2
     * }
     */
    public static int SYM_NODETYPE_CONS() {
        return SYM_NODETYPE_CONS;
    }
    private static final int SYM_NODETYPE_VAR = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SYM_Nodetype.SYM_NODETYPE_VAR = 3
     * }
     */
    public static int SYM_NODETYPE_VAR() {
        return SYM_NODETYPE_VAR;
    }
    private static final int SYM_CONSOPTYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_UNKNOWN = 0
     * }
     */
    public static int SYM_CONSOPTYPE_UNKNOWN() {
        return SYM_CONSOPTYPE_UNKNOWN;
    }
    private static final int SYM_CONSOPTYPE_BDDISJ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_BDDISJ = 1
     * }
     */
    public static int SYM_CONSOPTYPE_BDDISJ() {
        return SYM_CONSOPTYPE_BDDISJ;
    }
    private static final int SYM_CONSOPTYPE_EQ = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_EQ = 2
     * }
     */
    public static int SYM_CONSOPTYPE_EQ() {
        return SYM_CONSOPTYPE_EQ;
    }
    private static final int SYM_CONSOPTYPE_SOS2_TUPLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_SOS2_TUPLE = 3
     * }
     */
    public static int SYM_CONSOPTYPE_SOS2_TUPLE() {
        return SYM_CONSOPTYPE_SOS2_TUPLE;
    }
    private static final int SYM_CONSOPTYPE_SUM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_SUM = 4
     * }
     */
    public static int SYM_CONSOPTYPE_SUM() {
        return SYM_CONSOPTYPE_SUM;
    }
    private static final int SYM_CONSOPTYPE_SLACK = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_SLACK = 5
     * }
     */
    public static int SYM_CONSOPTYPE_SLACK() {
        return SYM_CONSOPTYPE_SLACK;
    }
    private static final int SYM_CONSOPTYPE_COEF = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_COEF = 6
     * }
     */
    public static int SYM_CONSOPTYPE_COEF() {
        return SYM_CONSOPTYPE_COEF;
    }
    private static final int SYM_CONSOPTYPE_SQDIFF = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_SQDIFF = 7
     * }
     */
    public static int SYM_CONSOPTYPE_SQDIFF() {
        return SYM_CONSOPTYPE_SQDIFF;
    }
    private static final int SYM_CONSOPTYPE_CARD_TUPLE = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_CARD_TUPLE = 8
     * }
     */
    public static int SYM_CONSOPTYPE_CARD_TUPLE() {
        return SYM_CONSOPTYPE_CARD_TUPLE;
    }
    private static final int SYM_CONSOPTYPE_PB_AND = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_PB_AND = 9
     * }
     */
    public static int SYM_CONSOPTYPE_PB_AND() {
        return SYM_CONSOPTYPE_PB_AND;
    }
    private static final int SYM_CONSOPTYPE_PB_LINEAR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_PB_LINEAR = 10
     * }
     */
    public static int SYM_CONSOPTYPE_PB_LINEAR() {
        return SYM_CONSOPTYPE_PB_LINEAR;
    }
    private static final int SYM_CONSOPTYPE_PB_SOFT = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_PB_SOFT = 11
     * }
     */
    public static int SYM_CONSOPTYPE_PB_SOFT() {
        return SYM_CONSOPTYPE_PB_SOFT;
    }
    private static final int SYM_CONSOPTYPE_PB_OBJ = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_PB_OBJ = 12
     * }
     */
    public static int SYM_CONSOPTYPE_PB_OBJ() {
        return SYM_CONSOPTYPE_PB_OBJ;
    }
    private static final int SYM_CONSOPTYPE_LAST = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SYM_Consoptype.SYM_CONSOPTYPE_LAST = 13
     * }
     */
    public static int SYM_CONSOPTYPE_LAST() {
        return SYM_CONSOPTYPE_LAST;
    }
    /**
     * {@snippet lang=c :
     * typedef uint32_t SYM_HANDLETYPE
     * }
     */
    public static final OfInt SYM_HANDLETYPE = scip_h.C_INT;
    private static final int SCIP_LEADERRULE_FIRSTINORBIT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderRule.SCIP_LEADERRULE_FIRSTINORBIT = 0
     * }
     */
    public static int SCIP_LEADERRULE_FIRSTINORBIT() {
        return SCIP_LEADERRULE_FIRSTINORBIT;
    }
    private static final int SCIP_LEADERRULE_LASTINORBIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderRule.SCIP_LEADERRULE_LASTINORBIT = 1
     * }
     */
    public static int SCIP_LEADERRULE_LASTINORBIT() {
        return SCIP_LEADERRULE_LASTINORBIT;
    }
    private static final int SCIP_LEADERRULE_MAXCONFLICTSINORBIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderRule.SCIP_LEADERRULE_MAXCONFLICTSINORBIT = 2
     * }
     */
    public static int SCIP_LEADERRULE_MAXCONFLICTSINORBIT() {
        return SCIP_LEADERRULE_MAXCONFLICTSINORBIT;
    }
    private static final int SCIP_LEADERTIEBREAKRULE_MINORBIT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderTiebreakRule.SCIP_LEADERTIEBREAKRULE_MINORBIT = 0
     * }
     */
    public static int SCIP_LEADERTIEBREAKRULE_MINORBIT() {
        return SCIP_LEADERTIEBREAKRULE_MINORBIT;
    }
    private static final int SCIP_LEADERTIEBREAKRULE_MAXORBIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderTiebreakRule.SCIP_LEADERTIEBREAKRULE_MAXORBIT = 1
     * }
     */
    public static int SCIP_LEADERTIEBREAKRULE_MAXORBIT() {
        return SCIP_LEADERTIEBREAKRULE_MAXORBIT;
    }
    private static final int SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LeaderTiebreakRule.SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT = 2
     * }
     */
    public static int SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT() {
        return SCIP_LEADERTIEBREAKRULE_MAXCONFLICTSINORBIT;
    }
    private static final int SCIP_SSTTYPE_BINARY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SSTType.SCIP_SSTTYPE_BINARY = 1
     * }
     */
    public static int SCIP_SSTTYPE_BINARY() {
        return SCIP_SSTTYPE_BINARY;
    }
    private static final int SCIP_SSTTYPE_INTEGER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SSTType.SCIP_SSTTYPE_INTEGER = 2
     * }
     */
    public static int SCIP_SSTTYPE_INTEGER() {
        return SCIP_SSTTYPE_INTEGER;
    }
    private static final int SCIP_SSTTYPE_IMPLINT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SSTType.SCIP_SSTTYPE_IMPLINT = 4
     * }
     */
    public static int SCIP_SSTTYPE_IMPLINT() {
        return SCIP_SSTTYPE_IMPLINT;
    }
    private static final int SCIP_SSTTYPE_CONTINUOUS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SSTType.SCIP_SSTTYPE_CONTINUOUS = 8
     * }
     */
    public static int SCIP_SSTTYPE_CONTINUOUS() {
        return SCIP_SSTTYPE_CONTINUOUS;
    }
    private static final int SCIP_ORBITOPETYPE_FULL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_OrbitopeType.SCIP_ORBITOPETYPE_FULL = 0
     * }
     */
    public static int SCIP_ORBITOPETYPE_FULL() {
        return SCIP_ORBITOPETYPE_FULL;
    }
    private static final int SCIP_ORBITOPETYPE_PARTITIONING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_OrbitopeType.SCIP_ORBITOPETYPE_PARTITIONING = 1
     * }
     */
    public static int SCIP_ORBITOPETYPE_PARTITIONING() {
        return SCIP_ORBITOPETYPE_PARTITIONING;
    }
    private static final int SCIP_ORBITOPETYPE_PACKING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_OrbitopeType.SCIP_ORBITOPETYPE_PACKING = 2
     * }
     */
    public static int SCIP_ORBITOPETYPE_PACKING() {
        return SCIP_ORBITOPETYPE_PACKING;
    }

    private static class SCIPincludeConshdlrOrbitope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrOrbitope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbitope(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrOrbitope$descriptor() {
        return SCIPincludeConshdlrOrbitope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbitope(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrOrbitope$handle() {
        return SCIPincludeConshdlrOrbitope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbitope(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrOrbitope$address() {
        return SCIPincludeConshdlrOrbitope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrOrbitope(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrOrbitope(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrOrbitope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrOrbitope", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsOrbitope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsOrbitope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int mayinteract, unsigned int resolveprop, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsOrbitope$descriptor() {
        return SCIPcreateConsOrbitope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int mayinteract, unsigned int resolveprop, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsOrbitope$handle() {
        return SCIPcreateConsOrbitope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int mayinteract, unsigned int resolveprop, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsOrbitope$address() {
        return SCIPcreateConsOrbitope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int mayinteract, unsigned int resolveprop, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsOrbitope(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment vars, int orbitopetype, int nspcons, int nblocks, int usedynamicprop, int mayinteract, int resolveprop, int ismodelcons, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsOrbitope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsOrbitope", scip, cons, name, vars, orbitopetype, nspcons, nblocks, usedynamicprop, mayinteract, resolveprop, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, vars, orbitopetype, nspcons, nblocks, usedynamicprop, mayinteract, resolveprop, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicOrbitope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicOrbitope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int resolveprop, unsigned int ismodelcons, unsigned int mayinteract)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicOrbitope$descriptor() {
        return SCIPcreateConsBasicOrbitope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int resolveprop, unsigned int ismodelcons, unsigned int mayinteract)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicOrbitope$handle() {
        return SCIPcreateConsBasicOrbitope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int resolveprop, unsigned int ismodelcons, unsigned int mayinteract)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicOrbitope$address() {
        return SCIPcreateConsBasicOrbitope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicOrbitope(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR ***vars, SCIP_ORBITOPETYPE orbitopetype, int nspcons, int nblocks, unsigned int usedynamicprop, unsigned int resolveprop, unsigned int ismodelcons, unsigned int mayinteract)
     * }
     */
    public static int SCIPcreateConsBasicOrbitope(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment vars, int orbitopetype, int nspcons, int nblocks, int usedynamicprop, int resolveprop, int ismodelcons, int mayinteract) {
        var mh$ = SCIPcreateConsBasicOrbitope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicOrbitope", scip, cons, name, vars, orbitopetype, nspcons, nblocks, usedynamicprop, resolveprop, ismodelcons, mayinteract);
            }
            return (int)mh$.invokeExact(scip, cons, name, vars, orbitopetype, nspcons, nblocks, usedynamicprop, resolveprop, ismodelcons, mayinteract);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrPseudoboolean(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrPseudoboolean$descriptor() {
        return SCIPincludeConshdlrPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrPseudoboolean(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrPseudoboolean$handle() {
        return SCIPincludeConshdlrPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrPseudoboolean(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrPseudoboolean$address() {
        return SCIPincludeConshdlrPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrPseudoboolean(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrPseudoboolean(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrPseudoboolean", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_LINEARCONSTYPE_INVALIDCONS = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinearConsType.SCIP_LINEARCONSTYPE_INVALIDCONS = -1
     * }
     */
    public static int SCIP_LINEARCONSTYPE_INVALIDCONS() {
        return SCIP_LINEARCONSTYPE_INVALIDCONS;
    }
    private static final int SCIP_LINEARCONSTYPE_LINEAR = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinearConsType.SCIP_LINEARCONSTYPE_LINEAR = 0
     * }
     */
    public static int SCIP_LINEARCONSTYPE_LINEAR() {
        return SCIP_LINEARCONSTYPE_LINEAR;
    }
    private static final int SCIP_LINEARCONSTYPE_LOGICOR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinearConsType.SCIP_LINEARCONSTYPE_LOGICOR = 1
     * }
     */
    public static int SCIP_LINEARCONSTYPE_LOGICOR() {
        return SCIP_LINEARCONSTYPE_LOGICOR;
    }
    private static final int SCIP_LINEARCONSTYPE_KNAPSACK = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinearConsType.SCIP_LINEARCONSTYPE_KNAPSACK = 2
     * }
     */
    public static int SCIP_LINEARCONSTYPE_KNAPSACK() {
        return SCIP_LINEARCONSTYPE_KNAPSACK;
    }
    private static final int SCIP_LINEARCONSTYPE_SETPPC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SCIP_LinearConsType.SCIP_LINEARCONSTYPE_SETPPC = 3
     * }
     */
    public static int SCIP_LINEARCONSTYPE_SETPPC() {
        return SCIP_LINEARCONSTYPE_SETPPC;
    }

    private static class SCIPcreateConsPseudobooleanWithConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsPseudobooleanWithConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudobooleanWithConss(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONS *lincons, SCIP_LINEARCONSTYPE linconstype, SCIP_CONS **andconss, double *andcoefs, int nandconss, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsPseudobooleanWithConss$descriptor() {
        return SCIPcreateConsPseudobooleanWithConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudobooleanWithConss(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONS *lincons, SCIP_LINEARCONSTYPE linconstype, SCIP_CONS **andconss, double *andcoefs, int nandconss, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsPseudobooleanWithConss$handle() {
        return SCIPcreateConsPseudobooleanWithConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudobooleanWithConss(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONS *lincons, SCIP_LINEARCONSTYPE linconstype, SCIP_CONS **andconss, double *andcoefs, int nandconss, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsPseudobooleanWithConss$address() {
        return SCIPcreateConsPseudobooleanWithConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudobooleanWithConss(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_CONS *lincons, SCIP_LINEARCONSTYPE linconstype, SCIP_CONS **andconss, double *andcoefs, int nandconss, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsPseudobooleanWithConss(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment lincons, int linconstype, MemorySegment andconss, MemorySegment andcoefs, int nandconss, MemorySegment indvar, double weight, int issoftcons, MemorySegment intvar, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsPseudobooleanWithConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsPseudobooleanWithConss", scip, cons, name, lincons, linconstype, andconss, andcoefs, nandconss, indvar, weight, issoftcons, intvar, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, lincons, linconstype, andconss, andcoefs, nandconss, indvar, weight, issoftcons, intvar, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsPseudoboolean$descriptor() {
        return SCIPcreateConsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsPseudoboolean$handle() {
        return SCIPcreateConsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsPseudoboolean$address() {
        return SCIPcreateConsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment linvars, int nlinvars, MemorySegment linvals, MemorySegment terms, int nterms, MemorySegment ntermvars, MemorySegment termvals, MemorySegment indvar, double weight, int issoftcons, MemorySegment intvar, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsPseudoboolean", scip, cons, name, linvars, nlinvars, linvals, terms, nterms, ntermvars, termvals, indvar, weight, issoftcons, intvar, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, linvars, nlinvars, linvals, terms, nterms, ntermvars, termvals, indvar, weight, issoftcons, intvar, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicPseudoboolean$descriptor() {
        return SCIPcreateConsBasicPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicPseudoboolean$handle() {
        return SCIPcreateConsBasicPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicPseudoboolean$address() {
        return SCIPcreateConsBasicPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicPseudoboolean(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR **linvars, int nlinvars, double *linvals, SCIP_VAR ***terms, int nterms, int *ntermvars, double *termvals, SCIP_VAR *indvar, double weight, unsigned int issoftcons, SCIP_VAR *intvar, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment linvars, int nlinvars, MemorySegment linvals, MemorySegment terms, int nterms, MemorySegment ntermvars, MemorySegment termvals, MemorySegment indvar, double weight, int issoftcons, MemorySegment intvar, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicPseudoboolean", scip, cons, name, linvars, nlinvars, linvals, terms, nterms, ntermvars, termvals, indvar, weight, issoftcons, intvar, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, linvars, nlinvars, linvals, terms, nterms, ntermvars, termvals, indvar, weight, issoftcons, intvar, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCoefPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCoefPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR *const var, const double val)
     * }
     */
    public static FunctionDescriptor SCIPaddCoefPseudoboolean$descriptor() {
        return SCIPaddCoefPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR *const var, const double val)
     * }
     */
    public static MethodHandle SCIPaddCoefPseudoboolean$handle() {
        return SCIPaddCoefPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR *const var, const double val)
     * }
     */
    public static MemorySegment SCIPaddCoefPseudoboolean$address() {
        return SCIPaddCoefPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR *const var, const double val)
     * }
     */
    public static int SCIPaddCoefPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment var_, double val) {
        var mh$ = SCIPaddCoefPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCoefPseudoboolean", scip, cons, var_, val);
            }
            return (int)mh$.invokeExact(scip, cons, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddTermPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddTermPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTermPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const vars, const int nvars, const double val)
     * }
     */
    public static FunctionDescriptor SCIPaddTermPseudoboolean$descriptor() {
        return SCIPaddTermPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTermPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const vars, const int nvars, const double val)
     * }
     */
    public static MethodHandle SCIPaddTermPseudoboolean$handle() {
        return SCIPaddTermPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTermPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const vars, const int nvars, const double val)
     * }
     */
    public static MemorySegment SCIPaddTermPseudoboolean$address() {
        return SCIPaddTermPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddTermPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const vars, const int nvars, const double val)
     * }
     */
    public static int SCIPaddTermPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment vars, int nvars, double val) {
        var mh$ = SCIPaddTermPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddTermPseudoboolean", scip, cons, vars, nvars, val);
            }
            return (int)mh$.invokeExact(scip, cons, vars, nvars, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIndVarPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIndVarPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIndVarPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetIndVarPseudoboolean$descriptor() {
        return SCIPgetIndVarPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIndVarPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetIndVarPseudoboolean$handle() {
        return SCIPgetIndVarPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIndVarPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetIndVarPseudoboolean$address() {
        return SCIPgetIndVarPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIndVarPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetIndVarPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetIndVarPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIndVarPseudoboolean", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinearConsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinearConsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLinearConsPseudoboolean$descriptor() {
        return SCIPgetLinearConsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetLinearConsPseudoboolean$handle() {
        return SCIPgetLinearConsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetLinearConsPseudoboolean$address() {
        return SCIPgetLinearConsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetLinearConsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetLinearConsPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLinearConsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinearConsPseudoboolean", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinearConsTypePseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinearConsTypePseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_LINEARCONSTYPE SCIPgetLinearConsTypePseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLinearConsTypePseudoboolean$descriptor() {
        return SCIPgetLinearConsTypePseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_LINEARCONSTYPE SCIPgetLinearConsTypePseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetLinearConsTypePseudoboolean$handle() {
        return SCIPgetLinearConsTypePseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_LINEARCONSTYPE SCIPgetLinearConsTypePseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetLinearConsTypePseudoboolean$address() {
        return SCIPgetLinearConsTypePseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_LINEARCONSTYPE SCIPgetLinearConsTypePseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static int SCIPgetLinearConsTypePseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLinearConsTypePseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinearConsTypePseudoboolean", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLinVarsWithoutAndPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLinVarsWithoutAndPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNLinVarsWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNLinVarsWithoutAndPseudoboolean$descriptor() {
        return SCIPgetNLinVarsWithoutAndPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNLinVarsWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetNLinVarsWithoutAndPseudoboolean$handle() {
        return SCIPgetNLinVarsWithoutAndPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNLinVarsWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetNLinVarsWithoutAndPseudoboolean$address() {
        return SCIPgetNLinVarsWithoutAndPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNLinVarsWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static int SCIPgetNLinVarsWithoutAndPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNLinVarsWithoutAndPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLinVarsWithoutAndPseudoboolean", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLinDatasWithoutAndPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLinDatasWithoutAndPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLinDatasWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const linvars, double *const lincoefs, int *const nlinvars)
     * }
     */
    public static FunctionDescriptor SCIPgetLinDatasWithoutAndPseudoboolean$descriptor() {
        return SCIPgetLinDatasWithoutAndPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLinDatasWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const linvars, double *const lincoefs, int *const nlinvars)
     * }
     */
    public static MethodHandle SCIPgetLinDatasWithoutAndPseudoboolean$handle() {
        return SCIPgetLinDatasWithoutAndPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLinDatasWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const linvars, double *const lincoefs, int *const nlinvars)
     * }
     */
    public static MemorySegment SCIPgetLinDatasWithoutAndPseudoboolean$address() {
        return SCIPgetLinDatasWithoutAndPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLinDatasWithoutAndPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_VAR **const linvars, double *const lincoefs, int *const nlinvars)
     * }
     */
    public static int SCIPgetLinDatasWithoutAndPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment linvars, MemorySegment lincoefs, MemorySegment nlinvars) {
        var mh$ = SCIPgetLinDatasWithoutAndPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLinDatasWithoutAndPseudoboolean", scip, cons, linvars, lincoefs, nlinvars);
            }
            return (int)mh$.invokeExact(scip, cons, linvars, lincoefs, nlinvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAndDatasPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAndDatasPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAndDatasPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_CONS **const andconss, double *const andcoefs, int *const nandconss)
     * }
     */
    public static FunctionDescriptor SCIPgetAndDatasPseudoboolean$descriptor() {
        return SCIPgetAndDatasPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAndDatasPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_CONS **const andconss, double *const andcoefs, int *const nandconss)
     * }
     */
    public static MethodHandle SCIPgetAndDatasPseudoboolean$handle() {
        return SCIPgetAndDatasPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAndDatasPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_CONS **const andconss, double *const andcoefs, int *const nandconss)
     * }
     */
    public static MemorySegment SCIPgetAndDatasPseudoboolean$address() {
        return SCIPgetAndDatasPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetAndDatasPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, SCIP_CONS **const andconss, double *const andcoefs, int *const nandconss)
     * }
     */
    public static int SCIPgetAndDatasPseudoboolean(MemorySegment scip, MemorySegment cons, MemorySegment andconss, MemorySegment andcoefs, MemorySegment nandconss) {
        var mh$ = SCIPgetAndDatasPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAndDatasPseudoboolean", scip, cons, andconss, andcoefs, nandconss);
            }
            return (int)mh$.invokeExact(scip, cons, andconss, andcoefs, nandconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNAndsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNAndsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNAndsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNAndsPseudoboolean$descriptor() {
        return SCIPgetNAndsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNAndsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetNAndsPseudoboolean$handle() {
        return SCIPgetNAndsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNAndsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetNAndsPseudoboolean$address() {
        return SCIPgetNAndsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNAndsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static int SCIPgetNAndsPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNAndsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNAndsPseudoboolean", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgLhsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgLhsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double lhs)
     * }
     */
    public static FunctionDescriptor SCIPchgLhsPseudoboolean$descriptor() {
        return SCIPchgLhsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double lhs)
     * }
     */
    public static MethodHandle SCIPchgLhsPseudoboolean$handle() {
        return SCIPchgLhsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double lhs)
     * }
     */
    public static MemorySegment SCIPchgLhsPseudoboolean$address() {
        return SCIPchgLhsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double lhs)
     * }
     */
    public static int SCIPchgLhsPseudoboolean(MemorySegment scip, MemorySegment cons, double lhs) {
        var mh$ = SCIPchgLhsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgLhsPseudoboolean", scip, cons, lhs);
            }
            return (int)mh$.invokeExact(scip, cons, lhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRhsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRhsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double rhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRhsPseudoboolean$descriptor() {
        return SCIPchgRhsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double rhs)
     * }
     */
    public static MethodHandle SCIPchgRhsPseudoboolean$handle() {
        return SCIPchgRhsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double rhs)
     * }
     */
    public static MemorySegment SCIPchgRhsPseudoboolean$address() {
        return SCIPchgRhsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons, const double rhs)
     * }
     */
    public static int SCIPchgRhsPseudoboolean(MemorySegment scip, MemorySegment cons, double rhs) {
        var mh$ = SCIPchgRhsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRhsPseudoboolean", scip, cons, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLhsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLhsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLhsPseudoboolean$descriptor() {
        return SCIPgetLhsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetLhsPseudoboolean$handle() {
        return SCIPgetLhsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetLhsPseudoboolean$address() {
        return SCIPgetLhsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static double SCIPgetLhsPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLhsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLhsPseudoboolean", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRhsPseudoboolean {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRhsPseudoboolean");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRhsPseudoboolean$descriptor() {
        return SCIPgetRhsPseudoboolean.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MethodHandle SCIPgetRhsPseudoboolean$handle() {
        return SCIPgetRhsPseudoboolean.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static MemorySegment SCIPgetRhsPseudoboolean$address() {
        return SCIPgetRhsPseudoboolean.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRhsPseudoboolean(SCIP *const scip, SCIP_CONS *const cons)
     * }
     */
    public static double SCIPgetRhsPseudoboolean(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRhsPseudoboolean.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRhsPseudoboolean", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSetppc(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrSetppc$descriptor() {
        return SCIPincludeConshdlrSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSetppc(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrSetppc$handle() {
        return SCIPincludeConshdlrSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSetppc(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrSetppc$address() {
        return SCIPincludeConshdlrSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSetppc(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrSetppc(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrSetppc", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SCIP_SETPPCTYPE_PARTITIONING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SetppcType.SCIP_SETPPCTYPE_PARTITIONING = 0
     * }
     */
    public static int SCIP_SETPPCTYPE_PARTITIONING() {
        return SCIP_SETPPCTYPE_PARTITIONING;
    }
    private static final int SCIP_SETPPCTYPE_PACKING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SetppcType.SCIP_SETPPCTYPE_PACKING = 1
     * }
     */
    public static int SCIP_SETPPCTYPE_PACKING() {
        return SCIP_SETPPCTYPE_PACKING;
    }
    private static final int SCIP_SETPPCTYPE_COVERING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SCIP_SetppcType.SCIP_SETPPCTYPE_COVERING = 2
     * }
     */
    public static int SCIP_SETPPCTYPE_COVERING() {
        return SCIP_SETPPCTYPE_COVERING;
    }

    private static class SCIPcreateConsSetpart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSetpart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSetpart$descriptor() {
        return SCIPcreateConsSetpart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSetpart$handle() {
        return SCIPcreateConsSetpart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSetpart$address() {
        return SCIPcreateConsSetpart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSetpart(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSetpart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSetpart", scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSetpart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSetpart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSetpart$descriptor() {
        return SCIPcreateConsBasicSetpart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSetpart$handle() {
        return SCIPcreateConsBasicSetpart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSetpart$address() {
        return SCIPcreateConsBasicSetpart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpart(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicSetpart(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicSetpart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSetpart", scip, cons, name, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSetpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSetpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSetpack$descriptor() {
        return SCIPcreateConsSetpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSetpack$handle() {
        return SCIPcreateConsSetpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSetpack$address() {
        return SCIPcreateConsSetpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSetpack(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSetpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSetpack", scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSetpack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSetpack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSetpack$descriptor() {
        return SCIPcreateConsBasicSetpack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSetpack$handle() {
        return SCIPcreateConsBasicSetpack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSetpack$address() {
        return SCIPcreateConsBasicSetpack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetpack(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicSetpack(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicSetpack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSetpack", scip, cons, name, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSetcover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSetcover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSetcover$descriptor() {
        return SCIPcreateConsSetcover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSetcover$handle() {
        return SCIPcreateConsSetcover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSetcover$address() {
        return SCIPcreateConsSetcover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSetcover(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSetcover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSetcover", scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSetcover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSetcover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSetcover$descriptor() {
        return SCIPcreateConsBasicSetcover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSetcover$handle() {
        return SCIPcreateConsBasicSetcover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSetcover$address() {
        return SCIPcreateConsBasicSetcover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSetcover(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicSetcover(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicSetcover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSetcover", scip, cons, name, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCoefSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCoefSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefSetppc(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPaddCoefSetppc$descriptor() {
        return SCIPaddCoefSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefSetppc(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPaddCoefSetppc$handle() {
        return SCIPaddCoefSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefSetppc(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPaddCoefSetppc$address() {
        return SCIPaddCoefSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCoefSetppc(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static int SCIPaddCoefSetppc(MemorySegment scip, MemorySegment cons, MemorySegment var_) {
        var mh$ = SCIPaddCoefSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCoefSetppc", scip, cons, var_);
            }
            return (int)mh$.invokeExact(scip, cons, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsSetppc$descriptor() {
        return SCIPgetNVarsSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsSetppc$handle() {
        return SCIPgetNVarsSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsSetppc$address() {
        return SCIPgetNVarsSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsSetppc", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsSetppc$descriptor() {
        return SCIPgetVarsSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsSetppc$handle() {
        return SCIPgetVarsSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSetppc$address() {
        return SCIPgetVarsSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsSetppc", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTypeSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTypeSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SETPPCTYPE SCIPgetTypeSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetTypeSetppc$descriptor() {
        return SCIPgetTypeSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SETPPCTYPE SCIPgetTypeSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetTypeSetppc$handle() {
        return SCIPgetTypeSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SETPPCTYPE SCIPgetTypeSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetTypeSetppc$address() {
        return SCIPgetTypeSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SETPPCTYPE SCIPgetTypeSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetTypeSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetTypeSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTypeSetppc", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualsolSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualsolSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualsolSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualsolSetppc$descriptor() {
        return SCIPgetDualsolSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualsolSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualsolSetppc$handle() {
        return SCIPgetDualsolSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualsolSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualsolSetppc$address() {
        return SCIPgetDualsolSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualsolSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualsolSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualsolSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualsolSetppc", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualfarkasSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualfarkasSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualfarkasSetppc$descriptor() {
        return SCIPgetDualfarkasSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualfarkasSetppc$handle() {
        return SCIPgetDualfarkasSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualfarkasSetppc$address() {
        return SCIPgetDualfarkasSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualfarkasSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualfarkasSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualfarkasSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualfarkasSetppc", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRowSetppc$descriptor() {
        return SCIPgetRowSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRowSetppc$handle() {
        return SCIPgetRowSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowSetppc$address() {
        return SCIPgetRowSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRowSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowSetppc", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNFixedonesSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNFixedonesSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNFixedonesSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNFixedonesSetppc$descriptor() {
        return SCIPgetNFixedonesSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNFixedonesSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNFixedonesSetppc$handle() {
        return SCIPgetNFixedonesSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNFixedonesSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNFixedonesSetppc$address() {
        return SCIPgetNFixedonesSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNFixedonesSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNFixedonesSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNFixedonesSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNFixedonesSetppc", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNFixedzerosSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNFixedzerosSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNFixedzerosSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNFixedzerosSetppc$descriptor() {
        return SCIPgetNFixedzerosSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNFixedzerosSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNFixedzerosSetppc$handle() {
        return SCIPgetNFixedzerosSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNFixedzerosSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNFixedzerosSetppc$address() {
        return SCIPgetNFixedzerosSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNFixedzerosSetppc(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNFixedzerosSetppc(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNFixedzerosSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNFixedzerosSetppc", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupConssSetppc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupConssSetppc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssSetppc(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgcoefs, int *nfixedvars)
     * }
     */
    public static FunctionDescriptor SCIPcleanupConssSetppc$descriptor() {
        return SCIPcleanupConssSetppc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssSetppc(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgcoefs, int *nfixedvars)
     * }
     */
    public static MethodHandle SCIPcleanupConssSetppc$handle() {
        return SCIPcleanupConssSetppc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssSetppc(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgcoefs, int *nfixedvars)
     * }
     */
    public static MemorySegment SCIPcleanupConssSetppc$address() {
        return SCIPcleanupConssSetppc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssSetppc(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgcoefs, int *nfixedvars)
     * }
     */
    public static int SCIPcleanupConssSetppc(MemorySegment scip, int onlychecked, MemorySegment infeasible, MemorySegment naddconss, MemorySegment ndelconss, MemorySegment nchgcoefs, MemorySegment nfixedvars) {
        var mh$ = SCIPcleanupConssSetppc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupConssSetppc", scip, onlychecked, infeasible, naddconss, ndelconss, nchgcoefs, nfixedvars);
            }
            return (int)mh$.invokeExact(scip, onlychecked, infeasible, naddconss, ndelconss, nchgcoefs, nfixedvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS1(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrSOS1$descriptor() {
        return SCIPincludeConshdlrSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS1(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrSOS1$handle() {
        return SCIPincludeConshdlrSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS1(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrSOS1$address() {
        return SCIPincludeConshdlrSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS1(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrSOS1(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrSOS1", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSOS1$descriptor() {
        return SCIPcreateConsSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSOS1$handle() {
        return SCIPcreateConsSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSOS1$address() {
        return SCIPcreateConsSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSOS1(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSOS1", scip, cons, name, nvars, vars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSOS1$descriptor() {
        return SCIPcreateConsBasicSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSOS1$handle() {
        return SCIPcreateConsBasicSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSOS1$address() {
        return SCIPcreateConsBasicSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS1(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static int SCIPcreateConsBasicSOS1(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights) {
        var mh$ = SCIPcreateConsBasicSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSOS1", scip, cons, name, nvars, vars, weights);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static FunctionDescriptor SCIPaddVarSOS1$descriptor() {
        return SCIPaddVarSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static MethodHandle SCIPaddVarSOS1$handle() {
        return SCIPaddVarSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static MemorySegment SCIPaddVarSOS1$address() {
        return SCIPaddVarSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static int SCIPaddVarSOS1(MemorySegment scip, MemorySegment cons, MemorySegment var_, double weight) {
        var mh$ = SCIPaddVarSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarSOS1", scip, cons, var_, weight);
            }
            return (int)mh$.invokeExact(scip, cons, var_, weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPappendVarSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPappendVarSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPappendVarSOS1$descriptor() {
        return SCIPappendVarSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPappendVarSOS1$handle() {
        return SCIPappendVarSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPappendVarSOS1$address() {
        return SCIPappendVarSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS1(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static int SCIPappendVarSOS1(MemorySegment scip, MemorySegment cons, MemorySegment var_) {
        var mh$ = SCIPappendVarSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPappendVarSOS1", scip, cons, var_);
            }
            return (int)mh$.invokeExact(scip, cons, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsSOS1$descriptor() {
        return SCIPgetNVarsSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsSOS1$handle() {
        return SCIPgetNVarsSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsSOS1$address() {
        return SCIPgetNVarsSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsSOS1(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsSOS1", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsSOS1$descriptor() {
        return SCIPgetVarsSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsSOS1$handle() {
        return SCIPgetVarsSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSOS1$address() {
        return SCIPgetVarsSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSOS1(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsSOS1", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetWeightsSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetWeightsSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetWeightsSOS1$descriptor() {
        return SCIPgetWeightsSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetWeightsSOS1$handle() {
        return SCIPgetWeightsSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsSOS1$address() {
        return SCIPgetWeightsSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS1(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsSOS1(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetWeightsSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetWeightsSOS1", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConflictgraphSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConflictgraphSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_DIGRAPH *SCIPgetConflictgraphSOS1(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetConflictgraphSOS1$descriptor() {
        return SCIPgetConflictgraphSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_DIGRAPH *SCIPgetConflictgraphSOS1(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetConflictgraphSOS1$handle() {
        return SCIPgetConflictgraphSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_DIGRAPH *SCIPgetConflictgraphSOS1(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetConflictgraphSOS1$address() {
        return SCIPgetConflictgraphSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_DIGRAPH *SCIPgetConflictgraphSOS1(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetConflictgraphSOS1(MemorySegment conshdlr) {
        var mh$ = SCIPgetConflictgraphSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConflictgraphSOS1", conshdlr);
            }
            return (MemorySegment)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSOS1Vars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSOS1Vars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNSOS1Vars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetNSOS1Vars$descriptor() {
        return SCIPgetNSOS1Vars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNSOS1Vars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MethodHandle SCIPgetNSOS1Vars$handle() {
        return SCIPgetNSOS1Vars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNSOS1Vars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static MemorySegment SCIPgetNSOS1Vars$address() {
        return SCIPgetNSOS1Vars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNSOS1Vars(SCIP_CONSHDLR *conshdlr)
     * }
     */
    public static int SCIPgetNSOS1Vars(MemorySegment conshdlr) {
        var mh$ = SCIPgetNSOS1Vars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSOS1Vars", conshdlr);
            }
            return (int)mh$.invokeExact(conshdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarIsSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarIsSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarIsSOS1$descriptor() {
        return SCIPvarIsSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarIsSOS1$handle() {
        return SCIPvarIsSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPvarIsSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarIsSOS1$address() {
        return SCIPvarIsSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPvarIsSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static int SCIPvarIsSOS1(MemorySegment conshdlr, MemorySegment var_) {
        var mh$ = SCIPvarIsSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarIsSOS1", conshdlr, var_);
            }
            return (int)mh$.invokeExact(conshdlr, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvarGetNodeSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvarGetNodeSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPvarGetNodeSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPvarGetNodeSOS1$descriptor() {
        return SCIPvarGetNodeSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPvarGetNodeSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPvarGetNodeSOS1$handle() {
        return SCIPvarGetNodeSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPvarGetNodeSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPvarGetNodeSOS1$address() {
        return SCIPvarGetNodeSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPvarGetNodeSOS1(SCIP_CONSHDLR *conshdlr, SCIP_VAR *var)
     * }
     */
    public static int SCIPvarGetNodeSOS1(MemorySegment conshdlr, MemorySegment var_) {
        var mh$ = SCIPvarGetNodeSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvarGetNodeSOS1", conshdlr, var_);
            }
            return (int)mh$.invokeExact(conshdlr, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnodeGetVarSOS1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnodeGetVarSOS1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPnodeGetVarSOS1(SCIP_DIGRAPH *conflictgraph, int node)
     * }
     */
    public static FunctionDescriptor SCIPnodeGetVarSOS1$descriptor() {
        return SCIPnodeGetVarSOS1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPnodeGetVarSOS1(SCIP_DIGRAPH *conflictgraph, int node)
     * }
     */
    public static MethodHandle SCIPnodeGetVarSOS1$handle() {
        return SCIPnodeGetVarSOS1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPnodeGetVarSOS1(SCIP_DIGRAPH *conflictgraph, int node)
     * }
     */
    public static MemorySegment SCIPnodeGetVarSOS1$address() {
        return SCIPnodeGetVarSOS1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPnodeGetVarSOS1(SCIP_DIGRAPH *conflictgraph, int node)
     * }
     */
    public static MemorySegment SCIPnodeGetVarSOS1(MemorySegment conflictgraph, int node) {
        var mh$ = SCIPnodeGetVarSOS1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnodeGetVarSOS1", conflictgraph, node);
            }
            return (MemorySegment)mh$.invokeExact(conflictgraph, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmakeSOS1sFeasible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmakeSOS1sFeasible");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeSOS1sFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPmakeSOS1sFeasible$descriptor() {
        return SCIPmakeSOS1sFeasible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeSOS1sFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPmakeSOS1sFeasible$handle() {
        return SCIPmakeSOS1sFeasible.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeSOS1sFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPmakeSOS1sFeasible$address() {
        return SCIPmakeSOS1sFeasible.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeSOS1sFeasible(SCIP *scip, SCIP_CONSHDLR *conshdlr, SCIP_SOL *sol, unsigned int *changed, unsigned int *success)
     * }
     */
    public static int SCIPmakeSOS1sFeasible(MemorySegment scip, MemorySegment conshdlr, MemorySegment sol, MemorySegment changed, MemorySegment success) {
        var mh$ = SCIPmakeSOS1sFeasible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmakeSOS1sFeasible", scip, conshdlr, sol, changed, success);
            }
            return (int)mh$.invokeExact(scip, conshdlr, sol, changed, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS2(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrSOS2$descriptor() {
        return SCIPincludeConshdlrSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS2(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrSOS2$handle() {
        return SCIPincludeConshdlrSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS2(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrSOS2$address() {
        return SCIPincludeConshdlrSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSOS2(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrSOS2(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrSOS2", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSOS2$descriptor() {
        return SCIPcreateConsSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSOS2$handle() {
        return SCIPcreateConsSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSOS2$address() {
        return SCIPcreateConsSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSOS2(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSOS2", scip, cons, name, nvars, vars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSOS2$descriptor() {
        return SCIPcreateConsBasicSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSOS2$handle() {
        return SCIPcreateConsBasicSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSOS2$address() {
        return SCIPcreateConsBasicSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSOS2(SCIP *scip, SCIP_CONS **cons, const char *name, int nvars, SCIP_VAR **vars, double *weights)
     * }
     */
    public static int SCIPcreateConsBasicSOS2(MemorySegment scip, MemorySegment cons, MemorySegment name, int nvars, MemorySegment vars, MemorySegment weights) {
        var mh$ = SCIPcreateConsBasicSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSOS2", scip, cons, name, nvars, vars, weights);
            }
            return (int)mh$.invokeExact(scip, cons, name, nvars, vars, weights);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static FunctionDescriptor SCIPaddVarSOS2$descriptor() {
        return SCIPaddVarSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static MethodHandle SCIPaddVarSOS2$handle() {
        return SCIPaddVarSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static MemorySegment SCIPaddVarSOS2$address() {
        return SCIPaddVarSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var, double weight)
     * }
     */
    public static int SCIPaddVarSOS2(MemorySegment scip, MemorySegment cons, MemorySegment var_, double weight) {
        var mh$ = SCIPaddVarSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarSOS2", scip, cons, var_, weight);
            }
            return (int)mh$.invokeExact(scip, cons, var_, weight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPappendVarSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPappendVarSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPappendVarSOS2$descriptor() {
        return SCIPappendVarSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPappendVarSOS2$handle() {
        return SCIPappendVarSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPappendVarSOS2$address() {
        return SCIPappendVarSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendVarSOS2(SCIP *scip, SCIP_CONS *cons, SCIP_VAR *var)
     * }
     */
    public static int SCIPappendVarSOS2(MemorySegment scip, MemorySegment cons, MemorySegment var_) {
        var mh$ = SCIPappendVarSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPappendVarSOS2", scip, cons, var_);
            }
            return (int)mh$.invokeExact(scip, cons, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsSOS2$descriptor() {
        return SCIPgetNVarsSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsSOS2$handle() {
        return SCIPgetNVarsSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsSOS2$address() {
        return SCIPgetNVarsSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsSOS2(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsSOS2", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsSOS2$descriptor() {
        return SCIPgetVarsSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsSOS2$handle() {
        return SCIPgetVarsSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSOS2$address() {
        return SCIPgetVarsSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsSOS2(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsSOS2", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetWeightsSOS2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetWeightsSOS2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetWeightsSOS2$descriptor() {
        return SCIPgetWeightsSOS2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetWeightsSOS2$handle() {
        return SCIPgetWeightsSOS2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsSOS2$address() {
        return SCIPgetWeightsSOS2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetWeightsSOS2(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetWeightsSOS2(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetWeightsSOS2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetWeightsSOS2", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrSuperindicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrSuperindicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSuperindicator(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrSuperindicator$descriptor() {
        return SCIPincludeConshdlrSuperindicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSuperindicator(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrSuperindicator$handle() {
        return SCIPincludeConshdlrSuperindicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSuperindicator(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrSuperindicator$address() {
        return SCIPincludeConshdlrSuperindicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSuperindicator(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrSuperindicator(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrSuperindicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrSuperindicator", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSuperindicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSuperindicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSuperindicator$descriptor() {
        return SCIPcreateConsSuperindicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSuperindicator$handle() {
        return SCIPcreateConsSuperindicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSuperindicator$address() {
        return SCIPcreateConsSuperindicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSuperindicator(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment slackcons, int initial, int separate, int enforce, int check, int propagate, int local, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSuperindicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSuperindicator", scip, cons, name, binvar, slackcons, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, slackcons, initial, separate, enforce, check, propagate, local, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSuperindicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSuperindicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSuperindicator$descriptor() {
        return SCIPcreateConsBasicSuperindicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSuperindicator$handle() {
        return SCIPcreateConsBasicSuperindicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSuperindicator$address() {
        return SCIPcreateConsBasicSuperindicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSuperindicator(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *binvar, SCIP_CONS *slackcons)
     * }
     */
    public static int SCIPcreateConsBasicSuperindicator(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment binvar, MemorySegment slackcons) {
        var mh$ = SCIPcreateConsBasicSuperindicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSuperindicator", scip, cons, name, binvar, slackcons);
            }
            return (int)mh$.invokeExact(scip, cons, name, binvar, slackcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinaryVarSuperindicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinaryVarSuperindicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetBinaryVarSuperindicator$descriptor() {
        return SCIPgetBinaryVarSuperindicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetBinaryVarSuperindicator$handle() {
        return SCIPgetBinaryVarSuperindicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarSuperindicator$address() {
        return SCIPgetBinaryVarSuperindicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetBinaryVarSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetBinaryVarSuperindicator(MemorySegment cons) {
        var mh$ = SCIPgetBinaryVarSuperindicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinaryVarSuperindicator", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSlackConsSuperindicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSlackConsSuperindicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetSlackConsSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetSlackConsSuperindicator$descriptor() {
        return SCIPgetSlackConsSuperindicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetSlackConsSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetSlackConsSuperindicator$handle() {
        return SCIPgetSlackConsSuperindicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetSlackConsSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetSlackConsSuperindicator$address() {
        return SCIPgetSlackConsSuperindicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPgetSlackConsSuperindicator(SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetSlackConsSuperindicator(MemorySegment cons) {
        var mh$ = SCIPgetSlackConsSuperindicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSlackConsSuperindicator", cons);
            }
            return (MemorySegment)mh$.invokeExact(cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformMinUC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformMinUC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformMinUC(SCIP *scip, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPtransformMinUC$descriptor() {
        return SCIPtransformMinUC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformMinUC(SCIP *scip, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPtransformMinUC$handle() {
        return SCIPtransformMinUC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformMinUC(SCIP *scip, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPtransformMinUC$address() {
        return SCIPtransformMinUC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformMinUC(SCIP *scip, unsigned int *success)
     * }
     */
    public static int SCIPtransformMinUC(MemorySegment scip, MemorySegment success) {
        var mh$ = SCIPtransformMinUC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformMinUC", scip, success);
            }
            return (int)mh$.invokeExact(scip, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChangeMinUC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChangeMinUC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeMinUC(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChangeMinUC$descriptor() {
        return SCIPdialogExecChangeMinUC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeMinUC(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChangeMinUC$handle() {
        return SCIPdialogExecChangeMinUC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeMinUC(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChangeMinUC$address() {
        return SCIPdialogExecChangeMinUC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeMinUC(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChangeMinUC(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChangeMinUC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChangeMinUC", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrSymresack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrSymresack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSymresack(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrSymresack$descriptor() {
        return SCIPincludeConshdlrSymresack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSymresack(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrSymresack$handle() {
        return SCIPincludeConshdlrSymresack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSymresack(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrSymresack$address() {
        return SCIPincludeConshdlrSymresack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrSymresack(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrSymresack(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrSymresack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrSymresack", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateSymbreakCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateSymbreakCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymbreakCons(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateSymbreakCons$descriptor() {
        return SCIPcreateSymbreakCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymbreakCons(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateSymbreakCons$handle() {
        return SCIPcreateSymbreakCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymbreakCons(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateSymbreakCons$address() {
        return SCIPcreateSymbreakCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymbreakCons(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateSymbreakCons(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment perm, MemorySegment vars, int nvars, int ismodelcons, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateSymbreakCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateSymbreakCons", scip, cons, name, perm, vars, nvars, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, perm, vars, nvars, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsSymresack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsSymresack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsSymresack$descriptor() {
        return SCIPcreateConsSymresack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsSymresack$handle() {
        return SCIPcreateConsSymresack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsSymresack$address() {
        return SCIPcreateConsSymresack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsSymresack(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment perm, MemorySegment vars, int nvars, int ismodelcons, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsSymresack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsSymresack", scip, cons, name, perm, vars, nvars, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, perm, vars, nvars, ismodelcons, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicSymresack {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicSymresack");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicSymresack$descriptor() {
        return SCIPcreateConsBasicSymresack.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicSymresack$handle() {
        return SCIPcreateConsBasicSymresack.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicSymresack$address() {
        return SCIPcreateConsBasicSymresack.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicSymresack(SCIP *scip, SCIP_CONS **cons, const char *name, int *perm, SCIP_VAR **vars, int nvars, unsigned int ismodelcons)
     * }
     */
    public static int SCIPcreateConsBasicSymresack(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment perm, MemorySegment vars, int nvars, int ismodelcons) {
        var mh$ = SCIPcreateConsBasicSymresack.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicSymresack", scip, cons, name, perm, vars, nvars, ismodelcons);
            }
            return (int)mh$.invokeExact(scip, cons, name, perm, vars, nvars, ismodelcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrVarbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrVarbound$descriptor() {
        return SCIPincludeConshdlrVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrVarbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrVarbound$handle() {
        return SCIPincludeConshdlrVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrVarbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrVarbound$address() {
        return SCIPincludeConshdlrVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrVarbound(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrVarbound(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrVarbound", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsVarbound$descriptor() {
        return SCIPcreateConsVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsVarbound$handle() {
        return SCIPcreateConsVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsVarbound$address() {
        return SCIPcreateConsVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsVarbound(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment var_, MemorySegment vbdvar, double vbdcoef, double lhs, double rhs, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsVarbound", scip, cons, name, var_, vbdvar, vbdcoef, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, var_, vbdvar, vbdcoef, lhs, rhs, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicVarbound$descriptor() {
        return SCIPcreateConsBasicVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicVarbound$handle() {
        return SCIPcreateConsBasicVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicVarbound$address() {
        return SCIPcreateConsBasicVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicVarbound(SCIP *scip, SCIP_CONS **cons, const char *name, SCIP_VAR *var, SCIP_VAR *vbdvar, double vbdcoef, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateConsBasicVarbound(MemorySegment scip, MemorySegment cons, MemorySegment name, MemorySegment var_, MemorySegment vbdvar, double vbdcoef, double lhs, double rhs) {
        var mh$ = SCIPcreateConsBasicVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicVarbound", scip, cons, name, var_, vbdvar, vbdcoef, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, cons, name, var_, vbdvar, vbdcoef, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLhsVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLhsVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetLhsVarbound$descriptor() {
        return SCIPgetLhsVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetLhsVarbound$handle() {
        return SCIPgetLhsVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetLhsVarbound$address() {
        return SCIPgetLhsVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetLhsVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetLhsVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLhsVarbound", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRhsVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRhsVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRhsVarbound$descriptor() {
        return SCIPgetRhsVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRhsVarbound$handle() {
        return SCIPgetRhsVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRhsVarbound$address() {
        return SCIPgetRhsVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRhsVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetRhsVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRhsVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRhsVarbound", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarVarbound$descriptor() {
        return SCIPgetVarVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarVarbound$handle() {
        return SCIPgetVarVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarVarbound$address() {
        return SCIPgetVarVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarVarbound", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVbdvarVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVbdvarVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVbdvarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVbdvarVarbound$descriptor() {
        return SCIPgetVbdvarVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVbdvarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVbdvarVarbound$handle() {
        return SCIPgetVbdvarVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVbdvarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVbdvarVarbound$address() {
        return SCIPgetVbdvarVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetVbdvarVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVbdvarVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVbdvarVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVbdvarVarbound", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVbdcoefVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVbdcoefVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVbdcoefVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVbdcoefVarbound$descriptor() {
        return SCIPgetVbdcoefVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVbdcoefVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVbdcoefVarbound$handle() {
        return SCIPgetVbdcoefVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVbdcoefVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVbdcoefVarbound$address() {
        return SCIPgetVbdcoefVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVbdcoefVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetVbdcoefVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVbdcoefVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVbdcoefVarbound", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualsolVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualsolVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualsolVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualsolVarbound$descriptor() {
        return SCIPgetDualsolVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualsolVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualsolVarbound$handle() {
        return SCIPgetDualsolVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualsolVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualsolVarbound$address() {
        return SCIPgetDualsolVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualsolVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualsolVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualsolVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualsolVarbound", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualfarkasVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualfarkasVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetDualfarkasVarbound$descriptor() {
        return SCIPgetDualfarkasVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetDualfarkasVarbound$handle() {
        return SCIPgetDualfarkasVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualfarkasVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetDualfarkasVarbound$address() {
        return SCIPgetDualfarkasVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualfarkasVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static double SCIPgetDualfarkasVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetDualfarkasVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualfarkasVarbound", scip, cons);
            }
            return (double)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRowVarbound$descriptor() {
        return SCIPgetRowVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRowVarbound$handle() {
        return SCIPgetRowVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowVarbound$address() {
        return SCIPgetRowVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW *SCIPgetRowVarbound(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRowVarbound(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRowVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowVarbound", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanupConssVarbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanupConssVarbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssVarbound(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgbds)
     * }
     */
    public static FunctionDescriptor SCIPcleanupConssVarbound$descriptor() {
        return SCIPcleanupConssVarbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssVarbound(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgbds)
     * }
     */
    public static MethodHandle SCIPcleanupConssVarbound$handle() {
        return SCIPcleanupConssVarbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssVarbound(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgbds)
     * }
     */
    public static MemorySegment SCIPcleanupConssVarbound$address() {
        return SCIPcleanupConssVarbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcleanupConssVarbound(SCIP *scip, unsigned int onlychecked, unsigned int *infeasible, int *naddconss, int *ndelconss, int *nchgbds)
     * }
     */
    public static int SCIPcleanupConssVarbound(MemorySegment scip, int onlychecked, MemorySegment infeasible, MemorySegment naddconss, MemorySegment ndelconss, MemorySegment nchgbds) {
        var mh$ = SCIPcleanupConssVarbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanupConssVarbound", scip, onlychecked, infeasible, naddconss, ndelconss, nchgbds);
            }
            return (int)mh$.invokeExact(scip, onlychecked, infeasible, naddconss, ndelconss, nchgbds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrXor(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrXor$descriptor() {
        return SCIPincludeConshdlrXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrXor(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrXor$handle() {
        return SCIPincludeConshdlrXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrXor(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrXor$address() {
        return SCIPincludeConshdlrXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrXor(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrXor(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrXor", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsXor$descriptor() {
        return SCIPcreateConsXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MethodHandle SCIPcreateConsXor$handle() {
        return SCIPcreateConsXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static MemorySegment SCIPcreateConsXor$address() {
        return SCIPcreateConsXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars, unsigned int initial, unsigned int separate, unsigned int enforce, unsigned int check, unsigned int propagate, unsigned int local, unsigned int modifiable, unsigned int dynamic, unsigned int removable, unsigned int stickingatnode)
     * }
     */
    public static int SCIPcreateConsXor(MemorySegment scip, MemorySegment cons, MemorySegment name, int rhs, int nvars, MemorySegment vars, int initial, int separate, int enforce, int check, int propagate, int local, int modifiable, int dynamic, int removable, int stickingatnode) {
        var mh$ = SCIPcreateConsXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsXor", scip, cons, name, rhs, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
            }
            return (int)mh$.invokeExact(scip, cons, name, rhs, nvars, vars, initial, separate, enforce, check, propagate, local, modifiable, dynamic, removable, stickingatnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateConsBasicXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateConsBasicXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars)
     * }
     */
    public static FunctionDescriptor SCIPcreateConsBasicXor$descriptor() {
        return SCIPcreateConsBasicXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MethodHandle SCIPcreateConsBasicXor$handle() {
        return SCIPcreateConsBasicXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars)
     * }
     */
    public static MemorySegment SCIPcreateConsBasicXor$address() {
        return SCIPcreateConsBasicXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateConsBasicXor(SCIP *scip, SCIP_CONS **cons, const char *name, unsigned int rhs, int nvars, SCIP_VAR **vars)
     * }
     */
    public static int SCIPcreateConsBasicXor(MemorySegment scip, MemorySegment cons, MemorySegment name, int rhs, int nvars, MemorySegment vars) {
        var mh$ = SCIPcreateConsBasicXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateConsBasicXor", scip, cons, name, rhs, nvars, vars);
            }
            return (int)mh$.invokeExact(scip, cons, name, rhs, nvars, vars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVarsXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVarsXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetNVarsXor$descriptor() {
        return SCIPgetNVarsXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetNVarsXor$handle() {
        return SCIPgetNVarsXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetNVarsXor$address() {
        return SCIPgetNVarsXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetNVarsXor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetNVarsXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVarsXor", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsXor$descriptor() {
        return SCIPgetVarsXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetVarsXor$handle() {
        return SCIPgetVarsXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsXor$address() {
        return SCIPgetVarsXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVarsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetVarsXor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetVarsXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsXor", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIntVarXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIntVarXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIntVarXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetIntVarXor$descriptor() {
        return SCIPgetIntVarXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIntVarXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetIntVarXor$handle() {
        return SCIPgetIntVarXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIntVarXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetIntVarXor$address() {
        return SCIPgetIntVarXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPgetIntVarXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetIntVarXor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetIntVarXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIntVarXor", scip, cons);
            }
            return (MemorySegment)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRhsXor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRhsXor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetRhsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPgetRhsXor$descriptor() {
        return SCIPgetRhsXor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetRhsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPgetRhsXor$handle() {
        return SCIPgetRhsXor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetRhsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPgetRhsXor$address() {
        return SCIPgetRhsXor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetRhsXor(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPgetRhsXor(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPgetRhsXor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRhsXor", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConshdlrComponents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConshdlrComponents");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrComponents(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConshdlrComponents$descriptor() {
        return SCIPincludeConshdlrComponents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrComponents(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConshdlrComponents$handle() {
        return SCIPincludeConshdlrComponents.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrComponents(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConshdlrComponents$address() {
        return SCIPincludeConshdlrComponents.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConshdlrComponents(SCIP *scip)
     * }
     */
    public static int SCIPincludeConshdlrComponents(MemorySegment scip) {
        var mh$ = SCIPincludeConshdlrComponents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConshdlrComponents", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDispDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDispDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDispDefault(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeDispDefault$descriptor() {
        return SCIPincludeDispDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDispDefault(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeDispDefault$handle() {
        return SCIPincludeDispDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDispDefault(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeDispDefault$address() {
        return SCIPincludeDispDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDispDefault(SCIP *scip)
     * }
     */
    public static int SCIPincludeDispDefault(MemorySegment scip) {
        var mh$ = SCIPincludeDispDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDispDefault", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecMenu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenu(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecMenu$descriptor() {
        return SCIPdialogExecMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenu(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecMenu$handle() {
        return SCIPdialogExecMenu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenu(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecMenu$address() {
        return SCIPdialogExecMenu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenu(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecMenu(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecMenu", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecMenuLazy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecMenuLazy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenuLazy(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecMenuLazy$descriptor() {
        return SCIPdialogExecMenuLazy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenuLazy(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecMenuLazy$handle() {
        return SCIPdialogExecMenuLazy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenuLazy(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecMenuLazy$address() {
        return SCIPdialogExecMenuLazy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecMenuLazy(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecMenuLazy(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecMenuLazy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecMenuLazy", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChangeAddCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChangeAddCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeAddCons(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChangeAddCons$descriptor() {
        return SCIPdialogExecChangeAddCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeAddCons(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChangeAddCons$handle() {
        return SCIPdialogExecChangeAddCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeAddCons(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChangeAddCons$address() {
        return SCIPdialogExecChangeAddCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeAddCons(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChangeAddCons(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChangeAddCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChangeAddCons", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChangeBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChangeBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeBounds(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChangeBounds$descriptor() {
        return SCIPdialogExecChangeBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeBounds(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChangeBounds$handle() {
        return SCIPdialogExecChangeBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeBounds(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChangeBounds$address() {
        return SCIPdialogExecChangeBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeBounds(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChangeBounds(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChangeBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChangeBounds", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChangeFreetransproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChangeFreetransproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeFreetransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChangeFreetransproblem$descriptor() {
        return SCIPdialogExecChangeFreetransproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeFreetransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChangeFreetransproblem$handle() {
        return SCIPdialogExecChangeFreetransproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeFreetransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChangeFreetransproblem$address() {
        return SCIPdialogExecChangeFreetransproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeFreetransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChangeFreetransproblem(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChangeFreetransproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChangeFreetransproblem", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChangeObjSense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChangeObjSense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeObjSense(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChangeObjSense$descriptor() {
        return SCIPdialogExecChangeObjSense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeObjSense(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChangeObjSense$handle() {
        return SCIPdialogExecChangeObjSense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeObjSense(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChangeObjSense$address() {
        return SCIPdialogExecChangeObjSense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChangeObjSense(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChangeObjSense(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChangeObjSense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChangeObjSense", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecChecksol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecChecksol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChecksol(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecChecksol$descriptor() {
        return SCIPdialogExecChecksol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChecksol(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecChecksol$handle() {
        return SCIPdialogExecChecksol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChecksol(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecChecksol$address() {
        return SCIPdialogExecChecksol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecChecksol(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecChecksol(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecChecksol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecChecksol", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecCliquegraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecCliquegraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCliquegraph(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecCliquegraph$descriptor() {
        return SCIPdialogExecCliquegraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCliquegraph(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecCliquegraph$handle() {
        return SCIPdialogExecCliquegraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCliquegraph(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecCliquegraph$address() {
        return SCIPdialogExecCliquegraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecCliquegraph(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecCliquegraph(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecCliquegraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecCliquegraph", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayBenders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayBenders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBenders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayBenders$descriptor() {
        return SCIPdialogExecDisplayBenders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBenders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayBenders$handle() {
        return SCIPdialogExecDisplayBenders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBenders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayBenders$address() {
        return SCIPdialogExecDisplayBenders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBenders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayBenders(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayBenders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayBenders", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayBranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayBranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBranching(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayBranching$descriptor() {
        return SCIPdialogExecDisplayBranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBranching(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayBranching$handle() {
        return SCIPdialogExecDisplayBranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBranching(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayBranching$address() {
        return SCIPdialogExecDisplayBranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayBranching(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayBranching(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayBranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayBranching", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCompression(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayCompression$descriptor() {
        return SCIPdialogExecDisplayCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCompression(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayCompression$handle() {
        return SCIPdialogExecDisplayCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCompression(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayCompression$address() {
        return SCIPdialogExecDisplayCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCompression(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayCompression(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayCompression", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayConflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayConflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConflict(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayConflict$descriptor() {
        return SCIPdialogExecDisplayConflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConflict(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayConflict$handle() {
        return SCIPdialogExecDisplayConflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConflict(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayConflict$address() {
        return SCIPdialogExecDisplayConflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConflict(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayConflict(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayConflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayConflict", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayConshdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayConshdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConshdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayConshdlrs$descriptor() {
        return SCIPdialogExecDisplayConshdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConshdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayConshdlrs$handle() {
        return SCIPdialogExecDisplayConshdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConshdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayConshdlrs$address() {
        return SCIPdialogExecDisplayConshdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayConshdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayConshdlrs(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayConshdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayConshdlrs", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayDisplaycols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayDisplaycols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDisplaycols(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayDisplaycols$descriptor() {
        return SCIPdialogExecDisplayDisplaycols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDisplaycols(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayDisplaycols$handle() {
        return SCIPdialogExecDisplayDisplaycols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDisplaycols(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayDisplaycols$address() {
        return SCIPdialogExecDisplayDisplaycols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDisplaycols(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayDisplaycols(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayDisplaycols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayDisplaycols", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayExprhdlrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayExprhdlrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayExprhdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayExprhdlrs$descriptor() {
        return SCIPdialogExecDisplayExprhdlrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayExprhdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayExprhdlrs$handle() {
        return SCIPdialogExecDisplayExprhdlrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayExprhdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayExprhdlrs$address() {
        return SCIPdialogExecDisplayExprhdlrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayExprhdlrs(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayExprhdlrs(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayExprhdlrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayExprhdlrs", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayCutselectors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayCutselectors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCutselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayCutselectors$descriptor() {
        return SCIPdialogExecDisplayCutselectors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCutselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayCutselectors$handle() {
        return SCIPdialogExecDisplayCutselectors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCutselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayCutselectors$address() {
        return SCIPdialogExecDisplayCutselectors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayCutselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayCutselectors(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayCutselectors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayCutselectors", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayHeuristics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayHeuristics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayHeuristics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayHeuristics$descriptor() {
        return SCIPdialogExecDisplayHeuristics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayHeuristics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayHeuristics$handle() {
        return SCIPdialogExecDisplayHeuristics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayHeuristics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayHeuristics$address() {
        return SCIPdialogExecDisplayHeuristics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayHeuristics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayHeuristics(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayHeuristics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayHeuristics", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayMemory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayMemory(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayMemory$descriptor() {
        return SCIPdialogExecDisplayMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayMemory(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayMemory$handle() {
        return SCIPdialogExecDisplayMemory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayMemory(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayMemory$address() {
        return SCIPdialogExecDisplayMemory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayMemory(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayMemory(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayMemory", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayNodeselectors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayNodeselectors");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNodeselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayNodeselectors$descriptor() {
        return SCIPdialogExecDisplayNodeselectors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNodeselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayNodeselectors$handle() {
        return SCIPdialogExecDisplayNodeselectors.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNodeselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayNodeselectors$address() {
        return SCIPdialogExecDisplayNodeselectors.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNodeselectors(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayNodeselectors(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayNodeselectors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayNodeselectors", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayNlpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayNlpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNlpi(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayNlpi$descriptor() {
        return SCIPdialogExecDisplayNlpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNlpi(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayNlpi$handle() {
        return SCIPdialogExecDisplayNlpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNlpi(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayNlpi$address() {
        return SCIPdialogExecDisplayNlpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayNlpi(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayNlpi(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayNlpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayNlpi", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayParameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayParameters(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayParameters$descriptor() {
        return SCIPdialogExecDisplayParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayParameters(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayParameters$handle() {
        return SCIPdialogExecDisplayParameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayParameters(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayParameters$address() {
        return SCIPdialogExecDisplayParameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayParameters(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayParameters(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayParameters", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayPresolvers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayPresolvers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPresolvers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayPresolvers$descriptor() {
        return SCIPdialogExecDisplayPresolvers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPresolvers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayPresolvers$handle() {
        return SCIPdialogExecDisplayPresolvers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPresolvers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayPresolvers$address() {
        return SCIPdialogExecDisplayPresolvers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPresolvers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayPresolvers(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayPresolvers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayPresolvers", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayPricers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayPricers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPricers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayPricers$descriptor() {
        return SCIPdialogExecDisplayPricers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPricers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayPricers$handle() {
        return SCIPdialogExecDisplayPricers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPricers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayPricers$address() {
        return SCIPdialogExecDisplayPricers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPricers(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayPricers(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayPricers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayPricers", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayProblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayProblem$descriptor() {
        return SCIPdialogExecDisplayProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayProblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayProblem$handle() {
        return SCIPdialogExecDisplayProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayProblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayProblem$address() {
        return SCIPdialogExecDisplayProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayProblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayProblem(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayProblem", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayPropagators {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayPropagators");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPropagators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayPropagators$descriptor() {
        return SCIPdialogExecDisplayPropagators.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPropagators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayPropagators$handle() {
        return SCIPdialogExecDisplayPropagators.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPropagators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayPropagators$address() {
        return SCIPdialogExecDisplayPropagators.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayPropagators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayPropagators(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayPropagators.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayPropagators", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayReaders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayReaders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReaders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayReaders$descriptor() {
        return SCIPdialogExecDisplayReaders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReaders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayReaders$handle() {
        return SCIPdialogExecDisplayReaders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReaders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayReaders$address() {
        return SCIPdialogExecDisplayReaders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReaders(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayReaders(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayReaders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayReaders", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayRelaxators {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayRelaxators");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayRelaxators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayRelaxators$descriptor() {
        return SCIPdialogExecDisplayRelaxators.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayRelaxators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayRelaxators$handle() {
        return SCIPdialogExecDisplayRelaxators.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayRelaxators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayRelaxators$address() {
        return SCIPdialogExecDisplayRelaxators.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayRelaxators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayRelaxators(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayRelaxators.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayRelaxators", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplaySeparators {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplaySeparators");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySeparators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplaySeparators$descriptor() {
        return SCIPdialogExecDisplaySeparators.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySeparators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplaySeparators$handle() {
        return SCIPdialogExecDisplaySeparators.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySeparators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplaySeparators$address() {
        return SCIPdialogExecDisplaySeparators.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySeparators(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplaySeparators(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplaySeparators.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplaySeparators", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplaySolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplaySolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplaySolution$descriptor() {
        return SCIPdialogExecDisplaySolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplaySolution$handle() {
        return SCIPdialogExecDisplaySolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplaySolution$address() {
        return SCIPdialogExecDisplaySolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplaySolution(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplaySolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplaySolution", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayFiniteSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayFiniteSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayFiniteSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayFiniteSolution$descriptor() {
        return SCIPdialogExecDisplayFiniteSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayFiniteSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayFiniteSolution$handle() {
        return SCIPdialogExecDisplayFiniteSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayFiniteSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayFiniteSolution$address() {
        return SCIPdialogExecDisplayFiniteSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayFiniteSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayFiniteSolution(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayFiniteSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayFiniteSolution", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayDualSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayDualSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDualSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayDualSolution$descriptor() {
        return SCIPdialogExecDisplayDualSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDualSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayDualSolution$handle() {
        return SCIPdialogExecDisplayDualSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDualSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayDualSolution$address() {
        return SCIPdialogExecDisplayDualSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayDualSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayDualSolution(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayDualSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayDualSolution", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplaySolutionPool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplaySolutionPool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolutionPool(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplaySolutionPool$descriptor() {
        return SCIPdialogExecDisplaySolutionPool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolutionPool(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplaySolutionPool$handle() {
        return SCIPdialogExecDisplaySolutionPool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolutionPool(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplaySolutionPool$address() {
        return SCIPdialogExecDisplaySolutionPool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySolutionPool(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplaySolutionPool(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplaySolutionPool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplaySolutionPool", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplaySubproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplaySubproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplaySubproblem$descriptor() {
        return SCIPdialogExecDisplaySubproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplaySubproblem$handle() {
        return SCIPdialogExecDisplaySubproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplaySubproblem$address() {
        return SCIPdialogExecDisplaySubproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplaySubproblem(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplaySubproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplaySubproblem", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplaySubSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplaySubSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplaySubSolution$descriptor() {
        return SCIPdialogExecDisplaySubSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplaySubSolution$handle() {
        return SCIPdialogExecDisplaySubSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplaySubSolution$address() {
        return SCIPdialogExecDisplaySubSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplaySubSolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplaySubSolution(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplaySubSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplaySubSolution", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayStatistics$descriptor() {
        return SCIPdialogExecDisplayStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayStatistics$handle() {
        return SCIPdialogExecDisplayStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayStatistics$address() {
        return SCIPdialogExecDisplayStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayStatistics(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayStatistics", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayReoptStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayReoptStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReoptStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayReoptStatistics$descriptor() {
        return SCIPdialogExecDisplayReoptStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReoptStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayReoptStatistics$handle() {
        return SCIPdialogExecDisplayReoptStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReoptStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayReoptStatistics$address() {
        return SCIPdialogExecDisplayReoptStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayReoptStatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayReoptStatistics(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayReoptStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayReoptStatistics", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayTransproblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayTransproblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayTransproblem$descriptor() {
        return SCIPdialogExecDisplayTransproblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayTransproblem$handle() {
        return SCIPdialogExecDisplayTransproblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayTransproblem$address() {
        return SCIPdialogExecDisplayTransproblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTransproblem(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayTransproblem(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayTransproblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayTransproblem", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayValue(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayValue$descriptor() {
        return SCIPdialogExecDisplayValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayValue(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayValue$handle() {
        return SCIPdialogExecDisplayValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayValue(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayValue$address() {
        return SCIPdialogExecDisplayValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayValue(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayValue(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayValue", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayVarbranchstatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayVarbranchstatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayVarbranchstatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayVarbranchstatistics$descriptor() {
        return SCIPdialogExecDisplayVarbranchstatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayVarbranchstatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayVarbranchstatistics$handle() {
        return SCIPdialogExecDisplayVarbranchstatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayVarbranchstatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayVarbranchstatistics$address() {
        return SCIPdialogExecDisplayVarbranchstatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayVarbranchstatistics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayVarbranchstatistics(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayVarbranchstatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayVarbranchstatistics", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayLPSolutionQuality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayLPSolutionQuality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLPSolutionQuality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayLPSolutionQuality$descriptor() {
        return SCIPdialogExecDisplayLPSolutionQuality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLPSolutionQuality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayLPSolutionQuality$handle() {
        return SCIPdialogExecDisplayLPSolutionQuality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLPSolutionQuality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayLPSolutionQuality$address() {
        return SCIPdialogExecDisplayLPSolutionQuality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLPSolutionQuality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayLPSolutionQuality(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayLPSolutionQuality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayLPSolutionQuality", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayTranssolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayTranssolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTranssolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayTranssolution$descriptor() {
        return SCIPdialogExecDisplayTranssolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTranssolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayTranssolution$handle() {
        return SCIPdialogExecDisplayTranssolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTranssolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayTranssolution$address() {
        return SCIPdialogExecDisplayTranssolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayTranssolution(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayTranssolution(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayTranssolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayTranssolution", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecHelp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecHelp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecHelp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecHelp$descriptor() {
        return SCIPdialogExecHelp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecHelp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecHelp$handle() {
        return SCIPdialogExecHelp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecHelp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecHelp$address() {
        return SCIPdialogExecHelp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecHelp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecHelp(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecHelp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecHelp", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFree(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecFree$descriptor() {
        return SCIPdialogExecFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFree(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecFree$handle() {
        return SCIPdialogExecFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFree(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecFree$address() {
        return SCIPdialogExecFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFree(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecFree(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecFree", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecNewstart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecNewstart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecNewstart(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecNewstart$descriptor() {
        return SCIPdialogExecNewstart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecNewstart(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecNewstart$handle() {
        return SCIPdialogExecNewstart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecNewstart(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecNewstart$address() {
        return SCIPdialogExecNewstart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecNewstart(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecNewstart(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecNewstart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecNewstart", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecTransform(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecTransform$descriptor() {
        return SCIPdialogExecTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecTransform(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecTransform$handle() {
        return SCIPdialogExecTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecTransform(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecTransform$address() {
        return SCIPdialogExecTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecTransform(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecTransform(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecTransform", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecOptimize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecOptimize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecOptimize(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecOptimize$descriptor() {
        return SCIPdialogExecOptimize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecOptimize(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecOptimize$handle() {
        return SCIPdialogExecOptimize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecOptimize(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecOptimize$address() {
        return SCIPdialogExecOptimize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecOptimize(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecOptimize(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecOptimize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecOptimize", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecConcurrentOpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecConcurrentOpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecConcurrentOpt(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecConcurrentOpt$descriptor() {
        return SCIPdialogExecConcurrentOpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecConcurrentOpt(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecConcurrentOpt$handle() {
        return SCIPdialogExecConcurrentOpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecConcurrentOpt(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecConcurrentOpt$address() {
        return SCIPdialogExecConcurrentOpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecConcurrentOpt(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecConcurrentOpt(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecConcurrentOpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecConcurrentOpt", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecPresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecPresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecPresolve$descriptor() {
        return SCIPdialogExecPresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecPresolve$handle() {
        return SCIPdialogExecPresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecPresolve$address() {
        return SCIPdialogExecPresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecPresolve(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecPresolve(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecPresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecPresolve", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecQuit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecQuit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecQuit(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecQuit$descriptor() {
        return SCIPdialogExecQuit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecQuit(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecQuit$handle() {
        return SCIPdialogExecQuit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecQuit(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecQuit$address() {
        return SCIPdialogExecQuit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecQuit(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecQuit(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecQuit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecQuit", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecRead(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecRead$descriptor() {
        return SCIPdialogExecRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecRead(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecRead$handle() {
        return SCIPdialogExecRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecRead(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecRead$address() {
        return SCIPdialogExecRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecRead(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecRead(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecRead", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetDefault$descriptor() {
        return SCIPdialogExecSetDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetDefault$handle() {
        return SCIPdialogExecSetDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetDefault$address() {
        return SCIPdialogExecSetDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetDefault(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetDefault", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetLoad {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetLoad");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLoad(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetLoad$descriptor() {
        return SCIPdialogExecSetLoad.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLoad(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetLoad$handle() {
        return SCIPdialogExecSetLoad.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLoad(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetLoad$address() {
        return SCIPdialogExecSetLoad.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLoad(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetLoad(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetLoad.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetLoad", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetSave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetSave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetSave$descriptor() {
        return SCIPdialogExecSetSave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetSave$handle() {
        return SCIPdialogExecSetSave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetSave$address() {
        return SCIPdialogExecSetSave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetSave(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetSave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetSave", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetDiffsave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetDiffsave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDiffsave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetDiffsave$descriptor() {
        return SCIPdialogExecSetDiffsave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDiffsave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetDiffsave$handle() {
        return SCIPdialogExecSetDiffsave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDiffsave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetDiffsave$address() {
        return SCIPdialogExecSetDiffsave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetDiffsave(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetDiffsave(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetDiffsave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetDiffsave", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetParam$descriptor() {
        return SCIPdialogExecSetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetParam$handle() {
        return SCIPdialogExecSetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetParam$address() {
        return SCIPdialogExecSetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetParam(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetParam", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogDescSetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogDescSetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescSetParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogDescSetParam$descriptor() {
        return SCIPdialogDescSetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescSetParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogDescSetParam$handle() {
        return SCIPdialogDescSetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescSetParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogDescSetParam$address() {
        return SCIPdialogDescSetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescSetParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPdialogDescSetParam(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPdialogDescSetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogDescSetParam", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecFixParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecFixParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFixParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecFixParam$descriptor() {
        return SCIPdialogExecFixParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFixParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecFixParam$handle() {
        return SCIPdialogExecFixParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFixParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecFixParam$address() {
        return SCIPdialogExecFixParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecFixParam(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecFixParam(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecFixParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecFixParam", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogDescFixParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogDescFixParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescFixParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogDescFixParam$descriptor() {
        return SCIPdialogDescFixParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescFixParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MethodHandle SCIPdialogDescFixParam$handle() {
        return SCIPdialogDescFixParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescFixParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static MemorySegment SCIPdialogDescFixParam$address() {
        return SCIPdialogDescFixParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogDescFixParam(SCIP *scip, SCIP_DIALOG *dialog)
     * }
     */
    public static int SCIPdialogDescFixParam(MemorySegment scip, MemorySegment dialog) {
        var mh$ = SCIPdialogDescFixParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogDescFixParam", scip, dialog);
            }
            return (int)mh$.invokeExact(scip, dialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetBranchingDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetBranchingDirection");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingDirection(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetBranchingDirection$descriptor() {
        return SCIPdialogExecSetBranchingDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingDirection(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetBranchingDirection$handle() {
        return SCIPdialogExecSetBranchingDirection.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingDirection(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetBranchingDirection$address() {
        return SCIPdialogExecSetBranchingDirection.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingDirection(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetBranchingDirection(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetBranchingDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetBranchingDirection", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetBranchingPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetBranchingPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingPriority(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetBranchingPriority$descriptor() {
        return SCIPdialogExecSetBranchingPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingPriority(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetBranchingPriority$handle() {
        return SCIPdialogExecSetBranchingPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingPriority(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetBranchingPriority$address() {
        return SCIPdialogExecSetBranchingPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetBranchingPriority(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetBranchingPriority(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetBranchingPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetBranchingPriority", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetHeuristicsAggressive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetHeuristicsAggressive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetHeuristicsAggressive$descriptor() {
        return SCIPdialogExecSetHeuristicsAggressive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetHeuristicsAggressive$handle() {
        return SCIPdialogExecSetHeuristicsAggressive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetHeuristicsAggressive$address() {
        return SCIPdialogExecSetHeuristicsAggressive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetHeuristicsAggressive(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetHeuristicsAggressive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetHeuristicsAggressive", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetHeuristicsDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetHeuristicsDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetHeuristicsDefault$descriptor() {
        return SCIPdialogExecSetHeuristicsDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetHeuristicsDefault$handle() {
        return SCIPdialogExecSetHeuristicsDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetHeuristicsDefault$address() {
        return SCIPdialogExecSetHeuristicsDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetHeuristicsDefault(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetHeuristicsDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetHeuristicsDefault", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetHeuristicsFast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetHeuristicsFast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetHeuristicsFast$descriptor() {
        return SCIPdialogExecSetHeuristicsFast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetHeuristicsFast$handle() {
        return SCIPdialogExecSetHeuristicsFast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetHeuristicsFast$address() {
        return SCIPdialogExecSetHeuristicsFast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetHeuristicsFast(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetHeuristicsFast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetHeuristicsFast", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetHeuristicsOff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetHeuristicsOff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetHeuristicsOff$descriptor() {
        return SCIPdialogExecSetHeuristicsOff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetHeuristicsOff$handle() {
        return SCIPdialogExecSetHeuristicsOff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetHeuristicsOff$address() {
        return SCIPdialogExecSetHeuristicsOff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetHeuristicsOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetHeuristicsOff(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetHeuristicsOff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetHeuristicsOff", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetPresolvingAggressive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetPresolvingAggressive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetPresolvingAggressive$descriptor() {
        return SCIPdialogExecSetPresolvingAggressive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetPresolvingAggressive$handle() {
        return SCIPdialogExecSetPresolvingAggressive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetPresolvingAggressive$address() {
        return SCIPdialogExecSetPresolvingAggressive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetPresolvingAggressive(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetPresolvingAggressive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetPresolvingAggressive", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetPresolvingDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetPresolvingDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetPresolvingDefault$descriptor() {
        return SCIPdialogExecSetPresolvingDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetPresolvingDefault$handle() {
        return SCIPdialogExecSetPresolvingDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetPresolvingDefault$address() {
        return SCIPdialogExecSetPresolvingDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetPresolvingDefault(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetPresolvingDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetPresolvingDefault", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetPresolvingFast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetPresolvingFast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetPresolvingFast$descriptor() {
        return SCIPdialogExecSetPresolvingFast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetPresolvingFast$handle() {
        return SCIPdialogExecSetPresolvingFast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetPresolvingFast$address() {
        return SCIPdialogExecSetPresolvingFast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetPresolvingFast(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetPresolvingFast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetPresolvingFast", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetPresolvingOff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetPresolvingOff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetPresolvingOff$descriptor() {
        return SCIPdialogExecSetPresolvingOff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetPresolvingOff$handle() {
        return SCIPdialogExecSetPresolvingOff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetPresolvingOff$address() {
        return SCIPdialogExecSetPresolvingOff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetPresolvingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetPresolvingOff(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetPresolvingOff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetPresolvingOff", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetSeparatingAggressive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetSeparatingAggressive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetSeparatingAggressive$descriptor() {
        return SCIPdialogExecSetSeparatingAggressive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetSeparatingAggressive$handle() {
        return SCIPdialogExecSetSeparatingAggressive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetSeparatingAggressive$address() {
        return SCIPdialogExecSetSeparatingAggressive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingAggressive(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetSeparatingAggressive(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetSeparatingAggressive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetSeparatingAggressive", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetSeparatingDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetSeparatingDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetSeparatingDefault$descriptor() {
        return SCIPdialogExecSetSeparatingDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetSeparatingDefault$handle() {
        return SCIPdialogExecSetSeparatingDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetSeparatingDefault$address() {
        return SCIPdialogExecSetSeparatingDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingDefault(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetSeparatingDefault(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetSeparatingDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetSeparatingDefault", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetSeparatingFast {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetSeparatingFast");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetSeparatingFast$descriptor() {
        return SCIPdialogExecSetSeparatingFast.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetSeparatingFast$handle() {
        return SCIPdialogExecSetSeparatingFast.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetSeparatingFast$address() {
        return SCIPdialogExecSetSeparatingFast.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingFast(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetSeparatingFast(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetSeparatingFast.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetSeparatingFast", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetSeparatingOff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetSeparatingOff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetSeparatingOff$descriptor() {
        return SCIPdialogExecSetSeparatingOff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetSeparatingOff$handle() {
        return SCIPdialogExecSetSeparatingOff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetSeparatingOff$address() {
        return SCIPdialogExecSetSeparatingOff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetSeparatingOff(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetSeparatingOff(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetSeparatingOff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetSeparatingOff", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisCounter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCounter(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisCounter$descriptor() {
        return SCIPdialogExecSetEmphasisCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCounter(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisCounter$handle() {
        return SCIPdialogExecSetEmphasisCounter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCounter(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisCounter$address() {
        return SCIPdialogExecSetEmphasisCounter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCounter(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisCounter(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisCounter", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisCpsolver {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisCpsolver");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCpsolver(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisCpsolver$descriptor() {
        return SCIPdialogExecSetEmphasisCpsolver.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCpsolver(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisCpsolver$handle() {
        return SCIPdialogExecSetEmphasisCpsolver.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCpsolver(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisCpsolver$address() {
        return SCIPdialogExecSetEmphasisCpsolver.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisCpsolver(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisCpsolver(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisCpsolver.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisCpsolver", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisEasycip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisEasycip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisEasycip(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisEasycip$descriptor() {
        return SCIPdialogExecSetEmphasisEasycip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisEasycip(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisEasycip$handle() {
        return SCIPdialogExecSetEmphasisEasycip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisEasycip(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisEasycip$address() {
        return SCIPdialogExecSetEmphasisEasycip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisEasycip(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisEasycip(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisEasycip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisEasycip", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisFeasibility(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisFeasibility$descriptor() {
        return SCIPdialogExecSetEmphasisFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisFeasibility(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisFeasibility$handle() {
        return SCIPdialogExecSetEmphasisFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisFeasibility(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisFeasibility$address() {
        return SCIPdialogExecSetEmphasisFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisFeasibility(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisFeasibility(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisFeasibility", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisHardlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisHardlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisHardlp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisHardlp$descriptor() {
        return SCIPdialogExecSetEmphasisHardlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisHardlp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisHardlp$handle() {
        return SCIPdialogExecSetEmphasisHardlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisHardlp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisHardlp$address() {
        return SCIPdialogExecSetEmphasisHardlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisHardlp(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisHardlp(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisHardlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisHardlp", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisOptimality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisOptimality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisOptimality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisOptimality$descriptor() {
        return SCIPdialogExecSetEmphasisOptimality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisOptimality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisOptimality$handle() {
        return SCIPdialogExecSetEmphasisOptimality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisOptimality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisOptimality$address() {
        return SCIPdialogExecSetEmphasisOptimality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisOptimality(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisOptimality(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisOptimality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisOptimality", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisNumerics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisNumerics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisNumerics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisNumerics$descriptor() {
        return SCIPdialogExecSetEmphasisNumerics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisNumerics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisNumerics$handle() {
        return SCIPdialogExecSetEmphasisNumerics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisNumerics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisNumerics$address() {
        return SCIPdialogExecSetEmphasisNumerics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisNumerics(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisNumerics(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisNumerics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisNumerics", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetEmphasisBenchmark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetEmphasisBenchmark");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisBenchmark(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetEmphasisBenchmark$descriptor() {
        return SCIPdialogExecSetEmphasisBenchmark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisBenchmark(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetEmphasisBenchmark$handle() {
        return SCIPdialogExecSetEmphasisBenchmark.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisBenchmark(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetEmphasisBenchmark$address() {
        return SCIPdialogExecSetEmphasisBenchmark.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetEmphasisBenchmark(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetEmphasisBenchmark(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetEmphasisBenchmark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetEmphasisBenchmark", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecSetLimitsObjective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecSetLimitsObjective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLimitsObjective(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecSetLimitsObjective$descriptor() {
        return SCIPdialogExecSetLimitsObjective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLimitsObjective(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecSetLimitsObjective$handle() {
        return SCIPdialogExecSetLimitsObjective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLimitsObjective(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecSetLimitsObjective$address() {
        return SCIPdialogExecSetLimitsObjective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecSetLimitsObjective(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecSetLimitsObjective(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecSetLimitsObjective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecSetLimitsObjective", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdialogExecDisplayLinearConsClassification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogExecDisplayLinearConsClassification");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLinearConsClassification(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static FunctionDescriptor SCIPdialogExecDisplayLinearConsClassification$descriptor() {
        return SCIPdialogExecDisplayLinearConsClassification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLinearConsClassification(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MethodHandle SCIPdialogExecDisplayLinearConsClassification$handle() {
        return SCIPdialogExecDisplayLinearConsClassification.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLinearConsClassification(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static MemorySegment SCIPdialogExecDisplayLinearConsClassification$address() {
        return SCIPdialogExecDisplayLinearConsClassification.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdialogExecDisplayLinearConsClassification(SCIP *scip, SCIP_DIALOG *dialog, SCIP_DIALOGHDLR *dialoghdlr, SCIP_DIALOG **nextdialog)
     * }
     */
    public static int SCIPdialogExecDisplayLinearConsClassification(MemorySegment scip, MemorySegment dialog, MemorySegment dialoghdlr, MemorySegment nextdialog) {
        var mh$ = SCIPdialogExecDisplayLinearConsClassification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdialogExecDisplayLinearConsClassification", scip, dialog, dialoghdlr, nextdialog);
            }
            return (int)mh$.invokeExact(scip, dialog, dialoghdlr, nextdialog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRootDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRootDialog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRootDialog(SCIP *scip, SCIP_DIALOG **root)
     * }
     */
    public static FunctionDescriptor SCIPcreateRootDialog$descriptor() {
        return SCIPcreateRootDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRootDialog(SCIP *scip, SCIP_DIALOG **root)
     * }
     */
    public static MethodHandle SCIPcreateRootDialog$handle() {
        return SCIPcreateRootDialog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRootDialog(SCIP *scip, SCIP_DIALOG **root)
     * }
     */
    public static MemorySegment SCIPcreateRootDialog$address() {
        return SCIPcreateRootDialog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRootDialog(SCIP *scip, SCIP_DIALOG **root)
     * }
     */
    public static int SCIPcreateRootDialog(MemorySegment scip, MemorySegment root) {
        var mh$ = SCIPcreateRootDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRootDialog", scip, root);
            }
            return (int)mh$.invokeExact(scip, root);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDialogDefaultBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDialogDefaultBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultBasic(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeDialogDefaultBasic$descriptor() {
        return SCIPincludeDialogDefaultBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultBasic(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeDialogDefaultBasic$handle() {
        return SCIPincludeDialogDefaultBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultBasic(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeDialogDefaultBasic$address() {
        return SCIPincludeDialogDefaultBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultBasic(SCIP *scip)
     * }
     */
    public static int SCIPincludeDialogDefaultBasic(MemorySegment scip) {
        var mh$ = SCIPincludeDialogDefaultBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDialogDefaultBasic", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDialogDefaultSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDialogDefaultSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultSet(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeDialogDefaultSet$descriptor() {
        return SCIPincludeDialogDefaultSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultSet(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeDialogDefaultSet$handle() {
        return SCIPincludeDialogDefaultSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultSet(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeDialogDefaultSet$address() {
        return SCIPincludeDialogDefaultSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultSet(SCIP *scip)
     * }
     */
    public static int SCIPincludeDialogDefaultSet(MemorySegment scip) {
        var mh$ = SCIPincludeDialogDefaultSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDialogDefaultSet", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDialogDefaultFix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDialogDefaultFix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultFix(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeDialogDefaultFix$descriptor() {
        return SCIPincludeDialogDefaultFix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultFix(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeDialogDefaultFix$handle() {
        return SCIPincludeDialogDefaultFix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultFix(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeDialogDefaultFix$address() {
        return SCIPincludeDialogDefaultFix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDialogDefaultFix(SCIP *scip)
     * }
     */
    public static int SCIPincludeDialogDefaultFix(MemorySegment scip) {
        var mh$ = SCIPincludeDialogDefaultFix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDialogDefaultFix", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeEventHdlrEstim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeEventHdlrEstim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrEstim(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeEventHdlrEstim$descriptor() {
        return SCIPincludeEventHdlrEstim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrEstim(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeEventHdlrEstim$handle() {
        return SCIPincludeEventHdlrEstim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrEstim(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeEventHdlrEstim$address() {
        return SCIPincludeEventHdlrEstim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrEstim(SCIP *scip)
     * }
     */
    public static int SCIPincludeEventHdlrEstim(MemorySegment scip) {
        var mh$ = SCIPincludeEventHdlrEstim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeEventHdlrEstim", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTreesizeEstimation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTreesizeEstimation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTreesizeEstimation(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTreesizeEstimation$descriptor() {
        return SCIPgetTreesizeEstimation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTreesizeEstimation(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTreesizeEstimation$handle() {
        return SCIPgetTreesizeEstimation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTreesizeEstimation(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTreesizeEstimation$address() {
        return SCIPgetTreesizeEstimation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTreesizeEstimation(SCIP *scip)
     * }
     */
    public static double SCIPgetTreesizeEstimation(MemorySegment scip) {
        var mh$ = SCIPgetTreesizeEstimation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTreesizeEstimation", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeEventHdlrSolvingphase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeEventHdlrSolvingphase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSolvingphase(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeEventHdlrSolvingphase$descriptor() {
        return SCIPincludeEventHdlrSolvingphase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSolvingphase(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeEventHdlrSolvingphase$handle() {
        return SCIPincludeEventHdlrSolvingphase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSolvingphase(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeEventHdlrSolvingphase$address() {
        return SCIPincludeEventHdlrSolvingphase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSolvingphase(SCIP *scip)
     * }
     */
    public static int SCIPincludeEventHdlrSolvingphase(MemorySegment scip) {
        var mh$ = SCIPincludeEventHdlrSolvingphase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeEventHdlrSolvingphase", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeEventHdlrSofttimelimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeEventHdlrSofttimelimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSofttimelimit(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeEventHdlrSofttimelimit$descriptor() {
        return SCIPincludeEventHdlrSofttimelimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSofttimelimit(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeEventHdlrSofttimelimit$handle() {
        return SCIPincludeEventHdlrSofttimelimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSofttimelimit(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeEventHdlrSofttimelimit$address() {
        return SCIPincludeEventHdlrSofttimelimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeEventHdlrSofttimelimit(SCIP *scip)
     * }
     */
    public static int SCIPincludeEventHdlrSofttimelimit(MemorySegment scip) {
        var mh$ = SCIPincludeEventHdlrSofttimelimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeEventHdlrSofttimelimit", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprAbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprAbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprAbs(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprAbs$descriptor() {
        return SCIPcreateExprAbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprAbs(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprAbs$handle() {
        return SCIPcreateExprAbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprAbs(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprAbs$address() {
        return SCIPcreateExprAbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprAbs(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprAbs(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprAbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprAbs", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprAbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprAbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprAbs(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprAbs$descriptor() {
        return SCIPisExprAbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprAbs(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprAbs$handle() {
        return SCIPisExprAbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprAbs(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprAbs$address() {
        return SCIPisExprAbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprAbs(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprAbs(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprAbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprAbs", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrAbs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrAbs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrAbs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrAbs$descriptor() {
        return SCIPincludeExprhdlrAbs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrAbs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrAbs$handle() {
        return SCIPincludeExprhdlrAbs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrAbs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrAbs$address() {
        return SCIPincludeExprhdlrAbs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrAbs(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrAbs(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrAbs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrAbs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrEntropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrEntropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrEntropy(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrEntropy$descriptor() {
        return SCIPincludeExprhdlrEntropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrEntropy(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrEntropy$handle() {
        return SCIPincludeExprhdlrEntropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrEntropy(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrEntropy$address() {
        return SCIPincludeExprhdlrEntropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrEntropy(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrEntropy(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrEntropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrEntropy", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprEntropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprEntropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprEntropy(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprEntropy$descriptor() {
        return SCIPcreateExprEntropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprEntropy(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprEntropy$handle() {
        return SCIPcreateExprEntropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprEntropy(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprEntropy$address() {
        return SCIPcreateExprEntropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprEntropy(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprEntropy(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprEntropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprEntropy", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprEntropy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprEntropy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprEntropy(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprEntropy$descriptor() {
        return SCIPisExprEntropy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprEntropy(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprEntropy$handle() {
        return SCIPisExprEntropy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprEntropy(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprEntropy$address() {
        return SCIPisExprEntropy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprEntropy(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprEntropy(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprEntropy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprEntropy", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprExp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprExp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprExp(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprExp$descriptor() {
        return SCIPcreateExprExp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprExp(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprExp$handle() {
        return SCIPcreateExprExp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprExp(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprExp$address() {
        return SCIPcreateExprExp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprExp(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprExp(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprExp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprExp", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprExp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprExp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprExp(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprExp$descriptor() {
        return SCIPisExprExp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprExp(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprExp$handle() {
        return SCIPisExprExp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprExp(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprExp$address() {
        return SCIPisExprExp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprExp(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprExp(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprExp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprExp", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrExp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrExp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrExp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrExp$descriptor() {
        return SCIPincludeExprhdlrExp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrExp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrExp$handle() {
        return SCIPincludeExprhdlrExp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrExp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrExp$address() {
        return SCIPincludeExprhdlrExp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrExp(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrExp(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrExp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrExp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprLog(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprLog$descriptor() {
        return SCIPcreateExprLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprLog(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprLog$handle() {
        return SCIPcreateExprLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprLog(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprLog$address() {
        return SCIPcreateExprLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprLog(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprLog(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprLog", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprLog(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprLog$descriptor() {
        return SCIPisExprLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprLog(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprLog$handle() {
        return SCIPisExprLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprLog(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprLog$address() {
        return SCIPisExprLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprLog(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprLog(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprLog", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrLog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrLog(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrLog$descriptor() {
        return SCIPincludeExprhdlrLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrLog(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrLog$handle() {
        return SCIPincludeExprhdlrLog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrLog(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrLog$address() {
        return SCIPincludeExprhdlrLog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrLog(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrLog(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrLog", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprPow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprPow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprPow(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprPow$descriptor() {
        return SCIPcreateExprPow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprPow(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprPow$handle() {
        return SCIPcreateExprPow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprPow(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprPow$address() {
        return SCIPcreateExprPow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprPow(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprPow(MemorySegment scip, MemorySegment expr, MemorySegment child, double exponent, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprPow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprPow", scip, expr, child, exponent, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, exponent, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprSignpower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprSignpower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSignpower(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprSignpower$descriptor() {
        return SCIPcreateExprSignpower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSignpower(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprSignpower$handle() {
        return SCIPcreateExprSignpower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSignpower(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprSignpower$address() {
        return SCIPcreateExprSignpower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSignpower(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, double exponent, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprSignpower(MemorySegment scip, MemorySegment expr, MemorySegment child, double exponent, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprSignpower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprSignpower", scip, expr, child, exponent, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, exponent, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprSignpower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprSignpower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSignpower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprSignpower$descriptor() {
        return SCIPisExprSignpower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSignpower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprSignpower$handle() {
        return SCIPisExprSignpower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSignpower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprSignpower$address() {
        return SCIPisExprSignpower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprSignpower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprSignpower(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprSignpower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprSignpower", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrPow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrPow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrPow(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrPow$descriptor() {
        return SCIPincludeExprhdlrPow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrPow(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrPow$handle() {
        return SCIPincludeExprhdlrPow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrPow(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrPow$address() {
        return SCIPincludeExprhdlrPow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrPow(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrPow(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrPow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrPow", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrSignpower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrSignpower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSignpower(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrSignpower$descriptor() {
        return SCIPincludeExprhdlrSignpower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSignpower(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrSignpower$handle() {
        return SCIPincludeExprhdlrSignpower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSignpower(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrSignpower$address() {
        return SCIPincludeExprhdlrSignpower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSignpower(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrSignpower(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrSignpower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrSignpower", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddSquareLinearization {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddSquareLinearization");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddSquareLinearization(SCIP *scip, double sqrcoef, double refpoint, unsigned int isint, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddSquareLinearization$descriptor() {
        return SCIPaddSquareLinearization.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddSquareLinearization(SCIP *scip, double sqrcoef, double refpoint, unsigned int isint, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddSquareLinearization$handle() {
        return SCIPaddSquareLinearization.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddSquareLinearization(SCIP *scip, double sqrcoef, double refpoint, unsigned int isint, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddSquareLinearization$address() {
        return SCIPaddSquareLinearization.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddSquareLinearization(SCIP *scip, double sqrcoef, double refpoint, unsigned int isint, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static void SCIPaddSquareLinearization(MemorySegment scip, double sqrcoef, double refpoint, int isint, MemorySegment lincoef, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPaddSquareLinearization.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddSquareLinearization", scip, sqrcoef, refpoint, isint, lincoef, linconstant, success);
            }
            mh$.invokeExact(scip, sqrcoef, refpoint, isint, lincoef, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddSquareSecant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddSquareSecant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddSquareSecant(SCIP *scip, double sqrcoef, double lb, double ub, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddSquareSecant$descriptor() {
        return SCIPaddSquareSecant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddSquareSecant(SCIP *scip, double sqrcoef, double lb, double ub, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddSquareSecant$handle() {
        return SCIPaddSquareSecant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddSquareSecant(SCIP *scip, double sqrcoef, double lb, double ub, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddSquareSecant$address() {
        return SCIPaddSquareSecant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddSquareSecant(SCIP *scip, double sqrcoef, double lb, double ub, double *lincoef, double *linconstant, unsigned int *success)
     * }
     */
    public static void SCIPaddSquareSecant(MemorySegment scip, double sqrcoef, double lb, double ub, MemorySegment lincoef, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPaddSquareSecant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddSquareSecant", scip, sqrcoef, lb, ub, lincoef, linconstant, success);
            }
            mh$.invokeExact(scip, sqrcoef, lb, ub, lincoef, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPestimateRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPestimateRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPestimateRoot(SCIP *scip, double exponent, unsigned int overestimate, double xlb, double xub, double xref, double *constant, double *slope, unsigned int *islocal, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPestimateRoot$descriptor() {
        return SCIPestimateRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPestimateRoot(SCIP *scip, double exponent, unsigned int overestimate, double xlb, double xub, double xref, double *constant, double *slope, unsigned int *islocal, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPestimateRoot$handle() {
        return SCIPestimateRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPestimateRoot(SCIP *scip, double exponent, unsigned int overestimate, double xlb, double xub, double xref, double *constant, double *slope, unsigned int *islocal, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPestimateRoot$address() {
        return SCIPestimateRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPestimateRoot(SCIP *scip, double exponent, unsigned int overestimate, double xlb, double xub, double xref, double *constant, double *slope, unsigned int *islocal, unsigned int *success)
     * }
     */
    public static void SCIPestimateRoot(MemorySegment scip, double exponent, int overestimate, double xlb, double xub, double xref, MemorySegment constant, MemorySegment slope, MemorySegment islocal, MemorySegment success) {
        var mh$ = SCIPestimateRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPestimateRoot", scip, exponent, overestimate, xlb, xub, xref, constant, slope, islocal, success);
            }
            mh$.invokeExact(scip, exponent, overestimate, xlb, xub, xref, constant, slope, islocal, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrProduct(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrProduct$descriptor() {
        return SCIPincludeExprhdlrProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrProduct(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrProduct$handle() {
        return SCIPincludeExprhdlrProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrProduct(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrProduct$address() {
        return SCIPincludeExprhdlrProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrProduct(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrProduct(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrProduct", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprProduct(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double coefficient, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprProduct$descriptor() {
        return SCIPcreateExprProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprProduct(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double coefficient, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprProduct$handle() {
        return SCIPcreateExprProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprProduct(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double coefficient, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprProduct$address() {
        return SCIPcreateExprProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprProduct(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double coefficient, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprProduct(MemorySegment scip, MemorySegment expr, int nchildren, MemorySegment children, double coefficient, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprProduct", scip, expr, nchildren, children, coefficient, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, nchildren, children, coefficient, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSum(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrSum$descriptor() {
        return SCIPincludeExprhdlrSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSum(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrSum$handle() {
        return SCIPincludeExprhdlrSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSum(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrSum$address() {
        return SCIPincludeExprhdlrSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSum(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrSum(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrSum", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSum(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double *coefficients, double constant, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprSum$descriptor() {
        return SCIPcreateExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSum(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double *coefficients, double constant, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprSum$handle() {
        return SCIPcreateExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSum(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double *coefficients, double constant, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprSum$address() {
        return SCIPcreateExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSum(SCIP *scip, SCIP_EXPR **expr, int nchildren, SCIP_EXPR **children, double *coefficients, double constant, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprSum(MemorySegment scip, MemorySegment expr, int nchildren, MemorySegment children, MemorySegment coefficients, double constant, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprSum", scip, expr, nchildren, children, coefficients, constant, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, nchildren, children, coefficients, constant, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetConstantExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetConstantExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static FunctionDescriptor SCIPsetConstantExprSum$descriptor() {
        return SCIPsetConstantExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static MethodHandle SCIPsetConstantExprSum$handle() {
        return SCIPsetConstantExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static MemorySegment SCIPsetConstantExprSum$address() {
        return SCIPsetConstantExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static void SCIPsetConstantExprSum(MemorySegment expr, double constant) {
        var mh$ = SCIPsetConstantExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetConstantExprSum", expr, constant);
            }
            mh$.invokeExact(expr, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPappendExprSumExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPappendExprSumExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprSumExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child, double childcoef)
     * }
     */
    public static FunctionDescriptor SCIPappendExprSumExpr$descriptor() {
        return SCIPappendExprSumExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprSumExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child, double childcoef)
     * }
     */
    public static MethodHandle SCIPappendExprSumExpr$handle() {
        return SCIPappendExprSumExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprSumExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child, double childcoef)
     * }
     */
    public static MemorySegment SCIPappendExprSumExpr$address() {
        return SCIPappendExprSumExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPappendExprSumExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR *child, double childcoef)
     * }
     */
    public static int SCIPappendExprSumExpr(MemorySegment scip, MemorySegment expr, MemorySegment child, double childcoef) {
        var mh$ = SCIPappendExprSumExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPappendExprSumExpr", scip, expr, child, childcoef);
            }
            return (int)mh$.invokeExact(scip, expr, child, childcoef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmultiplyByConstantExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmultiplyByConstantExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPmultiplyByConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static FunctionDescriptor SCIPmultiplyByConstantExprSum$descriptor() {
        return SCIPmultiplyByConstantExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPmultiplyByConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static MethodHandle SCIPmultiplyByConstantExprSum$handle() {
        return SCIPmultiplyByConstantExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPmultiplyByConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static MemorySegment SCIPmultiplyByConstantExprSum$address() {
        return SCIPmultiplyByConstantExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPmultiplyByConstantExprSum(SCIP_EXPR *expr, double constant)
     * }
     */
    public static void SCIPmultiplyByConstantExprSum(MemorySegment expr, double constant) {
        var mh$ = SCIPmultiplyByConstantExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmultiplyByConstantExprSum", expr, constant);
            }
            mh$.invokeExact(expr, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmultiplyBySumExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmultiplyBySumExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiplyBySumExprSum(SCIP *scip, SCIP_EXPR **product, SCIP_EXPR *factor1, SCIP_EXPR *factor2, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPmultiplyBySumExprSum$descriptor() {
        return SCIPmultiplyBySumExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiplyBySumExprSum(SCIP *scip, SCIP_EXPR **product, SCIP_EXPR *factor1, SCIP_EXPR *factor2, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPmultiplyBySumExprSum$handle() {
        return SCIPmultiplyBySumExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiplyBySumExprSum(SCIP *scip, SCIP_EXPR **product, SCIP_EXPR *factor1, SCIP_EXPR *factor2, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPmultiplyBySumExprSum$address() {
        return SCIPmultiplyBySumExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmultiplyBySumExprSum(SCIP *scip, SCIP_EXPR **product, SCIP_EXPR *factor1, SCIP_EXPR *factor2, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPmultiplyBySumExprSum(MemorySegment scip, MemorySegment product, MemorySegment factor1, MemorySegment factor2, int simplify, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPmultiplyBySumExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmultiplyBySumExprSum", scip, product, factor1, factor2, simplify, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, product, factor1, factor2, simplify, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpowerExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpowerExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpowerExprSum(SCIP *scip, SCIP_EXPR **result, SCIP_EXPR *base, int exponent, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPpowerExprSum$descriptor() {
        return SCIPpowerExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpowerExprSum(SCIP *scip, SCIP_EXPR **result, SCIP_EXPR *base, int exponent, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPpowerExprSum$handle() {
        return SCIPpowerExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpowerExprSum(SCIP *scip, SCIP_EXPR **result, SCIP_EXPR *base, int exponent, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPpowerExprSum$address() {
        return SCIPpowerExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpowerExprSum(SCIP *scip, SCIP_EXPR **result, SCIP_EXPR *base, int exponent, unsigned int simplify, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPpowerExprSum(MemorySegment scip, MemorySegment result, MemorySegment base, int exponent, int simplify, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPpowerExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpowerExprSum", scip, result, base, exponent, simplify, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, result, base, exponent, simplify, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrSin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrSin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSin(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrSin$descriptor() {
        return SCIPincludeExprhdlrSin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSin(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrSin$handle() {
        return SCIPincludeExprhdlrSin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSin(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrSin$address() {
        return SCIPincludeExprhdlrSin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrSin(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrSin(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrSin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrSin", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrCos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrCos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrCos(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrCos$descriptor() {
        return SCIPincludeExprhdlrCos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrCos(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrCos$handle() {
        return SCIPincludeExprhdlrCos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrCos(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrCos$address() {
        return SCIPincludeExprhdlrCos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrCos(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrCos(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrCos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrCos", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprSin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprSin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSin(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprSin$descriptor() {
        return SCIPcreateExprSin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSin(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprSin$handle() {
        return SCIPcreateExprSin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSin(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprSin$address() {
        return SCIPcreateExprSin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprSin(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprSin(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprSin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprSin", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprCos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprCos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprCos(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprCos$descriptor() {
        return SCIPcreateExprCos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprCos(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprCos$handle() {
        return SCIPcreateExprCos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprCos(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprCos$address() {
        return SCIPcreateExprCos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprCos(SCIP *scip, SCIP_EXPR **expr, SCIP_EXPR *child, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprCos(MemorySegment scip, MemorySegment expr, MemorySegment child, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprCos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprCos", scip, expr, child, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, child, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprSin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprSin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSin(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprSin$descriptor() {
        return SCIPisExprSin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSin(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprSin$handle() {
        return SCIPisExprSin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSin(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprSin$address() {
        return SCIPisExprSin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprSin(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprSin(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprSin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprSin", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprCos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprCos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprCos(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprCos$descriptor() {
        return SCIPisExprCos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprCos(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprCos$handle() {
        return SCIPisExprCos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprCos(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprCos$address() {
        return SCIPisExprCos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprCos(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprCos(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprCos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprCos", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrValue(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrValue$descriptor() {
        return SCIPincludeExprhdlrValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrValue(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrValue$handle() {
        return SCIPincludeExprhdlrValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrValue(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrValue$address() {
        return SCIPincludeExprhdlrValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrValue(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrValue(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrValue", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprValue(SCIP *scip, SCIP_EXPR **expr, double value, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprValue$descriptor() {
        return SCIPcreateExprValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprValue(SCIP *scip, SCIP_EXPR **expr, double value, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprValue$handle() {
        return SCIPcreateExprValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprValue(SCIP *scip, SCIP_EXPR **expr, double value, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprValue$address() {
        return SCIPcreateExprValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprValue(SCIP *scip, SCIP_EXPR **expr, double value, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprValue(MemorySegment scip, MemorySegment expr, double value, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprValue", scip, expr, value, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, value, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVar(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrVar$descriptor() {
        return SCIPincludeExprhdlrVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVar(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrVar$handle() {
        return SCIPincludeExprhdlrVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVar(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrVar$address() {
        return SCIPincludeExprhdlrVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVar(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrVar(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrVar", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVar(SCIP *scip, SCIP_EXPR **expr, SCIP_VAR *var, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprVar$descriptor() {
        return SCIPcreateExprVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVar(SCIP *scip, SCIP_EXPR **expr, SCIP_VAR *var, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprVar$handle() {
        return SCIPcreateExprVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVar(SCIP *scip, SCIP_EXPR **expr, SCIP_VAR *var, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprVar$address() {
        return SCIPcreateExprVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVar(SCIP *scip, SCIP_EXPR **expr, SCIP_VAR *var, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprVar(MemorySegment scip, MemorySegment expr, MemorySegment var_, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprVar", scip, expr, var_, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, var_, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurActconsdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurActconsdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurActconsdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurActconsdiving$descriptor() {
        return SCIPincludeHeurActconsdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurActconsdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurActconsdiving$handle() {
        return SCIPincludeHeurActconsdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurActconsdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurActconsdiving$address() {
        return SCIPincludeHeurActconsdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurActconsdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurActconsdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurActconsdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurActconsdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurAdaptivediving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurAdaptivediving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAdaptivediving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurAdaptivediving$descriptor() {
        return SCIPincludeHeurAdaptivediving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAdaptivediving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurAdaptivediving$handle() {
        return SCIPincludeHeurAdaptivediving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAdaptivediving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurAdaptivediving$address() {
        return SCIPincludeHeurAdaptivediving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAdaptivediving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurAdaptivediving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurAdaptivediving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurAdaptivediving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurBound$descriptor() {
        return SCIPincludeHeurBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurBound$handle() {
        return SCIPincludeHeurBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurBound$address() {
        return SCIPincludeHeurBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBound(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurBound(MemorySegment scip) {
        var mh$ = SCIPincludeHeurBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurBound", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurClique {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurClique");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurClique(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurClique$descriptor() {
        return SCIPincludeHeurClique.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurClique(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurClique$handle() {
        return SCIPincludeHeurClique.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurClique(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurClique$address() {
        return SCIPincludeHeurClique.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurClique(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurClique(MemorySegment scip) {
        var mh$ = SCIPincludeHeurClique.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurClique", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurCoefdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurCoefdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCoefdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurCoefdiving$descriptor() {
        return SCIPincludeHeurCoefdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCoefdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurCoefdiving$handle() {
        return SCIPincludeHeurCoefdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCoefdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurCoefdiving$address() {
        return SCIPincludeHeurCoefdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCoefdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurCoefdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurCoefdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurCoefdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurCompletesol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurCompletesol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCompletesol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurCompletesol$descriptor() {
        return SCIPincludeHeurCompletesol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCompletesol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurCompletesol$handle() {
        return SCIPincludeHeurCompletesol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCompletesol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurCompletesol$address() {
        return SCIPincludeHeurCompletesol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCompletesol(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurCompletesol(MemorySegment scip) {
        var mh$ = SCIPincludeHeurCompletesol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurCompletesol", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurConflictdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurConflictdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurConflictdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurConflictdiving$descriptor() {
        return SCIPincludeHeurConflictdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurConflictdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurConflictdiving$handle() {
        return SCIPincludeHeurConflictdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurConflictdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurConflictdiving$address() {
        return SCIPincludeHeurConflictdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurConflictdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurConflictdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurConflictdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurConflictdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurCrossover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurCrossover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCrossover(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurCrossover$descriptor() {
        return SCIPincludeHeurCrossover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCrossover(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurCrossover$handle() {
        return SCIPincludeHeurCrossover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCrossover(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurCrossover$address() {
        return SCIPincludeHeurCrossover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurCrossover(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurCrossover(MemorySegment scip) {
        var mh$ = SCIPincludeHeurCrossover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurCrossover", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurDins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurDins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurDins$descriptor() {
        return SCIPincludeHeurDins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurDins$handle() {
        return SCIPincludeHeurDins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurDins$address() {
        return SCIPincludeHeurDins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDins(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurDins(MemorySegment scip) {
        var mh$ = SCIPincludeHeurDins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurDins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurDistributiondiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurDistributiondiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDistributiondiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurDistributiondiving$descriptor() {
        return SCIPincludeHeurDistributiondiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDistributiondiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurDistributiondiving$handle() {
        return SCIPincludeHeurDistributiondiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDistributiondiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurDistributiondiving$address() {
        return SCIPincludeHeurDistributiondiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDistributiondiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurDistributiondiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurDistributiondiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurDistributiondiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurDps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurDps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurDps$descriptor() {
        return SCIPincludeHeurDps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurDps$handle() {
        return SCIPincludeHeurDps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurDps$address() {
        return SCIPincludeHeurDps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDps(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurDps(MemorySegment scip) {
        var mh$ = SCIPincludeHeurDps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurDps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurDualval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurDualval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDualval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurDualval$descriptor() {
        return SCIPincludeHeurDualval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDualval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurDualval$handle() {
        return SCIPincludeHeurDualval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDualval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurDualval$address() {
        return SCIPincludeHeurDualval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurDualval(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurDualval(MemorySegment scip) {
        var mh$ = SCIPincludeHeurDualval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurDualval", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyHeurDualval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyHeurDualval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurDualval(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint)
     * }
     */
    public static FunctionDescriptor SCIPapplyHeurDualval$descriptor() {
        return SCIPapplyHeurDualval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurDualval(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint)
     * }
     */
    public static MethodHandle SCIPapplyHeurDualval$handle() {
        return SCIPapplyHeurDualval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurDualval(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint)
     * }
     */
    public static MemorySegment SCIPapplyHeurDualval$address() {
        return SCIPapplyHeurDualval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurDualval(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint)
     * }
     */
    public static int SCIPapplyHeurDualval(MemorySegment scip, MemorySegment heur, MemorySegment result, MemorySegment refpoint) {
        var mh$ = SCIPapplyHeurDualval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyHeurDualval", scip, heur, result, refpoint);
            }
            return (int)mh$.invokeExact(scip, heur, result, refpoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurFarkasdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurFarkasdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFarkasdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurFarkasdiving$descriptor() {
        return SCIPincludeHeurFarkasdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFarkasdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurFarkasdiving$handle() {
        return SCIPincludeHeurFarkasdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFarkasdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurFarkasdiving$address() {
        return SCIPincludeHeurFarkasdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFarkasdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurFarkasdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurFarkasdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurFarkasdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurFeaspump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurFeaspump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFeaspump(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurFeaspump$descriptor() {
        return SCIPincludeHeurFeaspump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFeaspump(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurFeaspump$handle() {
        return SCIPincludeHeurFeaspump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFeaspump(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurFeaspump$address() {
        return SCIPincludeHeurFeaspump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFeaspump(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurFeaspump(MemorySegment scip) {
        var mh$ = SCIPincludeHeurFeaspump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurFeaspump", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurFixandinfer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurFixandinfer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFixandinfer(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurFixandinfer$descriptor() {
        return SCIPincludeHeurFixandinfer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFixandinfer(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurFixandinfer$handle() {
        return SCIPincludeHeurFixandinfer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFixandinfer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurFixandinfer$address() {
        return SCIPincludeHeurFixandinfer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFixandinfer(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurFixandinfer(MemorySegment scip) {
        var mh$ = SCIPincludeHeurFixandinfer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurFixandinfer", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurFracdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurFracdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFracdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurFracdiving$descriptor() {
        return SCIPincludeHeurFracdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFracdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurFracdiving$handle() {
        return SCIPincludeHeurFracdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFracdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurFracdiving$address() {
        return SCIPincludeHeurFracdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurFracdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurFracdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurFracdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurFracdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurGins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurGins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurGins$descriptor() {
        return SCIPincludeHeurGins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurGins$handle() {
        return SCIPincludeHeurGins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurGins$address() {
        return SCIPincludeHeurGins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGins(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurGins(MemorySegment scip) {
        var mh$ = SCIPincludeHeurGins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurGins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurGuideddiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurGuideddiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGuideddiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurGuideddiving$descriptor() {
        return SCIPincludeHeurGuideddiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGuideddiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurGuideddiving$handle() {
        return SCIPincludeHeurGuideddiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGuideddiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurGuideddiving$address() {
        return SCIPincludeHeurGuideddiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurGuideddiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurGuideddiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurGuideddiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurGuideddiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicator(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurIndicator$descriptor() {
        return SCIPincludeHeurIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicator(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurIndicator$handle() {
        return SCIPincludeHeurIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicator(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurIndicator$address() {
        return SCIPincludeHeurIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicator(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurIndicator(MemorySegment scip) {
        var mh$ = SCIPincludeHeurIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurIndicator", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurPassIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurPassIndicator");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassIndicator(SCIP *scip, SCIP_HEUR *heur, int nindconss, SCIP_CONS **indconss, unsigned int *solcand, double obj)
     * }
     */
    public static FunctionDescriptor SCIPheurPassIndicator$descriptor() {
        return SCIPheurPassIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassIndicator(SCIP *scip, SCIP_HEUR *heur, int nindconss, SCIP_CONS **indconss, unsigned int *solcand, double obj)
     * }
     */
    public static MethodHandle SCIPheurPassIndicator$handle() {
        return SCIPheurPassIndicator.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassIndicator(SCIP *scip, SCIP_HEUR *heur, int nindconss, SCIP_CONS **indconss, unsigned int *solcand, double obj)
     * }
     */
    public static MemorySegment SCIPheurPassIndicator$address() {
        return SCIPheurPassIndicator.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassIndicator(SCIP *scip, SCIP_HEUR *heur, int nindconss, SCIP_CONS **indconss, unsigned int *solcand, double obj)
     * }
     */
    public static int SCIPheurPassIndicator(MemorySegment scip, MemorySegment heur, int nindconss, MemorySegment indconss, MemorySegment solcand, double obj) {
        var mh$ = SCIPheurPassIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurPassIndicator", scip, heur, nindconss, indconss, solcand, obj);
            }
            return (int)mh$.invokeExact(scip, heur, nindconss, indconss, solcand, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurIndicatordiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurIndicatordiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicatordiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurIndicatordiving$descriptor() {
        return SCIPincludeHeurIndicatordiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicatordiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurIndicatordiving$handle() {
        return SCIPincludeHeurIndicatordiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicatordiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurIndicatordiving$address() {
        return SCIPincludeHeurIndicatordiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIndicatordiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurIndicatordiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurIndicatordiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurIndicatordiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurIntdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurIntdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurIntdiving$descriptor() {
        return SCIPincludeHeurIntdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurIntdiving$handle() {
        return SCIPincludeHeurIntdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurIntdiving$address() {
        return SCIPincludeHeurIntdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurIntdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurIntdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurIntdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurIntshifting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurIntshifting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntshifting(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurIntshifting$descriptor() {
        return SCIPincludeHeurIntshifting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntshifting(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurIntshifting$handle() {
        return SCIPincludeHeurIntshifting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntshifting(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurIntshifting$address() {
        return SCIPincludeHeurIntshifting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurIntshifting(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurIntshifting(MemorySegment scip) {
        var mh$ = SCIPincludeHeurIntshifting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurIntshifting", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurLinesearchdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurLinesearchdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLinesearchdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurLinesearchdiving$descriptor() {
        return SCIPincludeHeurLinesearchdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLinesearchdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurLinesearchdiving$handle() {
        return SCIPincludeHeurLinesearchdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLinesearchdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurLinesearchdiving$address() {
        return SCIPincludeHeurLinesearchdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLinesearchdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurLinesearchdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurLinesearchdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurLinesearchdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurLocalbranching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurLocalbranching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocalbranching(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurLocalbranching$descriptor() {
        return SCIPincludeHeurLocalbranching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocalbranching(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurLocalbranching$handle() {
        return SCIPincludeHeurLocalbranching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocalbranching(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurLocalbranching$address() {
        return SCIPincludeHeurLocalbranching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocalbranching(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurLocalbranching(MemorySegment scip) {
        var mh$ = SCIPincludeHeurLocalbranching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurLocalbranching", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurLocks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurLocks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocks(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurLocks$descriptor() {
        return SCIPincludeHeurLocks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocks(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurLocks$handle() {
        return SCIPincludeHeurLocks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocks(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurLocks$address() {
        return SCIPincludeHeurLocks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLocks(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurLocks(MemorySegment scip) {
        var mh$ = SCIPincludeHeurLocks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurLocks", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyLockFixings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyLockFixings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyLockFixings(SCIP *scip, SCIP_HEURDATA *heurdata, unsigned int *cutoff, unsigned int *allrowsfulfilled)
     * }
     */
    public static FunctionDescriptor SCIPapplyLockFixings$descriptor() {
        return SCIPapplyLockFixings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyLockFixings(SCIP *scip, SCIP_HEURDATA *heurdata, unsigned int *cutoff, unsigned int *allrowsfulfilled)
     * }
     */
    public static MethodHandle SCIPapplyLockFixings$handle() {
        return SCIPapplyLockFixings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyLockFixings(SCIP *scip, SCIP_HEURDATA *heurdata, unsigned int *cutoff, unsigned int *allrowsfulfilled)
     * }
     */
    public static MemorySegment SCIPapplyLockFixings$address() {
        return SCIPapplyLockFixings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyLockFixings(SCIP *scip, SCIP_HEURDATA *heurdata, unsigned int *cutoff, unsigned int *allrowsfulfilled)
     * }
     */
    public static int SCIPapplyLockFixings(MemorySegment scip, MemorySegment heurdata, MemorySegment cutoff, MemorySegment allrowsfulfilled) {
        var mh$ = SCIPapplyLockFixings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyLockFixings", scip, heurdata, cutoff, allrowsfulfilled);
            }
            return (int)mh$.invokeExact(scip, heurdata, cutoff, allrowsfulfilled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurLpface {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurLpface");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLpface(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurLpface$descriptor() {
        return SCIPincludeHeurLpface.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLpface(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurLpface$handle() {
        return SCIPincludeHeurLpface.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLpface(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurLpface$address() {
        return SCIPincludeHeurLpface.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurLpface(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurLpface(MemorySegment scip) {
        var mh$ = SCIPincludeHeurLpface.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurLpface", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurAlns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurAlns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAlns(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurAlns$descriptor() {
        return SCIPincludeHeurAlns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAlns(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurAlns$handle() {
        return SCIPincludeHeurAlns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAlns(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurAlns$address() {
        return SCIPincludeHeurAlns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurAlns(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurAlns(MemorySegment scip) {
        var mh$ = SCIPincludeHeurAlns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurAlns", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurMultistart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurMultistart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMultistart(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurMultistart$descriptor() {
        return SCIPincludeHeurMultistart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMultistart(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurMultistart$handle() {
        return SCIPincludeHeurMultistart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMultistart(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurMultistart$address() {
        return SCIPincludeHeurMultistart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMultistart(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurMultistart(MemorySegment scip) {
        var mh$ = SCIPincludeHeurMultistart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurMultistart", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurMutation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurMutation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMutation(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurMutation$descriptor() {
        return SCIPincludeHeurMutation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMutation(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurMutation$handle() {
        return SCIPincludeHeurMutation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMutation(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurMutation$address() {
        return SCIPincludeHeurMutation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMutation(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurMutation(MemorySegment scip) {
        var mh$ = SCIPincludeHeurMutation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurMutation", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurMpec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurMpec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMpec(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurMpec$descriptor() {
        return SCIPincludeHeurMpec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMpec(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurMpec$handle() {
        return SCIPincludeHeurMpec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMpec(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurMpec$address() {
        return SCIPincludeHeurMpec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurMpec(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurMpec(MemorySegment scip) {
        var mh$ = SCIPincludeHeurMpec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurMpec", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurNlpdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurNlpdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurNlpdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurNlpdiving$descriptor() {
        return SCIPincludeHeurNlpdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurNlpdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurNlpdiving$handle() {
        return SCIPincludeHeurNlpdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurNlpdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurNlpdiving$address() {
        return SCIPincludeHeurNlpdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurNlpdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurNlpdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurNlpdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurNlpdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurObjpscostdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurObjpscostdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurObjpscostdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurObjpscostdiving$descriptor() {
        return SCIPincludeHeurObjpscostdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurObjpscostdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurObjpscostdiving$handle() {
        return SCIPincludeHeurObjpscostdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurObjpscostdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurObjpscostdiving$address() {
        return SCIPincludeHeurObjpscostdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurObjpscostdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurObjpscostdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurObjpscostdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurObjpscostdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurOctane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurOctane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOctane(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurOctane$descriptor() {
        return SCIPincludeHeurOctane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOctane(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurOctane$handle() {
        return SCIPincludeHeurOctane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOctane(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurOctane$address() {
        return SCIPincludeHeurOctane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOctane(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurOctane(MemorySegment scip) {
        var mh$ = SCIPincludeHeurOctane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurOctane", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurOfins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurOfins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOfins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurOfins$descriptor() {
        return SCIPincludeHeurOfins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOfins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurOfins$handle() {
        return SCIPincludeHeurOfins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOfins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurOfins$address() {
        return SCIPincludeHeurOfins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOfins(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurOfins(MemorySegment scip) {
        var mh$ = SCIPincludeHeurOfins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurOfins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurOneopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurOneopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOneopt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurOneopt$descriptor() {
        return SCIPincludeHeurOneopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOneopt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurOneopt$handle() {
        return SCIPincludeHeurOneopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOneopt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurOneopt$address() {
        return SCIPincludeHeurOneopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurOneopt(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurOneopt(MemorySegment scip) {
        var mh$ = SCIPincludeHeurOneopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurOneopt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurPADM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurPADM");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPADM(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurPADM$descriptor() {
        return SCIPincludeHeurPADM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPADM(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurPADM$handle() {
        return SCIPincludeHeurPADM.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPADM(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurPADM$address() {
        return SCIPincludeHeurPADM.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPADM(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurPADM(MemorySegment scip) {
        var mh$ = SCIPincludeHeurPADM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurPADM", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurPscostdiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurPscostdiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPscostdiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurPscostdiving$descriptor() {
        return SCIPincludeHeurPscostdiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPscostdiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurPscostdiving$handle() {
        return SCIPincludeHeurPscostdiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPscostdiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurPscostdiving$address() {
        return SCIPincludeHeurPscostdiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurPscostdiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurPscostdiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurPscostdiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurPscostdiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurProximity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurProximity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurProximity(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurProximity$descriptor() {
        return SCIPincludeHeurProximity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurProximity(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurProximity$handle() {
        return SCIPincludeHeurProximity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurProximity(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurProximity$address() {
        return SCIPincludeHeurProximity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurProximity(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurProximity(MemorySegment scip) {
        var mh$ = SCIPincludeHeurProximity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurProximity", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyProximity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyProximity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProximity(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes, long long nlpiters, long long *nusednodes, long long *nusedlpiters, unsigned int freesubscip)
     * }
     */
    public static FunctionDescriptor SCIPapplyProximity$descriptor() {
        return SCIPapplyProximity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProximity(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes, long long nlpiters, long long *nusednodes, long long *nusedlpiters, unsigned int freesubscip)
     * }
     */
    public static MethodHandle SCIPapplyProximity$handle() {
        return SCIPapplyProximity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProximity(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes, long long nlpiters, long long *nusednodes, long long *nusedlpiters, unsigned int freesubscip)
     * }
     */
    public static MemorySegment SCIPapplyProximity$address() {
        return SCIPapplyProximity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProximity(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes, long long nlpiters, long long *nusednodes, long long *nusedlpiters, unsigned int freesubscip)
     * }
     */
    public static int SCIPapplyProximity(MemorySegment scip, MemorySegment heur, MemorySegment result, double minimprove, long nnodes, long nlpiters, MemorySegment nusednodes, MemorySegment nusedlpiters, int freesubscip) {
        var mh$ = SCIPapplyProximity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyProximity", scip, heur, result, minimprove, nnodes, nlpiters, nusednodes, nusedlpiters, freesubscip);
            }
            return (int)mh$.invokeExact(scip, heur, result, minimprove, nnodes, nlpiters, nusednodes, nusedlpiters, freesubscip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeleteSubproblemProximity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeleteSubproblemProximity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteSubproblemProximity(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdeleteSubproblemProximity$descriptor() {
        return SCIPdeleteSubproblemProximity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteSubproblemProximity(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdeleteSubproblemProximity$handle() {
        return SCIPdeleteSubproblemProximity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteSubproblemProximity(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdeleteSubproblemProximity$address() {
        return SCIPdeleteSubproblemProximity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteSubproblemProximity(SCIP *scip)
     * }
     */
    public static int SCIPdeleteSubproblemProximity(MemorySegment scip) {
        var mh$ = SCIPdeleteSubproblemProximity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeleteSubproblemProximity", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRandrounding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRandrounding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRandrounding(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRandrounding$descriptor() {
        return SCIPincludeHeurRandrounding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRandrounding(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRandrounding$handle() {
        return SCIPincludeHeurRandrounding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRandrounding(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRandrounding$address() {
        return SCIPincludeHeurRandrounding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRandrounding(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRandrounding(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRandrounding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRandrounding", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRens(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRens$descriptor() {
        return SCIPincludeHeurRens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRens(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRens$handle() {
        return SCIPincludeHeurRens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRens(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRens$address() {
        return SCIPincludeHeurRens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRens(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRens(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRens", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyRens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_CHAR,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyRens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyRens(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minfixingrate, double minimprove, long long maxnodes, long long nstallnodes, char startsol, unsigned int binarybounds, unsigned int uselprows)
     * }
     */
    public static FunctionDescriptor SCIPapplyRens$descriptor() {
        return SCIPapplyRens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyRens(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minfixingrate, double minimprove, long long maxnodes, long long nstallnodes, char startsol, unsigned int binarybounds, unsigned int uselprows)
     * }
     */
    public static MethodHandle SCIPapplyRens$handle() {
        return SCIPapplyRens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyRens(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minfixingrate, double minimprove, long long maxnodes, long long nstallnodes, char startsol, unsigned int binarybounds, unsigned int uselprows)
     * }
     */
    public static MemorySegment SCIPapplyRens$address() {
        return SCIPapplyRens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyRens(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minfixingrate, double minimprove, long long maxnodes, long long nstallnodes, char startsol, unsigned int binarybounds, unsigned int uselprows)
     * }
     */
    public static int SCIPapplyRens(MemorySegment scip, MemorySegment heur, MemorySegment result, double minfixingrate, double minimprove, long maxnodes, long nstallnodes, byte startsol, int binarybounds, int uselprows) {
        var mh$ = SCIPapplyRens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyRens", scip, heur, result, minfixingrate, minimprove, maxnodes, nstallnodes, startsol, binarybounds, uselprows);
            }
            return (int)mh$.invokeExact(scip, heur, result, minfixingrate, minimprove, maxnodes, nstallnodes, startsol, binarybounds, uselprows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurReoptsols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurReoptsols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurReoptsols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurReoptsols$descriptor() {
        return SCIPincludeHeurReoptsols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurReoptsols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurReoptsols$handle() {
        return SCIPincludeHeurReoptsols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurReoptsols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurReoptsols$address() {
        return SCIPincludeHeurReoptsols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurReoptsols(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurReoptsols(MemorySegment scip) {
        var mh$ = SCIPincludeHeurReoptsols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurReoptsols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptsolsGetNCheckedsols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptsolsGetNCheckedsols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNCheckedsols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPreoptsolsGetNCheckedsols$descriptor() {
        return SCIPreoptsolsGetNCheckedsols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNCheckedsols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPreoptsolsGetNCheckedsols$handle() {
        return SCIPreoptsolsGetNCheckedsols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNCheckedsols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPreoptsolsGetNCheckedsols$address() {
        return SCIPreoptsolsGetNCheckedsols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNCheckedsols(SCIP *scip)
     * }
     */
    public static int SCIPreoptsolsGetNCheckedsols(MemorySegment scip) {
        var mh$ = SCIPreoptsolsGetNCheckedsols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptsolsGetNCheckedsols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptsolsGetNImprovingsols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptsolsGetNImprovingsols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNImprovingsols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPreoptsolsGetNImprovingsols$descriptor() {
        return SCIPreoptsolsGetNImprovingsols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNImprovingsols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPreoptsolsGetNImprovingsols$handle() {
        return SCIPreoptsolsGetNImprovingsols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNImprovingsols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPreoptsolsGetNImprovingsols$address() {
        return SCIPreoptsolsGetNImprovingsols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPreoptsolsGetNImprovingsols(SCIP *scip)
     * }
     */
    public static int SCIPreoptsolsGetNImprovingsols(MemorySegment scip) {
        var mh$ = SCIPreoptsolsGetNImprovingsols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptsolsGetNImprovingsols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRepair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRepair");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRepair(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRepair$descriptor() {
        return SCIPincludeHeurRepair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRepair(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRepair$handle() {
        return SCIPincludeHeurRepair.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRepair(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRepair$address() {
        return SCIPincludeHeurRepair.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRepair(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRepair(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRepair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRepair", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRins$descriptor() {
        return SCIPincludeHeurRins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRins$handle() {
        return SCIPincludeHeurRins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRins$address() {
        return SCIPincludeHeurRins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRins(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRins(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRootsoldiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRootsoldiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRootsoldiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRootsoldiving$descriptor() {
        return SCIPincludeHeurRootsoldiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRootsoldiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRootsoldiving$handle() {
        return SCIPincludeHeurRootsoldiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRootsoldiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRootsoldiving$address() {
        return SCIPincludeHeurRootsoldiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRootsoldiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRootsoldiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRootsoldiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRootsoldiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurRounding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurRounding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRounding(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurRounding$descriptor() {
        return SCIPincludeHeurRounding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRounding(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurRounding$handle() {
        return SCIPincludeHeurRounding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRounding(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurRounding$address() {
        return SCIPincludeHeurRounding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurRounding(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurRounding(MemorySegment scip) {
        var mh$ = SCIPincludeHeurRounding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurRounding", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurScheduler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurScheduler");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurScheduler(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurScheduler$descriptor() {
        return SCIPincludeHeurScheduler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurScheduler(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurScheduler$handle() {
        return SCIPincludeHeurScheduler.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurScheduler(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurScheduler$address() {
        return SCIPincludeHeurScheduler.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurScheduler(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurScheduler(MemorySegment scip) {
        var mh$ = SCIPincludeHeurScheduler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurScheduler", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurShiftandpropagate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurShiftandpropagate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShiftandpropagate(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurShiftandpropagate$descriptor() {
        return SCIPincludeHeurShiftandpropagate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShiftandpropagate(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurShiftandpropagate$handle() {
        return SCIPincludeHeurShiftandpropagate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShiftandpropagate(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurShiftandpropagate$address() {
        return SCIPincludeHeurShiftandpropagate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShiftandpropagate(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurShiftandpropagate(MemorySegment scip) {
        var mh$ = SCIPincludeHeurShiftandpropagate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurShiftandpropagate", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurShifting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurShifting");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShifting(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurShifting$descriptor() {
        return SCIPincludeHeurShifting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShifting(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurShifting$handle() {
        return SCIPincludeHeurShifting.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShifting(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurShifting$address() {
        return SCIPincludeHeurShifting.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurShifting(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurShifting(MemorySegment scip) {
        var mh$ = SCIPincludeHeurShifting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurShifting", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurSimplerounding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurSimplerounding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSimplerounding(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurSimplerounding$descriptor() {
        return SCIPincludeHeurSimplerounding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSimplerounding(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurSimplerounding$handle() {
        return SCIPincludeHeurSimplerounding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSimplerounding(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurSimplerounding$address() {
        return SCIPincludeHeurSimplerounding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSimplerounding(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurSimplerounding(MemorySegment scip) {
        var mh$ = SCIPincludeHeurSimplerounding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurSimplerounding", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurSubNlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurSubNlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSubNlp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurSubNlp$descriptor() {
        return SCIPincludeHeurSubNlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSubNlp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurSubNlp$handle() {
        return SCIPincludeHeurSubNlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSubNlp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurSubNlp$address() {
        return SCIPincludeHeurSubNlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurSubNlp(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurSubNlp(MemorySegment scip) {
        var mh$ = SCIPincludeHeurSubNlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurSubNlp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyHeurSubNlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyHeurSubNlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint, SCIP_SOL *resultsol)
     * }
     */
    public static FunctionDescriptor SCIPapplyHeurSubNlp$descriptor() {
        return SCIPapplyHeurSubNlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint, SCIP_SOL *resultsol)
     * }
     */
    public static MethodHandle SCIPapplyHeurSubNlp$handle() {
        return SCIPapplyHeurSubNlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint, SCIP_SOL *resultsol)
     * }
     */
    public static MemorySegment SCIPapplyHeurSubNlp$address() {
        return SCIPapplyHeurSubNlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, SCIP_SOL *refpoint, SCIP_SOL *resultsol)
     * }
     */
    public static int SCIPapplyHeurSubNlp(MemorySegment scip, MemorySegment heur, MemorySegment result, MemorySegment refpoint, MemorySegment resultsol) {
        var mh$ = SCIPapplyHeurSubNlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyHeurSubNlp", scip, heur, result, refpoint, resultsol);
            }
            return (int)mh$.invokeExact(scip, heur, result, refpoint, resultsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateStartpointHeurSubNlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateStartpointHeurSubNlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateStartpointHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *solcand, double violation)
     * }
     */
    public static FunctionDescriptor SCIPupdateStartpointHeurSubNlp$descriptor() {
        return SCIPupdateStartpointHeurSubNlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateStartpointHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *solcand, double violation)
     * }
     */
    public static MethodHandle SCIPupdateStartpointHeurSubNlp$handle() {
        return SCIPupdateStartpointHeurSubNlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateStartpointHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *solcand, double violation)
     * }
     */
    public static MemorySegment SCIPupdateStartpointHeurSubNlp$address() {
        return SCIPupdateStartpointHeurSubNlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateStartpointHeurSubNlp(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *solcand, double violation)
     * }
     */
    public static int SCIPupdateStartpointHeurSubNlp(MemorySegment scip, MemorySegment heur, MemorySegment solcand, double violation) {
        var mh$ = SCIPupdateStartpointHeurSubNlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateStartpointHeurSubNlp", scip, heur, solcand, violation);
            }
            return (int)mh$.invokeExact(scip, heur, solcand, violation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetStartCandidateHeurSubNlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetStartCandidateHeurSubNlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetStartCandidateHeurSubNlp(SCIP *scip, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPgetStartCandidateHeurSubNlp$descriptor() {
        return SCIPgetStartCandidateHeurSubNlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetStartCandidateHeurSubNlp(SCIP *scip, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPgetStartCandidateHeurSubNlp$handle() {
        return SCIPgetStartCandidateHeurSubNlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetStartCandidateHeurSubNlp(SCIP *scip, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPgetStartCandidateHeurSubNlp$address() {
        return SCIPgetStartCandidateHeurSubNlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetStartCandidateHeurSubNlp(SCIP *scip, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPgetStartCandidateHeurSubNlp(MemorySegment scip, MemorySegment heur) {
        var mh$ = SCIPgetStartCandidateHeurSubNlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetStartCandidateHeurSubNlp", scip, heur);
            }
            return (MemorySegment)mh$.invokeExact(scip, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurTrivial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurTrivial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivial(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurTrivial$descriptor() {
        return SCIPincludeHeurTrivial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivial(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurTrivial$handle() {
        return SCIPincludeHeurTrivial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivial(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurTrivial$address() {
        return SCIPincludeHeurTrivial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivial(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurTrivial(MemorySegment scip) {
        var mh$ = SCIPincludeHeurTrivial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurTrivial", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurTrivialnegation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurTrivialnegation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivialnegation(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurTrivialnegation$descriptor() {
        return SCIPincludeHeurTrivialnegation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivialnegation(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurTrivialnegation$handle() {
        return SCIPincludeHeurTrivialnegation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivialnegation(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurTrivialnegation$address() {
        return SCIPincludeHeurTrivialnegation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrivialnegation(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurTrivialnegation(MemorySegment scip) {
        var mh$ = SCIPincludeHeurTrivialnegation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurTrivialnegation", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurTrustregion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurTrustregion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrustregion(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurTrustregion$descriptor() {
        return SCIPincludeHeurTrustregion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrustregion(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurTrustregion$handle() {
        return SCIPincludeHeurTrustregion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrustregion(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurTrustregion$address() {
        return SCIPincludeHeurTrustregion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrustregion(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurTrustregion(MemorySegment scip) {
        var mh$ = SCIPincludeHeurTrustregion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurTrustregion", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurTrySol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurTrySol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrySol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurTrySol$descriptor() {
        return SCIPincludeHeurTrySol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrySol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurTrySol$handle() {
        return SCIPincludeHeurTrySol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrySol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurTrySol$address() {
        return SCIPincludeHeurTrySol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTrySol(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurTrySol(MemorySegment scip) {
        var mh$ = SCIPincludeHeurTrySol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurTrySol", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurPassSolTrySol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurPassSolTrySol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolTrySol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPheurPassSolTrySol$descriptor() {
        return SCIPheurPassSolTrySol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolTrySol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPheurPassSolTrySol$handle() {
        return SCIPheurPassSolTrySol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolTrySol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPheurPassSolTrySol$address() {
        return SCIPheurPassSolTrySol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolTrySol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static int SCIPheurPassSolTrySol(MemorySegment scip, MemorySegment heur, MemorySegment sol) {
        var mh$ = SCIPheurPassSolTrySol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurPassSolTrySol", scip, heur, sol);
            }
            return (int)mh$.invokeExact(scip, heur, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPheurPassSolAddSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPheurPassSolAddSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolAddSol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPheurPassSolAddSol$descriptor() {
        return SCIPheurPassSolAddSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolAddSol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPheurPassSolAddSol$handle() {
        return SCIPheurPassSolAddSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolAddSol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPheurPassSolAddSol$address() {
        return SCIPheurPassSolAddSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPheurPassSolAddSol(SCIP *scip, SCIP_HEUR *heur, SCIP_SOL *sol)
     * }
     */
    public static int SCIPheurPassSolAddSol(MemorySegment scip, MemorySegment heur, MemorySegment sol) {
        var mh$ = SCIPheurPassSolAddSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPheurPassSolAddSol", scip, heur, sol);
            }
            return (int)mh$.invokeExact(scip, heur, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurTwoopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurTwoopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTwoopt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurTwoopt$descriptor() {
        return SCIPincludeHeurTwoopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTwoopt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurTwoopt$handle() {
        return SCIPincludeHeurTwoopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTwoopt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurTwoopt$address() {
        return SCIPincludeHeurTwoopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurTwoopt(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurTwoopt(MemorySegment scip) {
        var mh$ = SCIPincludeHeurTwoopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurTwoopt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurUndercover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurUndercover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurUndercover(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurUndercover$descriptor() {
        return SCIPincludeHeurUndercover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurUndercover(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurUndercover$handle() {
        return SCIPincludeHeurUndercover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurUndercover(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurUndercover$address() {
        return SCIPincludeHeurUndercover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurUndercover(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurUndercover(MemorySegment scip) {
        var mh$ = SCIPincludeHeurUndercover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurUndercover", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeCoverUndercover {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeCoverUndercover");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeCoverUndercover(SCIP *scip, int *coversize, SCIP_VAR **cover, double timelimit, double memorylimit, double objlimit, unsigned int globalbounds, unsigned int onlyconvexify, unsigned int coverand, unsigned int coverbd, unsigned int coverind, unsigned int covernl, char coveringobj, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcomputeCoverUndercover$descriptor() {
        return SCIPcomputeCoverUndercover.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeCoverUndercover(SCIP *scip, int *coversize, SCIP_VAR **cover, double timelimit, double memorylimit, double objlimit, unsigned int globalbounds, unsigned int onlyconvexify, unsigned int coverand, unsigned int coverbd, unsigned int coverind, unsigned int covernl, char coveringobj, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcomputeCoverUndercover$handle() {
        return SCIPcomputeCoverUndercover.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeCoverUndercover(SCIP *scip, int *coversize, SCIP_VAR **cover, double timelimit, double memorylimit, double objlimit, unsigned int globalbounds, unsigned int onlyconvexify, unsigned int coverand, unsigned int coverbd, unsigned int coverind, unsigned int covernl, char coveringobj, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcomputeCoverUndercover$address() {
        return SCIPcomputeCoverUndercover.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeCoverUndercover(SCIP *scip, int *coversize, SCIP_VAR **cover, double timelimit, double memorylimit, double objlimit, unsigned int globalbounds, unsigned int onlyconvexify, unsigned int coverand, unsigned int coverbd, unsigned int coverind, unsigned int covernl, char coveringobj, unsigned int *success)
     * }
     */
    public static int SCIPcomputeCoverUndercover(MemorySegment scip, MemorySegment coversize, MemorySegment cover, double timelimit, double memorylimit, double objlimit, int globalbounds, int onlyconvexify, int coverand, int coverbd, int coverind, int covernl, byte coveringobj, MemorySegment success) {
        var mh$ = SCIPcomputeCoverUndercover.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeCoverUndercover", scip, coversize, cover, timelimit, memorylimit, objlimit, globalbounds, onlyconvexify, coverand, coverbd, coverind, covernl, coveringobj, success);
            }
            return (int)mh$.invokeExact(scip, coversize, cover, timelimit, memorylimit, objlimit, globalbounds, onlyconvexify, coverand, coverbd, coverind, covernl, coveringobj, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurVbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurVbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVbounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurVbounds$descriptor() {
        return SCIPincludeHeurVbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVbounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurVbounds$handle() {
        return SCIPincludeHeurVbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVbounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurVbounds$address() {
        return SCIPincludeHeurVbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVbounds(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurVbounds(MemorySegment scip) {
        var mh$ = SCIPincludeHeurVbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurVbounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurVeclendiving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurVeclendiving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVeclendiving(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurVeclendiving$descriptor() {
        return SCIPincludeHeurVeclendiving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVeclendiving(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurVeclendiving$handle() {
        return SCIPincludeHeurVeclendiving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVeclendiving(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurVeclendiving$address() {
        return SCIPincludeHeurVeclendiving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurVeclendiving(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurVeclendiving(MemorySegment scip) {
        var mh$ = SCIPincludeHeurVeclendiving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurVeclendiving", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurZeroobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurZeroobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZeroobj(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurZeroobj$descriptor() {
        return SCIPincludeHeurZeroobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZeroobj(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurZeroobj$handle() {
        return SCIPincludeHeurZeroobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZeroobj(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurZeroobj$address() {
        return SCIPincludeHeurZeroobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZeroobj(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurZeroobj(MemorySegment scip) {
        var mh$ = SCIPincludeHeurZeroobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurZeroobj", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyZeroobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyZeroobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyZeroobj(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes)
     * }
     */
    public static FunctionDescriptor SCIPapplyZeroobj$descriptor() {
        return SCIPapplyZeroobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyZeroobj(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes)
     * }
     */
    public static MethodHandle SCIPapplyZeroobj$handle() {
        return SCIPapplyZeroobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyZeroobj(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes)
     * }
     */
    public static MemorySegment SCIPapplyZeroobj$address() {
        return SCIPapplyZeroobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyZeroobj(SCIP *scip, SCIP_HEUR *heur, SCIP_RESULT *result, double minimprove, long long nnodes)
     * }
     */
    public static int SCIPapplyZeroobj(MemorySegment scip, MemorySegment heur, MemorySegment result, double minimprove, long nnodes) {
        var mh$ = SCIPapplyZeroobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyZeroobj", scip, heur, result, minimprove, nnodes);
            }
            return (int)mh$.invokeExact(scip, heur, result, minimprove, nnodes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurZirounding {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurZirounding");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZirounding(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurZirounding$descriptor() {
        return SCIPincludeHeurZirounding.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZirounding(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeHeurZirounding$handle() {
        return SCIPincludeHeurZirounding.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZirounding(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeHeurZirounding$address() {
        return SCIPincludeHeurZirounding.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurZirounding(SCIP *scip)
     * }
     */
    public static int SCIPincludeHeurZirounding(MemorySegment scip) {
        var mh$ = SCIPincludeHeurZirounding.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurZirounding", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetCopyHdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetCopyHdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetCopyHdlr(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*copy)(SCIP *, SCIP_CONSHDLR *, SCIP_CONSHDLR *, SCIP_NLHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetCopyHdlr$descriptor() {
        return SCIPnlhdlrSetCopyHdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetCopyHdlr(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*copy)(SCIP *, SCIP_CONSHDLR *, SCIP_CONSHDLR *, SCIP_NLHDLR *))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetCopyHdlr$handle() {
        return SCIPnlhdlrSetCopyHdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetCopyHdlr(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*copy)(SCIP *, SCIP_CONSHDLR *, SCIP_CONSHDLR *, SCIP_NLHDLR *))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetCopyHdlr$address() {
        return SCIPnlhdlrSetCopyHdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetCopyHdlr(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*copy)(SCIP *, SCIP_CONSHDLR *, SCIP_CONSHDLR *, SCIP_NLHDLR *))
     * }
     */
    public static void SCIPnlhdlrSetCopyHdlr(MemorySegment nlhdlr, MemorySegment copy) {
        var mh$ = SCIPnlhdlrSetCopyHdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetCopyHdlr", nlhdlr, copy);
            }
            mh$.invokeExact(nlhdlr, copy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetFreeHdlrData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetFreeHdlrData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeHdlrData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freehdlrdata)(SCIP *, SCIP_NLHDLR *, SCIP_NLHDLRDATA **))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetFreeHdlrData$descriptor() {
        return SCIPnlhdlrSetFreeHdlrData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeHdlrData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freehdlrdata)(SCIP *, SCIP_NLHDLR *, SCIP_NLHDLRDATA **))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetFreeHdlrData$handle() {
        return SCIPnlhdlrSetFreeHdlrData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeHdlrData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freehdlrdata)(SCIP *, SCIP_NLHDLR *, SCIP_NLHDLRDATA **))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetFreeHdlrData$address() {
        return SCIPnlhdlrSetFreeHdlrData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeHdlrData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freehdlrdata)(SCIP *, SCIP_NLHDLR *, SCIP_NLHDLRDATA **))
     * }
     */
    public static void SCIPnlhdlrSetFreeHdlrData(MemorySegment nlhdlr, MemorySegment freehdlrdata) {
        var mh$ = SCIPnlhdlrSetFreeHdlrData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetFreeHdlrData", nlhdlr, freehdlrdata);
            }
            mh$.invokeExact(nlhdlr, freehdlrdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetFreeExprData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetFreeExprData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeExprData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freeexprdata)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA **))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetFreeExprData$descriptor() {
        return SCIPnlhdlrSetFreeExprData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeExprData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freeexprdata)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA **))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetFreeExprData$handle() {
        return SCIPnlhdlrSetFreeExprData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeExprData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freeexprdata)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA **))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetFreeExprData$address() {
        return SCIPnlhdlrSetFreeExprData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetFreeExprData(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*freeexprdata)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA **))
     * }
     */
    public static void SCIPnlhdlrSetFreeExprData(MemorySegment nlhdlr, MemorySegment freeexprdata) {
        var mh$ = SCIPnlhdlrSetFreeExprData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetFreeExprData", nlhdlr, freeexprdata);
            }
            mh$.invokeExact(nlhdlr, freeexprdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetInitExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetInitExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetInitExit(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*init)(SCIP *, SCIP_NLHDLR *), SCIP_RETCODE (*exit)(SCIP *, SCIP_NLHDLR *))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetInitExit$descriptor() {
        return SCIPnlhdlrSetInitExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetInitExit(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*init)(SCIP *, SCIP_NLHDLR *), SCIP_RETCODE (*exit)(SCIP *, SCIP_NLHDLR *))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetInitExit$handle() {
        return SCIPnlhdlrSetInitExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetInitExit(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*init)(SCIP *, SCIP_NLHDLR *), SCIP_RETCODE (*exit)(SCIP *, SCIP_NLHDLR *))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetInitExit$address() {
        return SCIPnlhdlrSetInitExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetInitExit(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*init)(SCIP *, SCIP_NLHDLR *), SCIP_RETCODE (*exit)(SCIP *, SCIP_NLHDLR *))
     * }
     */
    public static void SCIPnlhdlrSetInitExit(MemorySegment nlhdlr, MemorySegment init, MemorySegment exit) {
        var mh$ = SCIPnlhdlrSetInitExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetInitExit", nlhdlr, init, exit);
            }
            mh$.invokeExact(nlhdlr, init, exit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetProp(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *), SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL, unsigned int *, int *))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetProp$descriptor() {
        return SCIPnlhdlrSetProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetProp(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *), SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL, unsigned int *, int *))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetProp$handle() {
        return SCIPnlhdlrSetProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetProp(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *), SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL, unsigned int *, int *))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetProp$address() {
        return SCIPnlhdlrSetProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetProp(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*inteval)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL *, SCIP_INTERVAL (*)(SCIP *, SCIP_VAR *, void *), void *), SCIP_RETCODE (*reverseprop)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_INTERVAL, unsigned int *, int *))
     * }
     */
    public static void SCIPnlhdlrSetProp(MemorySegment nlhdlr, MemorySegment inteval, MemorySegment reverseprop) {
        var mh$ = SCIPnlhdlrSetProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetProp", nlhdlr, inteval, reverseprop);
            }
            mh$.invokeExact(nlhdlr, inteval, reverseprop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSepa(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*initsepa)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*enfo)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, double, unsigned int, SCIP_PTRARRAY *, unsigned int *, unsigned int *), SCIP_RETCODE (*exitsepa)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetSepa$descriptor() {
        return SCIPnlhdlrSetSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSepa(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*initsepa)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*enfo)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, double, unsigned int, SCIP_PTRARRAY *, unsigned int *, unsigned int *), SCIP_RETCODE (*exitsepa)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetSepa$handle() {
        return SCIPnlhdlrSetSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSepa(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*initsepa)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*enfo)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, double, unsigned int, SCIP_PTRARRAY *, unsigned int *, unsigned int *), SCIP_RETCODE (*exitsepa)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetSepa$address() {
        return SCIPnlhdlrSetSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSepa(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*initsepa)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, unsigned int, unsigned int, unsigned int *), SCIP_RETCODE (*enfo)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, SCIP_RESULT *), SCIP_RETCODE (*estimate)(SCIP *, SCIP_CONSHDLR *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, double, unsigned int, double, unsigned int, SCIP_PTRARRAY *, unsigned int *, unsigned int *), SCIP_RETCODE (*exitsepa)(SCIP *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *))
     * }
     */
    public static void SCIPnlhdlrSetSepa(MemorySegment nlhdlr, MemorySegment initsepa, MemorySegment enfo, MemorySegment estimate, MemorySegment exitsepa) {
        var mh$ = SCIPnlhdlrSetSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetSepa", nlhdlr, initsepa, enfo, estimate, exitsepa);
            }
            mh$.invokeExact(nlhdlr, initsepa, enfo, estimate, exitsepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrSetSollinearize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrSetSollinearize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSollinearize(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*sollinearize)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, unsigned int, unsigned int, unsigned int))
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrSetSollinearize$descriptor() {
        return SCIPnlhdlrSetSollinearize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSollinearize(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*sollinearize)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, unsigned int, unsigned int, unsigned int))
     * }
     */
    public static MethodHandle SCIPnlhdlrSetSollinearize$handle() {
        return SCIPnlhdlrSetSollinearize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSollinearize(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*sollinearize)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, unsigned int, unsigned int, unsigned int))
     * }
     */
    public static MemorySegment SCIPnlhdlrSetSollinearize$address() {
        return SCIPnlhdlrSetSollinearize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlhdlrSetSollinearize(SCIP_NLHDLR *nlhdlr, SCIP_RETCODE (*sollinearize)(SCIP *, SCIP_CONSHDLR *, SCIP_CONS *, SCIP_NLHDLR *, SCIP_EXPR *, SCIP_NLHDLREXPRDATA *, SCIP_SOL *, unsigned int, unsigned int, unsigned int))
     * }
     */
    public static void SCIPnlhdlrSetSollinearize(MemorySegment nlhdlr, MemorySegment sollinearize) {
        var mh$ = SCIPnlhdlrSetSollinearize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrSetSollinearize", nlhdlr, sollinearize);
            }
            mh$.invokeExact(nlhdlr, sollinearize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetName(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrGetName$descriptor() {
        return SCIPnlhdlrGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetName(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrGetName$handle() {
        return SCIPnlhdlrGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetName(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetName$address() {
        return SCIPnlhdlrGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetName(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetName(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrGetName", nlhdlr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetDesc(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrGetDesc$descriptor() {
        return SCIPnlhdlrGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetDesc(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrGetDesc$handle() {
        return SCIPnlhdlrGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetDesc(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetDesc$address() {
        return SCIPnlhdlrGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnlhdlrGetDesc(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetDesc(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrGetDesc", nlhdlr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrGetDetectPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrGetDetectPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetDetectPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrGetDetectPriority$descriptor() {
        return SCIPnlhdlrGetDetectPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetDetectPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrGetDetectPriority$handle() {
        return SCIPnlhdlrGetDetectPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetDetectPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetDetectPriority$address() {
        return SCIPnlhdlrGetDetectPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlhdlrGetDetectPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrGetDetectPriority(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrGetDetectPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrGetDetectPriority", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrGetEnfoPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrGetEnfoPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetEnfoPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrGetEnfoPriority$descriptor() {
        return SCIPnlhdlrGetEnfoPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetEnfoPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrGetEnfoPriority$handle() {
        return SCIPnlhdlrGetEnfoPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlhdlrGetEnfoPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetEnfoPriority$address() {
        return SCIPnlhdlrGetEnfoPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlhdlrGetEnfoPriority(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrGetEnfoPriority(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrGetEnfoPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrGetEnfoPriority", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrIsEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrIsEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrIsEnabled(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrIsEnabled$descriptor() {
        return SCIPnlhdlrIsEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrIsEnabled(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrIsEnabled$handle() {
        return SCIPnlhdlrIsEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrIsEnabled(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrIsEnabled$address() {
        return SCIPnlhdlrIsEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrIsEnabled(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrIsEnabled(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrIsEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrIsEnabled", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLHDLRDATA *SCIPnlhdlrGetData(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrGetData$descriptor() {
        return SCIPnlhdlrGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLHDLRDATA *SCIPnlhdlrGetData(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrGetData$handle() {
        return SCIPnlhdlrGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLHDLRDATA *SCIPnlhdlrGetData(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetData$address() {
        return SCIPnlhdlrGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLHDLRDATA *SCIPnlhdlrGetData(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrGetData(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrGetData", nlhdlr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasIntEval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasIntEval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasIntEval(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasIntEval$descriptor() {
        return SCIPnlhdlrHasIntEval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasIntEval(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasIntEval$handle() {
        return SCIPnlhdlrHasIntEval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasIntEval(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasIntEval$address() {
        return SCIPnlhdlrHasIntEval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasIntEval(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasIntEval(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasIntEval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasIntEval", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasReverseProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasReverseProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasReverseProp(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasReverseProp$descriptor() {
        return SCIPnlhdlrHasReverseProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasReverseProp(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasReverseProp$handle() {
        return SCIPnlhdlrHasReverseProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasReverseProp(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasReverseProp$address() {
        return SCIPnlhdlrHasReverseProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasReverseProp(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasReverseProp(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasReverseProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasReverseProp", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasInitSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasInitSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasInitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasInitSepa$descriptor() {
        return SCIPnlhdlrHasInitSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasInitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasInitSepa$handle() {
        return SCIPnlhdlrHasInitSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasInitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasInitSepa$address() {
        return SCIPnlhdlrHasInitSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasInitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasInitSepa(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasInitSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasInitSepa", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasExitSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasExitSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasExitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasExitSepa$descriptor() {
        return SCIPnlhdlrHasExitSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasExitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasExitSepa$handle() {
        return SCIPnlhdlrHasExitSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasExitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasExitSepa$address() {
        return SCIPnlhdlrHasExitSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasExitSepa(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasExitSepa(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasExitSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasExitSepa", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasEnfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasEnfo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEnfo(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasEnfo$descriptor() {
        return SCIPnlhdlrHasEnfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEnfo(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasEnfo$handle() {
        return SCIPnlhdlrHasEnfo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEnfo(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasEnfo$address() {
        return SCIPnlhdlrHasEnfo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEnfo(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasEnfo(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasEnfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasEnfo", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEstimate(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasEstimate$descriptor() {
        return SCIPnlhdlrHasEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEstimate(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasEstimate$handle() {
        return SCIPnlhdlrHasEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEstimate(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasEstimate$address() {
        return SCIPnlhdlrHasEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasEstimate(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasEstimate(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasEstimate", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrHasSollinearize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrHasSollinearize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasSollinearize(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrHasSollinearize$descriptor() {
        return SCIPnlhdlrHasSollinearize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasSollinearize(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPnlhdlrHasSollinearize$handle() {
        return SCIPnlhdlrHasSollinearize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasSollinearize(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPnlhdlrHasSollinearize$address() {
        return SCIPnlhdlrHasSollinearize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPnlhdlrHasSollinearize(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPnlhdlrHasSollinearize(MemorySegment nlhdlr) {
        var mh$ = SCIPnlhdlrHasSollinearize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrHasSollinearize", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlhdlrComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlhdlrComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPnlhdlrComp$descriptor() {
        return SCIPnlhdlrComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPnlhdlrComp$handle() {
        return SCIPnlhdlrComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPnlhdlrComp$address() {
        return SCIPnlhdlrComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlhdlrComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPnlhdlrComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPnlhdlrComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlhdlrComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrBilinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrBilinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrBilinear(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrBilinear$descriptor() {
        return SCIPincludeNlhdlrBilinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrBilinear(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrBilinear$handle() {
        return SCIPincludeNlhdlrBilinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrBilinear(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrBilinear$address() {
        return SCIPincludeNlhdlrBilinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrBilinear(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrBilinear(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrBilinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrBilinear", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprsBilinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprsBilinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPgetExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprsBilinear$descriptor() {
        return SCIPgetExprsBilinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPgetExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPgetExprsBilinear$handle() {
        return SCIPgetExprsBilinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPgetExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPgetExprsBilinear$address() {
        return SCIPgetExprsBilinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_EXPR **SCIPgetExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPgetExprsBilinear(MemorySegment nlhdlr) {
        var mh$ = SCIPgetExprsBilinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprsBilinear", nlhdlr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprsdataBilinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprsdataBilinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA **SCIPgetExprsdataBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetExprsdataBilinear$descriptor() {
        return SCIPgetExprsdataBilinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA **SCIPgetExprsdataBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPgetExprsdataBilinear$handle() {
        return SCIPgetExprsdataBilinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA **SCIPgetExprsdataBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPgetExprsdataBilinear$address() {
        return SCIPgetExprsdataBilinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLHDLREXPRDATA **SCIPgetExprsdataBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPgetExprsdataBilinear(MemorySegment nlhdlr) {
        var mh$ = SCIPgetExprsdataBilinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprsdataBilinear", nlhdlr);
            }
            return (MemorySegment)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNExprsBilinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNExprsBilinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static FunctionDescriptor SCIPgetNExprsBilinear$descriptor() {
        return SCIPgetNExprsBilinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MethodHandle SCIPgetNExprsBilinear$handle() {
        return SCIPgetNExprsBilinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static MemorySegment SCIPgetNExprsBilinear$address() {
        return SCIPgetNExprsBilinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNExprsBilinear(SCIP_NLHDLR *nlhdlr)
     * }
     */
    public static int SCIPgetNExprsBilinear(MemorySegment nlhdlr) {
        var mh$ = SCIPgetNExprsBilinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNExprsBilinear", nlhdlr);
            }
            return (int)mh$.invokeExact(nlhdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddIneqBilinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddIneqBilinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIneqBilinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr, double xcoef, double ycoef, double constant, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddIneqBilinear$descriptor() {
        return SCIPaddIneqBilinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIneqBilinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr, double xcoef, double ycoef, double constant, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddIneqBilinear$handle() {
        return SCIPaddIneqBilinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIneqBilinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr, double xcoef, double ycoef, double constant, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddIneqBilinear$address() {
        return SCIPaddIneqBilinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIneqBilinear(SCIP *scip, SCIP_NLHDLR *nlhdlr, SCIP_EXPR *expr, double xcoef, double ycoef, double constant, unsigned int *success)
     * }
     */
    public static int SCIPaddIneqBilinear(MemorySegment scip, MemorySegment nlhdlr, MemorySegment expr, double xcoef, double ycoef, double constant, MemorySegment success) {
        var mh$ = SCIPaddIneqBilinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddIneqBilinear", scip, nlhdlr, expr, xcoef, ycoef, constant, success);
            }
            return (int)mh$.invokeExact(scip, nlhdlr, expr, xcoef, ycoef, constant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddBilinLinearization {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddBilinLinearization");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddBilinLinearization(SCIP *scip, double bilincoef, double refpointx, double refpointy, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddBilinLinearization$descriptor() {
        return SCIPaddBilinLinearization.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddBilinLinearization(SCIP *scip, double bilincoef, double refpointx, double refpointy, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddBilinLinearization$handle() {
        return SCIPaddBilinLinearization.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddBilinLinearization(SCIP *scip, double bilincoef, double refpointx, double refpointy, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddBilinLinearization$address() {
        return SCIPaddBilinLinearization.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddBilinLinearization(SCIP *scip, double bilincoef, double refpointx, double refpointy, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static void SCIPaddBilinLinearization(MemorySegment scip, double bilincoef, double refpointx, double refpointy, MemorySegment lincoefx, MemorySegment lincoefy, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPaddBilinLinearization.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddBilinLinearization", scip, bilincoef, refpointx, refpointy, lincoefx, lincoefy, linconstant, success);
            }
            mh$.invokeExact(scip, bilincoef, refpointx, refpointy, lincoefx, lincoefy, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddBilinMcCormick {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddBilinMcCormick");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddBilinMcCormick(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPaddBilinMcCormick$descriptor() {
        return SCIPaddBilinMcCormick.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddBilinMcCormick(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPaddBilinMcCormick$handle() {
        return SCIPaddBilinMcCormick.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddBilinMcCormick(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPaddBilinMcCormick$address() {
        return SCIPaddBilinMcCormick.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddBilinMcCormick(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double *lincoefx, double *lincoefy, double *linconstant, unsigned int *success)
     * }
     */
    public static void SCIPaddBilinMcCormick(MemorySegment scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, int overestimate, MemorySegment lincoefx, MemorySegment lincoefy, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPaddBilinMcCormick.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddBilinMcCormick", scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, lincoefx, lincoefy, linconstant, success);
            }
            mh$.invokeExact(scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, lincoefx, lincoefy, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeBilinEnvelope1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeBilinEnvelope1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope1(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double xcoef, double ycoef, double constant, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static FunctionDescriptor SCIPcomputeBilinEnvelope1$descriptor() {
        return SCIPcomputeBilinEnvelope1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope1(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double xcoef, double ycoef, double constant, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static MethodHandle SCIPcomputeBilinEnvelope1$handle() {
        return SCIPcomputeBilinEnvelope1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope1(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double xcoef, double ycoef, double constant, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static MemorySegment SCIPcomputeBilinEnvelope1$address() {
        return SCIPcomputeBilinEnvelope1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope1(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double xcoef, double ycoef, double constant, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static void SCIPcomputeBilinEnvelope1(MemorySegment scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, int overestimate, double xcoef, double ycoef, double constant, MemorySegment lincoefx, MemorySegment lincoefy, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPcomputeBilinEnvelope1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeBilinEnvelope1", scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, xcoef, ycoef, constant, lincoefx, lincoefy, linconstant, success);
            }
            mh$.invokeExact(scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, xcoef, ycoef, constant, lincoefx, lincoefy, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeBilinEnvelope2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeBilinEnvelope2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope2(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double alpha1, double beta1, double gamma1, double alpha2, double beta2, double gamma2, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static FunctionDescriptor SCIPcomputeBilinEnvelope2$descriptor() {
        return SCIPcomputeBilinEnvelope2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope2(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double alpha1, double beta1, double gamma1, double alpha2, double beta2, double gamma2, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static MethodHandle SCIPcomputeBilinEnvelope2$handle() {
        return SCIPcomputeBilinEnvelope2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope2(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double alpha1, double beta1, double gamma1, double alpha2, double beta2, double gamma2, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static MemorySegment SCIPcomputeBilinEnvelope2$address() {
        return SCIPcomputeBilinEnvelope2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcomputeBilinEnvelope2(SCIP *scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, unsigned int overestimate, double alpha1, double beta1, double gamma1, double alpha2, double beta2, double gamma2, double *restrict lincoefx, double *restrict lincoefy, double *restrict linconstant, unsigned int *restrict success)
     * }
     */
    public static void SCIPcomputeBilinEnvelope2(MemorySegment scip, double bilincoef, double lbx, double ubx, double refpointx, double lby, double uby, double refpointy, int overestimate, double alpha1, double beta1, double gamma1, double alpha2, double beta2, double gamma2, MemorySegment lincoefx, MemorySegment lincoefy, MemorySegment linconstant, MemorySegment success) {
        var mh$ = SCIPcomputeBilinEnvelope2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeBilinEnvelope2", scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, alpha1, beta1, gamma1, alpha2, beta2, gamma2, lincoefx, lincoefy, linconstant, success);
            }
            mh$.invokeExact(scip, bilincoef, lbx, ubx, refpointx, lby, uby, refpointy, overestimate, alpha1, beta1, gamma1, alpha2, beta2, gamma2, lincoefx, lincoefy, linconstant, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrConvex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrConvex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConvex(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrConvex$descriptor() {
        return SCIPincludeNlhdlrConvex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConvex(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrConvex$handle() {
        return SCIPincludeNlhdlrConvex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConvex(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrConvex$address() {
        return SCIPincludeNlhdlrConvex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConvex(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrConvex(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrConvex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrConvex", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrConcave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrConcave");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConcave(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrConcave$descriptor() {
        return SCIPincludeNlhdlrConcave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConcave(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrConcave$handle() {
        return SCIPincludeNlhdlrConcave.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConcave(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrConcave$address() {
        return SCIPincludeNlhdlrConcave.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrConcave(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrConcave(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrConcave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrConcave", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasExprCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasExprCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV curv, unsigned int *success, SCIP_HASHMAP *assumevarfixed)
     * }
     */
    public static FunctionDescriptor SCIPhasExprCurvature$descriptor() {
        return SCIPhasExprCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV curv, unsigned int *success, SCIP_HASHMAP *assumevarfixed)
     * }
     */
    public static MethodHandle SCIPhasExprCurvature$handle() {
        return SCIPhasExprCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV curv, unsigned int *success, SCIP_HASHMAP *assumevarfixed)
     * }
     */
    public static MemorySegment SCIPhasExprCurvature$address() {
        return SCIPhasExprCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV curv, unsigned int *success, SCIP_HASHMAP *assumevarfixed)
     * }
     */
    public static int SCIPhasExprCurvature(MemorySegment scip, MemorySegment expr, int curv, MemorySegment success, MemorySegment assumevarfixed) {
        var mh$ = SCIPhasExprCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasExprCurvature", scip, expr, curv, success, assumevarfixed);
            }
            return (int)mh$.invokeExact(scip, expr, curv, success, assumevarfixed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrDefault(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrDefault$descriptor() {
        return SCIPincludeNlhdlrDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrDefault(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrDefault$handle() {
        return SCIPincludeNlhdlrDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrDefault(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrDefault$address() {
        return SCIPincludeNlhdlrDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrDefault(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrDefault(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrDefault", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrPerspective(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrPerspective$descriptor() {
        return SCIPincludeNlhdlrPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrPerspective(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrPerspective$handle() {
        return SCIPincludeNlhdlrPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrPerspective(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrPerspective$address() {
        return SCIPincludeNlhdlrPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrPerspective(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrPerspective(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrPerspective", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuadratic(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrQuadratic$descriptor() {
        return SCIPincludeNlhdlrQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuadratic(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrQuadratic$handle() {
        return SCIPincludeNlhdlrQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuadratic(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrQuadratic$address() {
        return SCIPincludeNlhdlrQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuadratic(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrQuadratic(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrQuadratic", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrQuotient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrQuotient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuotient(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrQuotient$descriptor() {
        return SCIPincludeNlhdlrQuotient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuotient(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrQuotient$handle() {
        return SCIPincludeNlhdlrQuotient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuotient(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrQuotient$address() {
        return SCIPincludeNlhdlrQuotient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrQuotient(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrQuotient(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrQuotient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrQuotient", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrSignomial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrSignomial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSignomial(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrSignomial$descriptor() {
        return SCIPincludeNlhdlrSignomial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSignomial(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrSignomial$handle() {
        return SCIPincludeNlhdlrSignomial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSignomial(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrSignomial$address() {
        return SCIPincludeNlhdlrSignomial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSignomial(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrSignomial(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrSignomial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrSignomial", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlhdlrSoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlhdlrSoc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSoc(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlhdlrSoc$descriptor() {
        return SCIPincludeNlhdlrSoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSoc(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlhdlrSoc$handle() {
        return SCIPincludeNlhdlrSoc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSoc(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlhdlrSoc$address() {
        return SCIPincludeNlhdlrSoc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlhdlrSoc(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlhdlrSoc(MemorySegment scip) {
        var mh$ = SCIPincludeNlhdlrSoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlhdlrSoc", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSOCNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSOCNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisSOCNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int compeigenvalues, unsigned int *success, SCIP_SIDETYPE *sidetype, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int *nvars, int *nterms)
     * }
     */
    public static FunctionDescriptor SCIPisSOCNonlinear$descriptor() {
        return SCIPisSOCNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisSOCNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int compeigenvalues, unsigned int *success, SCIP_SIDETYPE *sidetype, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int *nvars, int *nterms)
     * }
     */
    public static MethodHandle SCIPisSOCNonlinear$handle() {
        return SCIPisSOCNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisSOCNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int compeigenvalues, unsigned int *success, SCIP_SIDETYPE *sidetype, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int *nvars, int *nterms)
     * }
     */
    public static MemorySegment SCIPisSOCNonlinear$address() {
        return SCIPisSOCNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisSOCNonlinear(SCIP *scip, SCIP_CONS *cons, unsigned int compeigenvalues, unsigned int *success, SCIP_SIDETYPE *sidetype, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int *nvars, int *nterms)
     * }
     */
    public static int SCIPisSOCNonlinear(MemorySegment scip, MemorySegment cons, int compeigenvalues, MemorySegment success, MemorySegment sidetype, MemorySegment vars, MemorySegment offsets, MemorySegment transcoefs, MemorySegment transcoefsidx, MemorySegment termbegins, MemorySegment nvars, MemorySegment nterms) {
        var mh$ = SCIPisSOCNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSOCNonlinear", scip, cons, compeigenvalues, success, sidetype, vars, offsets, transcoefs, transcoefsidx, termbegins, nvars, nterms);
            }
            return (int)mh$.invokeExact(scip, cons, compeigenvalues, success, sidetype, vars, offsets, transcoefs, transcoefsidx, termbegins, nvars, nterms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeSOCArraysNonlinear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeSOCArraysNonlinear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeSOCArraysNonlinear(SCIP *scip, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int nvars, int nterms)
     * }
     */
    public static FunctionDescriptor SCIPfreeSOCArraysNonlinear$descriptor() {
        return SCIPfreeSOCArraysNonlinear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeSOCArraysNonlinear(SCIP *scip, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int nvars, int nterms)
     * }
     */
    public static MethodHandle SCIPfreeSOCArraysNonlinear$handle() {
        return SCIPfreeSOCArraysNonlinear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeSOCArraysNonlinear(SCIP *scip, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int nvars, int nterms)
     * }
     */
    public static MemorySegment SCIPfreeSOCArraysNonlinear$address() {
        return SCIPfreeSOCArraysNonlinear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeSOCArraysNonlinear(SCIP *scip, SCIP_VAR ***vars, double **offsets, double **transcoefs, int **transcoefsidx, int **termbegins, int nvars, int nterms)
     * }
     */
    public static void SCIPfreeSOCArraysNonlinear(MemorySegment scip, MemorySegment vars, MemorySegment offsets, MemorySegment transcoefs, MemorySegment transcoefsidx, MemorySegment termbegins, int nvars, int nterms) {
        var mh$ = SCIPfreeSOCArraysNonlinear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeSOCArraysNonlinear", scip, vars, offsets, transcoefs, transcoefsidx, termbegins, nvars, nterms);
            }
            mh$.invokeExact(scip, vars, offsets, transcoefs, transcoefsidx, termbegins, nvars, nterms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselBfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselBfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBfs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselBfs$descriptor() {
        return SCIPincludeNodeselBfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBfs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselBfs$handle() {
        return SCIPincludeNodeselBfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBfs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselBfs$address() {
        return SCIPincludeNodeselBfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBfs(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselBfs(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselBfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselBfs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselBreadthfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselBreadthfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBreadthfirst(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselBreadthfirst$descriptor() {
        return SCIPincludeNodeselBreadthfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBreadthfirst(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselBreadthfirst$handle() {
        return SCIPincludeNodeselBreadthfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBreadthfirst(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselBreadthfirst$address() {
        return SCIPincludeNodeselBreadthfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBreadthfirst(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselBreadthfirst(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselBreadthfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselBreadthfirst", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselDfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselDfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselDfs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselDfs$descriptor() {
        return SCIPincludeNodeselDfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselDfs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselDfs$handle() {
        return SCIPincludeNodeselDfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselDfs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselDfs$address() {
        return SCIPincludeNodeselDfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselDfs(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselDfs(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselDfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselDfs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselEstimate(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselEstimate$descriptor() {
        return SCIPincludeNodeselEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselEstimate(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselEstimate$handle() {
        return SCIPincludeNodeselEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselEstimate(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselEstimate$address() {
        return SCIPincludeNodeselEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselEstimate(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselEstimate(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselEstimate", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselHybridestim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselHybridestim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselHybridestim(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselHybridestim$descriptor() {
        return SCIPincludeNodeselHybridestim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselHybridestim(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselHybridestim$handle() {
        return SCIPincludeNodeselHybridestim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselHybridestim(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselHybridestim$address() {
        return SCIPincludeNodeselHybridestim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselHybridestim(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselHybridestim(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselHybridestim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselHybridestim", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselUct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselUct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselUct(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselUct$descriptor() {
        return SCIPincludeNodeselUct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselUct(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselUct$handle() {
        return SCIPincludeNodeselUct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselUct(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselUct$address() {
        return SCIPincludeNodeselUct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselUct(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselUct(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselUct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselUct", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselRestartdfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselRestartdfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselRestartdfs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselRestartdfs$descriptor() {
        return SCIPincludeNodeselRestartdfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselRestartdfs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNodeselRestartdfs$handle() {
        return SCIPincludeNodeselRestartdfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselRestartdfs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNodeselRestartdfs$address() {
        return SCIPincludeNodeselRestartdfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselRestartdfs(SCIP *scip)
     * }
     */
    public static int SCIPincludeNodeselRestartdfs(MemorySegment scip) {
        var mh$ = SCIPincludeNodeselRestartdfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselRestartdfs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolBoundshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolBoundshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBoundshift(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolBoundshift$descriptor() {
        return SCIPincludePresolBoundshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBoundshift(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolBoundshift$handle() {
        return SCIPincludePresolBoundshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBoundshift(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolBoundshift$address() {
        return SCIPincludePresolBoundshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBoundshift(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolBoundshift(MemorySegment scip) {
        var mh$ = SCIPincludePresolBoundshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolBoundshift", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolConvertinttobin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolConvertinttobin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolConvertinttobin(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolConvertinttobin$descriptor() {
        return SCIPincludePresolConvertinttobin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolConvertinttobin(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolConvertinttobin$handle() {
        return SCIPincludePresolConvertinttobin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolConvertinttobin(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolConvertinttobin$address() {
        return SCIPincludePresolConvertinttobin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolConvertinttobin(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolConvertinttobin(MemorySegment scip) {
        var mh$ = SCIPincludePresolConvertinttobin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolConvertinttobin", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolDomcol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolDomcol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDomcol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolDomcol$descriptor() {
        return SCIPincludePresolDomcol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDomcol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolDomcol$handle() {
        return SCIPincludePresolDomcol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDomcol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolDomcol$address() {
        return SCIPincludePresolDomcol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDomcol(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolDomcol(MemorySegment scip) {
        var mh$ = SCIPincludePresolDomcol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolDomcol", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolDualagg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolDualagg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualagg(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolDualagg$descriptor() {
        return SCIPincludePresolDualagg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualagg(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolDualagg$handle() {
        return SCIPincludePresolDualagg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualagg(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolDualagg$address() {
        return SCIPincludePresolDualagg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualagg(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolDualagg(MemorySegment scip) {
        var mh$ = SCIPincludePresolDualagg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolDualagg", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolDualcomp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolDualcomp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualcomp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolDualcomp$descriptor() {
        return SCIPincludePresolDualcomp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualcomp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolDualcomp$handle() {
        return SCIPincludePresolDualcomp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualcomp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolDualcomp$address() {
        return SCIPincludePresolDualcomp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualcomp(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolDualcomp(MemorySegment scip) {
        var mh$ = SCIPincludePresolDualcomp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolDualcomp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolDualinfer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolDualinfer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualinfer(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolDualinfer$descriptor() {
        return SCIPincludePresolDualinfer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualinfer(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolDualinfer$handle() {
        return SCIPincludePresolDualinfer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualinfer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolDualinfer$address() {
        return SCIPincludePresolDualinfer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualinfer(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolDualinfer(MemorySegment scip) {
        var mh$ = SCIPincludePresolDualinfer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolDualinfer", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolGateextraction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolGateextraction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolGateextraction(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolGateextraction$descriptor() {
        return SCIPincludePresolGateextraction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolGateextraction(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolGateextraction$handle() {
        return SCIPincludePresolGateextraction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolGateextraction(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolGateextraction$address() {
        return SCIPincludePresolGateextraction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolGateextraction(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolGateextraction(MemorySegment scip) {
        var mh$ = SCIPincludePresolGateextraction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolGateextraction", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolImplics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolImplics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolImplics(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolImplics$descriptor() {
        return SCIPincludePresolImplics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolImplics(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolImplics$handle() {
        return SCIPincludePresolImplics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolImplics(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolImplics$address() {
        return SCIPincludePresolImplics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolImplics(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolImplics(MemorySegment scip) {
        var mh$ = SCIPincludePresolImplics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolImplics", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolInttobinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolInttobinary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolInttobinary(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolInttobinary$descriptor() {
        return SCIPincludePresolInttobinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolInttobinary(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolInttobinary$handle() {
        return SCIPincludePresolInttobinary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolInttobinary(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolInttobinary$address() {
        return SCIPincludePresolInttobinary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolInttobinary(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolInttobinary(MemorySegment scip) {
        var mh$ = SCIPincludePresolInttobinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolInttobinary", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolMILP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolMILP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolMILP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolMILP$descriptor() {
        return SCIPincludePresolMILP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolMILP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolMILP$handle() {
        return SCIPincludePresolMILP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolMILP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolMILP$address() {
        return SCIPincludePresolMILP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolMILP(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolMILP(MemorySegment scip) {
        var mh$ = SCIPincludePresolMILP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolMILP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolRedvub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolRedvub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolRedvub(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolRedvub$descriptor() {
        return SCIPincludePresolRedvub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolRedvub(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolRedvub$handle() {
        return SCIPincludePresolRedvub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolRedvub(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolRedvub$address() {
        return SCIPincludePresolRedvub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolRedvub(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolRedvub(MemorySegment scip) {
        var mh$ = SCIPincludePresolRedvub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolRedvub", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolQPKKTref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolQPKKTref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolQPKKTref(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolQPKKTref$descriptor() {
        return SCIPincludePresolQPKKTref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolQPKKTref(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolQPKKTref$handle() {
        return SCIPincludePresolQPKKTref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolQPKKTref(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolQPKKTref$address() {
        return SCIPincludePresolQPKKTref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolQPKKTref(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolQPKKTref(MemorySegment scip) {
        var mh$ = SCIPincludePresolQPKKTref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolQPKKTref", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolTrivial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolTrivial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTrivial(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolTrivial$descriptor() {
        return SCIPincludePresolTrivial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTrivial(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolTrivial$handle() {
        return SCIPincludePresolTrivial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTrivial(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolTrivial$address() {
        return SCIPincludePresolTrivial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTrivial(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolTrivial(MemorySegment scip) {
        var mh$ = SCIPincludePresolTrivial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolTrivial", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolTworowbnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolTworowbnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTworowbnd(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolTworowbnd$descriptor() {
        return SCIPincludePresolTworowbnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTworowbnd(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolTworowbnd$handle() {
        return SCIPincludePresolTworowbnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTworowbnd(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolTworowbnd$address() {
        return SCIPincludePresolTworowbnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolTworowbnd(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolTworowbnd(MemorySegment scip) {
        var mh$ = SCIPincludePresolTworowbnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolTworowbnd", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolSparsify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolSparsify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolSparsify(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolSparsify$descriptor() {
        return SCIPincludePresolSparsify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolSparsify(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolSparsify$handle() {
        return SCIPincludePresolSparsify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolSparsify(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolSparsify$address() {
        return SCIPincludePresolSparsify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolSparsify(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolSparsify(MemorySegment scip) {
        var mh$ = SCIPincludePresolSparsify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolSparsify", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolDualsparsify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolDualsparsify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualsparsify(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolDualsparsify$descriptor() {
        return SCIPincludePresolDualsparsify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualsparsify(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolDualsparsify$handle() {
        return SCIPincludePresolDualsparsify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualsparsify(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolDualsparsify$address() {
        return SCIPincludePresolDualsparsify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolDualsparsify(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolDualsparsify(MemorySegment scip) {
        var mh$ = SCIPincludePresolDualsparsify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolDualsparsify", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolStuffing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolStuffing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolStuffing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolStuffing$descriptor() {
        return SCIPincludePresolStuffing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolStuffing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePresolStuffing$handle() {
        return SCIPincludePresolStuffing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolStuffing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePresolStuffing$address() {
        return SCIPincludePresolStuffing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolStuffing(SCIP *scip)
     * }
     */
    public static int SCIPincludePresolStuffing(MemorySegment scip) {
        var mh$ = SCIPincludePresolStuffing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolStuffing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropDualfix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropDualfix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropDualfix(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropDualfix$descriptor() {
        return SCIPincludePropDualfix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropDualfix(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropDualfix$handle() {
        return SCIPincludePropDualfix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropDualfix(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropDualfix$address() {
        return SCIPincludePropDualfix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropDualfix(SCIP *scip)
     * }
     */
    public static int SCIPincludePropDualfix(MemorySegment scip) {
        var mh$ = SCIPincludePropDualfix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropDualfix", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgenVBoundAdd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgenVBoundAdd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenVBoundAdd(SCIP *scip, SCIP_PROP *genvboundprop, SCIP_VAR **vars, SCIP_VAR *var, double *coefs, int ncoefs, double coefprimalbound, double constant, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static FunctionDescriptor SCIPgenVBoundAdd$descriptor() {
        return SCIPgenVBoundAdd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenVBoundAdd(SCIP *scip, SCIP_PROP *genvboundprop, SCIP_VAR **vars, SCIP_VAR *var, double *coefs, int ncoefs, double coefprimalbound, double constant, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static MethodHandle SCIPgenVBoundAdd$handle() {
        return SCIPgenVBoundAdd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenVBoundAdd(SCIP *scip, SCIP_PROP *genvboundprop, SCIP_VAR **vars, SCIP_VAR *var, double *coefs, int ncoefs, double coefprimalbound, double constant, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static MemorySegment SCIPgenVBoundAdd$address() {
        return SCIPgenVBoundAdd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenVBoundAdd(SCIP *scip, SCIP_PROP *genvboundprop, SCIP_VAR **vars, SCIP_VAR *var, double *coefs, int ncoefs, double coefprimalbound, double constant, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static int SCIPgenVBoundAdd(MemorySegment scip, MemorySegment genvboundprop, MemorySegment vars, MemorySegment var_, MemorySegment coefs, int ncoefs, double coefprimalbound, double constant, int boundtype) {
        var mh$ = SCIPgenVBoundAdd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgenVBoundAdd", scip, genvboundprop, vars, var_, coefs, ncoefs, coefprimalbound, constant, boundtype);
            }
            return (int)mh$.invokeExact(scip, genvboundprop, vars, var_, coefs, ncoefs, coefprimalbound, constant, boundtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropGenvbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropGenvbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropGenvbounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropGenvbounds$descriptor() {
        return SCIPincludePropGenvbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropGenvbounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropGenvbounds$handle() {
        return SCIPincludePropGenvbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropGenvbounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropGenvbounds$address() {
        return SCIPincludePropGenvbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropGenvbounds(SCIP *scip)
     * }
     */
    public static int SCIPincludePropGenvbounds(MemorySegment scip) {
        var mh$ = SCIPincludePropGenvbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropGenvbounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropNlobbt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropNlobbt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropNlobbt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropNlobbt$descriptor() {
        return SCIPincludePropNlobbt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropNlobbt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropNlobbt$handle() {
        return SCIPincludePropNlobbt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropNlobbt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropNlobbt$address() {
        return SCIPincludePropNlobbt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropNlobbt(SCIP *scip)
     * }
     */
    public static int SCIPincludePropNlobbt(MemorySegment scip) {
        var mh$ = SCIPincludePropNlobbt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropNlobbt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropObbt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropObbt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropObbt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropObbt$descriptor() {
        return SCIPincludePropObbt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropObbt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropObbt$handle() {
        return SCIPincludePropObbt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropObbt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropObbt$address() {
        return SCIPincludePropObbt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropObbt(SCIP *scip)
     * }
     */
    public static int SCIPincludePropObbt(MemorySegment scip) {
        var mh$ = SCIPincludePropObbt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropObbt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropProbing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropProbing$descriptor() {
        return SCIPincludePropProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropProbing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropProbing$handle() {
        return SCIPincludePropProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropProbing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropProbing$address() {
        return SCIPincludePropProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropProbing(SCIP *scip)
     * }
     */
    public static int SCIPincludePropProbing(MemorySegment scip) {
        var mh$ = SCIPincludePropProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropProbing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyProbingVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyProbingVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProbingVar(SCIP *scip, SCIP_VAR **vars, int nvars, int probingpos, SCIP_BOUNDTYPE boundtype, double bound, int maxproprounds, double *impllbs, double *implubs, double *proplbs, double *propubs, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPapplyProbingVar$descriptor() {
        return SCIPapplyProbingVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProbingVar(SCIP *scip, SCIP_VAR **vars, int nvars, int probingpos, SCIP_BOUNDTYPE boundtype, double bound, int maxproprounds, double *impllbs, double *implubs, double *proplbs, double *propubs, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPapplyProbingVar$handle() {
        return SCIPapplyProbingVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProbingVar(SCIP *scip, SCIP_VAR **vars, int nvars, int probingpos, SCIP_BOUNDTYPE boundtype, double bound, int maxproprounds, double *impllbs, double *implubs, double *proplbs, double *propubs, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPapplyProbingVar$address() {
        return SCIPapplyProbingVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyProbingVar(SCIP *scip, SCIP_VAR **vars, int nvars, int probingpos, SCIP_BOUNDTYPE boundtype, double bound, int maxproprounds, double *impllbs, double *implubs, double *proplbs, double *propubs, unsigned int *cutoff)
     * }
     */
    public static int SCIPapplyProbingVar(MemorySegment scip, MemorySegment vars, int nvars, int probingpos, int boundtype, double bound, int maxproprounds, MemorySegment impllbs, MemorySegment implubs, MemorySegment proplbs, MemorySegment propubs, MemorySegment cutoff) {
        var mh$ = SCIPapplyProbingVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyProbingVar", scip, vars, nvars, probingpos, boundtype, bound, maxproprounds, impllbs, implubs, proplbs, propubs, cutoff);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, probingpos, boundtype, bound, maxproprounds, impllbs, implubs, proplbs, propubs, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPanalyzeDeductionsProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPanalyzeDeductionsProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeDeductionsProbing(SCIP *scip, SCIP_VAR *probingvar, double leftub, double rightlb, int nvars, SCIP_VAR **vars, double *leftimpllbs, double *leftimplubs, double *leftproplbs, double *leftpropubs, double *rightimpllbs, double *rightimplubs, double *rightproplbs, double *rightpropubs, int *nfixedvars, int *naggrvars, int *nimplications, int *nchgbds, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPanalyzeDeductionsProbing$descriptor() {
        return SCIPanalyzeDeductionsProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeDeductionsProbing(SCIP *scip, SCIP_VAR *probingvar, double leftub, double rightlb, int nvars, SCIP_VAR **vars, double *leftimpllbs, double *leftimplubs, double *leftproplbs, double *leftpropubs, double *rightimpllbs, double *rightimplubs, double *rightproplbs, double *rightpropubs, int *nfixedvars, int *naggrvars, int *nimplications, int *nchgbds, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPanalyzeDeductionsProbing$handle() {
        return SCIPanalyzeDeductionsProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeDeductionsProbing(SCIP *scip, SCIP_VAR *probingvar, double leftub, double rightlb, int nvars, SCIP_VAR **vars, double *leftimpllbs, double *leftimplubs, double *leftproplbs, double *leftpropubs, double *rightimpllbs, double *rightimplubs, double *rightproplbs, double *rightpropubs, int *nfixedvars, int *naggrvars, int *nimplications, int *nchgbds, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPanalyzeDeductionsProbing$address() {
        return SCIPanalyzeDeductionsProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPanalyzeDeductionsProbing(SCIP *scip, SCIP_VAR *probingvar, double leftub, double rightlb, int nvars, SCIP_VAR **vars, double *leftimpllbs, double *leftimplubs, double *leftproplbs, double *leftpropubs, double *rightimpllbs, double *rightimplubs, double *rightproplbs, double *rightpropubs, int *nfixedvars, int *naggrvars, int *nimplications, int *nchgbds, unsigned int *cutoff)
     * }
     */
    public static int SCIPanalyzeDeductionsProbing(MemorySegment scip, MemorySegment probingvar, double leftub, double rightlb, int nvars, MemorySegment vars, MemorySegment leftimpllbs, MemorySegment leftimplubs, MemorySegment leftproplbs, MemorySegment leftpropubs, MemorySegment rightimpllbs, MemorySegment rightimplubs, MemorySegment rightproplbs, MemorySegment rightpropubs, MemorySegment nfixedvars, MemorySegment naggrvars, MemorySegment nimplications, MemorySegment nchgbds, MemorySegment cutoff) {
        var mh$ = SCIPanalyzeDeductionsProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPanalyzeDeductionsProbing", scip, probingvar, leftub, rightlb, nvars, vars, leftimpllbs, leftimplubs, leftproplbs, leftpropubs, rightimpllbs, rightimplubs, rightproplbs, rightpropubs, nfixedvars, naggrvars, nimplications, nchgbds, cutoff);
            }
            return (int)mh$.invokeExact(scip, probingvar, leftub, rightlb, nvars, vars, leftimpllbs, leftimplubs, leftproplbs, leftpropubs, rightimpllbs, rightimplubs, rightproplbs, rightpropubs, nfixedvars, naggrvars, nimplications, nchgbds, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropPseudoobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropPseudoobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropPseudoobj(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropPseudoobj$descriptor() {
        return SCIPincludePropPseudoobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropPseudoobj(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropPseudoobj$handle() {
        return SCIPincludePropPseudoobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropPseudoobj(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropPseudoobj$address() {
        return SCIPincludePropPseudoobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropPseudoobj(SCIP *scip)
     * }
     */
    public static int SCIPincludePropPseudoobj(MemorySegment scip) {
        var mh$ = SCIPincludePropPseudoobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropPseudoobj", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropagateCutoffboundVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropagateCutoffboundVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateCutoffboundVar(SCIP *scip, SCIP_PROP *prop, SCIP_VAR *var, double cutoffbound, double pseudoobjval, unsigned int *tightened)
     * }
     */
    public static FunctionDescriptor SCIPpropagateCutoffboundVar$descriptor() {
        return SCIPpropagateCutoffboundVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateCutoffboundVar(SCIP *scip, SCIP_PROP *prop, SCIP_VAR *var, double cutoffbound, double pseudoobjval, unsigned int *tightened)
     * }
     */
    public static MethodHandle SCIPpropagateCutoffboundVar$handle() {
        return SCIPpropagateCutoffboundVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateCutoffboundVar(SCIP *scip, SCIP_PROP *prop, SCIP_VAR *var, double cutoffbound, double pseudoobjval, unsigned int *tightened)
     * }
     */
    public static MemorySegment SCIPpropagateCutoffboundVar$address() {
        return SCIPpropagateCutoffboundVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateCutoffboundVar(SCIP *scip, SCIP_PROP *prop, SCIP_VAR *var, double cutoffbound, double pseudoobjval, unsigned int *tightened)
     * }
     */
    public static int SCIPpropagateCutoffboundVar(MemorySegment scip, MemorySegment prop, MemorySegment var_, double cutoffbound, double pseudoobjval, MemorySegment tightened) {
        var mh$ = SCIPpropagateCutoffboundVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropagateCutoffboundVar", scip, prop, var_, cutoffbound, pseudoobjval, tightened);
            }
            return (int)mh$.invokeExact(scip, prop, var_, cutoffbound, pseudoobjval, tightened);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropRedcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropRedcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRedcost(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropRedcost$descriptor() {
        return SCIPincludePropRedcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRedcost(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropRedcost$handle() {
        return SCIPincludePropRedcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRedcost(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropRedcost$address() {
        return SCIPincludePropRedcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRedcost(SCIP *scip)
     * }
     */
    public static int SCIPincludePropRedcost(MemorySegment scip) {
        var mh$ = SCIPincludePropRedcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropRedcost", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropRootredcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropRootredcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRootredcost(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropRootredcost$descriptor() {
        return SCIPincludePropRootredcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRootredcost(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropRootredcost$handle() {
        return SCIPincludePropRootredcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRootredcost(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropRootredcost$address() {
        return SCIPincludePropRootredcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropRootredcost(SCIP *scip)
     * }
     */
    public static int SCIPincludePropRootredcost(MemorySegment scip) {
        var mh$ = SCIPincludePropRootredcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropRootredcost", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropSymmetry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropSymmetry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropSymmetry(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropSymmetry$descriptor() {
        return SCIPincludePropSymmetry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropSymmetry(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropSymmetry$handle() {
        return SCIPincludePropSymmetry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropSymmetry(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropSymmetry$address() {
        return SCIPincludePropSymmetry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropSymmetry(SCIP *scip)
     * }
     */
    public static int SCIPincludePropSymmetry(MemorySegment scip) {
        var mh$ = SCIPincludePropSymmetry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropSymmetry", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSymmetry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSymmetry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymmetry(SCIP *scip, int *npermvars, SCIP_VAR ***permvars, SCIP_HASHMAP **permvarmap, int *nperms, int ***perms, int ***permstrans, double *log10groupsize, unsigned int *binvaraffected, int **components, int **componentbegins, int **vartocomponent, int *ncomponents)
     * }
     */
    public static FunctionDescriptor SCIPgetSymmetry$descriptor() {
        return SCIPgetSymmetry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymmetry(SCIP *scip, int *npermvars, SCIP_VAR ***permvars, SCIP_HASHMAP **permvarmap, int *nperms, int ***perms, int ***permstrans, double *log10groupsize, unsigned int *binvaraffected, int **components, int **componentbegins, int **vartocomponent, int *ncomponents)
     * }
     */
    public static MethodHandle SCIPgetSymmetry$handle() {
        return SCIPgetSymmetry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymmetry(SCIP *scip, int *npermvars, SCIP_VAR ***permvars, SCIP_HASHMAP **permvarmap, int *nperms, int ***perms, int ***permstrans, double *log10groupsize, unsigned int *binvaraffected, int **components, int **componentbegins, int **vartocomponent, int *ncomponents)
     * }
     */
    public static MemorySegment SCIPgetSymmetry$address() {
        return SCIPgetSymmetry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymmetry(SCIP *scip, int *npermvars, SCIP_VAR ***permvars, SCIP_HASHMAP **permvarmap, int *nperms, int ***perms, int ***permstrans, double *log10groupsize, unsigned int *binvaraffected, int **components, int **componentbegins, int **vartocomponent, int *ncomponents)
     * }
     */
    public static int SCIPgetSymmetry(MemorySegment scip, MemorySegment npermvars, MemorySegment permvars, MemorySegment permvarmap, MemorySegment nperms, MemorySegment perms, MemorySegment permstrans, MemorySegment log10groupsize, MemorySegment binvaraffected, MemorySegment components, MemorySegment componentbegins, MemorySegment vartocomponent, MemorySegment ncomponents) {
        var mh$ = SCIPgetSymmetry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSymmetry", scip, npermvars, permvars, permvarmap, nperms, perms, permstrans, log10groupsize, binvaraffected, components, componentbegins, vartocomponent, ncomponents);
            }
            return (int)mh$.invokeExact(scip, npermvars, permvars, permvarmap, nperms, perms, permstrans, log10groupsize, binvaraffected, components, componentbegins, vartocomponent, ncomponents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSymmetryNGenerators {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSymmetryNGenerators");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetSymmetryNGenerators(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSymmetryNGenerators$descriptor() {
        return SCIPgetSymmetryNGenerators.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetSymmetryNGenerators(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSymmetryNGenerators$handle() {
        return SCIPgetSymmetryNGenerators.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetSymmetryNGenerators(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSymmetryNGenerators$address() {
        return SCIPgetSymmetryNGenerators.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetSymmetryNGenerators(SCIP *scip)
     * }
     */
    public static int SCIPgetSymmetryNGenerators(MemorySegment scip) {
        var mh$ = SCIPgetSymmetryNGenerators.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSymmetryNGenerators", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateSymOpNodeType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateSymOpNodeType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static FunctionDescriptor SCIPcreateSymOpNodeType$descriptor() {
        return SCIPcreateSymOpNodeType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static MethodHandle SCIPcreateSymOpNodeType$handle() {
        return SCIPcreateSymOpNodeType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static MemorySegment SCIPcreateSymOpNodeType$address() {
        return SCIPcreateSymOpNodeType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static int SCIPcreateSymOpNodeType(MemorySegment scip, MemorySegment opnodename, MemorySegment nodetype) {
        var mh$ = SCIPcreateSymOpNodeType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateSymOpNodeType", scip, opnodename, nodetype);
            }
            return (int)mh$.invokeExact(scip, opnodename, nodetype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSymOpNodeType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSymOpNodeType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static FunctionDescriptor SCIPgetSymOpNodeType$descriptor() {
        return SCIPgetSymOpNodeType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static MethodHandle SCIPgetSymOpNodeType$handle() {
        return SCIPgetSymOpNodeType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static MemorySegment SCIPgetSymOpNodeType$address() {
        return SCIPgetSymOpNodeType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymOpNodeType(SCIP *scip, const char *opnodename, int *nodetype)
     * }
     */
    public static int SCIPgetSymOpNodeType(MemorySegment scip, MemorySegment opnodename, MemorySegment nodetype) {
        var mh$ = SCIPgetSymOpNodeType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSymOpNodeType", scip, opnodename, nodetype);
            }
            return (int)mh$.invokeExact(scip, opnodename, nodetype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropVbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropVbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropVbounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludePropVbounds$descriptor() {
        return SCIPincludePropVbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropVbounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludePropVbounds$handle() {
        return SCIPincludePropVbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropVbounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludePropVbounds$address() {
        return SCIPincludePropVbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropVbounds(SCIP *scip)
     * }
     */
    public static int SCIPincludePropVbounds(MemorySegment scip) {
        var mh$ = SCIPincludePropVbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropVbounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisPropagatedVbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisPropagatedVbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisPropagatedVbounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisPropagatedVbounds$descriptor() {
        return SCIPisPropagatedVbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisPropagatedVbounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisPropagatedVbounds$handle() {
        return SCIPisPropagatedVbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisPropagatedVbounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisPropagatedVbounds$address() {
        return SCIPisPropagatedVbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisPropagatedVbounds(SCIP *scip)
     * }
     */
    public static int SCIPisPropagatedVbounds(MemorySegment scip) {
        var mh$ = SCIPisPropagatedVbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisPropagatedVbounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPexecPropVbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPexecPropVbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecPropVbounds(SCIP *scip, unsigned int force, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPexecPropVbounds$descriptor() {
        return SCIPexecPropVbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecPropVbounds(SCIP *scip, unsigned int force, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPexecPropVbounds$handle() {
        return SCIPexecPropVbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecPropVbounds(SCIP *scip, unsigned int force, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPexecPropVbounds$address() {
        return SCIPexecPropVbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPexecPropVbounds(SCIP *scip, unsigned int force, SCIP_RESULT *result)
     * }
     */
    public static int SCIPexecPropVbounds(MemorySegment scip, int force, MemorySegment result) {
        var mh$ = SCIPexecPropVbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPexecPropVbounds", scip, force, result);
            }
            return (int)mh$.invokeExact(scip, force, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderBnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderBnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBnd(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderBnd$descriptor() {
        return SCIPincludeReaderBnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBnd(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderBnd$handle() {
        return SCIPincludeReaderBnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBnd(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderBnd$address() {
        return SCIPincludeReaderBnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBnd(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderBnd(MemorySegment scip) {
        var mh$ = SCIPincludeReaderBnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderBnd", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderCcg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderCcg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCcg(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderCcg$descriptor() {
        return SCIPincludeReaderCcg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCcg(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderCcg$handle() {
        return SCIPincludeReaderCcg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCcg(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderCcg$address() {
        return SCIPincludeReaderCcg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCcg(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderCcg(MemorySegment scip) {
        var mh$ = SCIPincludeReaderCcg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderCcg", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteCcg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteCcg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCcg(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteCcg$descriptor() {
        return SCIPwriteCcg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCcg(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteCcg$handle() {
        return SCIPwriteCcg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCcg(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteCcg$address() {
        return SCIPwriteCcg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteCcg(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteCcg(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, MemorySegment vars, int nvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteCcg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteCcg", scip, file, name, transformed, vars, nvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, vars, nvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderCip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderCip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCip(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderCip$descriptor() {
        return SCIPincludeReaderCip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCip(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderCip$handle() {
        return SCIPincludeReaderCip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCip(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderCip$address() {
        return SCIPincludeReaderCip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCip(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderCip(MemorySegment scip) {
        var mh$ = SCIPincludeReaderCip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderCip", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderCnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderCnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCnf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderCnf$descriptor() {
        return SCIPincludeReaderCnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCnf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderCnf$handle() {
        return SCIPincludeReaderCnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCnf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderCnf$address() {
        return SCIPincludeReaderCnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCnf(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderCnf(MemorySegment scip) {
        var mh$ = SCIPincludeReaderCnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderCnf", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderCor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderCor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCor(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderCor$descriptor() {
        return SCIPincludeReaderCor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCor(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderCor$handle() {
        return SCIPincludeReaderCor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCor(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderCor$address() {
        return SCIPincludeReaderCor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderCor(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderCor(MemorySegment scip) {
        var mh$ = SCIPincludeReaderCor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderCor", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadCor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadCor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadCor(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadCor$descriptor() {
        return SCIPreadCor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadCor(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadCor$handle() {
        return SCIPreadCor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadCor(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadCor$address() {
        return SCIPreadCor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadCor(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadCor(MemorySegment scip, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadCor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadCor", scip, filename, result);
            }
            return (int)mh$.invokeExact(scip, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcorHasRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcorHasRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPcorHasRead(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPcorHasRead$descriptor() {
        return SCIPcorHasRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPcorHasRead(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPcorHasRead$handle() {
        return SCIPcorHasRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPcorHasRead(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPcorHasRead$address() {
        return SCIPcorHasRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPcorHasRead(SCIP_READER *reader)
     * }
     */
    public static int SCIPcorHasRead(MemorySegment reader) {
        var mh$ = SCIPcorHasRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcorHasRead", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcorGetNVarNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcorGetNVarNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcorGetNVarNames(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPcorGetNVarNames$descriptor() {
        return SCIPcorGetNVarNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcorGetNVarNames(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPcorGetNVarNames$handle() {
        return SCIPcorGetNVarNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcorGetNVarNames(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPcorGetNVarNames$address() {
        return SCIPcorGetNVarNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcorGetNVarNames(SCIP_READER *reader)
     * }
     */
    public static int SCIPcorGetNVarNames(MemorySegment reader) {
        var mh$ = SCIPcorGetNVarNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcorGetNVarNames", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcorGetNConsNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcorGetNConsNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcorGetNConsNames(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPcorGetNConsNames$descriptor() {
        return SCIPcorGetNConsNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcorGetNConsNames(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPcorGetNConsNames$handle() {
        return SCIPcorGetNConsNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcorGetNConsNames(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPcorGetNConsNames$address() {
        return SCIPcorGetNConsNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcorGetNConsNames(SCIP_READER *reader)
     * }
     */
    public static int SCIPcorGetNConsNames(MemorySegment reader) {
        var mh$ = SCIPcorGetNConsNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcorGetNConsNames", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcorGetVarName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcorGetVarName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcorGetVarName(SCIP_READER *reader, int i)
     * }
     */
    public static FunctionDescriptor SCIPcorGetVarName$descriptor() {
        return SCIPcorGetVarName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcorGetVarName(SCIP_READER *reader, int i)
     * }
     */
    public static MethodHandle SCIPcorGetVarName$handle() {
        return SCIPcorGetVarName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcorGetVarName(SCIP_READER *reader, int i)
     * }
     */
    public static MemorySegment SCIPcorGetVarName$address() {
        return SCIPcorGetVarName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcorGetVarName(SCIP_READER *reader, int i)
     * }
     */
    public static MemorySegment SCIPcorGetVarName(MemorySegment reader, int i) {
        var mh$ = SCIPcorGetVarName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcorGetVarName", reader, i);
            }
            return (MemorySegment)mh$.invokeExact(reader, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcorGetConsName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcorGetConsName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPcorGetConsName(SCIP_READER *reader, int i)
     * }
     */
    public static FunctionDescriptor SCIPcorGetConsName$descriptor() {
        return SCIPcorGetConsName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPcorGetConsName(SCIP_READER *reader, int i)
     * }
     */
    public static MethodHandle SCIPcorGetConsName$handle() {
        return SCIPcorGetConsName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPcorGetConsName(SCIP_READER *reader, int i)
     * }
     */
    public static MemorySegment SCIPcorGetConsName$address() {
        return SCIPcorGetConsName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPcorGetConsName(SCIP_READER *reader, int i)
     * }
     */
    public static MemorySegment SCIPcorGetConsName(MemorySegment reader, int i) {
        var mh$ = SCIPcorGetConsName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcorGetConsName", reader, i);
            }
            return (MemorySegment)mh$.invokeExact(reader, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderDec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderDec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDec(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderDec$descriptor() {
        return SCIPincludeReaderDec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDec(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderDec$handle() {
        return SCIPincludeReaderDec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDec(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderDec$address() {
        return SCIPincludeReaderDec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDec(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderDec(MemorySegment scip) {
        var mh$ = SCIPincludeReaderDec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderDec", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderDiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderDiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDiff(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderDiff$descriptor() {
        return SCIPincludeReaderDiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDiff(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderDiff$handle() {
        return SCIPincludeReaderDiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDiff(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderDiff$address() {
        return SCIPincludeReaderDiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderDiff(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderDiff(MemorySegment scip) {
        var mh$ = SCIPincludeReaderDiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderDiff", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadDiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadDiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadDiff(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadDiff$descriptor() {
        return SCIPreadDiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadDiff(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadDiff$handle() {
        return SCIPreadDiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadDiff(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadDiff$address() {
        return SCIPreadDiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadDiff(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadDiff(MemorySegment scip, MemorySegment reader, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadDiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadDiff", scip, reader, filename, result);
            }
            return (int)mh$.invokeExact(scip, reader, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteDiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteDiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteDiff(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteDiff$descriptor() {
        return SCIPwriteDiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteDiff(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteDiff$handle() {
        return SCIPwriteDiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteDiff(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteDiff$address() {
        return SCIPwriteDiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteDiff(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteDiff(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteDiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteDiff", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderFix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderFix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFix(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderFix$descriptor() {
        return SCIPincludeReaderFix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFix(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderFix$handle() {
        return SCIPincludeReaderFix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFix(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderFix$address() {
        return SCIPincludeReaderFix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFix(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderFix(MemorySegment scip) {
        var mh$ = SCIPincludeReaderFix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderFix", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderFzn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderFzn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFzn(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderFzn$descriptor() {
        return SCIPincludeReaderFzn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFzn(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderFzn$handle() {
        return SCIPincludeReaderFzn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFzn(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderFzn$address() {
        return SCIPincludeReaderFzn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderFzn(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderFzn(MemorySegment scip) {
        var mh$ = SCIPincludeReaderFzn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderFzn", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintSolReaderFzn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintSolReaderFzn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSolReaderFzn(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintSolReaderFzn$descriptor() {
        return SCIPprintSolReaderFzn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSolReaderFzn(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintSolReaderFzn$handle() {
        return SCIPprintSolReaderFzn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSolReaderFzn(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintSolReaderFzn$address() {
        return SCIPprintSolReaderFzn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSolReaderFzn(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static int SCIPprintSolReaderFzn(MemorySegment scip, MemorySegment sol, MemorySegment file) {
        var mh$ = SCIPprintSolReaderFzn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintSolReaderFzn", scip, sol, file);
            }
            return (int)mh$.invokeExact(scip, sol, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderGms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderGms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderGms(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderGms$descriptor() {
        return SCIPincludeReaderGms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderGms(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderGms$handle() {
        return SCIPincludeReaderGms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderGms(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderGms$address() {
        return SCIPincludeReaderGms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderGms(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderGms(MemorySegment scip) {
        var mh$ = SCIPincludeReaderGms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderGms", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteGms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteGms");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteGms(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteGms$descriptor() {
        return SCIPwriteGms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteGms(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteGms$handle() {
        return SCIPwriteGms.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteGms(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteGms$address() {
        return SCIPwriteGms.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteGms(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteGms(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteGms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteGms", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderLp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderLp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderLp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderLp$descriptor() {
        return SCIPincludeReaderLp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderLp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderLp$handle() {
        return SCIPincludeReaderLp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderLp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderLp$address() {
        return SCIPincludeReaderLp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderLp(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderLp(MemorySegment scip) {
        var mh$ = SCIPincludeReaderLp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderLp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadLp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadLp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadLp(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadLp$descriptor() {
        return SCIPreadLp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadLp(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadLp$handle() {
        return SCIPreadLp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadLp(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadLp$address() {
        return SCIPreadLp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadLp(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadLp(MemorySegment scip, MemorySegment reader, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadLp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadLp", scip, reader, filename, result);
            }
            return (int)mh$.invokeExact(scip, reader, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteLp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteLp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLp(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteLp$descriptor() {
        return SCIPwriteLp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLp(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteLp$handle() {
        return SCIPwriteLp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLp(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteLp$address() {
        return SCIPwriteLp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLp(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteLp(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteLp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteLp", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderMps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderMps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderMps$descriptor() {
        return SCIPincludeReaderMps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderMps$handle() {
        return SCIPincludeReaderMps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderMps$address() {
        return SCIPincludeReaderMps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMps(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderMps(MemorySegment scip) {
        var mh$ = SCIPincludeReaderMps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderMps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadMps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadMps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadMps(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result, const char ***varnames, const char ***consnames, int *varnamessize, int *consnamessize, int *nvarnames, int *nconsnames)
     * }
     */
    public static FunctionDescriptor SCIPreadMps$descriptor() {
        return SCIPreadMps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadMps(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result, const char ***varnames, const char ***consnames, int *varnamessize, int *consnamessize, int *nvarnames, int *nconsnames)
     * }
     */
    public static MethodHandle SCIPreadMps$handle() {
        return SCIPreadMps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadMps(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result, const char ***varnames, const char ***consnames, int *varnamessize, int *consnamessize, int *nvarnames, int *nconsnames)
     * }
     */
    public static MemorySegment SCIPreadMps$address() {
        return SCIPreadMps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadMps(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result, const char ***varnames, const char ***consnames, int *varnamessize, int *consnamessize, int *nvarnames, int *nconsnames)
     * }
     */
    public static int SCIPreadMps(MemorySegment scip, MemorySegment reader, MemorySegment filename, MemorySegment result, MemorySegment varnames, MemorySegment consnames, MemorySegment varnamessize, MemorySegment consnamessize, MemorySegment nvarnames, MemorySegment nconsnames) {
        var mh$ = SCIPreadMps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadMps", scip, reader, filename, result, varnames, consnames, varnamessize, consnamessize, nvarnames, nconsnames);
            }
            return (int)mh$.invokeExact(scip, reader, filename, result, varnames, consnames, varnamessize, consnamessize, nvarnames, nconsnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteMps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteMps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMps(SCIP *scip, SCIP_READER *reader, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteMps$descriptor() {
        return SCIPwriteMps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMps(SCIP *scip, SCIP_READER *reader, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteMps$handle() {
        return SCIPwriteMps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMps(SCIP *scip, SCIP_READER *reader, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteMps$address() {
        return SCIPwriteMps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMps(SCIP *scip, SCIP_READER *reader, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteMps(MemorySegment scip, MemorySegment reader, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment fixedvars, int nfixedvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteMps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteMps", scip, reader, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, fixedvars, nfixedvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, reader, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, fixedvars, nfixedvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderMst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderMst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMst(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderMst$descriptor() {
        return SCIPincludeReaderMst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMst(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderMst$handle() {
        return SCIPincludeReaderMst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMst(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderMst$address() {
        return SCIPincludeReaderMst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderMst(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderMst(MemorySegment scip) {
        var mh$ = SCIPincludeReaderMst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderMst", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderNl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderNl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderNl(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderNl$descriptor() {
        return SCIPincludeReaderNl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderNl(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderNl$handle() {
        return SCIPincludeReaderNl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderNl(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderNl$address() {
        return SCIPincludeReaderNl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderNl(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderNl(MemorySegment scip) {
        var mh$ = SCIPincludeReaderNl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderNl", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteSolutionNl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteSolutionNl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSolutionNl(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPwriteSolutionNl$descriptor() {
        return SCIPwriteSolutionNl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSolutionNl(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPwriteSolutionNl$handle() {
        return SCIPwriteSolutionNl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSolutionNl(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPwriteSolutionNl$address() {
        return SCIPwriteSolutionNl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSolutionNl(SCIP *scip)
     * }
     */
    public static int SCIPwriteSolutionNl(MemorySegment scip) {
        var mh$ = SCIPwriteSolutionNl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteSolutionNl", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderOpb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderOpb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOpb(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderOpb$descriptor() {
        return SCIPincludeReaderOpb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOpb(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderOpb$handle() {
        return SCIPincludeReaderOpb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOpb(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderOpb$address() {
        return SCIPincludeReaderOpb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOpb(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderOpb(MemorySegment scip) {
        var mh$ = SCIPincludeReaderOpb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderOpb", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadOpb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadOpb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadOpb(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadOpb$descriptor() {
        return SCIPreadOpb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadOpb(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadOpb$handle() {
        return SCIPreadOpb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadOpb(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadOpb$address() {
        return SCIPreadOpb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadOpb(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadOpb(MemorySegment scip, MemorySegment reader, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadOpb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadOpb", scip, reader, filename, result);
            }
            return (int)mh$.invokeExact(scip, reader, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteOpb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteOpb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOpb(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, unsigned int genericnames, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteOpb$descriptor() {
        return SCIPwriteOpb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOpb(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, unsigned int genericnames, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteOpb$handle() {
        return SCIPwriteOpb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOpb(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, unsigned int genericnames, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteOpb$address() {
        return SCIPwriteOpb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOpb(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_VAR **fixedvars, int nfixedvars, SCIP_CONS **conss, int nconss, unsigned int genericnames, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteOpb(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment fixedvars, int nfixedvars, MemorySegment conss, int nconss, int genericnames, MemorySegment result) {
        var mh$ = SCIPwriteOpb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteOpb", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, fixedvars, nfixedvars, conss, nconss, genericnames, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, fixedvars, nfixedvars, conss, nconss, genericnames, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderOsil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderOsil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOsil(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderOsil$descriptor() {
        return SCIPincludeReaderOsil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOsil(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderOsil$handle() {
        return SCIPincludeReaderOsil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOsil(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderOsil$address() {
        return SCIPincludeReaderOsil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderOsil(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderOsil(MemorySegment scip) {
        var mh$ = SCIPincludeReaderOsil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderOsil", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderPip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderPip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPip(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderPip$descriptor() {
        return SCIPincludeReaderPip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPip(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderPip$handle() {
        return SCIPincludeReaderPip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPip(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderPip$address() {
        return SCIPincludeReaderPip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPip(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderPip(MemorySegment scip) {
        var mh$ = SCIPincludeReaderPip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderPip", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadPip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadPip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadPip(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadPip$descriptor() {
        return SCIPreadPip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadPip(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadPip$handle() {
        return SCIPreadPip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadPip(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadPip$address() {
        return SCIPreadPip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadPip(SCIP *scip, SCIP_READER *reader, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadPip(MemorySegment scip, MemorySegment reader, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadPip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadPip", scip, reader, filename, result);
            }
            return (int)mh$.invokeExact(scip, reader, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwritePip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwritePip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePip(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwritePip$descriptor() {
        return SCIPwritePip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePip(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwritePip$handle() {
        return SCIPwritePip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePip(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwritePip$address() {
        return SCIPwritePip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePip(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwritePip(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwritePip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwritePip", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderPpm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderPpm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPpm(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderPpm$descriptor() {
        return SCIPincludeReaderPpm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPpm(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderPpm$handle() {
        return SCIPincludeReaderPpm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPpm(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderPpm$address() {
        return SCIPincludeReaderPpm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPpm(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderPpm(MemorySegment scip) {
        var mh$ = SCIPincludeReaderPpm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderPpm", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwritePpm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwritePpm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePpm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwritePpm$descriptor() {
        return SCIPwritePpm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePpm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwritePpm$handle() {
        return SCIPwritePpm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePpm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwritePpm$address() {
        return SCIPwritePpm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePpm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, SCIP_VAR **vars, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwritePpm(MemorySegment scip, MemorySegment file, MemorySegment name, MemorySegment readerdata, int transformed, MemorySegment vars, int nvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwritePpm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwritePpm", scip, file, name, readerdata, transformed, vars, nvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, readerdata, transformed, vars, nvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderPbm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderPbm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPbm(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderPbm$descriptor() {
        return SCIPincludeReaderPbm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPbm(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderPbm$handle() {
        return SCIPincludeReaderPbm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPbm(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderPbm$address() {
        return SCIPincludeReaderPbm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderPbm(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderPbm(MemorySegment scip) {
        var mh$ = SCIPincludeReaderPbm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderPbm", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwritePbm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwritePbm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePbm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwritePbm$descriptor() {
        return SCIPwritePbm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePbm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwritePbm$handle() {
        return SCIPwritePbm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePbm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwritePbm$address() {
        return SCIPwritePbm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwritePbm(SCIP *scip, FILE *file, const char *name, SCIP_READERDATA *readerdata, unsigned int transformed, int nvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwritePbm(MemorySegment scip, MemorySegment file, MemorySegment name, MemorySegment readerdata, int transformed, int nvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwritePbm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwritePbm", scip, file, name, readerdata, transformed, nvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, readerdata, transformed, nvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderRlp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderRlp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderRlp(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderRlp$descriptor() {
        return SCIPincludeReaderRlp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderRlp(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderRlp$handle() {
        return SCIPincludeReaderRlp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderRlp(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderRlp$address() {
        return SCIPincludeReaderRlp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderRlp(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderRlp(MemorySegment scip) {
        var mh$ = SCIPincludeReaderRlp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderRlp", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderSmps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderSmps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSmps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderSmps$descriptor() {
        return SCIPincludeReaderSmps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSmps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderSmps$handle() {
        return SCIPincludeReaderSmps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSmps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderSmps$address() {
        return SCIPincludeReaderSmps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSmps(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderSmps(MemorySegment scip) {
        var mh$ = SCIPincludeReaderSmps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderSmps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderSol$descriptor() {
        return SCIPincludeReaderSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderSol$handle() {
        return SCIPincludeReaderSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderSol$address() {
        return SCIPincludeReaderSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSol(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderSol(MemorySegment scip) {
        var mh$ = SCIPincludeReaderSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderSol", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderSto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderSto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSto(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderSto$descriptor() {
        return SCIPincludeReaderSto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSto(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderSto$handle() {
        return SCIPincludeReaderSto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSto(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderSto$address() {
        return SCIPincludeReaderSto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderSto(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderSto(MemorySegment scip) {
        var mh$ = SCIPincludeReaderSto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderSto", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadSto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadSto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSto(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadSto$descriptor() {
        return SCIPreadSto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSto(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadSto$handle() {
        return SCIPreadSto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSto(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadSto$address() {
        return SCIPreadSto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSto(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadSto(MemorySegment scip, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadSto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadSto", scip, filename, result);
            }
            return (int)mh$.invokeExact(scip, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteSto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteSto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSto(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPwriteSto$descriptor() {
        return SCIPwriteSto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSto(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPwriteSto$handle() {
        return SCIPwriteSto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSto(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPwriteSto$address() {
        return SCIPwriteSto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteSto(SCIP *scip, FILE *file, const char *name, unsigned int transformed, SCIP_OBJSENSE objsense, double objscale, double objoffset, SCIP_VAR **vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, SCIP_CONS **conss, int nconss, SCIP_RESULT *result)
     * }
     */
    public static int SCIPwriteSto(MemorySegment scip, MemorySegment file, MemorySegment name, int transformed, int objsense, double objscale, double objoffset, MemorySegment vars, int nvars, int nbinvars, int nintvars, int nimplvars, int ncontvars, MemorySegment conss, int nconss, MemorySegment result) {
        var mh$ = SCIPwriteSto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteSto", scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
            }
            return (int)mh$.invokeExact(scip, file, name, transformed, objsense, objscale, objoffset, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars, conss, nconss, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstoGetNScenarios {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstoGetNScenarios");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPstoGetNScenarios(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstoGetNScenarios$descriptor() {
        return SCIPstoGetNScenarios.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPstoGetNScenarios(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstoGetNScenarios$handle() {
        return SCIPstoGetNScenarios.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPstoGetNScenarios(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstoGetNScenarios$address() {
        return SCIPstoGetNScenarios.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPstoGetNScenarios(SCIP *scip)
     * }
     */
    public static int SCIPstoGetNScenarios(MemorySegment scip) {
        var mh$ = SCIPstoGetNScenarios.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstoGetNScenarios", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderTim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderTim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderTim(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderTim$descriptor() {
        return SCIPincludeReaderTim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderTim(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderTim$handle() {
        return SCIPincludeReaderTim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderTim(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderTim$address() {
        return SCIPincludeReaderTim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderTim(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderTim(MemorySegment scip) {
        var mh$ = SCIPincludeReaderTim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderTim", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadTim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadTim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadTim(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static FunctionDescriptor SCIPreadTim$descriptor() {
        return SCIPreadTim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadTim(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MethodHandle SCIPreadTim$handle() {
        return SCIPreadTim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadTim(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static MemorySegment SCIPreadTim$address() {
        return SCIPreadTim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadTim(SCIP *scip, const char *filename, SCIP_RESULT *result)
     * }
     */
    public static int SCIPreadTim(MemorySegment scip, MemorySegment filename, MemorySegment result) {
        var mh$ = SCIPreadTim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadTim", scip, filename, result);
            }
            return (int)mh$.invokeExact(scip, filename, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimHasRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimHasRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPtimHasRead(SCIP_READER *reader)
     * }
     */
    public static FunctionDescriptor SCIPtimHasRead$descriptor() {
        return SCIPtimHasRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPtimHasRead(SCIP_READER *reader)
     * }
     */
    public static MethodHandle SCIPtimHasRead$handle() {
        return SCIPtimHasRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPtimHasRead(SCIP_READER *reader)
     * }
     */
    public static MemorySegment SCIPtimHasRead$address() {
        return SCIPtimHasRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPtimHasRead(SCIP_READER *reader)
     * }
     */
    public static int SCIPtimHasRead(MemorySegment reader) {
        var mh$ = SCIPtimHasRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimHasRead", reader);
            }
            return (int)mh$.invokeExact(reader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetNStages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetNStages");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtimGetNStages(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPtimGetNStages$descriptor() {
        return SCIPtimGetNStages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtimGetNStages(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPtimGetNStages$handle() {
        return SCIPtimGetNStages.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtimGetNStages(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPtimGetNStages$address() {
        return SCIPtimGetNStages.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtimGetNStages(SCIP *scip)
     * }
     */
    public static int SCIPtimGetNStages(MemorySegment scip) {
        var mh$ = SCIPtimGetNStages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetNStages", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetStageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetStageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPtimGetStageName(SCIP *scip, int stagenum)
     * }
     */
    public static FunctionDescriptor SCIPtimGetStageName$descriptor() {
        return SCIPtimGetStageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPtimGetStageName(SCIP *scip, int stagenum)
     * }
     */
    public static MethodHandle SCIPtimGetStageName$handle() {
        return SCIPtimGetStageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPtimGetStageName(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageName$address() {
        return SCIPtimGetStageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPtimGetStageName(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageName(MemorySegment scip, int stagenum) {
        var mh$ = SCIPtimGetStageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetStageName", scip, stagenum);
            }
            return (MemorySegment)mh$.invokeExact(scip, stagenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimConsGetStageName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimConsGetStageName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPtimConsGetStageName(SCIP *scip, const char *consname)
     * }
     */
    public static FunctionDescriptor SCIPtimConsGetStageName$descriptor() {
        return SCIPtimConsGetStageName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPtimConsGetStageName(SCIP *scip, const char *consname)
     * }
     */
    public static MethodHandle SCIPtimConsGetStageName$handle() {
        return SCIPtimConsGetStageName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPtimConsGetStageName(SCIP *scip, const char *consname)
     * }
     */
    public static MemorySegment SCIPtimConsGetStageName$address() {
        return SCIPtimConsGetStageName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPtimConsGetStageName(SCIP *scip, const char *consname)
     * }
     */
    public static MemorySegment SCIPtimConsGetStageName(MemorySegment scip, MemorySegment consname) {
        var mh$ = SCIPtimConsGetStageName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimConsGetStageName", scip, consname);
            }
            return (MemorySegment)mh$.invokeExact(scip, consname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimFindStage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimFindStage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtimFindStage(SCIP *scip, const char *stage)
     * }
     */
    public static FunctionDescriptor SCIPtimFindStage$descriptor() {
        return SCIPtimFindStage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtimFindStage(SCIP *scip, const char *stage)
     * }
     */
    public static MethodHandle SCIPtimFindStage$handle() {
        return SCIPtimFindStage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtimFindStage(SCIP *scip, const char *stage)
     * }
     */
    public static MemorySegment SCIPtimFindStage$address() {
        return SCIPtimFindStage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtimFindStage(SCIP *scip, const char *stage)
     * }
     */
    public static int SCIPtimFindStage(MemorySegment scip, MemorySegment stage) {
        var mh$ = SCIPtimFindStage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimFindStage", scip, stage);
            }
            return (int)mh$.invokeExact(scip, stage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetStageVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetStageVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPtimGetStageVars(SCIP *scip, int stagenum)
     * }
     */
    public static FunctionDescriptor SCIPtimGetStageVars$descriptor() {
        return SCIPtimGetStageVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPtimGetStageVars(SCIP *scip, int stagenum)
     * }
     */
    public static MethodHandle SCIPtimGetStageVars$handle() {
        return SCIPtimGetStageVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPtimGetStageVars(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageVars$address() {
        return SCIPtimGetStageVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPtimGetStageVars(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageVars(MemorySegment scip, int stagenum) {
        var mh$ = SCIPtimGetStageVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetStageVars", scip, stagenum);
            }
            return (MemorySegment)mh$.invokeExact(scip, stagenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetStageConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetStageConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPtimGetStageConss(SCIP *scip, int stagenum)
     * }
     */
    public static FunctionDescriptor SCIPtimGetStageConss$descriptor() {
        return SCIPtimGetStageConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPtimGetStageConss(SCIP *scip, int stagenum)
     * }
     */
    public static MethodHandle SCIPtimGetStageConss$handle() {
        return SCIPtimGetStageConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPtimGetStageConss(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageConss$address() {
        return SCIPtimGetStageConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPtimGetStageConss(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageConss(MemorySegment scip, int stagenum) {
        var mh$ = SCIPtimGetStageConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetStageConss", scip, stagenum);
            }
            return (MemorySegment)mh$.invokeExact(scip, stagenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetStageNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetStageNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNVars(SCIP *scip, int stagenum)
     * }
     */
    public static FunctionDescriptor SCIPtimGetStageNVars$descriptor() {
        return SCIPtimGetStageNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNVars(SCIP *scip, int stagenum)
     * }
     */
    public static MethodHandle SCIPtimGetStageNVars$handle() {
        return SCIPtimGetStageNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNVars(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageNVars$address() {
        return SCIPtimGetStageNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtimGetStageNVars(SCIP *scip, int stagenum)
     * }
     */
    public static int SCIPtimGetStageNVars(MemorySegment scip, int stagenum) {
        var mh$ = SCIPtimGetStageNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetStageNVars", scip, stagenum);
            }
            return (int)mh$.invokeExact(scip, stagenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtimGetStageNConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtimGetStageNConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNConss(SCIP *scip, int stagenum)
     * }
     */
    public static FunctionDescriptor SCIPtimGetStageNConss$descriptor() {
        return SCIPtimGetStageNConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNConss(SCIP *scip, int stagenum)
     * }
     */
    public static MethodHandle SCIPtimGetStageNConss$handle() {
        return SCIPtimGetStageNConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtimGetStageNConss(SCIP *scip, int stagenum)
     * }
     */
    public static MemorySegment SCIPtimGetStageNConss$address() {
        return SCIPtimGetStageNConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtimGetStageNConss(SCIP *scip, int stagenum)
     * }
     */
    public static int SCIPtimGetStageNConss(MemorySegment scip, int stagenum) {
        var mh$ = SCIPtimGetStageNConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtimGetStageNConss", scip, stagenum);
            }
            return (int)mh$.invokeExact(scip, stagenum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderWbo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderWbo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderWbo(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderWbo$descriptor() {
        return SCIPincludeReaderWbo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderWbo(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderWbo$handle() {
        return SCIPincludeReaderWbo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderWbo(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderWbo$address() {
        return SCIPincludeReaderWbo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderWbo(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderWbo(MemorySegment scip) {
        var mh$ = SCIPincludeReaderWbo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderWbo", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderZpl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderZpl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderZpl(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderZpl$descriptor() {
        return SCIPincludeReaderZpl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderZpl(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeReaderZpl$handle() {
        return SCIPincludeReaderZpl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderZpl(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeReaderZpl$address() {
        return SCIPincludeReaderZpl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderZpl(SCIP *scip)
     * }
     */
    public static int SCIPincludeReaderZpl(MemorySegment scip) {
        var mh$ = SCIPincludeReaderZpl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderZpl", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaEccuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaEccuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaEccuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaEccuts$descriptor() {
        return SCIPincludeSepaEccuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaEccuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaEccuts$handle() {
        return SCIPincludeSepaEccuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaEccuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaEccuts$address() {
        return SCIPincludeSepaEccuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaEccuts(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaEccuts(MemorySegment scip) {
        var mh$ = SCIPincludeSepaEccuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaEccuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaCGMIP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaCGMIP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaCGMIP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaCGMIP$descriptor() {
        return SCIPincludeSepaCGMIP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaCGMIP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaCGMIP$handle() {
        return SCIPincludeSepaCGMIP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaCGMIP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaCGMIP$address() {
        return SCIPincludeSepaCGMIP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaCGMIP(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaCGMIP(MemorySegment scip) {
        var mh$ = SCIPincludeSepaCGMIP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaCGMIP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaClique {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaClique");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClique(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaClique$descriptor() {
        return SCIPincludeSepaClique.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClique(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaClique$handle() {
        return SCIPincludeSepaClique.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClique(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaClique$address() {
        return SCIPincludeSepaClique.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClique(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaClique(MemorySegment scip) {
        var mh$ = SCIPincludeSepaClique.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaClique", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaClosecuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaClosecuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClosecuts(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaClosecuts$descriptor() {
        return SCIPincludeSepaClosecuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClosecuts(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaClosecuts$handle() {
        return SCIPincludeSepaClosecuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClosecuts(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaClosecuts$address() {
        return SCIPincludeSepaClosecuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaClosecuts(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaClosecuts(MemorySegment scip) {
        var mh$ = SCIPincludeSepaClosecuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaClosecuts", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBasePointClosecuts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBasePointClosecuts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBasePointClosecuts(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsetBasePointClosecuts$descriptor() {
        return SCIPsetBasePointClosecuts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBasePointClosecuts(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsetBasePointClosecuts$handle() {
        return SCIPsetBasePointClosecuts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBasePointClosecuts(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsetBasePointClosecuts$address() {
        return SCIPsetBasePointClosecuts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBasePointClosecuts(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPsetBasePointClosecuts(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPsetBasePointClosecuts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBasePointClosecuts", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaAggregation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaAggregation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaAggregation(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaAggregation$descriptor() {
        return SCIPincludeSepaAggregation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaAggregation(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaAggregation$handle() {
        return SCIPincludeSepaAggregation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaAggregation(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaAggregation$address() {
        return SCIPincludeSepaAggregation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaAggregation(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaAggregation(MemorySegment scip) {
        var mh$ = SCIPincludeSepaAggregation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaAggregation", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaConvexproj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaConvexproj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaConvexproj(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaConvexproj$descriptor() {
        return SCIPincludeSepaConvexproj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaConvexproj(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaConvexproj$handle() {
        return SCIPincludeSepaConvexproj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaConvexproj(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaConvexproj$address() {
        return SCIPincludeSepaConvexproj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaConvexproj(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaConvexproj(MemorySegment scip) {
        var mh$ = SCIPincludeSepaConvexproj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaConvexproj", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaDisjunctive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaDisjunctive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaDisjunctive(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaDisjunctive$descriptor() {
        return SCIPincludeSepaDisjunctive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaDisjunctive(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaDisjunctive$handle() {
        return SCIPincludeSepaDisjunctive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaDisjunctive(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaDisjunctive$address() {
        return SCIPincludeSepaDisjunctive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaDisjunctive(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaDisjunctive(MemorySegment scip) {
        var mh$ = SCIPincludeSepaDisjunctive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaDisjunctive", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaGauge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaGauge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGauge(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaGauge$descriptor() {
        return SCIPincludeSepaGauge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGauge(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaGauge$handle() {
        return SCIPincludeSepaGauge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGauge(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaGauge$address() {
        return SCIPincludeSepaGauge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGauge(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaGauge(MemorySegment scip) {
        var mh$ = SCIPincludeSepaGauge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaGauge", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaGomory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaGomory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGomory(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaGomory$descriptor() {
        return SCIPincludeSepaGomory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGomory(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaGomory$handle() {
        return SCIPincludeSepaGomory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGomory(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaGomory$address() {
        return SCIPincludeSepaGomory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaGomory(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaGomory(MemorySegment scip) {
        var mh$ = SCIPincludeSepaGomory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaGomory", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaImpliedbounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaImpliedbounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaImpliedbounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaImpliedbounds$descriptor() {
        return SCIPincludeSepaImpliedbounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaImpliedbounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaImpliedbounds$handle() {
        return SCIPincludeSepaImpliedbounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaImpliedbounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaImpliedbounds$address() {
        return SCIPincludeSepaImpliedbounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaImpliedbounds(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaImpliedbounds(MemorySegment scip) {
        var mh$ = SCIPincludeSepaImpliedbounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaImpliedbounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaInterminor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaInterminor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaInterminor(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaInterminor$descriptor() {
        return SCIPincludeSepaInterminor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaInterminor(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaInterminor$handle() {
        return SCIPincludeSepaInterminor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaInterminor(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaInterminor$address() {
        return SCIPincludeSepaInterminor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaInterminor(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaInterminor(MemorySegment scip) {
        var mh$ = SCIPincludeSepaInterminor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaInterminor", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaIntobj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaIntobj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaIntobj(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaIntobj$descriptor() {
        return SCIPincludeSepaIntobj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaIntobj(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaIntobj$handle() {
        return SCIPincludeSepaIntobj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaIntobj(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaIntobj$address() {
        return SCIPincludeSepaIntobj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaIntobj(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaIntobj(MemorySegment scip) {
        var mh$ = SCIPincludeSepaIntobj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaIntobj", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaLagromory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaLagromory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaLagromory(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaLagromory$descriptor() {
        return SCIPincludeSepaLagromory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaLagromory(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaLagromory$handle() {
        return SCIPincludeSepaLagromory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaLagromory(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaLagromory$address() {
        return SCIPincludeSepaLagromory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaLagromory(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaLagromory(MemorySegment scip) {
        var mh$ = SCIPincludeSepaLagromory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaLagromory", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaMcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaMcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMcf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaMcf$descriptor() {
        return SCIPincludeSepaMcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMcf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaMcf$handle() {
        return SCIPincludeSepaMcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMcf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaMcf$address() {
        return SCIPincludeSepaMcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMcf(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaMcf(MemorySegment scip) {
        var mh$ = SCIPincludeSepaMcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaMcf", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaMinor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaMinor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMinor(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaMinor$descriptor() {
        return SCIPincludeSepaMinor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMinor(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaMinor$handle() {
        return SCIPincludeSepaMinor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMinor(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaMinor$address() {
        return SCIPincludeSepaMinor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMinor(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaMinor(MemorySegment scip) {
        var mh$ = SCIPincludeSepaMinor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaMinor", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaMixing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaMixing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMixing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaMixing$descriptor() {
        return SCIPincludeSepaMixing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMixing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaMixing$handle() {
        return SCIPincludeSepaMixing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMixing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaMixing$address() {
        return SCIPincludeSepaMixing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaMixing(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaMixing(MemorySegment scip) {
        var mh$ = SCIPincludeSepaMixing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaMixing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaOddcycle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaOddcycle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaOddcycle(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaOddcycle$descriptor() {
        return SCIPincludeSepaOddcycle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaOddcycle(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaOddcycle$handle() {
        return SCIPincludeSepaOddcycle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaOddcycle(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaOddcycle$address() {
        return SCIPincludeSepaOddcycle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaOddcycle(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaOddcycle(MemorySegment scip) {
        var mh$ = SCIPincludeSepaOddcycle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaOddcycle", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaRapidlearning {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaRapidlearning");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRapidlearning(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaRapidlearning$descriptor() {
        return SCIPincludeSepaRapidlearning.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRapidlearning(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaRapidlearning$handle() {
        return SCIPincludeSepaRapidlearning.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRapidlearning(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaRapidlearning$address() {
        return SCIPincludeSepaRapidlearning.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRapidlearning(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaRapidlearning(MemorySegment scip) {
        var mh$ = SCIPincludeSepaRapidlearning.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaRapidlearning", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaRlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaRlt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRlt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaRlt$descriptor() {
        return SCIPincludeSepaRlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRlt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaRlt$handle() {
        return SCIPincludeSepaRlt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRlt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaRlt$address() {
        return SCIPincludeSepaRlt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaRlt(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaRlt(MemorySegment scip) {
        var mh$ = SCIPincludeSepaRlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaRlt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaZerohalf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaZerohalf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaZerohalf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaZerohalf$descriptor() {
        return SCIPincludeSepaZerohalf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaZerohalf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeSepaZerohalf$handle() {
        return SCIPincludeSepaZerohalf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaZerohalf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeSepaZerohalf$address() {
        return SCIPincludeSepaZerohalf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaZerohalf(SCIP *scip)
     * }
     */
    public static int SCIPincludeSepaZerohalf(MemorySegment scip) {
        var mh$ = SCIPincludeSepaZerohalf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaZerohalf", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprocessShellArguments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprocessShellArguments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessShellArguments(SCIP *scip, int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static FunctionDescriptor SCIPprocessShellArguments$descriptor() {
        return SCIPprocessShellArguments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessShellArguments(SCIP *scip, int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static MethodHandle SCIPprocessShellArguments$handle() {
        return SCIPprocessShellArguments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessShellArguments(SCIP *scip, int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static MemorySegment SCIPprocessShellArguments$address() {
        return SCIPprocessShellArguments.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprocessShellArguments(SCIP *scip, int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static int SCIPprocessShellArguments(MemorySegment scip, int argc, MemorySegment argv, MemorySegment defaultsetname) {
        var mh$ = SCIPprocessShellArguments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprocessShellArguments", scip, argc, argv, defaultsetname);
            }
            return (int)mh$.invokeExact(scip, argc, argv, defaultsetname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrunShell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrunShell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrunShell(int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static FunctionDescriptor SCIPrunShell$descriptor() {
        return SCIPrunShell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrunShell(int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static MethodHandle SCIPrunShell$handle() {
        return SCIPrunShell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrunShell(int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static MemorySegment SCIPrunShell$address() {
        return SCIPrunShell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrunShell(int argc, char **argv, const char *defaultsetname)
     * }
     */
    public static int SCIPrunShell(int argc, MemorySegment argv, MemorySegment defaultsetname) {
        var mh$ = SCIPrunShell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrunShell", argc, argv, defaultsetname);
            }
            return (int)mh$.invokeExact(argc, argv, defaultsetname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeOrbitsSym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeOrbitsSym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsSym(SCIP *scip, unsigned int issigned, SCIP_VAR **permvars, int npermvars, int **perms, int nperms, int *orbits, int *orbitbegins, int *norbits)
     * }
     */
    public static FunctionDescriptor SCIPcomputeOrbitsSym$descriptor() {
        return SCIPcomputeOrbitsSym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsSym(SCIP *scip, unsigned int issigned, SCIP_VAR **permvars, int npermvars, int **perms, int nperms, int *orbits, int *orbitbegins, int *norbits)
     * }
     */
    public static MethodHandle SCIPcomputeOrbitsSym$handle() {
        return SCIPcomputeOrbitsSym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsSym(SCIP *scip, unsigned int issigned, SCIP_VAR **permvars, int npermvars, int **perms, int nperms, int *orbits, int *orbitbegins, int *norbits)
     * }
     */
    public static MemorySegment SCIPcomputeOrbitsSym$address() {
        return SCIPcomputeOrbitsSym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsSym(SCIP *scip, unsigned int issigned, SCIP_VAR **permvars, int npermvars, int **perms, int nperms, int *orbits, int *orbitbegins, int *norbits)
     * }
     */
    public static int SCIPcomputeOrbitsSym(MemorySegment scip, int issigned, MemorySegment permvars, int npermvars, MemorySegment perms, int nperms, MemorySegment orbits, MemorySegment orbitbegins, MemorySegment norbits) {
        var mh$ = SCIPcomputeOrbitsSym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeOrbitsSym", scip, issigned, permvars, npermvars, perms, nperms, orbits, orbitbegins, norbits);
            }
            return (int)mh$.invokeExact(scip, issigned, permvars, npermvars, perms, nperms, orbits, orbitbegins, norbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeOrbitsFilterSym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeOrbitsFilterSym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsFilterSym(SCIP *scip, int npermvars, int **permstrans, int nperms, uint8_t *inactiveperms, int *orbits, int *orbitbegins, int *norbits, int *components, int *componentbegins, int *vartocomponent, unsigned int *componentblocked, int ncomponents, int nmovedpermvars)
     * }
     */
    public static FunctionDescriptor SCIPcomputeOrbitsFilterSym$descriptor() {
        return SCIPcomputeOrbitsFilterSym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsFilterSym(SCIP *scip, int npermvars, int **permstrans, int nperms, uint8_t *inactiveperms, int *orbits, int *orbitbegins, int *norbits, int *components, int *componentbegins, int *vartocomponent, unsigned int *componentblocked, int ncomponents, int nmovedpermvars)
     * }
     */
    public static MethodHandle SCIPcomputeOrbitsFilterSym$handle() {
        return SCIPcomputeOrbitsFilterSym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsFilterSym(SCIP *scip, int npermvars, int **permstrans, int nperms, uint8_t *inactiveperms, int *orbits, int *orbitbegins, int *norbits, int *components, int *componentbegins, int *vartocomponent, unsigned int *componentblocked, int ncomponents, int nmovedpermvars)
     * }
     */
    public static MemorySegment SCIPcomputeOrbitsFilterSym$address() {
        return SCIPcomputeOrbitsFilterSym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsFilterSym(SCIP *scip, int npermvars, int **permstrans, int nperms, uint8_t *inactiveperms, int *orbits, int *orbitbegins, int *norbits, int *components, int *componentbegins, int *vartocomponent, unsigned int *componentblocked, int ncomponents, int nmovedpermvars)
     * }
     */
    public static int SCIPcomputeOrbitsFilterSym(MemorySegment scip, int npermvars, MemorySegment permstrans, int nperms, MemorySegment inactiveperms, MemorySegment orbits, MemorySegment orbitbegins, MemorySegment norbits, MemorySegment components, MemorySegment componentbegins, MemorySegment vartocomponent, MemorySegment componentblocked, int ncomponents, int nmovedpermvars) {
        var mh$ = SCIPcomputeOrbitsFilterSym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeOrbitsFilterSym", scip, npermvars, permstrans, nperms, inactiveperms, orbits, orbitbegins, norbits, components, componentbegins, vartocomponent, componentblocked, ncomponents, nmovedpermvars);
            }
            return (int)mh$.invokeExact(scip, npermvars, permstrans, nperms, inactiveperms, orbits, orbitbegins, norbits, components, componentbegins, vartocomponent, componentblocked, ncomponents, nmovedpermvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeOrbitsComponentsSym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeOrbitsComponentsSym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsComponentsSym(SCIP *scip, int npermvars, int **permstrans, int nperms, int *components, int *componentbegins, int *vartocomponent, int ncomponents, int *orbits, int *orbitbegins, int *norbits, int *varorbitmap)
     * }
     */
    public static FunctionDescriptor SCIPcomputeOrbitsComponentsSym$descriptor() {
        return SCIPcomputeOrbitsComponentsSym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsComponentsSym(SCIP *scip, int npermvars, int **permstrans, int nperms, int *components, int *componentbegins, int *vartocomponent, int ncomponents, int *orbits, int *orbitbegins, int *norbits, int *varorbitmap)
     * }
     */
    public static MethodHandle SCIPcomputeOrbitsComponentsSym$handle() {
        return SCIPcomputeOrbitsComponentsSym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsComponentsSym(SCIP *scip, int npermvars, int **permstrans, int nperms, int *components, int *componentbegins, int *vartocomponent, int ncomponents, int *orbits, int *orbitbegins, int *norbits, int *varorbitmap)
     * }
     */
    public static MemorySegment SCIPcomputeOrbitsComponentsSym$address() {
        return SCIPcomputeOrbitsComponentsSym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitsComponentsSym(SCIP *scip, int npermvars, int **permstrans, int nperms, int *components, int *componentbegins, int *vartocomponent, int ncomponents, int *orbits, int *orbitbegins, int *norbits, int *varorbitmap)
     * }
     */
    public static int SCIPcomputeOrbitsComponentsSym(MemorySegment scip, int npermvars, MemorySegment permstrans, int nperms, MemorySegment components, MemorySegment componentbegins, MemorySegment vartocomponent, int ncomponents, MemorySegment orbits, MemorySegment orbitbegins, MemorySegment norbits, MemorySegment varorbitmap) {
        var mh$ = SCIPcomputeOrbitsComponentsSym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeOrbitsComponentsSym", scip, npermvars, permstrans, nperms, components, componentbegins, vartocomponent, ncomponents, orbits, orbitbegins, norbits, varorbitmap);
            }
            return (int)mh$.invokeExact(scip, npermvars, permstrans, nperms, components, componentbegins, vartocomponent, ncomponents, orbits, orbitbegins, norbits, varorbitmap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeOrbitVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeOrbitVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitVar(SCIP *scip, int npermvars, int **perms, int **permstrans, int *components, int *componentbegins, uint8_t *ignoredvars, uint8_t *varfound, int varidx, int component, int *orbit, int *orbitsize)
     * }
     */
    public static FunctionDescriptor SCIPcomputeOrbitVar$descriptor() {
        return SCIPcomputeOrbitVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitVar(SCIP *scip, int npermvars, int **perms, int **permstrans, int *components, int *componentbegins, uint8_t *ignoredvars, uint8_t *varfound, int varidx, int component, int *orbit, int *orbitsize)
     * }
     */
    public static MethodHandle SCIPcomputeOrbitVar$handle() {
        return SCIPcomputeOrbitVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitVar(SCIP *scip, int npermvars, int **perms, int **permstrans, int *components, int *componentbegins, uint8_t *ignoredvars, uint8_t *varfound, int varidx, int component, int *orbit, int *orbitsize)
     * }
     */
    public static MemorySegment SCIPcomputeOrbitVar$address() {
        return SCIPcomputeOrbitVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeOrbitVar(SCIP *scip, int npermvars, int **perms, int **permstrans, int *components, int *componentbegins, uint8_t *ignoredvars, uint8_t *varfound, int varidx, int component, int *orbit, int *orbitsize)
     * }
     */
    public static int SCIPcomputeOrbitVar(MemorySegment scip, int npermvars, MemorySegment perms, MemorySegment permstrans, MemorySegment components, MemorySegment componentbegins, MemorySegment ignoredvars, MemorySegment varfound, int varidx, int component, MemorySegment orbit, MemorySegment orbitsize) {
        var mh$ = SCIPcomputeOrbitVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeOrbitVar", scip, npermvars, perms, permstrans, components, componentbegins, ignoredvars, varfound, varidx, component, orbit, orbitsize);
            }
            return (int)mh$.invokeExact(scip, npermvars, perms, permstrans, components, componentbegins, ignoredvars, varfound, varidx, component, orbit, orbitsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisInvolutionPerm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisInvolutionPerm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisInvolutionPerm(int *perm, SCIP_VAR **vars, int nvars, int *ntwocyclesperm, int *nbincyclesperm, unsigned int earlytermination)
     * }
     */
    public static FunctionDescriptor SCIPisInvolutionPerm$descriptor() {
        return SCIPisInvolutionPerm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisInvolutionPerm(int *perm, SCIP_VAR **vars, int nvars, int *ntwocyclesperm, int *nbincyclesperm, unsigned int earlytermination)
     * }
     */
    public static MethodHandle SCIPisInvolutionPerm$handle() {
        return SCIPisInvolutionPerm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisInvolutionPerm(int *perm, SCIP_VAR **vars, int nvars, int *ntwocyclesperm, int *nbincyclesperm, unsigned int earlytermination)
     * }
     */
    public static MemorySegment SCIPisInvolutionPerm$address() {
        return SCIPisInvolutionPerm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisInvolutionPerm(int *perm, SCIP_VAR **vars, int nvars, int *ntwocyclesperm, int *nbincyclesperm, unsigned int earlytermination)
     * }
     */
    public static int SCIPisInvolutionPerm(MemorySegment perm, MemorySegment vars, int nvars, MemorySegment ntwocyclesperm, MemorySegment nbincyclesperm, int earlytermination) {
        var mh$ = SCIPisInvolutionPerm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisInvolutionPerm", perm, vars, nvars, ntwocyclesperm, nbincyclesperm, earlytermination);
            }
            return (int)mh$.invokeExact(perm, vars, nvars, ntwocyclesperm, nbincyclesperm, earlytermination);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdetermineNVarsAffectedSym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdetermineNVarsAffectedSym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetermineNVarsAffectedSym(SCIP *scip, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, int *nvarsaffected)
     * }
     */
    public static FunctionDescriptor SCIPdetermineNVarsAffectedSym$descriptor() {
        return SCIPdetermineNVarsAffectedSym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetermineNVarsAffectedSym(SCIP *scip, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, int *nvarsaffected)
     * }
     */
    public static MethodHandle SCIPdetermineNVarsAffectedSym$handle() {
        return SCIPdetermineNVarsAffectedSym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetermineNVarsAffectedSym(SCIP *scip, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, int *nvarsaffected)
     * }
     */
    public static MemorySegment SCIPdetermineNVarsAffectedSym$address() {
        return SCIPdetermineNVarsAffectedSym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetermineNVarsAffectedSym(SCIP *scip, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, int *nvarsaffected)
     * }
     */
    public static int SCIPdetermineNVarsAffectedSym(MemorySegment scip, MemorySegment perms, int nperms, MemorySegment permvars, int npermvars, MemorySegment nvarsaffected) {
        var mh$ = SCIPdetermineNVarsAffectedSym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdetermineNVarsAffectedSym", scip, perms, nperms, permvars, npermvars, nvarsaffected);
            }
            return (int)mh$.invokeExact(scip, perms, nperms, permvars, npermvars, nvarsaffected);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeComponentsSym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeComponentsSym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeComponentsSym(SCIP *scip, SYM_SYMTYPE symtype, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, unsigned int transposed, int **components, int **componentbegins, int **vartocomponent, unsigned int **componentblocked, int *ncomponents)
     * }
     */
    public static FunctionDescriptor SCIPcomputeComponentsSym$descriptor() {
        return SCIPcomputeComponentsSym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeComponentsSym(SCIP *scip, SYM_SYMTYPE symtype, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, unsigned int transposed, int **components, int **componentbegins, int **vartocomponent, unsigned int **componentblocked, int *ncomponents)
     * }
     */
    public static MethodHandle SCIPcomputeComponentsSym$handle() {
        return SCIPcomputeComponentsSym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeComponentsSym(SCIP *scip, SYM_SYMTYPE symtype, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, unsigned int transposed, int **components, int **componentbegins, int **vartocomponent, unsigned int **componentblocked, int *ncomponents)
     * }
     */
    public static MemorySegment SCIPcomputeComponentsSym$address() {
        return SCIPcomputeComponentsSym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeComponentsSym(SCIP *scip, SYM_SYMTYPE symtype, int **perms, int nperms, SCIP_VAR **permvars, int npermvars, unsigned int transposed, int **components, int **componentbegins, int **vartocomponent, unsigned int **componentblocked, int *ncomponents)
     * }
     */
    public static int SCIPcomputeComponentsSym(MemorySegment scip, int symtype, MemorySegment perms, int nperms, MemorySegment permvars, int npermvars, int transposed, MemorySegment components, MemorySegment componentbegins, MemorySegment vartocomponent, MemorySegment componentblocked, MemorySegment ncomponents) {
        var mh$ = SCIPcomputeComponentsSym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeComponentsSym", scip, symtype, perms, nperms, permvars, npermvars, transposed, components, componentbegins, vartocomponent, componentblocked, ncomponents);
            }
            return (int)mh$.invokeExact(scip, symtype, perms, nperms, permvars, npermvars, transposed, components, componentbegins, vartocomponent, componentblocked, ncomponents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPextendSubOrbitope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPextendSubOrbitope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendSubOrbitope(int **suborbitope, int nrows, int nfilledcols, int coltoextend, int *perm, unsigned int leftextension, int **nusedelems, SCIP_VAR **permvars, uint8_t *rowisbinary, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPextendSubOrbitope$descriptor() {
        return SCIPextendSubOrbitope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendSubOrbitope(int **suborbitope, int nrows, int nfilledcols, int coltoextend, int *perm, unsigned int leftextension, int **nusedelems, SCIP_VAR **permvars, uint8_t *rowisbinary, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPextendSubOrbitope$handle() {
        return SCIPextendSubOrbitope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendSubOrbitope(int **suborbitope, int nrows, int nfilledcols, int coltoextend, int *perm, unsigned int leftextension, int **nusedelems, SCIP_VAR **permvars, uint8_t *rowisbinary, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPextendSubOrbitope$address() {
        return SCIPextendSubOrbitope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPextendSubOrbitope(int **suborbitope, int nrows, int nfilledcols, int coltoextend, int *perm, unsigned int leftextension, int **nusedelems, SCIP_VAR **permvars, uint8_t *rowisbinary, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static int SCIPextendSubOrbitope(MemorySegment suborbitope, int nrows, int nfilledcols, int coltoextend, MemorySegment perm, int leftextension, MemorySegment nusedelems, MemorySegment permvars, MemorySegment rowisbinary, MemorySegment success, MemorySegment infeasible) {
        var mh$ = SCIPextendSubOrbitope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPextendSubOrbitope", suborbitope, nrows, nfilledcols, coltoextend, perm, leftextension, nusedelems, permvars, rowisbinary, success, infeasible);
            }
            return (int)mh$.invokeExact(suborbitope, nrows, nfilledcols, coltoextend, perm, leftextension, nusedelems, permvars, rowisbinary, success, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgenerateOrbitopeVarsMatrix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgenerateOrbitopeVarsMatrix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenerateOrbitopeVarsMatrix(SCIP *scip, SCIP_VAR ****vars, int nrows, int ncols, SCIP_VAR **permvars, int npermvars, int **orbitopevaridx, int *columnorder, int *nusedelems, uint8_t *rowisbinary, unsigned int *infeasible, unsigned int storelexorder, int **lexorder, int *nvarsorder, int *maxnvarsorder)
     * }
     */
    public static FunctionDescriptor SCIPgenerateOrbitopeVarsMatrix$descriptor() {
        return SCIPgenerateOrbitopeVarsMatrix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenerateOrbitopeVarsMatrix(SCIP *scip, SCIP_VAR ****vars, int nrows, int ncols, SCIP_VAR **permvars, int npermvars, int **orbitopevaridx, int *columnorder, int *nusedelems, uint8_t *rowisbinary, unsigned int *infeasible, unsigned int storelexorder, int **lexorder, int *nvarsorder, int *maxnvarsorder)
     * }
     */
    public static MethodHandle SCIPgenerateOrbitopeVarsMatrix$handle() {
        return SCIPgenerateOrbitopeVarsMatrix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenerateOrbitopeVarsMatrix(SCIP *scip, SCIP_VAR ****vars, int nrows, int ncols, SCIP_VAR **permvars, int npermvars, int **orbitopevaridx, int *columnorder, int *nusedelems, uint8_t *rowisbinary, unsigned int *infeasible, unsigned int storelexorder, int **lexorder, int *nvarsorder, int *maxnvarsorder)
     * }
     */
    public static MemorySegment SCIPgenerateOrbitopeVarsMatrix$address() {
        return SCIPgenerateOrbitopeVarsMatrix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgenerateOrbitopeVarsMatrix(SCIP *scip, SCIP_VAR ****vars, int nrows, int ncols, SCIP_VAR **permvars, int npermvars, int **orbitopevaridx, int *columnorder, int *nusedelems, uint8_t *rowisbinary, unsigned int *infeasible, unsigned int storelexorder, int **lexorder, int *nvarsorder, int *maxnvarsorder)
     * }
     */
    public static int SCIPgenerateOrbitopeVarsMatrix(MemorySegment scip, MemorySegment vars, int nrows, int ncols, MemorySegment permvars, int npermvars, MemorySegment orbitopevaridx, MemorySegment columnorder, MemorySegment nusedelems, MemorySegment rowisbinary, MemorySegment infeasible, int storelexorder, MemorySegment lexorder, MemorySegment nvarsorder, MemorySegment maxnvarsorder) {
        var mh$ = SCIPgenerateOrbitopeVarsMatrix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgenerateOrbitopeVarsMatrix", scip, vars, nrows, ncols, permvars, npermvars, orbitopevaridx, columnorder, nusedelems, rowisbinary, infeasible, storelexorder, lexorder, nvarsorder, maxnvarsorder);
            }
            return (int)mh$.invokeExact(scip, vars, nrows, ncols, permvars, npermvars, orbitopevaridx, columnorder, nusedelems, rowisbinary, infeasible, storelexorder, lexorder, nvarsorder, maxnvarsorder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisPackingPartitioningOrbitope {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisPackingPartitioningOrbitope");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisPackingPartitioningOrbitope(SCIP *scip, SCIP_VAR ***vars, int nrows, int ncols, unsigned int **pprows, int *npprows, SCIP_ORBITOPETYPE *type)
     * }
     */
    public static FunctionDescriptor SCIPisPackingPartitioningOrbitope$descriptor() {
        return SCIPisPackingPartitioningOrbitope.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisPackingPartitioningOrbitope(SCIP *scip, SCIP_VAR ***vars, int nrows, int ncols, unsigned int **pprows, int *npprows, SCIP_ORBITOPETYPE *type)
     * }
     */
    public static MethodHandle SCIPisPackingPartitioningOrbitope$handle() {
        return SCIPisPackingPartitioningOrbitope.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisPackingPartitioningOrbitope(SCIP *scip, SCIP_VAR ***vars, int nrows, int ncols, unsigned int **pprows, int *npprows, SCIP_ORBITOPETYPE *type)
     * }
     */
    public static MemorySegment SCIPisPackingPartitioningOrbitope$address() {
        return SCIPisPackingPartitioningOrbitope.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisPackingPartitioningOrbitope(SCIP *scip, SCIP_VAR ***vars, int nrows, int ncols, unsigned int **pprows, int *npprows, SCIP_ORBITOPETYPE *type)
     * }
     */
    public static int SCIPisPackingPartitioningOrbitope(MemorySegment scip, MemorySegment vars, int nrows, int ncols, MemorySegment pprows, MemorySegment npprows, MemorySegment type) {
        var mh$ = SCIPisPackingPartitioningOrbitope.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisPackingPartitioningOrbitope", scip, vars, nrows, ncols, pprows, npprows, type);
            }
            return (int)mh$.invokeExact(scip, vars, nrows, ncols, pprows, npprows, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdetectSingleOrDoubleLexMatrices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdetectSingleOrDoubleLexMatrices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetectSingleOrDoubleLexMatrices(SCIP *scip, unsigned int detectsinglelex, int **perms, int nperms, int permlen, unsigned int *success, unsigned int *isorbitope, int ***lexmatrix, int *nrows, int *ncols, int **lexrowsbegin, int **lexcolsbegin, int *nrowmatrices, int *ncolmatrices)
     * }
     */
    public static FunctionDescriptor SCIPdetectSingleOrDoubleLexMatrices$descriptor() {
        return SCIPdetectSingleOrDoubleLexMatrices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetectSingleOrDoubleLexMatrices(SCIP *scip, unsigned int detectsinglelex, int **perms, int nperms, int permlen, unsigned int *success, unsigned int *isorbitope, int ***lexmatrix, int *nrows, int *ncols, int **lexrowsbegin, int **lexcolsbegin, int *nrowmatrices, int *ncolmatrices)
     * }
     */
    public static MethodHandle SCIPdetectSingleOrDoubleLexMatrices$handle() {
        return SCIPdetectSingleOrDoubleLexMatrices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetectSingleOrDoubleLexMatrices(SCIP *scip, unsigned int detectsinglelex, int **perms, int nperms, int permlen, unsigned int *success, unsigned int *isorbitope, int ***lexmatrix, int *nrows, int *ncols, int **lexrowsbegin, int **lexcolsbegin, int *nrowmatrices, int *ncolmatrices)
     * }
     */
    public static MemorySegment SCIPdetectSingleOrDoubleLexMatrices$address() {
        return SCIPdetectSingleOrDoubleLexMatrices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdetectSingleOrDoubleLexMatrices(SCIP *scip, unsigned int detectsinglelex, int **perms, int nperms, int permlen, unsigned int *success, unsigned int *isorbitope, int ***lexmatrix, int *nrows, int *ncols, int **lexrowsbegin, int **lexcolsbegin, int *nrowmatrices, int *ncolmatrices)
     * }
     */
    public static int SCIPdetectSingleOrDoubleLexMatrices(MemorySegment scip, int detectsinglelex, MemorySegment perms, int nperms, int permlen, MemorySegment success, MemorySegment isorbitope, MemorySegment lexmatrix, MemorySegment nrows, MemorySegment ncols, MemorySegment lexrowsbegin, MemorySegment lexcolsbegin, MemorySegment nrowmatrices, MemorySegment ncolmatrices) {
        var mh$ = SCIPdetectSingleOrDoubleLexMatrices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdetectSingleOrDoubleLexMatrices", scip, detectsinglelex, perms, nperms, permlen, success, isorbitope, lexmatrix, nrows, ncols, lexrowsbegin, lexcolsbegin, nrowmatrices, ncolmatrices);
            }
            return (int)mh$.invokeExact(scip, detectsinglelex, perms, nperms, permlen, success, isorbitope, lexmatrix, nrows, ncols, lexrowsbegin, lexcolsbegin, nrowmatrices, ncolmatrices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsymEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsymEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsymEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPsymEQ$descriptor() {
        return SCIPsymEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsymEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPsymEQ$handle() {
        return SCIPsymEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsymEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPsymEQ$address() {
        return SCIPsymEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsymEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPsymEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPsymEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsymEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsymLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsymLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPsymLE$descriptor() {
        return SCIPsymLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPsymLE$handle() {
        return SCIPsymLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPsymLE$address() {
        return SCIPsymLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsymLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPsymLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPsymLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsymLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsymGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsymGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPsymGE$descriptor() {
        return SCIPsymGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPsymGE$handle() {
        return SCIPsymGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPsymGE$address() {
        return SCIPsymGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsymGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPsymGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPsymGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsymGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsymLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsymLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPsymLT$descriptor() {
        return SCIPsymLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPsymLT$handle() {
        return SCIPsymLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsymLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPsymLT$address() {
        return SCIPsymLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsymLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPsymLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPsymLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsymLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsymGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsymGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPsymGT$descriptor() {
        return SCIPsymGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPsymGT$handle() {
        return SCIPsymGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPsymGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPsymGT$address() {
        return SCIPsymGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPsymGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPsymGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPsymGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsymGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeTableDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeTableDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTableDefault(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeTableDefault$descriptor() {
        return SCIPincludeTableDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTableDefault(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeTableDefault$handle() {
        return SCIPincludeTableDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTableDefault(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeTableDefault$address() {
        return SCIPincludeTableDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTableDefault(SCIP *scip)
     * }
     */
    public static int SCIPincludeTableDefault(MemorySegment scip) {
        var mh$ = SCIPincludeTableDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeTableDefault", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeConcurrentScipSolvers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeConcurrentScipSolvers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcurrentScipSolvers(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeConcurrentScipSolvers$descriptor() {
        return SCIPincludeConcurrentScipSolvers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcurrentScipSolvers(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeConcurrentScipSolvers$handle() {
        return SCIPincludeConcurrentScipSolvers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcurrentScipSolvers(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeConcurrentScipSolvers$address() {
        return SCIPincludeConcurrentScipSolvers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeConcurrentScipSolvers(SCIP *scip)
     * }
     */
    public static int SCIPincludeConcurrentScipSolvers(MemorySegment scip) {
        var mh$ = SCIPincludeConcurrentScipSolvers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeConcurrentScipSolvers", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeBendersDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeBendersDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersDefault(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeBendersDefault$descriptor() {
        return SCIPincludeBendersDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersDefault(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeBendersDefault$handle() {
        return SCIPincludeBendersDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersDefault(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeBendersDefault$address() {
        return SCIPincludeBendersDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeBendersDefault(SCIP *scip)
     * }
     */
    public static int SCIPincludeBendersDefault(MemorySegment scip) {
        var mh$ = SCIPincludeBendersDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeBendersDefault", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateBendersDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateBendersDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBendersDefault(SCIP *scip, SCIP **subproblems, int nsubproblems)
     * }
     */
    public static FunctionDescriptor SCIPcreateBendersDefault$descriptor() {
        return SCIPcreateBendersDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBendersDefault(SCIP *scip, SCIP **subproblems, int nsubproblems)
     * }
     */
    public static MethodHandle SCIPcreateBendersDefault$handle() {
        return SCIPcreateBendersDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBendersDefault(SCIP *scip, SCIP **subproblems, int nsubproblems)
     * }
     */
    public static MemorySegment SCIPcreateBendersDefault$address() {
        return SCIPcreateBendersDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateBendersDefault(SCIP *scip, SCIP **subproblems, int nsubproblems)
     * }
     */
    public static int SCIPcreateBendersDefault(MemorySegment scip, MemorySegment subproblems, int nsubproblems) {
        var mh$ = SCIPcreateBendersDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateBendersDefault", scip, subproblems, nsubproblems);
            }
            return (int)mh$.invokeExact(scip, subproblems, nsubproblems);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCutselHybrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCutselHybrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselHybrid(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeCutselHybrid$descriptor() {
        return SCIPincludeCutselHybrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselHybrid(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeCutselHybrid$handle() {
        return SCIPincludeCutselHybrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselHybrid(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeCutselHybrid$address() {
        return SCIPincludeCutselHybrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselHybrid(SCIP *scip)
     * }
     */
    public static int SCIPincludeCutselHybrid(MemorySegment scip) {
        var mh$ = SCIPincludeCutselHybrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCutselHybrid", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectCutsHybrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectCutsHybrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsHybrid(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, double goodscorefac, double badscorefac, double goodmaxparall, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static FunctionDescriptor SCIPselectCutsHybrid$descriptor() {
        return SCIPselectCutsHybrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsHybrid(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, double goodscorefac, double badscorefac, double goodmaxparall, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MethodHandle SCIPselectCutsHybrid$handle() {
        return SCIPselectCutsHybrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsHybrid(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, double goodscorefac, double badscorefac, double goodmaxparall, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MemorySegment SCIPselectCutsHybrid$address() {
        return SCIPselectCutsHybrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsHybrid(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, double goodscorefac, double badscorefac, double goodmaxparall, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static int SCIPselectCutsHybrid(MemorySegment scip, MemorySegment cuts, MemorySegment forcedcuts, MemorySegment randnumgen, double goodscorefac, double badscorefac, double goodmaxparall, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, MemorySegment nselectedcuts) {
        var mh$ = SCIPselectCutsHybrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectCutsHybrid", scip, cuts, forcedcuts, randnumgen, goodscorefac, badscorefac, goodmaxparall, maxparall, dircutoffdistweight, efficacyweight, objparalweight, intsupportweight, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
            }
            return (int)mh$.invokeExact(scip, cuts, forcedcuts, randnumgen, goodscorefac, badscorefac, goodmaxparall, maxparall, dircutoffdistweight, efficacyweight, objparalweight, intsupportweight, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCutselDynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCutselDynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselDynamic(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeCutselDynamic$descriptor() {
        return SCIPincludeCutselDynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselDynamic(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeCutselDynamic$handle() {
        return SCIPincludeCutselDynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselDynamic(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeCutselDynamic$address() {
        return SCIPincludeCutselDynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselDynamic(SCIP *scip)
     * }
     */
    public static int SCIPincludeCutselDynamic(MemorySegment scip) {
        var mh$ = SCIPincludeCutselDynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCutselDynamic", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectCutsDynamic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectCutsDynamic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsDynamic(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, char filtermode, double mingain, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static FunctionDescriptor SCIPselectCutsDynamic$descriptor() {
        return SCIPselectCutsDynamic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsDynamic(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, char filtermode, double mingain, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MethodHandle SCIPselectCutsDynamic$handle() {
        return SCIPselectCutsDynamic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsDynamic(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, char filtermode, double mingain, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MemorySegment SCIPselectCutsDynamic$address() {
        return SCIPselectCutsDynamic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsDynamic(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_RANDNUMGEN *randnumgen, char filtermode, double mingain, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static int SCIPselectCutsDynamic(MemorySegment scip, MemorySegment cuts, MemorySegment forcedcuts, MemorySegment randnumgen, byte filtermode, double mingain, double maxparall, double dircutoffdistweight, double efficacyweight, double objparalweight, double intsupportweight, int ncuts, int nforcedcuts, int maxselectedcuts, MemorySegment nselectedcuts) {
        var mh$ = SCIPselectCutsDynamic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectCutsDynamic", scip, cuts, forcedcuts, randnumgen, filtermode, mingain, maxparall, dircutoffdistweight, efficacyweight, objparalweight, intsupportweight, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
            }
            return (int)mh$.invokeExact(scip, cuts, forcedcuts, randnumgen, filtermode, mingain, maxparall, dircutoffdistweight, efficacyweight, objparalweight, intsupportweight, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCutselEnsemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCutselEnsemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselEnsemble(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeCutselEnsemble$descriptor() {
        return SCIPincludeCutselEnsemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselEnsemble(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeCutselEnsemble$handle() {
        return SCIPincludeCutselEnsemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselEnsemble(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeCutselEnsemble$address() {
        return SCIPincludeCutselEnsemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselEnsemble(SCIP *scip)
     * }
     */
    public static int SCIPincludeCutselEnsemble(MemorySegment scip) {
        var mh$ = SCIPincludeCutselEnsemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCutselEnsemble", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPselectCutsEnsemble {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPselectCutsEnsemble");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsEnsemble(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_CUTSELDATA *cutseldata, unsigned int root, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static FunctionDescriptor SCIPselectCutsEnsemble$descriptor() {
        return SCIPselectCutsEnsemble.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsEnsemble(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_CUTSELDATA *cutseldata, unsigned int root, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MethodHandle SCIPselectCutsEnsemble$handle() {
        return SCIPselectCutsEnsemble.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsEnsemble(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_CUTSELDATA *cutseldata, unsigned int root, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static MemorySegment SCIPselectCutsEnsemble$address() {
        return SCIPselectCutsEnsemble.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPselectCutsEnsemble(SCIP *scip, SCIP_ROW **cuts, SCIP_ROW **forcedcuts, SCIP_CUTSELDATA *cutseldata, unsigned int root, int ncuts, int nforcedcuts, int maxselectedcuts, int *nselectedcuts)
     * }
     */
    public static int SCIPselectCutsEnsemble(MemorySegment scip, MemorySegment cuts, MemorySegment forcedcuts, MemorySegment cutseldata, int root, int ncuts, int nforcedcuts, int maxselectedcuts, MemorySegment nselectedcuts) {
        var mh$ = SCIPselectCutsEnsemble.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPselectCutsEnsemble", scip, cuts, forcedcuts, cutseldata, root, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
            }
            return (int)mh$.invokeExact(scip, cuts, forcedcuts, cutseldata, root, ncuts, nforcedcuts, maxselectedcuts, nselectedcuts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExprhdlrVaridx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExprhdlrVaridx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVaridx(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeExprhdlrVaridx$descriptor() {
        return SCIPincludeExprhdlrVaridx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVaridx(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeExprhdlrVaridx$handle() {
        return SCIPincludeExprhdlrVaridx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVaridx(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeExprhdlrVaridx$address() {
        return SCIPincludeExprhdlrVaridx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExprhdlrVaridx(SCIP *scip)
     * }
     */
    public static int SCIPincludeExprhdlrVaridx(MemorySegment scip) {
        var mh$ = SCIPincludeExprhdlrVaridx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExprhdlrVaridx", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExprVaridx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExprVaridx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVaridx(SCIP *scip, SCIP_EXPR **expr, int varidx, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcreateExprVaridx$descriptor() {
        return SCIPcreateExprVaridx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVaridx(SCIP *scip, SCIP_EXPR **expr, int varidx, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcreateExprVaridx$handle() {
        return SCIPcreateExprVaridx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVaridx(SCIP *scip, SCIP_EXPR **expr, int varidx, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcreateExprVaridx$address() {
        return SCIPcreateExprVaridx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExprVaridx(SCIP *scip, SCIP_EXPR **expr, int varidx, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcreateExprVaridx(MemorySegment scip, MemorySegment expr, int varidx, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcreateExprVaridx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExprVaridx", scip, expr, varidx, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, varidx, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprVaridx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprVaridx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVaridx(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprVaridx$descriptor() {
        return SCIPisExprVaridx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVaridx(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprVaridx$handle() {
        return SCIPisExprVaridx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVaridx(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprVaridx$address() {
        return SCIPisExprVaridx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprVaridx(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprVaridx(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprVaridx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprVaridx", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIndexExprVaridx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIndexExprVaridx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetIndexExprVaridx(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPgetIndexExprVaridx$descriptor() {
        return SCIPgetIndexExprVaridx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetIndexExprVaridx(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPgetIndexExprVaridx$handle() {
        return SCIPgetIndexExprVaridx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetIndexExprVaridx(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPgetIndexExprVaridx$address() {
        return SCIPgetIndexExprVaridx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetIndexExprVaridx(SCIP_EXPR *expr)
     * }
     */
    public static int SCIPgetIndexExprVaridx(MemorySegment expr) {
        var mh$ = SCIPgetIndexExprVaridx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIndexExprVaridx", expr);
            }
            return (int)mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetIndexExprVaridx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetIndexExprVaridx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetIndexExprVaridx(SCIP_EXPR *expr, int newindex)
     * }
     */
    public static FunctionDescriptor SCIPsetIndexExprVaridx$descriptor() {
        return SCIPsetIndexExprVaridx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetIndexExprVaridx(SCIP_EXPR *expr, int newindex)
     * }
     */
    public static MethodHandle SCIPsetIndexExprVaridx$handle() {
        return SCIPsetIndexExprVaridx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetIndexExprVaridx(SCIP_EXPR *expr, int newindex)
     * }
     */
    public static MemorySegment SCIPsetIndexExprVaridx$address() {
        return SCIPsetIndexExprVaridx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetIndexExprVaridx(SCIP_EXPR *expr, int newindex)
     * }
     */
    public static void SCIPsetIndexExprVaridx(MemorySegment expr, int newindex) {
        var mh$ = SCIPsetIndexExprVaridx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetIndexExprVaridx", expr, newindex);
            }
            mh$.invokeExact(expr, newindex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlpSolverIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlpSolverIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverIpopt(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlpSolverIpopt$descriptor() {
        return SCIPincludeNlpSolverIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverIpopt(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlpSolverIpopt$handle() {
        return SCIPincludeNlpSolverIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverIpopt(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlpSolverIpopt$address() {
        return SCIPincludeNlpSolverIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverIpopt(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlpSolverIpopt(MemorySegment scip) {
        var mh$ = SCIPincludeNlpSolverIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlpSolverIpopt", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverNameIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverNameIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameIpopt()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverNameIpopt$descriptor() {
        return SCIPgetSolverNameIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameIpopt()
     * }
     */
    public static MethodHandle SCIPgetSolverNameIpopt$handle() {
        return SCIPgetSolverNameIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameIpopt()
     * }
     */
    public static MemorySegment SCIPgetSolverNameIpopt$address() {
        return SCIPgetSolverNameIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameIpopt()
     * }
     */
    public static MemorySegment SCIPgetSolverNameIpopt() {
        var mh$ = SCIPgetSolverNameIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverNameIpopt");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverDescIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverDescIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescIpopt()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverDescIpopt$descriptor() {
        return SCIPgetSolverDescIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescIpopt()
     * }
     */
    public static MethodHandle SCIPgetSolverDescIpopt$handle() {
        return SCIPgetSolverDescIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescIpopt()
     * }
     */
    public static MemorySegment SCIPgetSolverDescIpopt$address() {
        return SCIPgetSolverDescIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescIpopt()
     * }
     */
    public static MemorySegment SCIPgetSolverDescIpopt() {
        var mh$ = SCIPgetSolverDescIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverDescIpopt");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisIpoptAvailableIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisIpoptAvailableIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisIpoptAvailableIpopt()
     * }
     */
    public static FunctionDescriptor SCIPisIpoptAvailableIpopt$descriptor() {
        return SCIPisIpoptAvailableIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisIpoptAvailableIpopt()
     * }
     */
    public static MethodHandle SCIPisIpoptAvailableIpopt$handle() {
        return SCIPisIpoptAvailableIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisIpoptAvailableIpopt()
     * }
     */
    public static MemorySegment SCIPisIpoptAvailableIpopt$address() {
        return SCIPisIpoptAvailableIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisIpoptAvailableIpopt()
     * }
     */
    public static int SCIPisIpoptAvailableIpopt() {
        var mh$ = SCIPisIpoptAvailableIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisIpoptAvailableIpopt");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiOracleIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiOracleIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiOracleIpopt(SCIP_NLPIPROBLEM *nlpiproblem)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiOracleIpopt$descriptor() {
        return SCIPgetNlpiOracleIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiOracleIpopt(SCIP_NLPIPROBLEM *nlpiproblem)
     * }
     */
    public static MethodHandle SCIPgetNlpiOracleIpopt$handle() {
        return SCIPgetNlpiOracleIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiOracleIpopt(SCIP_NLPIPROBLEM *nlpiproblem)
     * }
     */
    public static MemorySegment SCIPgetNlpiOracleIpopt$address() {
        return SCIPgetNlpiOracleIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPgetNlpiOracleIpopt(SCIP_NLPIPROBLEM *nlpiproblem)
     * }
     */
    public static MemorySegment SCIPgetNlpiOracleIpopt(MemorySegment nlpiproblem) {
        var mh$ = SCIPgetNlpiOracleIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiOracleIpopt", nlpiproblem);
            }
            return (MemorySegment)mh$.invokeExact(nlpiproblem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallLapackDsyevIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallLapackDsyevIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallLapackDsyevIpopt(unsigned int computeeigenvectors, int N, double *a, double *w)
     * }
     */
    public static FunctionDescriptor SCIPcallLapackDsyevIpopt$descriptor() {
        return SCIPcallLapackDsyevIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallLapackDsyevIpopt(unsigned int computeeigenvectors, int N, double *a, double *w)
     * }
     */
    public static MethodHandle SCIPcallLapackDsyevIpopt$handle() {
        return SCIPcallLapackDsyevIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallLapackDsyevIpopt(unsigned int computeeigenvectors, int N, double *a, double *w)
     * }
     */
    public static MemorySegment SCIPcallLapackDsyevIpopt$address() {
        return SCIPcallLapackDsyevIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallLapackDsyevIpopt(unsigned int computeeigenvectors, int N, double *a, double *w)
     * }
     */
    public static int SCIPcallLapackDsyevIpopt(int computeeigenvectors, int N, MemorySegment a, MemorySegment w) {
        var mh$ = SCIPcallLapackDsyevIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallLapackDsyevIpopt", computeeigenvectors, N, a, w);
            }
            return (int)mh$.invokeExact(computeeigenvectors, N, a, w);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveLinearEquationsIpopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveLinearEquationsIpopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveLinearEquationsIpopt(int N, double *A, double *b, double *x, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPsolveLinearEquationsIpopt$descriptor() {
        return SCIPsolveLinearEquationsIpopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveLinearEquationsIpopt(int N, double *A, double *b, double *x, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPsolveLinearEquationsIpopt$handle() {
        return SCIPsolveLinearEquationsIpopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveLinearEquationsIpopt(int N, double *A, double *b, double *x, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPsolveLinearEquationsIpopt$address() {
        return SCIPsolveLinearEquationsIpopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveLinearEquationsIpopt(int N, double *A, double *b, double *x, unsigned int *success)
     * }
     */
    public static int SCIPsolveLinearEquationsIpopt(int N, MemorySegment A, MemorySegment b, MemorySegment x, MemorySegment success) {
        var mh$ = SCIPsolveLinearEquationsIpopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveLinearEquationsIpopt", N, A, b, x, success);
            }
            return (int)mh$.invokeExact(N, A, b, x, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlpSolverFilterSQP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlpSolverFilterSQP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverFilterSQP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlpSolverFilterSQP$descriptor() {
        return SCIPincludeNlpSolverFilterSQP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverFilterSQP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlpSolverFilterSQP$handle() {
        return SCIPincludeNlpSolverFilterSQP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverFilterSQP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlpSolverFilterSQP$address() {
        return SCIPincludeNlpSolverFilterSQP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverFilterSQP(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlpSolverFilterSQP(MemorySegment scip) {
        var mh$ = SCIPincludeNlpSolverFilterSQP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlpSolverFilterSQP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverNameFilterSQP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverNameFilterSQP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameFilterSQP()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverNameFilterSQP$descriptor() {
        return SCIPgetSolverNameFilterSQP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameFilterSQP()
     * }
     */
    public static MethodHandle SCIPgetSolverNameFilterSQP$handle() {
        return SCIPgetSolverNameFilterSQP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameFilterSQP()
     * }
     */
    public static MemorySegment SCIPgetSolverNameFilterSQP$address() {
        return SCIPgetSolverNameFilterSQP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameFilterSQP()
     * }
     */
    public static MemorySegment SCIPgetSolverNameFilterSQP() {
        var mh$ = SCIPgetSolverNameFilterSQP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverNameFilterSQP");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverDescFilterSQP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverDescFilterSQP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescFilterSQP()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverDescFilterSQP$descriptor() {
        return SCIPgetSolverDescFilterSQP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescFilterSQP()
     * }
     */
    public static MethodHandle SCIPgetSolverDescFilterSQP$handle() {
        return SCIPgetSolverDescFilterSQP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescFilterSQP()
     * }
     */
    public static MemorySegment SCIPgetSolverDescFilterSQP$address() {
        return SCIPgetSolverDescFilterSQP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescFilterSQP()
     * }
     */
    public static MemorySegment SCIPgetSolverDescFilterSQP() {
        var mh$ = SCIPgetSolverDescFilterSQP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverDescFilterSQP");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFilterSQPAvailableFilterSQP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFilterSQPAvailableFilterSQP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFilterSQPAvailableFilterSQP()
     * }
     */
    public static FunctionDescriptor SCIPisFilterSQPAvailableFilterSQP$descriptor() {
        return SCIPisFilterSQPAvailableFilterSQP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFilterSQPAvailableFilterSQP()
     * }
     */
    public static MethodHandle SCIPisFilterSQPAvailableFilterSQP$handle() {
        return SCIPisFilterSQPAvailableFilterSQP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFilterSQPAvailableFilterSQP()
     * }
     */
    public static MemorySegment SCIPisFilterSQPAvailableFilterSQP$address() {
        return SCIPisFilterSQPAvailableFilterSQP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFilterSQPAvailableFilterSQP()
     * }
     */
    public static int SCIPisFilterSQPAvailableFilterSQP() {
        var mh$ = SCIPisFilterSQPAvailableFilterSQP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFilterSQPAvailableFilterSQP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlpSolverWorhp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlpSolverWorhp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverWorhp(SCIP *scip, unsigned int useip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlpSolverWorhp$descriptor() {
        return SCIPincludeNlpSolverWorhp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverWorhp(SCIP *scip, unsigned int useip)
     * }
     */
    public static MethodHandle SCIPincludeNlpSolverWorhp$handle() {
        return SCIPincludeNlpSolverWorhp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverWorhp(SCIP *scip, unsigned int useip)
     * }
     */
    public static MemorySegment SCIPincludeNlpSolverWorhp$address() {
        return SCIPincludeNlpSolverWorhp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverWorhp(SCIP *scip, unsigned int useip)
     * }
     */
    public static int SCIPincludeNlpSolverWorhp(MemorySegment scip, int useip) {
        var mh$ = SCIPincludeNlpSolverWorhp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlpSolverWorhp", scip, useip);
            }
            return (int)mh$.invokeExact(scip, useip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverNameWorhp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverNameWorhp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameWorhp()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverNameWorhp$descriptor() {
        return SCIPgetSolverNameWorhp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameWorhp()
     * }
     */
    public static MethodHandle SCIPgetSolverNameWorhp$handle() {
        return SCIPgetSolverNameWorhp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameWorhp()
     * }
     */
    public static MemorySegment SCIPgetSolverNameWorhp$address() {
        return SCIPgetSolverNameWorhp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverNameWorhp()
     * }
     */
    public static MemorySegment SCIPgetSolverNameWorhp() {
        var mh$ = SCIPgetSolverNameWorhp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverNameWorhp");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolverDescWorhp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolverDescWorhp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescWorhp()
     * }
     */
    public static FunctionDescriptor SCIPgetSolverDescWorhp$descriptor() {
        return SCIPgetSolverDescWorhp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescWorhp()
     * }
     */
    public static MethodHandle SCIPgetSolverDescWorhp$handle() {
        return SCIPgetSolverDescWorhp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescWorhp()
     * }
     */
    public static MemorySegment SCIPgetSolverDescWorhp$address() {
        return SCIPgetSolverDescWorhp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetSolverDescWorhp()
     * }
     */
    public static MemorySegment SCIPgetSolverDescWorhp() {
        var mh$ = SCIPgetSolverDescWorhp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolverDescWorhp");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisWorhpAvailableWorhp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisWorhpAvailableWorhp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisWorhpAvailableWorhp()
     * }
     */
    public static FunctionDescriptor SCIPisWorhpAvailableWorhp$descriptor() {
        return SCIPisWorhpAvailableWorhp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisWorhpAvailableWorhp()
     * }
     */
    public static MethodHandle SCIPisWorhpAvailableWorhp$handle() {
        return SCIPisWorhpAvailableWorhp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisWorhpAvailableWorhp()
     * }
     */
    public static MemorySegment SCIPisWorhpAvailableWorhp$address() {
        return SCIPisWorhpAvailableWorhp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisWorhpAvailableWorhp()
     * }
     */
    public static int SCIPisWorhpAvailableWorhp() {
        var mh$ = SCIPisWorhpAvailableWorhp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisWorhpAvailableWorhp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlpSolverAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlpSolverAll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverAll(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlpSolverAll$descriptor() {
        return SCIPincludeNlpSolverAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverAll(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeNlpSolverAll$handle() {
        return SCIPincludeNlpSolverAll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverAll(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeNlpSolverAll$address() {
        return SCIPincludeNlpSolverAll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpSolverAll(SCIP *scip)
     * }
     */
    public static int SCIPincludeNlpSolverAll(MemorySegment scip) {
        var mh$ = SCIPincludeNlpSolverAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlpSolverAll", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeDefaultPlugins {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeDefaultPlugins");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDefaultPlugins(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPincludeDefaultPlugins$descriptor() {
        return SCIPincludeDefaultPlugins.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDefaultPlugins(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPincludeDefaultPlugins$handle() {
        return SCIPincludeDefaultPlugins.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDefaultPlugins(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPincludeDefaultPlugins$address() {
        return SCIPincludeDefaultPlugins.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeDefaultPlugins(SCIP *scip)
     * }
     */
    public static int SCIPincludeDefaultPlugins(MemorySegment scip) {
        var mh$ = SCIPincludeDefaultPlugins.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeDefaultPlugins", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define CMAKE_BUILD_TYPE "Release"
     * }
     */
    public static MemorySegment CMAKE_BUILD_TYPE() {
        class Holder {
            static final MemorySegment CMAKE_BUILD_TYPE
                = scip_h.LIBRARY_ARENA.allocateFrom("Release");
        }
        return Holder.CMAKE_BUILD_TYPE;
    }
    private static final int SCIP_VERSION = (int)910L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VERSION 910
     * }
     */
    public static int SCIP_VERSION() {
        return SCIP_VERSION;
    }
    private static final int SCIP_SUBVERSION = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SCIP_SUBVERSION 0
     * }
     */
    public static int SCIP_SUBVERSION() {
        return SCIP_SUBVERSION;
    }
    private static final int SCIP_APIVERSION = (int)115L;
    /**
     * {@snippet lang=c :
     * #define SCIP_APIVERSION 115
     * }
     */
    public static int SCIP_APIVERSION() {
        return SCIP_APIVERSION;
    }
    /**
     * {@snippet lang=c :
     * #define SCIP_COPYRIGHT "Copyright (c) 2002-2024 Zuse Institute Berlin (ZIB)"
     * }
     */
    public static MemorySegment SCIP_COPYRIGHT() {
        class Holder {
            static final MemorySegment SCIP_COPYRIGHT
                = scip_h.LIBRARY_ARENA.allocateFrom("Copyright (c) 2002-2024 Zuse Institute Berlin (ZIB)");
        }
        return Holder.SCIP_COPYRIGHT;
    }
    private static final int SCIP_VARTYPE_BINARY_CHAR = (int)66L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VARTYPE_BINARY_CHAR 66
     * }
     */
    public static int SCIP_VARTYPE_BINARY_CHAR() {
        return SCIP_VARTYPE_BINARY_CHAR;
    }
    private static final int SCIP_VARTYPE_INTEGER_CHAR = (int)73L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VARTYPE_INTEGER_CHAR 73
     * }
     */
    public static int SCIP_VARTYPE_INTEGER_CHAR() {
        return SCIP_VARTYPE_INTEGER_CHAR;
    }
    private static final int SCIP_VARTYPE_IMPLINT_CHAR = (int)77L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VARTYPE_IMPLINT_CHAR 77
     * }
     */
    public static int SCIP_VARTYPE_IMPLINT_CHAR() {
        return SCIP_VARTYPE_IMPLINT_CHAR;
    }
    private static final int SCIP_VARTYPE_CONTINUOUS_CHAR = (int)67L;
    /**
     * {@snippet lang=c :
     * #define SCIP_VARTYPE_CONTINUOUS_CHAR 67
     * }
     */
    public static int SCIP_VARTYPE_CONTINUOUS_CHAR() {
        return SCIP_VARTYPE_CONTINUOUS_CHAR;
    }
    private static final long SCIP_LONGINT_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SCIP_LONGINT_MAX 9223372036854775807
     * }
     */
    public static long SCIP_LONGINT_MAX() {
        return SCIP_LONGINT_MAX;
    }
    private static final long SCIP_LONGINT_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define SCIP_LONGINT_MIN -9223372036854775808
     * }
     */
    public static long SCIP_LONGINT_MIN() {
        return SCIP_LONGINT_MIN;
    }
    private static final double SCIP_REAL_MAX = 1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define SCIP_REAL_MAX 1.7976931348623157E308
     * }
     */
    public static double SCIP_REAL_MAX() {
        return SCIP_REAL_MAX;
    }
    private static final double SCIP_REAL_MIN = -1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define SCIP_REAL_MIN -1.7976931348623157E308
     * }
     */
    public static double SCIP_REAL_MIN() {
        return SCIP_REAL_MIN;
    }
    /**
     * {@snippet lang=c :
     * #define SCIP_REAL_FORMAT "lf"
     * }
     */
    public static MemorySegment SCIP_REAL_FORMAT() {
        class Holder {
            static final MemorySegment SCIP_REAL_FORMAT
                = scip_h.LIBRARY_ARENA.allocateFrom("lf");
        }
        return Holder.SCIP_REAL_FORMAT;
    }
    private static final double SCIP_DEFAULT_INFINITY = 1.0E20d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_INFINITY 1.0E20
     * }
     */
    public static double SCIP_DEFAULT_INFINITY() {
        return SCIP_DEFAULT_INFINITY;
    }
    private static final double SCIP_DEFAULT_EPSILON = 1.0E-9d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_EPSILON 1.0E-9
     * }
     */
    public static double SCIP_DEFAULT_EPSILON() {
        return SCIP_DEFAULT_EPSILON;
    }
    private static final double SCIP_DEFAULT_SUMEPSILON = 1.0E-6d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_SUMEPSILON 1.0E-6
     * }
     */
    public static double SCIP_DEFAULT_SUMEPSILON() {
        return SCIP_DEFAULT_SUMEPSILON;
    }
    private static final double SCIP_DEFAULT_FEASTOL = 1.0E-6d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_FEASTOL 1.0E-6
     * }
     */
    public static double SCIP_DEFAULT_FEASTOL() {
        return SCIP_DEFAULT_FEASTOL;
    }
    private static final double SCIP_DEFAULT_CHECKFEASTOLFAC = 1.0d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_CHECKFEASTOLFAC 1.0
     * }
     */
    public static double SCIP_DEFAULT_CHECKFEASTOLFAC() {
        return SCIP_DEFAULT_CHECKFEASTOLFAC;
    }
    private static final double SCIP_DEFAULT_LPFEASTOLFACTOR = 1.0d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_LPFEASTOLFACTOR 1.0
     * }
     */
    public static double SCIP_DEFAULT_LPFEASTOLFACTOR() {
        return SCIP_DEFAULT_LPFEASTOLFACTOR;
    }
    private static final double SCIP_DEFAULT_DUALFEASTOL = 1.0E-7d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_DUALFEASTOL 1.0E-7
     * }
     */
    public static double SCIP_DEFAULT_DUALFEASTOL() {
        return SCIP_DEFAULT_DUALFEASTOL;
    }
    private static final double SCIP_DEFAULT_BARRIERCONVTOL = 1.0E-10d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_BARRIERCONVTOL 1.0E-10
     * }
     */
    public static double SCIP_DEFAULT_BARRIERCONVTOL() {
        return SCIP_DEFAULT_BARRIERCONVTOL;
    }
    private static final double SCIP_DEFAULT_BOUNDSTREPS = 0.05d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_BOUNDSTREPS 0.05
     * }
     */
    public static double SCIP_DEFAULT_BOUNDSTREPS() {
        return SCIP_DEFAULT_BOUNDSTREPS;
    }
    private static final double SCIP_DEFAULT_PSEUDOCOSTEPS = 0.1d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_PSEUDOCOSTEPS 0.1
     * }
     */
    public static double SCIP_DEFAULT_PSEUDOCOSTEPS() {
        return SCIP_DEFAULT_PSEUDOCOSTEPS;
    }
    private static final double SCIP_DEFAULT_PSEUDOCOSTDELTA = 1.0E-4d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_PSEUDOCOSTDELTA 1.0E-4
     * }
     */
    public static double SCIP_DEFAULT_PSEUDOCOSTDELTA() {
        return SCIP_DEFAULT_PSEUDOCOSTDELTA;
    }
    private static final double SCIP_DEFAULT_RECOMPFAC = 1.0E7d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_RECOMPFAC 1.0E7
     * }
     */
    public static double SCIP_DEFAULT_RECOMPFAC() {
        return SCIP_DEFAULT_RECOMPFAC;
    }
    private static final double SCIP_DEFAULT_HUGEVAL = 1.0E15d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_HUGEVAL 1.0E15
     * }
     */
    public static double SCIP_DEFAULT_HUGEVAL() {
        return SCIP_DEFAULT_HUGEVAL;
    }
    private static final double SCIP_MAXEPSILON = 0.001d;
    /**
     * {@snippet lang=c :
     * #define SCIP_MAXEPSILON 0.001
     * }
     */
    public static double SCIP_MAXEPSILON() {
        return SCIP_MAXEPSILON;
    }
    private static final double SCIP_MINEPSILON = 1.0E-20d;
    /**
     * {@snippet lang=c :
     * #define SCIP_MINEPSILON 1.0E-20
     * }
     */
    public static double SCIP_MINEPSILON() {
        return SCIP_MINEPSILON;
    }
    private static final double SCIP_INVALID = 1.0E99d;
    /**
     * {@snippet lang=c :
     * #define SCIP_INVALID 1.0E99
     * }
     */
    public static double SCIP_INVALID() {
        return SCIP_INVALID;
    }
    private static final double SCIP_UNKNOWN = 1.0E98d;
    /**
     * {@snippet lang=c :
     * #define SCIP_UNKNOWN 1.0E98
     * }
     */
    public static double SCIP_UNKNOWN() {
        return SCIP_UNKNOWN;
    }
    private static final double SCIP_INTERVAL_INFINITY = 1.0E300d;
    /**
     * {@snippet lang=c :
     * #define SCIP_INTERVAL_INFINITY 1.0E300
     * }
     */
    public static double SCIP_INTERVAL_INFINITY() {
        return SCIP_INTERVAL_INFINITY;
    }
    /**
     * {@snippet lang=c :
     * #define SCIP_SPACECONTROL " tnvfr"
     * }
     */
    public static MemorySegment SCIP_SPACECONTROL() {
        class Holder {
            static final MemorySegment SCIP_SPACECONTROL
                = scip_h.LIBRARY_ARENA.allocateFrom(" tnvfr");
        }
        return Holder.SCIP_SPACECONTROL;
    }
    private static final long SCIP_MAXMEMSIZE = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SCIP_MAXMEMSIZE 9223372036854775807
     * }
     */
    public static long SCIP_MAXMEMSIZE() {
        return SCIP_MAXMEMSIZE;
    }
    private static final double SCIP_DEFAULT_MEM_ARRAYGROWFAC = 1.2d;
    /**
     * {@snippet lang=c :
     * #define SCIP_DEFAULT_MEM_ARRAYGROWFAC 1.2
     * }
     */
    public static double SCIP_DEFAULT_MEM_ARRAYGROWFAC() {
        return SCIP_DEFAULT_MEM_ARRAYGROWFAC;
    }
    private static final long SCIP_MEM_NOLIMIT = 8796093022207L;
    /**
     * {@snippet lang=c :
     * #define SCIP_MEM_NOLIMIT 8796093022207
     * }
     */
    public static long SCIP_MEM_NOLIMIT() {
        return SCIP_MEM_NOLIMIT;
    }
    private static final int SCIP_PRESOLTIMING_NONE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_NONE 2
     * }
     */
    public static int SCIP_PRESOLTIMING_NONE() {
        return SCIP_PRESOLTIMING_NONE;
    }
    private static final int SCIP_PRESOLTIMING_FAST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_FAST 4
     * }
     */
    public static int SCIP_PRESOLTIMING_FAST() {
        return SCIP_PRESOLTIMING_FAST;
    }
    private static final int SCIP_PRESOLTIMING_MEDIUM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_MEDIUM 8
     * }
     */
    public static int SCIP_PRESOLTIMING_MEDIUM() {
        return SCIP_PRESOLTIMING_MEDIUM;
    }
    private static final int SCIP_PRESOLTIMING_EXHAUSTIVE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_EXHAUSTIVE 16
     * }
     */
    public static int SCIP_PRESOLTIMING_EXHAUSTIVE() {
        return SCIP_PRESOLTIMING_EXHAUSTIVE;
    }
    private static final int SCIP_PRESOLTIMING_FINAL = (int)32L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_FINAL 32
     * }
     */
    public static int SCIP_PRESOLTIMING_FINAL() {
        return SCIP_PRESOLTIMING_FINAL;
    }
    private static final int SCIP_PRESOLTIMING_ALWAYS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_ALWAYS 28
     * }
     */
    public static int SCIP_PRESOLTIMING_ALWAYS() {
        return SCIP_PRESOLTIMING_ALWAYS;
    }
    private static final int SCIP_PRESOLTIMING_MAX = (int)60L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PRESOLTIMING_MAX 60
     * }
     */
    public static int SCIP_PRESOLTIMING_MAX() {
        return SCIP_PRESOLTIMING_MAX;
    }
    private static final int SCIP_PROPTIMING_BEFORELP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SCIP_PROPTIMING_BEFORELP 1
     * }
     */
    public static int SCIP_PROPTIMING_BEFORELP() {
        return SCIP_PROPTIMING_BEFORELP;
    }
}

