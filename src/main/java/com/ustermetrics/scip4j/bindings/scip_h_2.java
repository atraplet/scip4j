// Generated by jextract

package com.ustermetrics.scip4j.bindings;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class scip_h_2 extends scip_h_3 {

    scip_h_2() {
        // Should not be called directly
    }

    private static class SCIPduplicateExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPduplicateExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*mapexpr)(SCIP *, SCIP_EXPR **, SCIP *, SCIP_EXPR *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *, void *), void *mapexprdata, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPduplicateExpr$descriptor() {
        return SCIPduplicateExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*mapexpr)(SCIP *, SCIP_EXPR **, SCIP *, SCIP_EXPR *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *, void *), void *mapexprdata, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPduplicateExpr$handle() {
        return SCIPduplicateExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*mapexpr)(SCIP *, SCIP_EXPR **, SCIP *, SCIP_EXPR *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *, void *), void *mapexprdata, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPduplicateExpr$address() {
        return SCIPduplicateExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*mapexpr)(SCIP *, SCIP_EXPR **, SCIP *, SCIP_EXPR *, SCIP_RETCODE (*)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *, void *), void *mapexprdata, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPduplicateExpr(MemorySegment scip, MemorySegment expr, MemorySegment copyexpr, MemorySegment mapexpr, MemorySegment mapexprdata, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPduplicateExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPduplicateExpr", scip, expr, copyexpr, mapexpr, mapexprdata, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, copyexpr, mapexpr, mapexprdata, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPduplicateExprShallow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPduplicateExprShallow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExprShallow(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPduplicateExprShallow$descriptor() {
        return SCIPduplicateExprShallow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExprShallow(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPduplicateExprShallow$handle() {
        return SCIPduplicateExprShallow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExprShallow(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPduplicateExprShallow$address() {
        return SCIPduplicateExprShallow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPduplicateExprShallow(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPduplicateExprShallow(MemorySegment scip, MemorySegment expr, MemorySegment copyexpr, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPduplicateExprShallow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPduplicateExprShallow", scip, expr, copyexpr, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, copyexpr, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcopyExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcopyExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyExpr(SCIP *sourcescip, SCIP *targetscip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *valid)
     * }
     */
    public static FunctionDescriptor SCIPcopyExpr$descriptor() {
        return SCIPcopyExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyExpr(SCIP *sourcescip, SCIP *targetscip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *valid)
     * }
     */
    public static MethodHandle SCIPcopyExpr$handle() {
        return SCIPcopyExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyExpr(SCIP *sourcescip, SCIP *targetscip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *valid)
     * }
     */
    public static MemorySegment SCIPcopyExpr$address() {
        return SCIPcopyExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcopyExpr(SCIP *sourcescip, SCIP *targetscip, SCIP_EXPR *expr, SCIP_EXPR **copyexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata, SCIP_HASHMAP *varmap, SCIP_HASHMAP *consmap, unsigned int global, unsigned int *valid)
     * }
     */
    public static int SCIPcopyExpr(MemorySegment sourcescip, MemorySegment targetscip, MemorySegment expr, MemorySegment copyexpr, MemorySegment ownercreate, MemorySegment ownercreatedata, MemorySegment varmap, MemorySegment consmap, int global, MemorySegment valid) {
        var mh$ = SCIPcopyExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcopyExpr", sourcescip, targetscip, expr, copyexpr, ownercreate, ownercreatedata, varmap, consmap, global, valid);
            }
            return (int)mh$.invokeExact(sourcescip, targetscip, expr, copyexpr, ownercreate, ownercreatedata, varmap, consmap, global, valid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseExpr(SCIP *scip, SCIP_EXPR **expr, const char *exprstr, const char **finalpos, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPparseExpr$descriptor() {
        return SCIPparseExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseExpr(SCIP *scip, SCIP_EXPR **expr, const char *exprstr, const char **finalpos, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPparseExpr$handle() {
        return SCIPparseExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseExpr(SCIP *scip, SCIP_EXPR **expr, const char *exprstr, const char **finalpos, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPparseExpr$address() {
        return SCIPparseExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseExpr(SCIP *scip, SCIP_EXPR **expr, const char *exprstr, const char **finalpos, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPparseExpr(MemorySegment scip, MemorySegment expr, MemorySegment exprstr, MemorySegment finalpos, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPparseExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseExpr", scip, expr, exprstr, finalpos, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, exprstr, finalpos, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPcaptureExpr(SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPcaptureExpr$descriptor() {
        return SCIPcaptureExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPcaptureExpr(SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPcaptureExpr$handle() {
        return SCIPcaptureExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPcaptureExpr(SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPcaptureExpr$address() {
        return SCIPcaptureExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPcaptureExpr(SCIP_EXPR *expr)
     * }
     */
    public static void SCIPcaptureExpr(MemorySegment expr) {
        var mh$ = SCIPcaptureExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureExpr", expr);
            }
            mh$.invokeExact(expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseExpr(SCIP *scip, SCIP_EXPR **expr)
     * }
     */
    public static FunctionDescriptor SCIPreleaseExpr$descriptor() {
        return SCIPreleaseExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseExpr(SCIP *scip, SCIP_EXPR **expr)
     * }
     */
    public static MethodHandle SCIPreleaseExpr$handle() {
        return SCIPreleaseExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseExpr(SCIP *scip, SCIP_EXPR **expr)
     * }
     */
    public static MemorySegment SCIPreleaseExpr$address() {
        return SCIPreleaseExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseExpr(SCIP *scip, SCIP_EXPR **expr)
     * }
     */
    public static int SCIPreleaseExpr(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPreleaseExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseExpr", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVar(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprVar$descriptor() {
        return SCIPisExprVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVar(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprVar$handle() {
        return SCIPisExprVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprVar(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprVar$address() {
        return SCIPisExprVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprVar(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprVar(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprVar", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprValue(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprValue$descriptor() {
        return SCIPisExprValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprValue(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprValue$handle() {
        return SCIPisExprValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprValue(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprValue$address() {
        return SCIPisExprValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprValue(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprValue(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprValue", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSum(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprSum$descriptor() {
        return SCIPisExprSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSum(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprSum$handle() {
        return SCIPisExprSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprSum(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprSum$address() {
        return SCIPisExprSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprSum(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprSum(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprSum", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprProduct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprProduct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprProduct(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprProduct$descriptor() {
        return SCIPisExprProduct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprProduct(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprProduct$handle() {
        return SCIPisExprProduct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprProduct(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprProduct$address() {
        return SCIPisExprProduct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprProduct(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprProduct(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprProduct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprProduct", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExprPower {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExprPower");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprPower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPisExprPower$descriptor() {
        return SCIPisExprPower.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprPower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPisExprPower$handle() {
        return SCIPisExprPower.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExprPower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPisExprPower$address() {
        return SCIPisExprPower.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExprPower(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPisExprPower(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPisExprPower.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExprPower", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExpr(SCIP *scip, SCIP_EXPR *expr, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintExpr$descriptor() {
        return SCIPprintExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExpr(SCIP *scip, SCIP_EXPR *expr, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintExpr$handle() {
        return SCIPprintExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExpr(SCIP *scip, SCIP_EXPR *expr, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintExpr$address() {
        return SCIPprintExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExpr(SCIP *scip, SCIP_EXPR *expr, FILE *file)
     * }
     */
    public static int SCIPprintExpr(MemorySegment scip, MemorySegment expr, MemorySegment file) {
        var mh$ = SCIPprintExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExpr", scip, expr, file);
            }
            return (int)mh$.invokeExact(scip, expr, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExprDotInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExprDotInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, FILE *file, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static FunctionDescriptor SCIPprintExprDotInit$descriptor() {
        return SCIPprintExprDotInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, FILE *file, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static MethodHandle SCIPprintExprDotInit$handle() {
        return SCIPprintExprDotInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, FILE *file, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static MemorySegment SCIPprintExprDotInit$address() {
        return SCIPprintExprDotInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, FILE *file, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static int SCIPprintExprDotInit(MemorySegment scip, MemorySegment printdata, MemorySegment file, int whattoprint) {
        var mh$ = SCIPprintExprDotInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExprDotInit", scip, printdata, file, whattoprint);
            }
            return (int)mh$.invokeExact(scip, printdata, file, whattoprint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExprDotInit2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExprDotInit2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit2(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, const char *filename, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static FunctionDescriptor SCIPprintExprDotInit2$descriptor() {
        return SCIPprintExprDotInit2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit2(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, const char *filename, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static MethodHandle SCIPprintExprDotInit2$handle() {
        return SCIPprintExprDotInit2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit2(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, const char *filename, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static MemorySegment SCIPprintExprDotInit2$address() {
        return SCIPprintExprDotInit2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotInit2(SCIP *scip, SCIP_EXPRPRINTDATA **printdata, const char *filename, SCIP_EXPRPRINT_WHAT whattoprint)
     * }
     */
    public static int SCIPprintExprDotInit2(MemorySegment scip, MemorySegment printdata, MemorySegment filename, int whattoprint) {
        var mh$ = SCIPprintExprDotInit2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExprDotInit2", scip, printdata, filename, whattoprint);
            }
            return (int)mh$.invokeExact(scip, printdata, filename, whattoprint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExprDot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExprDot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDot(SCIP *scip, SCIP_EXPRPRINTDATA *printdata, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPprintExprDot$descriptor() {
        return SCIPprintExprDot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDot(SCIP *scip, SCIP_EXPRPRINTDATA *printdata, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPprintExprDot$handle() {
        return SCIPprintExprDot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDot(SCIP *scip, SCIP_EXPRPRINTDATA *printdata, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPprintExprDot$address() {
        return SCIPprintExprDot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDot(SCIP *scip, SCIP_EXPRPRINTDATA *printdata, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPprintExprDot(MemorySegment scip, MemorySegment printdata, MemorySegment expr) {
        var mh$ = SCIPprintExprDot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExprDot", scip, printdata, expr);
            }
            return (int)mh$.invokeExact(scip, printdata, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExprDotFinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExprDotFinal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotFinal(SCIP *scip, SCIP_EXPRPRINTDATA **printdata)
     * }
     */
    public static FunctionDescriptor SCIPprintExprDotFinal$descriptor() {
        return SCIPprintExprDotFinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotFinal(SCIP *scip, SCIP_EXPRPRINTDATA **printdata)
     * }
     */
    public static MethodHandle SCIPprintExprDotFinal$handle() {
        return SCIPprintExprDotFinal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotFinal(SCIP *scip, SCIP_EXPRPRINTDATA **printdata)
     * }
     */
    public static MemorySegment SCIPprintExprDotFinal$address() {
        return SCIPprintExprDotFinal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprDotFinal(SCIP *scip, SCIP_EXPRPRINTDATA **printdata)
     * }
     */
    public static int SCIPprintExprDotFinal(MemorySegment scip, MemorySegment printdata) {
        var mh$ = SCIPprintExprDotFinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExprDotFinal", scip, printdata);
            }
            return (int)mh$.invokeExact(scip, printdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPshowExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPshowExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshowExpr(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPshowExpr$descriptor() {
        return SCIPshowExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshowExpr(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPshowExpr$handle() {
        return SCIPshowExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshowExpr(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPshowExpr$address() {
        return SCIPshowExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPshowExpr(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPshowExpr(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPshowExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPshowExpr", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdismantleExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdismantleExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdismantleExpr(SCIP *scip, FILE *file, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPdismantleExpr$descriptor() {
        return SCIPdismantleExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdismantleExpr(SCIP *scip, FILE *file, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPdismantleExpr$handle() {
        return SCIPdismantleExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdismantleExpr(SCIP *scip, FILE *file, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPdismantleExpr$address() {
        return SCIPdismantleExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdismantleExpr(SCIP *scip, FILE *file, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPdismantleExpr(MemorySegment scip, MemorySegment file, MemorySegment expr) {
        var mh$ = SCIPdismantleExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdismantleExpr", scip, file, expr);
            }
            return (int)mh$.invokeExact(scip, file, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static FunctionDescriptor SCIPevalExpr$descriptor() {
        return SCIPevalExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static MethodHandle SCIPevalExpr$handle() {
        return SCIPevalExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static MemorySegment SCIPevalExpr$address() {
        return SCIPevalExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExpr(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static int SCIPevalExpr(MemorySegment scip, MemorySegment expr, MemorySegment sol, long soltag) {
        var mh$ = SCIPevalExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExpr", scip, expr, sol, soltag);
            }
            return (int)mh$.invokeExact(scip, expr, sol, soltag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNewSoltag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNewSoltag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetExprNewSoltag(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNewSoltag$descriptor() {
        return SCIPgetExprNewSoltag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetExprNewSoltag(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExprNewSoltag$handle() {
        return SCIPgetExprNewSoltag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetExprNewSoltag(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExprNewSoltag$address() {
        return SCIPgetExprNewSoltag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetExprNewSoltag(SCIP *scip)
     * }
     */
    public static long SCIPgetExprNewSoltag(MemorySegment scip) {
        var mh$ = SCIPgetExprNewSoltag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNewSoltag", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExprGradient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExprGradient");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprGradient(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static FunctionDescriptor SCIPevalExprGradient$descriptor() {
        return SCIPevalExprGradient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprGradient(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static MethodHandle SCIPevalExprGradient$handle() {
        return SCIPevalExprGradient.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprGradient(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static MemorySegment SCIPevalExprGradient$address() {
        return SCIPevalExprGradient.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprGradient(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag)
     * }
     */
    public static int SCIPevalExprGradient(MemorySegment scip, MemorySegment expr, MemorySegment sol, long soltag) {
        var mh$ = SCIPevalExprGradient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExprGradient", scip, expr, sol, soltag);
            }
            return (int)mh$.invokeExact(scip, expr, sol, soltag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExprHessianDir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExprHessianDir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprHessianDir(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, SCIP_SOL *direction)
     * }
     */
    public static FunctionDescriptor SCIPevalExprHessianDir$descriptor() {
        return SCIPevalExprHessianDir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprHessianDir(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, SCIP_SOL *direction)
     * }
     */
    public static MethodHandle SCIPevalExprHessianDir$handle() {
        return SCIPevalExprHessianDir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprHessianDir(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, SCIP_SOL *direction)
     * }
     */
    public static MemorySegment SCIPevalExprHessianDir$address() {
        return SCIPevalExprHessianDir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprHessianDir(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol, long long soltag, SCIP_SOL *direction)
     * }
     */
    public static int SCIPevalExprHessianDir(MemorySegment scip, MemorySegment expr, MemorySegment sol, long soltag, MemorySegment direction) {
        var mh$ = SCIPevalExprHessianDir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExprHessianDir", scip, expr, sol, soltag, direction);
            }
            return (int)mh$.invokeExact(scip, expr, sol, soltag, direction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExprActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExprActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprActivity(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPevalExprActivity$descriptor() {
        return SCIPevalExprActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprActivity(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPevalExprActivity$handle() {
        return SCIPevalExprActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprActivity(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPevalExprActivity$address() {
        return SCIPevalExprActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPevalExprActivity(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPevalExprActivity(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPevalExprActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExprActivity", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcompareExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcompareExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcompareExpr(SCIP *scip, SCIP_EXPR *expr1, SCIP_EXPR *expr2)
     * }
     */
    public static FunctionDescriptor SCIPcompareExpr$descriptor() {
        return SCIPcompareExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcompareExpr(SCIP *scip, SCIP_EXPR *expr1, SCIP_EXPR *expr2)
     * }
     */
    public static MethodHandle SCIPcompareExpr$handle() {
        return SCIPcompareExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcompareExpr(SCIP *scip, SCIP_EXPR *expr1, SCIP_EXPR *expr2)
     * }
     */
    public static MemorySegment SCIPcompareExpr$address() {
        return SCIPcompareExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcompareExpr(SCIP *scip, SCIP_EXPR *expr1, SCIP_EXPR *expr2)
     * }
     */
    public static int SCIPcompareExpr(MemorySegment scip, MemorySegment expr1, MemorySegment expr2) {
        var mh$ = SCIPcompareExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcompareExpr", scip, expr1, expr2);
            }
            return (int)mh$.invokeExact(scip, expr1, expr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhashExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhashExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhashExpr(SCIP *scip, SCIP_EXPR *expr, unsigned int *hashval)
     * }
     */
    public static FunctionDescriptor SCIPhashExpr$descriptor() {
        return SCIPhashExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhashExpr(SCIP *scip, SCIP_EXPR *expr, unsigned int *hashval)
     * }
     */
    public static MethodHandle SCIPhashExpr$handle() {
        return SCIPhashExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhashExpr(SCIP *scip, SCIP_EXPR *expr, unsigned int *hashval)
     * }
     */
    public static MemorySegment SCIPhashExpr$address() {
        return SCIPhashExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhashExpr(SCIP *scip, SCIP_EXPR *expr, unsigned int *hashval)
     * }
     */
    public static int SCIPhashExpr(MemorySegment scip, MemorySegment expr, MemorySegment hashval) {
        var mh$ = SCIPhashExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhashExpr", scip, expr, hashval);
            }
            return (int)mh$.invokeExact(scip, expr, hashval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsimplifyExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsimplifyExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsimplifyExpr(SCIP *scip, SCIP_EXPR *rootexpr, SCIP_EXPR **simplified, unsigned int *changed, unsigned int *infeasible, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPsimplifyExpr$descriptor() {
        return SCIPsimplifyExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsimplifyExpr(SCIP *scip, SCIP_EXPR *rootexpr, SCIP_EXPR **simplified, unsigned int *changed, unsigned int *infeasible, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPsimplifyExpr$handle() {
        return SCIPsimplifyExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsimplifyExpr(SCIP *scip, SCIP_EXPR *rootexpr, SCIP_EXPR **simplified, unsigned int *changed, unsigned int *infeasible, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPsimplifyExpr$address() {
        return SCIPsimplifyExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsimplifyExpr(SCIP *scip, SCIP_EXPR *rootexpr, SCIP_EXPR **simplified, unsigned int *changed, unsigned int *infeasible, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPsimplifyExpr(MemorySegment scip, MemorySegment rootexpr, MemorySegment simplified, MemorySegment changed, MemorySegment infeasible, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPsimplifyExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsimplifyExpr", scip, rootexpr, simplified, changed, infeasible, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, rootexpr, simplified, changed, infeasible, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSymDataExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSymDataExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymDataExpr(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static FunctionDescriptor SCIPgetSymDataExpr$descriptor() {
        return SCIPgetSymDataExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymDataExpr(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static MethodHandle SCIPgetSymDataExpr$handle() {
        return SCIPgetSymDataExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymDataExpr(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static MemorySegment SCIPgetSymDataExpr$address() {
        return SCIPgetSymDataExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSymDataExpr(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static int SCIPgetSymDataExpr(MemorySegment scip, MemorySegment expr, MemorySegment symdata) {
        var mh$ = SCIPgetSymDataExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSymDataExpr", scip, expr, symdata);
            }
            return (int)mh$.invokeExact(scip, expr, symdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreplaceCommonSubexpressions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreplaceCommonSubexpressions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceCommonSubexpressions(SCIP *scip, SCIP_EXPR **exprs, int nexprs, unsigned int *replacedroot)
     * }
     */
    public static FunctionDescriptor SCIPreplaceCommonSubexpressions$descriptor() {
        return SCIPreplaceCommonSubexpressions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceCommonSubexpressions(SCIP *scip, SCIP_EXPR **exprs, int nexprs, unsigned int *replacedroot)
     * }
     */
    public static MethodHandle SCIPreplaceCommonSubexpressions$handle() {
        return SCIPreplaceCommonSubexpressions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceCommonSubexpressions(SCIP *scip, SCIP_EXPR **exprs, int nexprs, unsigned int *replacedroot)
     * }
     */
    public static MemorySegment SCIPreplaceCommonSubexpressions$address() {
        return SCIPreplaceCommonSubexpressions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreplaceCommonSubexpressions(SCIP *scip, SCIP_EXPR **exprs, int nexprs, unsigned int *replacedroot)
     * }
     */
    public static int SCIPreplaceCommonSubexpressions(MemorySegment scip, MemorySegment exprs, int nexprs, MemorySegment replacedroot) {
        var mh$ = SCIPreplaceCommonSubexpressions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreplaceCommonSubexpressions", scip, exprs, nexprs, replacedroot);
            }
            return (int)mh$.invokeExact(scip, exprs, nexprs, replacedroot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeExprCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeExprCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprCurvature(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPcomputeExprCurvature$descriptor() {
        return SCIPcomputeExprCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprCurvature(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPcomputeExprCurvature$handle() {
        return SCIPcomputeExprCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprCurvature(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPcomputeExprCurvature$address() {
        return SCIPcomputeExprCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprCurvature(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPcomputeExprCurvature(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPcomputeExprCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeExprCurvature", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeExprIntegrality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeExprIntegrality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprIntegrality(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPcomputeExprIntegrality$descriptor() {
        return SCIPcomputeExprIntegrality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprIntegrality(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPcomputeExprIntegrality$handle() {
        return SCIPcomputeExprIntegrality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprIntegrality(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPcomputeExprIntegrality$address() {
        return SCIPcomputeExprIntegrality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprIntegrality(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPcomputeExprIntegrality(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPcomputeExprIntegrality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeExprIntegrality", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprNVars(SCIP *scip, SCIP_EXPR *expr, int *nvars)
     * }
     */
    public static FunctionDescriptor SCIPgetExprNVars$descriptor() {
        return SCIPgetExprNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprNVars(SCIP *scip, SCIP_EXPR *expr, int *nvars)
     * }
     */
    public static MethodHandle SCIPgetExprNVars$handle() {
        return SCIPgetExprNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprNVars(SCIP *scip, SCIP_EXPR *expr, int *nvars)
     * }
     */
    public static MemorySegment SCIPgetExprNVars$address() {
        return SCIPgetExprNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprNVars(SCIP *scip, SCIP_EXPR *expr, int *nvars)
     * }
     */
    public static int SCIPgetExprNVars(MemorySegment scip, MemorySegment expr, MemorySegment nvars) {
        var mh$ = SCIPgetExprNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprNVars", scip, expr, nvars);
            }
            return (int)mh$.invokeExact(scip, expr, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprVarExprs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprVarExprs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprVarExprs(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **varexprs, int *nvarexprs)
     * }
     */
    public static FunctionDescriptor SCIPgetExprVarExprs$descriptor() {
        return SCIPgetExprVarExprs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprVarExprs(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **varexprs, int *nvarexprs)
     * }
     */
    public static MethodHandle SCIPgetExprVarExprs$handle() {
        return SCIPgetExprVarExprs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprVarExprs(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **varexprs, int *nvarexprs)
     * }
     */
    public static MemorySegment SCIPgetExprVarExprs$address() {
        return SCIPgetExprVarExprs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprVarExprs(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **varexprs, int *nvarexprs)
     * }
     */
    public static int SCIPgetExprVarExprs(MemorySegment scip, MemorySegment expr, MemorySegment varexprs, MemorySegment nvarexprs) {
        var mh$ = SCIPgetExprVarExprs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprVarExprs", scip, expr, varexprs, nvarexprs);
            }
            return (int)mh$.invokeExact(scip, expr, varexprs, nvarexprs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprPrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprPrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprPrint(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRITER_STAGE stage, int currentchild, unsigned int parentprecedence, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPcallExprPrint$descriptor() {
        return SCIPcallExprPrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprPrint(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRITER_STAGE stage, int currentchild, unsigned int parentprecedence, FILE *file)
     * }
     */
    public static MethodHandle SCIPcallExprPrint$handle() {
        return SCIPcallExprPrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprPrint(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRITER_STAGE stage, int currentchild, unsigned int parentprecedence, FILE *file)
     * }
     */
    public static MemorySegment SCIPcallExprPrint$address() {
        return SCIPcallExprPrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprPrint(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRITER_STAGE stage, int currentchild, unsigned int parentprecedence, FILE *file)
     * }
     */
    public static int SCIPcallExprPrint(MemorySegment scip, MemorySegment expr, int stage, int currentchild, int parentprecedence, MemorySegment file) {
        var mh$ = SCIPcallExprPrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprPrint", scip, expr, stage, currentchild, parentprecedence, file);
            }
            return (int)mh$.invokeExact(scip, expr, stage, currentchild, parentprecedence, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV exprcurvature, unsigned int *success, SCIP_EXPRCURV *childcurv)
     * }
     */
    public static FunctionDescriptor SCIPcallExprCurvature$descriptor() {
        return SCIPcallExprCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV exprcurvature, unsigned int *success, SCIP_EXPRCURV *childcurv)
     * }
     */
    public static MethodHandle SCIPcallExprCurvature$handle() {
        return SCIPcallExprCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV exprcurvature, unsigned int *success, SCIP_EXPRCURV *childcurv)
     * }
     */
    public static MemorySegment SCIPcallExprCurvature$address() {
        return SCIPcallExprCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV exprcurvature, unsigned int *success, SCIP_EXPRCURV *childcurv)
     * }
     */
    public static int SCIPcallExprCurvature(MemorySegment scip, MemorySegment expr, int exprcurvature, MemorySegment success, MemorySegment childcurv) {
        var mh$ = SCIPcallExprCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprCurvature", scip, expr, exprcurvature, success, childcurv);
            }
            return (int)mh$.invokeExact(scip, expr, exprcurvature, success, childcurv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprMonotonicity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprMonotonicity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprMonotonicity(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_MONOTONE *result)
     * }
     */
    public static FunctionDescriptor SCIPcallExprMonotonicity$descriptor() {
        return SCIPcallExprMonotonicity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprMonotonicity(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_MONOTONE *result)
     * }
     */
    public static MethodHandle SCIPcallExprMonotonicity$handle() {
        return SCIPcallExprMonotonicity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprMonotonicity(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_MONOTONE *result)
     * }
     */
    public static MemorySegment SCIPcallExprMonotonicity$address() {
        return SCIPcallExprMonotonicity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprMonotonicity(SCIP *scip, SCIP_EXPR *expr, int childidx, SCIP_MONOTONE *result)
     * }
     */
    public static int SCIPcallExprMonotonicity(MemorySegment scip, MemorySegment expr, int childidx, MemorySegment result) {
        var mh$ = SCIPcallExprMonotonicity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprMonotonicity", scip, expr, childidx, result);
            }
            return (int)mh$.invokeExact(scip, expr, childidx, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprEval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprEval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEval(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *val)
     * }
     */
    public static FunctionDescriptor SCIPcallExprEval$descriptor() {
        return SCIPcallExprEval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEval(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *val)
     * }
     */
    public static MethodHandle SCIPcallExprEval$handle() {
        return SCIPcallExprEval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEval(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *val)
     * }
     */
    public static MemorySegment SCIPcallExprEval$address() {
        return SCIPcallExprEval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEval(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *val)
     * }
     */
    public static int SCIPcallExprEval(MemorySegment scip, MemorySegment expr, MemorySegment childrenvalues, MemorySegment val) {
        var mh$ = SCIPcallExprEval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprEval", scip, expr, childrenvalues, val);
            }
            return (int)mh$.invokeExact(scip, expr, childrenvalues, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprEvalFwdiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprEvalFwdiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEvalFwdiff(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *direction, double *val, double *dot)
     * }
     */
    public static FunctionDescriptor SCIPcallExprEvalFwdiff$descriptor() {
        return SCIPcallExprEvalFwdiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEvalFwdiff(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *direction, double *val, double *dot)
     * }
     */
    public static MethodHandle SCIPcallExprEvalFwdiff$handle() {
        return SCIPcallExprEvalFwdiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEvalFwdiff(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *direction, double *val, double *dot)
     * }
     */
    public static MemorySegment SCIPcallExprEvalFwdiff$address() {
        return SCIPcallExprEvalFwdiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEvalFwdiff(SCIP *scip, SCIP_EXPR *expr, double *childrenvalues, double *direction, double *val, double *dot)
     * }
     */
    public static int SCIPcallExprEvalFwdiff(MemorySegment scip, MemorySegment expr, MemorySegment childrenvalues, MemorySegment direction, MemorySegment val, MemorySegment dot) {
        var mh$ = SCIPcallExprEvalFwdiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprEvalFwdiff", scip, expr, childrenvalues, direction, val, dot);
            }
            return (int)mh$.invokeExact(scip, expr, childrenvalues, direction, val, dot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprInteval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprInteval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInteval(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *interval, SCIP_INTERVAL (*intevalvar)(SCIP *, SCIP_VAR *, void *), void *intevalvardata)
     * }
     */
    public static FunctionDescriptor SCIPcallExprInteval$descriptor() {
        return SCIPcallExprInteval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInteval(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *interval, SCIP_INTERVAL (*intevalvar)(SCIP *, SCIP_VAR *, void *), void *intevalvardata)
     * }
     */
    public static MethodHandle SCIPcallExprInteval$handle() {
        return SCIPcallExprInteval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInteval(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *interval, SCIP_INTERVAL (*intevalvar)(SCIP *, SCIP_VAR *, void *), void *intevalvardata)
     * }
     */
    public static MemorySegment SCIPcallExprInteval$address() {
        return SCIPcallExprInteval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInteval(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *interval, SCIP_INTERVAL (*intevalvar)(SCIP *, SCIP_VAR *, void *), void *intevalvardata)
     * }
     */
    public static int SCIPcallExprInteval(MemorySegment scip, MemorySegment expr, MemorySegment interval, MemorySegment intevalvar, MemorySegment intevalvardata) {
        var mh$ = SCIPcallExprInteval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprInteval", scip, expr, interval, intevalvar, intevalvardata);
            }
            return (int)mh$.invokeExact(scip, expr, interval, intevalvar, intevalvardata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEstimate(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *localbounds, SCIP_INTERVAL *globalbounds, double *refpoint, unsigned int overestimate, double targetvalue, double *coefs, double *constant, unsigned int *islocal, unsigned int *success, unsigned int *branchcand)
     * }
     */
    public static FunctionDescriptor SCIPcallExprEstimate$descriptor() {
        return SCIPcallExprEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEstimate(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *localbounds, SCIP_INTERVAL *globalbounds, double *refpoint, unsigned int overestimate, double targetvalue, double *coefs, double *constant, unsigned int *islocal, unsigned int *success, unsigned int *branchcand)
     * }
     */
    public static MethodHandle SCIPcallExprEstimate$handle() {
        return SCIPcallExprEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEstimate(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *localbounds, SCIP_INTERVAL *globalbounds, double *refpoint, unsigned int overestimate, double targetvalue, double *coefs, double *constant, unsigned int *islocal, unsigned int *success, unsigned int *branchcand)
     * }
     */
    public static MemorySegment SCIPcallExprEstimate$address() {
        return SCIPcallExprEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprEstimate(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *localbounds, SCIP_INTERVAL *globalbounds, double *refpoint, unsigned int overestimate, double targetvalue, double *coefs, double *constant, unsigned int *islocal, unsigned int *success, unsigned int *branchcand)
     * }
     */
    public static int SCIPcallExprEstimate(MemorySegment scip, MemorySegment expr, MemorySegment localbounds, MemorySegment globalbounds, MemorySegment refpoint, int overestimate, double targetvalue, MemorySegment coefs, MemorySegment constant, MemorySegment islocal, MemorySegment success, MemorySegment branchcand) {
        var mh$ = SCIPcallExprEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprEstimate", scip, expr, localbounds, globalbounds, refpoint, overestimate, targetvalue, coefs, constant, islocal, success, branchcand);
            }
            return (int)mh$.invokeExact(scip, expr, localbounds, globalbounds, refpoint, overestimate, targetvalue, coefs, constant, islocal, success, branchcand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprInitestimates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprInitestimates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInitestimates(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *bounds, unsigned int overestimate, double *coefs[10], double constant[10], int *nreturned)
     * }
     */
    public static FunctionDescriptor SCIPcallExprInitestimates$descriptor() {
        return SCIPcallExprInitestimates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInitestimates(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *bounds, unsigned int overestimate, double *coefs[10], double constant[10], int *nreturned)
     * }
     */
    public static MethodHandle SCIPcallExprInitestimates$handle() {
        return SCIPcallExprInitestimates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInitestimates(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *bounds, unsigned int overestimate, double *coefs[10], double constant[10], int *nreturned)
     * }
     */
    public static MemorySegment SCIPcallExprInitestimates$address() {
        return SCIPcallExprInitestimates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprInitestimates(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL *bounds, unsigned int overestimate, double *coefs[10], double constant[10], int *nreturned)
     * }
     */
    public static int SCIPcallExprInitestimates(MemorySegment scip, MemorySegment expr, MemorySegment bounds, int overestimate, MemorySegment coefs, MemorySegment constant, MemorySegment nreturned) {
        var mh$ = SCIPcallExprInitestimates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprInitestimates", scip, expr, bounds, overestimate, coefs, constant, nreturned);
            }
            return (int)mh$.invokeExact(scip, expr, bounds, overestimate, coefs, constant, nreturned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprSimplify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprSimplify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprSimplify(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **simplifiedexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static FunctionDescriptor SCIPcallExprSimplify$descriptor() {
        return SCIPcallExprSimplify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprSimplify(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **simplifiedexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MethodHandle SCIPcallExprSimplify$handle() {
        return SCIPcallExprSimplify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprSimplify(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **simplifiedexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static MemorySegment SCIPcallExprSimplify$address() {
        return SCIPcallExprSimplify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprSimplify(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPR **simplifiedexpr, SCIP_RETCODE (*ownercreate)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **, SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA **), SCIP_RETCODE (**)(SCIP *, FILE *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), SCIP_RETCODE (**)(SCIP *, SCIP_EXPR *, SCIP_EXPR_OWNERDATA *), void *), void *ownercreatedata)
     * }
     */
    public static int SCIPcallExprSimplify(MemorySegment scip, MemorySegment expr, MemorySegment simplifiedexpr, MemorySegment ownercreate, MemorySegment ownercreatedata) {
        var mh$ = SCIPcallExprSimplify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprSimplify", scip, expr, simplifiedexpr, ownercreate, ownercreatedata);
            }
            return (int)mh$.invokeExact(scip, expr, simplifiedexpr, ownercreate, ownercreatedata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprReverseprop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            SCIP_Interval.layout(),
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprReverseprop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprReverseprop(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL bounds, SCIP_INTERVAL *childrenbounds, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPcallExprReverseprop$descriptor() {
        return SCIPcallExprReverseprop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprReverseprop(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL bounds, SCIP_INTERVAL *childrenbounds, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPcallExprReverseprop$handle() {
        return SCIPcallExprReverseprop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprReverseprop(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL bounds, SCIP_INTERVAL *childrenbounds, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPcallExprReverseprop$address() {
        return SCIPcallExprReverseprop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprReverseprop(SCIP *scip, SCIP_EXPR *expr, SCIP_INTERVAL bounds, SCIP_INTERVAL *childrenbounds, unsigned int *infeasible)
     * }
     */
    public static int SCIPcallExprReverseprop(MemorySegment scip, MemorySegment expr, MemorySegment bounds, MemorySegment childrenbounds, MemorySegment infeasible) {
        var mh$ = SCIPcallExprReverseprop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprReverseprop", scip, expr, bounds, childrenbounds, infeasible);
            }
            return (int)mh$.invokeExact(scip, expr, bounds, childrenbounds, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcallExprGetSymData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcallExprGetSymData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprGetSymData(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static FunctionDescriptor SCIPcallExprGetSymData$descriptor() {
        return SCIPcallExprGetSymData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprGetSymData(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static MethodHandle SCIPcallExprGetSymData$handle() {
        return SCIPcallExprGetSymData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprGetSymData(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static MemorySegment SCIPcallExprGetSymData$address() {
        return SCIPcallExprGetSymData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcallExprGetSymData(SCIP *scip, SCIP_EXPR *expr, SYM_EXPRDATA **symdata)
     * }
     */
    public static int SCIPcallExprGetSymData(MemorySegment scip, MemorySegment expr, MemorySegment symdata) {
        var mh$ = SCIPcallExprGetSymData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcallExprGetSymData", scip, expr, symdata);
            }
            return (int)mh$.invokeExact(scip, expr, symdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateExpriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateExpriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpriter(SCIP *scip, SCIP_EXPRITER **iterator)
     * }
     */
    public static FunctionDescriptor SCIPcreateExpriter$descriptor() {
        return SCIPcreateExpriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpriter(SCIP *scip, SCIP_EXPRITER **iterator)
     * }
     */
    public static MethodHandle SCIPcreateExpriter$handle() {
        return SCIPcreateExpriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpriter(SCIP *scip, SCIP_EXPRITER **iterator)
     * }
     */
    public static MemorySegment SCIPcreateExpriter$address() {
        return SCIPcreateExpriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateExpriter(SCIP *scip, SCIP_EXPRITER **iterator)
     * }
     */
    public static int SCIPcreateExpriter(MemorySegment scip, MemorySegment iterator) {
        var mh$ = SCIPcreateExpriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateExpriter", scip, iterator);
            }
            return (int)mh$.invokeExact(scip, iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeExpriter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeExpriter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeExpriter(SCIP_EXPRITER **iterator)
     * }
     */
    public static FunctionDescriptor SCIPfreeExpriter$descriptor() {
        return SCIPfreeExpriter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeExpriter(SCIP_EXPRITER **iterator)
     * }
     */
    public static MethodHandle SCIPfreeExpriter$handle() {
        return SCIPfreeExpriter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeExpriter(SCIP_EXPRITER **iterator)
     * }
     */
    public static MemorySegment SCIPfreeExpriter$address() {
        return SCIPfreeExpriter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeExpriter(SCIP_EXPRITER **iterator)
     * }
     */
    public static void SCIPfreeExpriter(MemorySegment iterator) {
        var mh$ = SCIPfreeExpriter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeExpriter", iterator);
            }
            mh$.invokeExact(iterator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckExprQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckExprQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckExprQuadratic(SCIP *scip, SCIP_EXPR *expr, unsigned int *isquadratic)
     * }
     */
    public static FunctionDescriptor SCIPcheckExprQuadratic$descriptor() {
        return SCIPcheckExprQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckExprQuadratic(SCIP *scip, SCIP_EXPR *expr, unsigned int *isquadratic)
     * }
     */
    public static MethodHandle SCIPcheckExprQuadratic$handle() {
        return SCIPcheckExprQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckExprQuadratic(SCIP *scip, SCIP_EXPR *expr, unsigned int *isquadratic)
     * }
     */
    public static MemorySegment SCIPcheckExprQuadratic$address() {
        return SCIPcheckExprQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckExprQuadratic(SCIP *scip, SCIP_EXPR *expr, unsigned int *isquadratic)
     * }
     */
    public static int SCIPcheckExprQuadratic(MemorySegment scip, MemorySegment expr, MemorySegment isquadratic) {
        var mh$ = SCIPcheckExprQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckExprQuadratic", scip, expr, isquadratic);
            }
            return (int)mh$.invokeExact(scip, expr, isquadratic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeExprQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeExprQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPfreeExprQuadratic$descriptor() {
        return SCIPfreeExprQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPfreeExprQuadratic$handle() {
        return SCIPfreeExprQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPfreeExprQuadratic$address() {
        return SCIPfreeExprQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static void SCIPfreeExprQuadratic(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPfreeExprQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeExprQuadratic", scip, expr);
            }
            mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPevalExprQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPevalExprQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadratic(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPevalExprQuadratic$descriptor() {
        return SCIPevalExprQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadratic(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPevalExprQuadratic$handle() {
        return SCIPevalExprQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPevalExprQuadratic(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPevalExprQuadratic$address() {
        return SCIPevalExprQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPevalExprQuadratic(SCIP *scip, SCIP_EXPR *expr, SCIP_SOL *sol)
     * }
     */
    public static double SCIPevalExprQuadratic(MemorySegment scip, MemorySegment expr, MemorySegment sol) {
        var mh$ = SCIPevalExprQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPevalExprQuadratic", scip, expr, sol);
            }
            return (double)mh$.invokeExact(scip, expr, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExprQuadratic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExprQuadratic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPprintExprQuadratic$descriptor() {
        return SCIPprintExprQuadratic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPprintExprQuadratic$handle() {
        return SCIPprintExprQuadratic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPprintExprQuadratic$address() {
        return SCIPprintExprQuadratic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintExprQuadratic(SCIP *scip, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPprintExprQuadratic(MemorySegment scip, MemorySegment expr) {
        var mh$ = SCIPprintExprQuadratic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExprQuadratic", scip, expr);
            }
            return (int)mh$.invokeExact(scip, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeExprQuadraticCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeExprQuadraticCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprQuadraticCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV *curv, SCIP_HASHMAP *assumevarfixed, unsigned int storeeigeninfo)
     * }
     */
    public static FunctionDescriptor SCIPcomputeExprQuadraticCurvature$descriptor() {
        return SCIPcomputeExprQuadraticCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprQuadraticCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV *curv, SCIP_HASHMAP *assumevarfixed, unsigned int storeeigeninfo)
     * }
     */
    public static MethodHandle SCIPcomputeExprQuadraticCurvature$handle() {
        return SCIPcomputeExprQuadraticCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprQuadraticCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV *curv, SCIP_HASHMAP *assumevarfixed, unsigned int storeeigeninfo)
     * }
     */
    public static MemorySegment SCIPcomputeExprQuadraticCurvature$address() {
        return SCIPcomputeExprQuadraticCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeExprQuadraticCurvature(SCIP *scip, SCIP_EXPR *expr, SCIP_EXPRCURV *curv, SCIP_HASHMAP *assumevarfixed, unsigned int storeeigeninfo)
     * }
     */
    public static int SCIPcomputeExprQuadraticCurvature(MemorySegment scip, MemorySegment expr, MemorySegment curv, MemorySegment assumevarfixed, int storeeigeninfo) {
        var mh$ = SCIPcomputeExprQuadraticCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeExprQuadraticCurvature", scip, expr, curv, assumevarfixed, storeeigeninfo);
            }
            return (int)mh$.invokeExact(scip, expr, curv, assumevarfixed, storeeigeninfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExprMonomialData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExprMonomialData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprMonomialData(SCIP *scip, SCIP_EXPR *expr, double *coef, double *exponents, SCIP_EXPR **factors)
     * }
     */
    public static FunctionDescriptor SCIPgetExprMonomialData$descriptor() {
        return SCIPgetExprMonomialData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprMonomialData(SCIP *scip, SCIP_EXPR *expr, double *coef, double *exponents, SCIP_EXPR **factors)
     * }
     */
    public static MethodHandle SCIPgetExprMonomialData$handle() {
        return SCIPgetExprMonomialData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprMonomialData(SCIP *scip, SCIP_EXPR *expr, double *coef, double *exponents, SCIP_EXPR **factors)
     * }
     */
    public static MemorySegment SCIPgetExprMonomialData$address() {
        return SCIPgetExprMonomialData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetExprMonomialData(SCIP *scip, SCIP_EXPR *expr, double *coef, double *exponents, SCIP_EXPR **factors)
     * }
     */
    public static int SCIPgetExprMonomialData(MemorySegment scip, MemorySegment expr, MemorySegment coef, MemorySegment exponents, MemorySegment factors) {
        var mh$ = SCIPgetExprMonomialData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExprMonomialData", scip, expr, coef, exponents, factors);
            }
            return (int)mh$.invokeExact(scip, expr, coef, exponents, factors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPversion()
     * }
     */
    public static FunctionDescriptor SCIPversion$descriptor() {
        return SCIPversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPversion()
     * }
     */
    public static MethodHandle SCIPversion$handle() {
        return SCIPversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPversion()
     * }
     */
    public static MemorySegment SCIPversion$address() {
        return SCIPversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPversion()
     * }
     */
    public static double SCIPversion() {
        var mh$ = SCIPversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPversion");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmajorVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmajorVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPmajorVersion()
     * }
     */
    public static FunctionDescriptor SCIPmajorVersion$descriptor() {
        return SCIPmajorVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPmajorVersion()
     * }
     */
    public static MethodHandle SCIPmajorVersion$handle() {
        return SCIPmajorVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPmajorVersion()
     * }
     */
    public static MemorySegment SCIPmajorVersion$address() {
        return SCIPmajorVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPmajorVersion()
     * }
     */
    public static int SCIPmajorVersion() {
        var mh$ = SCIPmajorVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmajorVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPminorVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPminorVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPminorVersion()
     * }
     */
    public static FunctionDescriptor SCIPminorVersion$descriptor() {
        return SCIPminorVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPminorVersion()
     * }
     */
    public static MethodHandle SCIPminorVersion$handle() {
        return SCIPminorVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPminorVersion()
     * }
     */
    public static MemorySegment SCIPminorVersion$address() {
        return SCIPminorVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPminorVersion()
     * }
     */
    public static int SCIPminorVersion() {
        var mh$ = SCIPminorVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPminorVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtechVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtechVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPtechVersion()
     * }
     */
    public static FunctionDescriptor SCIPtechVersion$descriptor() {
        return SCIPtechVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPtechVersion()
     * }
     */
    public static MethodHandle SCIPtechVersion$handle() {
        return SCIPtechVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPtechVersion()
     * }
     */
    public static MemorySegment SCIPtechVersion$address() {
        return SCIPtechVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPtechVersion()
     * }
     */
    public static int SCIPtechVersion() {
        var mh$ = SCIPtechVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtechVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsubversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT    );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsubversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPsubversion()
     * }
     */
    public static FunctionDescriptor SCIPsubversion$descriptor() {
        return SCIPsubversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPsubversion()
     * }
     */
    public static MethodHandle SCIPsubversion$handle() {
        return SCIPsubversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPsubversion()
     * }
     */
    public static MemorySegment SCIPsubversion$address() {
        return SCIPsubversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPsubversion()
     * }
     */
    public static int SCIPsubversion() {
        var mh$ = SCIPsubversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsubversion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintVersion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintVersion(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintVersion$descriptor() {
        return SCIPprintVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintVersion(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintVersion$handle() {
        return SCIPprintVersion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintVersion(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintVersion$address() {
        return SCIPprintVersion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintVersion(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintVersion(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintVersion", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBuildOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBuildOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintBuildOptions(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintBuildOptions$descriptor() {
        return SCIPprintBuildOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintBuildOptions(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintBuildOptions$handle() {
        return SCIPprintBuildOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintBuildOptions(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintBuildOptions$address() {
        return SCIPprintBuildOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintBuildOptions(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintBuildOptions(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintBuildOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBuildOptions", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintError");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintError(SCIP_RETCODE retcode)
     * }
     */
    public static FunctionDescriptor SCIPprintError$descriptor() {
        return SCIPprintError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintError(SCIP_RETCODE retcode)
     * }
     */
    public static MethodHandle SCIPprintError$handle() {
        return SCIPprintError.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintError(SCIP_RETCODE retcode)
     * }
     */
    public static MemorySegment SCIPprintError$address() {
        return SCIPprintError.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintError(SCIP_RETCODE retcode)
     * }
     */
    public static void SCIPprintError(int retcode) {
        var mh$ = SCIPprintError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintError", retcode);
            }
            mh$.invokeExact(retcode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreate(SCIP **scip)
     * }
     */
    public static FunctionDescriptor SCIPcreate$descriptor() {
        return SCIPcreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreate(SCIP **scip)
     * }
     */
    public static MethodHandle SCIPcreate$handle() {
        return SCIPcreate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreate(SCIP **scip)
     * }
     */
    public static MemorySegment SCIPcreate$address() {
        return SCIPcreate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreate(SCIP **scip)
     * }
     */
    public static int SCIPcreate(MemorySegment scip) {
        var mh$ = SCIPcreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreate", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfree(SCIP **scip)
     * }
     */
    public static FunctionDescriptor SCIPfree$descriptor() {
        return SCIPfree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfree(SCIP **scip)
     * }
     */
    public static MethodHandle SCIPfree$handle() {
        return SCIPfree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfree(SCIP **scip)
     * }
     */
    public static MemorySegment SCIPfree$address() {
        return SCIPfree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfree(SCIP **scip)
     * }
     */
    public static int SCIPfree(MemorySegment scip) {
        var mh$ = SCIPfree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfree", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetStage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetStage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPgetStage(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetStage$descriptor() {
        return SCIPgetStage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPgetStage(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetStage$handle() {
        return SCIPgetStage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_STAGE SCIPgetStage(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetStage$address() {
        return SCIPgetStage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_STAGE SCIPgetStage(SCIP *scip)
     * }
     */
    public static int SCIPgetStage(MemorySegment scip) {
        var mh$ = SCIPgetStage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetStage", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintStage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintStage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStage(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintStage$descriptor() {
        return SCIPprintStage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStage(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintStage$handle() {
        return SCIPprintStage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStage(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintStage$address() {
        return SCIPprintStage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStage(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintStage(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintStage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintStage", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_STATUS SCIPgetStatus(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetStatus$descriptor() {
        return SCIPgetStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_STATUS SCIPgetStatus(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetStatus$handle() {
        return SCIPgetStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_STATUS SCIPgetStatus(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetStatus$address() {
        return SCIPgetStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_STATUS SCIPgetStatus(SCIP *scip)
     * }
     */
    public static int SCIPgetStatus(MemorySegment scip) {
        var mh$ = SCIPgetStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetStatus", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintStatus");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatus(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintStatus$descriptor() {
        return SCIPprintStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatus(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintStatus$handle() {
        return SCIPprintStatus.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatus(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintStatus$address() {
        return SCIPprintStatus.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatus(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintStatus(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintStatus", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisTransformed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisTransformed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisTransformed(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisTransformed$descriptor() {
        return SCIPisTransformed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisTransformed(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisTransformed$handle() {
        return SCIPisTransformed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisTransformed(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisTransformed$address() {
        return SCIPisTransformed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisTransformed(SCIP *scip)
     * }
     */
    public static int SCIPisTransformed(MemorySegment scip) {
        var mh$ = SCIPisTransformed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisTransformed", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisExactSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisExactSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisExactSolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisExactSolve$descriptor() {
        return SCIPisExactSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisExactSolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisExactSolve$handle() {
        return SCIPisExactSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisExactSolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisExactSolve$address() {
        return SCIPisExactSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisExactSolve(SCIP *scip)
     * }
     */
    public static int SCIPisExactSolve(MemorySegment scip) {
        var mh$ = SCIPisExactSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisExactSolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisPresolveFinished {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisPresolveFinished");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisPresolveFinished(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisPresolveFinished$descriptor() {
        return SCIPisPresolveFinished.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisPresolveFinished(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisPresolveFinished$handle() {
        return SCIPisPresolveFinished.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisPresolveFinished(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisPresolveFinished$address() {
        return SCIPisPresolveFinished.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisPresolveFinished(SCIP *scip)
     * }
     */
    public static int SCIPisPresolveFinished(MemorySegment scip) {
        var mh$ = SCIPisPresolveFinished.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisPresolveFinished", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasPerformedPresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasPerformedPresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPerformedPresolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPhasPerformedPresolve$descriptor() {
        return SCIPhasPerformedPresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPerformedPresolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPhasPerformedPresolve$handle() {
        return SCIPhasPerformedPresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPerformedPresolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPhasPerformedPresolve$address() {
        return SCIPhasPerformedPresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPhasPerformedPresolve(SCIP *scip)
     * }
     */
    public static int SCIPhasPerformedPresolve(MemorySegment scip) {
        var mh$ = SCIPhasPerformedPresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasPerformedPresolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpressedCtrlC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpressedCtrlC");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPpressedCtrlC(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPpressedCtrlC$descriptor() {
        return SCIPpressedCtrlC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPpressedCtrlC(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPpressedCtrlC$handle() {
        return SCIPpressedCtrlC.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPpressedCtrlC(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPpressedCtrlC$address() {
        return SCIPpressedCtrlC.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPpressedCtrlC(SCIP *scip)
     * }
     */
    public static int SCIPpressedCtrlC(MemorySegment scip) {
        var mh$ = SCIPpressedCtrlC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpressedCtrlC", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisStopped {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisStopped");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisStopped(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisStopped$descriptor() {
        return SCIPisStopped.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisStopped(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisStopped$handle() {
        return SCIPisStopped.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisStopped(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisStopped$address() {
        return SCIPisStopped.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisStopped(SCIP *scip)
     * }
     */
    public static int SCIPisStopped(MemorySegment scip) {
        var mh$ = SCIPisStopped.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisStopped", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeExternalCodeInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeExternalCodeInformation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExternalCodeInformation(SCIP *scip, const char *name, const char *description)
     * }
     */
    public static FunctionDescriptor SCIPincludeExternalCodeInformation$descriptor() {
        return SCIPincludeExternalCodeInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExternalCodeInformation(SCIP *scip, const char *name, const char *description)
     * }
     */
    public static MethodHandle SCIPincludeExternalCodeInformation$handle() {
        return SCIPincludeExternalCodeInformation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExternalCodeInformation(SCIP *scip, const char *name, const char *description)
     * }
     */
    public static MemorySegment SCIPincludeExternalCodeInformation$address() {
        return SCIPincludeExternalCodeInformation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeExternalCodeInformation(SCIP *scip, const char *name, const char *description)
     * }
     */
    public static int SCIPincludeExternalCodeInformation(MemorySegment scip, MemorySegment name, MemorySegment description) {
        var mh$ = SCIPincludeExternalCodeInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeExternalCodeInformation", scip, name, description);
            }
            return (int)mh$.invokeExact(scip, name, description);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExternalCodeNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExternalCodeNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeNames(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExternalCodeNames$descriptor() {
        return SCIPgetExternalCodeNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeNames(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExternalCodeNames$handle() {
        return SCIPgetExternalCodeNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeNames(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExternalCodeNames$address() {
        return SCIPgetExternalCodeNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeNames(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExternalCodeNames(MemorySegment scip) {
        var mh$ = SCIPgetExternalCodeNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExternalCodeNames", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetExternalCodeDescriptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetExternalCodeDescriptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeDescriptions(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetExternalCodeDescriptions$descriptor() {
        return SCIPgetExternalCodeDescriptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeDescriptions(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetExternalCodeDescriptions$handle() {
        return SCIPgetExternalCodeDescriptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeDescriptions(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExternalCodeDescriptions$address() {
        return SCIPgetExternalCodeDescriptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char **SCIPgetExternalCodeDescriptions(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetExternalCodeDescriptions(MemorySegment scip) {
        var mh$ = SCIPgetExternalCodeDescriptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetExternalCodeDescriptions", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNExternalCodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNExternalCodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNExternalCodes(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNExternalCodes$descriptor() {
        return SCIPgetNExternalCodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNExternalCodes(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNExternalCodes$handle() {
        return SCIPgetNExternalCodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNExternalCodes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNExternalCodes$address() {
        return SCIPgetNExternalCodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNExternalCodes(SCIP *scip)
     * }
     */
    public static int SCIPgetNExternalCodes(MemorySegment scip) {
        var mh$ = SCIPgetNExternalCodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNExternalCodes", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExternalCodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExternalCodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintExternalCodes(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintExternalCodes$descriptor() {
        return SCIPprintExternalCodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintExternalCodes(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintExternalCodes$handle() {
        return SCIPprintExternalCodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintExternalCodes(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintExternalCodes$address() {
        return SCIPprintExternalCodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintExternalCodes(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintExternalCodes(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintExternalCodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExternalCodes", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeur(SCIP *scip, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeur$descriptor() {
        return SCIPincludeHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeur(SCIP *scip, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static MethodHandle SCIPincludeHeur$handle() {
        return SCIPincludeHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeur(SCIP *scip, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static MemorySegment SCIPincludeHeur$address() {
        return SCIPincludeHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeur(SCIP *scip, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *), SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static int SCIPincludeHeur(MemorySegment scip, MemorySegment name, MemorySegment desc, byte dispchar, int priority, int freq, int freqofs, int maxdepth, int timingmask, int usessubscip, MemorySegment heurcopy, MemorySegment heurfree, MemorySegment heurinit, MemorySegment heurexit, MemorySegment heurinitsol, MemorySegment heurexitsol, MemorySegment heurexec, MemorySegment heurdata) {
        var mh$ = SCIPincludeHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeur", scip, name, desc, dispchar, priority, freq, freqofs, maxdepth, timingmask, usessubscip, heurcopy, heurfree, heurinit, heurexit, heurinitsol, heurexitsol, heurexec, heurdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, dispchar, priority, freq, freqofs, maxdepth, timingmask, usessubscip, heurcopy, heurfree, heurinit, heurexit, heurinitsol, heurexitsol, heurexec, heurdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeHeurBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeHeurBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBasic(SCIP *scip, SCIP_HEUR **heur, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeHeurBasic$descriptor() {
        return SCIPincludeHeurBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBasic(SCIP *scip, SCIP_HEUR **heur, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static MethodHandle SCIPincludeHeurBasic$handle() {
        return SCIPincludeHeurBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBasic(SCIP *scip, SCIP_HEUR **heur, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static MemorySegment SCIPincludeHeurBasic$address() {
        return SCIPincludeHeurBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeHeurBasic(SCIP *scip, SCIP_HEUR **heur, const char *name, const char *desc, char dispchar, int priority, int freq, int freqofs, int maxdepth, SCIP_HEURTIMING timingmask, unsigned int usessubscip, SCIP_RETCODE (*heurexec)(SCIP *, SCIP_HEUR *, SCIP_HEURTIMING, unsigned int, SCIP_RESULT *), SCIP_HEURDATA *heurdata)
     * }
     */
    public static int SCIPincludeHeurBasic(MemorySegment scip, MemorySegment heur, MemorySegment name, MemorySegment desc, byte dispchar, int priority, int freq, int freqofs, int maxdepth, int timingmask, int usessubscip, MemorySegment heurexec, MemorySegment heurdata) {
        var mh$ = SCIPincludeHeurBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeHeurBasic", scip, heur, name, desc, dispchar, priority, freq, freqofs, maxdepth, timingmask, usessubscip, heurexec, heurdata);
            }
            return (int)mh$.invokeExact(scip, heur, name, desc, dispchar, priority, freq, freqofs, maxdepth, timingmask, usessubscip, heurexec, heurdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurCopy(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurCopy$descriptor() {
        return SCIPsetHeurCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurCopy(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurCopy$handle() {
        return SCIPsetHeurCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurCopy(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurCopy$address() {
        return SCIPsetHeurCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurCopy(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurcopy)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurCopy(MemorySegment scip, MemorySegment heur, MemorySegment heurcopy) {
        var mh$ = SCIPsetHeurCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurCopy", scip, heur, heurcopy);
            }
            return (int)mh$.invokeExact(scip, heur, heurcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurFree(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurFree$descriptor() {
        return SCIPsetHeurFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurFree(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurFree$handle() {
        return SCIPsetHeurFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurFree(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurFree$address() {
        return SCIPsetHeurFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurFree(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurfree)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurFree(MemorySegment scip, MemorySegment heur, MemorySegment heurfree) {
        var mh$ = SCIPsetHeurFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurFree", scip, heur, heurfree);
            }
            return (int)mh$.invokeExact(scip, heur, heurfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurInit$descriptor() {
        return SCIPsetHeurInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurInit$handle() {
        return SCIPsetHeurInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurInit$address() {
        return SCIPsetHeurInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurInit(MemorySegment scip, MemorySegment heur, MemorySegment heurinit) {
        var mh$ = SCIPsetHeurInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurInit", scip, heur, heurinit);
            }
            return (int)mh$.invokeExact(scip, heur, heurinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurExit$descriptor() {
        return SCIPsetHeurExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurExit$handle() {
        return SCIPsetHeurExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurExit$address() {
        return SCIPsetHeurExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExit(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexit)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurExit(MemorySegment scip, MemorySegment heur, MemorySegment heurexit) {
        var mh$ = SCIPsetHeurExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurExit", scip, heur, heurexit);
            }
            return (int)mh$.invokeExact(scip, heur, heurexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurInitsol$descriptor() {
        return SCIPsetHeurInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurInitsol$handle() {
        return SCIPsetHeurInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurInitsol$address() {
        return SCIPsetHeurInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurInitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurinitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurInitsol(MemorySegment scip, MemorySegment heur, MemorySegment heurinitsol) {
        var mh$ = SCIPsetHeurInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurInitsol", scip, heur, heurinitsol);
            }
            return (int)mh$.invokeExact(scip, heur, heurinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static FunctionDescriptor SCIPsetHeurExitsol$descriptor() {
        return SCIPsetHeurExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MethodHandle SCIPsetHeurExitsol$handle() {
        return SCIPsetHeurExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static MemorySegment SCIPsetHeurExitsol$address() {
        return SCIPsetHeurExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurExitsol(SCIP *scip, SCIP_HEUR *heur, SCIP_RETCODE (*heurexitsol)(SCIP *, SCIP_HEUR *))
     * }
     */
    public static int SCIPsetHeurExitsol(MemorySegment scip, MemorySegment heur, MemorySegment heurexitsol) {
        var mh$ = SCIPsetHeurExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurExitsol", scip, heur, heurexitsol);
            }
            return (int)mh$.invokeExact(scip, heur, heurexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPfindHeur(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindHeur$descriptor() {
        return SCIPfindHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPfindHeur(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindHeur$handle() {
        return SCIPfindHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPfindHeur(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindHeur$address() {
        return SCIPfindHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPfindHeur(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindHeur(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindHeur", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetHeurs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetHeurs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEUR **SCIPgetHeurs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetHeurs$descriptor() {
        return SCIPgetHeurs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEUR **SCIPgetHeurs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetHeurs$handle() {
        return SCIPgetHeurs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEUR **SCIPgetHeurs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetHeurs$address() {
        return SCIPgetHeurs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEUR **SCIPgetHeurs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetHeurs(MemorySegment scip) {
        var mh$ = SCIPgetHeurs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetHeurs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNHeurs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNHeurs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNHeurs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNHeurs$descriptor() {
        return SCIPgetNHeurs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNHeurs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNHeurs$handle() {
        return SCIPgetNHeurs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNHeurs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNHeurs$address() {
        return SCIPgetNHeurs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNHeurs(SCIP *scip)
     * }
     */
    public static int SCIPgetNHeurs(MemorySegment scip) {
        var mh$ = SCIPgetNHeurs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNHeurs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeurPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeurPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurPriority(SCIP *scip, SCIP_HEUR *heur, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetHeurPriority$descriptor() {
        return SCIPsetHeurPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurPriority(SCIP *scip, SCIP_HEUR *heur, int priority)
     * }
     */
    public static MethodHandle SCIPsetHeurPriority$handle() {
        return SCIPsetHeurPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurPriority(SCIP *scip, SCIP_HEUR *heur, int priority)
     * }
     */
    public static MemorySegment SCIPsetHeurPriority$address() {
        return SCIPsetHeurPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeurPriority(SCIP *scip, SCIP_HEUR *heur, int priority)
     * }
     */
    public static int SCIPsetHeurPriority(MemorySegment scip, MemorySegment heur, int priority) {
        var mh$ = SCIPsetHeurPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeurPriority", scip, heur, priority);
            }
            return (int)mh$.invokeExact(scip, heur, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateDiveset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateDiveset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDiveset(SCIP *scip, SCIP_DIVESET **diveset, SCIP_HEUR *heur, const char *name, double minreldepth, double maxreldepth, double maxlpiterquot, double maxdiveubquot, double maxdiveavgquot, double maxdiveubquotnosol, double maxdiveavgquotnosol, double lpresolvedomchgquot, int lpsolvefreq, int maxlpiterofs, unsigned int initialseed, unsigned int backtrack, unsigned int onlylpbranchcands, unsigned int ispublic, unsigned int specificsos1score, SCIP_RETCODE (*divesetgetscore)(SCIP *, SCIP_DIVESET *, SCIP_DIVETYPE, SCIP_VAR *, double, double, double *, unsigned int *), SCIP_RETCODE (*divesetavailable)(SCIP *, SCIP_DIVESET *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPcreateDiveset$descriptor() {
        return SCIPcreateDiveset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDiveset(SCIP *scip, SCIP_DIVESET **diveset, SCIP_HEUR *heur, const char *name, double minreldepth, double maxreldepth, double maxlpiterquot, double maxdiveubquot, double maxdiveavgquot, double maxdiveubquotnosol, double maxdiveavgquotnosol, double lpresolvedomchgquot, int lpsolvefreq, int maxlpiterofs, unsigned int initialseed, unsigned int backtrack, unsigned int onlylpbranchcands, unsigned int ispublic, unsigned int specificsos1score, SCIP_RETCODE (*divesetgetscore)(SCIP *, SCIP_DIVESET *, SCIP_DIVETYPE, SCIP_VAR *, double, double, double *, unsigned int *), SCIP_RETCODE (*divesetavailable)(SCIP *, SCIP_DIVESET *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPcreateDiveset$handle() {
        return SCIPcreateDiveset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDiveset(SCIP *scip, SCIP_DIVESET **diveset, SCIP_HEUR *heur, const char *name, double minreldepth, double maxreldepth, double maxlpiterquot, double maxdiveubquot, double maxdiveavgquot, double maxdiveubquotnosol, double maxdiveavgquotnosol, double lpresolvedomchgquot, int lpsolvefreq, int maxlpiterofs, unsigned int initialseed, unsigned int backtrack, unsigned int onlylpbranchcands, unsigned int ispublic, unsigned int specificsos1score, SCIP_RETCODE (*divesetgetscore)(SCIP *, SCIP_DIVESET *, SCIP_DIVETYPE, SCIP_VAR *, double, double, double *, unsigned int *), SCIP_RETCODE (*divesetavailable)(SCIP *, SCIP_DIVESET *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPcreateDiveset$address() {
        return SCIPcreateDiveset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateDiveset(SCIP *scip, SCIP_DIVESET **diveset, SCIP_HEUR *heur, const char *name, double minreldepth, double maxreldepth, double maxlpiterquot, double maxdiveubquot, double maxdiveavgquot, double maxdiveubquotnosol, double maxdiveavgquotnosol, double lpresolvedomchgquot, int lpsolvefreq, int maxlpiterofs, unsigned int initialseed, unsigned int backtrack, unsigned int onlylpbranchcands, unsigned int ispublic, unsigned int specificsos1score, SCIP_RETCODE (*divesetgetscore)(SCIP *, SCIP_DIVESET *, SCIP_DIVETYPE, SCIP_VAR *, double, double, double *, unsigned int *), SCIP_RETCODE (*divesetavailable)(SCIP *, SCIP_DIVESET *, unsigned int *))
     * }
     */
    public static int SCIPcreateDiveset(MemorySegment scip, MemorySegment diveset, MemorySegment heur, MemorySegment name, double minreldepth, double maxreldepth, double maxlpiterquot, double maxdiveubquot, double maxdiveavgquot, double maxdiveubquotnosol, double maxdiveavgquotnosol, double lpresolvedomchgquot, int lpsolvefreq, int maxlpiterofs, int initialseed, int backtrack, int onlylpbranchcands, int ispublic, int specificsos1score, MemorySegment divesetgetscore, MemorySegment divesetavailable) {
        var mh$ = SCIPcreateDiveset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateDiveset", scip, diveset, heur, name, minreldepth, maxreldepth, maxlpiterquot, maxdiveubquot, maxdiveavgquot, maxdiveubquotnosol, maxdiveavgquotnosol, lpresolvedomchgquot, lpsolvefreq, maxlpiterofs, initialseed, backtrack, onlylpbranchcands, ispublic, specificsos1score, divesetgetscore, divesetavailable);
            }
            return (int)mh$.invokeExact(scip, diveset, heur, name, minreldepth, maxreldepth, maxlpiterquot, maxdiveubquot, maxdiveavgquot, maxdiveubquotnosol, maxdiveavgquotnosol, lpresolvedomchgquot, lpsolvefreq, maxlpiterofs, initialseed, backtrack, onlylpbranchcands, ispublic, specificsos1score, divesetgetscore, divesetavailable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDivesetAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDivesetAvailable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisDivesetAvailable(SCIP *scip, SCIP_DIVESET *diveset, unsigned int *available)
     * }
     */
    public static FunctionDescriptor SCIPisDivesetAvailable$descriptor() {
        return SCIPisDivesetAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisDivesetAvailable(SCIP *scip, SCIP_DIVESET *diveset, unsigned int *available)
     * }
     */
    public static MethodHandle SCIPisDivesetAvailable$handle() {
        return SCIPisDivesetAvailable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisDivesetAvailable(SCIP *scip, SCIP_DIVESET *diveset, unsigned int *available)
     * }
     */
    public static MemorySegment SCIPisDivesetAvailable$address() {
        return SCIPisDivesetAvailable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPisDivesetAvailable(SCIP *scip, SCIP_DIVESET *diveset, unsigned int *available)
     * }
     */
    public static int SCIPisDivesetAvailable(MemorySegment scip, MemorySegment diveset, MemorySegment available) {
        var mh$ = SCIPisDivesetAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDivesetAvailable", scip, diveset, available);
            }
            return (int)mh$.invokeExact(scip, diveset, available);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasCurrentNodeLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasCurrentNodeLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPhasCurrentNodeLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPhasCurrentNodeLP$descriptor() {
        return SCIPhasCurrentNodeLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPhasCurrentNodeLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPhasCurrentNodeLP$handle() {
        return SCIPhasCurrentNodeLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPhasCurrentNodeLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPhasCurrentNodeLP$address() {
        return SCIPhasCurrentNodeLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPhasCurrentNodeLP(SCIP *scip)
     * }
     */
    public static int SCIPhasCurrentNodeLP(MemorySegment scip) {
        var mh$ = SCIPhasCurrentNodeLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasCurrentNodeLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLPConstructed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLPConstructed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPConstructed(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisLPConstructed$descriptor() {
        return SCIPisLPConstructed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPConstructed(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisLPConstructed$handle() {
        return SCIPisLPConstructed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPConstructed(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisLPConstructed$address() {
        return SCIPisLPConstructed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLPConstructed(SCIP *scip)
     * }
     */
    public static int SCIPisLPConstructed(MemorySegment scip) {
        var mh$ = SCIPisLPConstructed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLPConstructed", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconstructLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconstructLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructLP(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPconstructLP$descriptor() {
        return SCIPconstructLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructLP(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPconstructLP$handle() {
        return SCIPconstructLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructLP(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPconstructLP$address() {
        return SCIPconstructLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPconstructLP(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static int SCIPconstructLP(MemorySegment scip, MemorySegment cutoff) {
        var mh$ = SCIPconstructLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconstructLP", scip, cutoff);
            }
            return (int)mh$.invokeExact(scip, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPflushLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPflushLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPflushLP$descriptor() {
        return SCIPflushLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPflushLP$handle() {
        return SCIPflushLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPflushLP$address() {
        return SCIPflushLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushLP(SCIP *scip)
     * }
     */
    public static int SCIPflushLP(MemorySegment scip) {
        var mh$ = SCIPflushLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPflushLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPSolstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPSolstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLPSolstat(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPSolstat$descriptor() {
        return SCIPgetLPSolstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLPSolstat(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPSolstat$handle() {
        return SCIPgetLPSolstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLPSolstat(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPSolstat$address() {
        return SCIPgetLPSolstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_LPSOLSTAT SCIPgetLPSolstat(SCIP *scip)
     * }
     */
    public static int SCIPgetLPSolstat(MemorySegment scip) {
        var mh$ = SCIPgetLPSolstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPSolstat", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLPPrimalReliable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLPPrimalReliable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPPrimalReliable(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisLPPrimalReliable$descriptor() {
        return SCIPisLPPrimalReliable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPPrimalReliable(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisLPPrimalReliable$handle() {
        return SCIPisLPPrimalReliable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPPrimalReliable(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisLPPrimalReliable$address() {
        return SCIPisLPPrimalReliable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLPPrimalReliable(SCIP *scip)
     * }
     */
    public static int SCIPisLPPrimalReliable(MemorySegment scip) {
        var mh$ = SCIPisLPPrimalReliable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLPPrimalReliable", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLPDualReliable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLPDualReliable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPDualReliable(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisLPDualReliable$descriptor() {
        return SCIPisLPDualReliable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPDualReliable(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisLPDualReliable$handle() {
        return SCIPisLPDualReliable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPDualReliable(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisLPDualReliable$address() {
        return SCIPisLPDualReliable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLPDualReliable(SCIP *scip)
     * }
     */
    public static int SCIPisLPDualReliable(MemorySegment scip) {
        var mh$ = SCIPisLPDualReliable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLPDualReliable", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLPRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLPRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPRelax(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisLPRelax$descriptor() {
        return SCIPisLPRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPRelax(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisLPRelax$handle() {
        return SCIPisLPRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPRelax(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisLPRelax$address() {
        return SCIPisLPRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLPRelax(SCIP *scip)
     * }
     */
    public static int SCIPisLPRelax(MemorySegment scip) {
        var mh$ = SCIPisLPRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLPRelax", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPObjval$descriptor() {
        return SCIPgetLPObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPObjval$handle() {
        return SCIPgetLPObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPObjval$address() {
        return SCIPgetLPObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPColumnObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPColumnObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPColumnObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPColumnObjval$descriptor() {
        return SCIPgetLPColumnObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPColumnObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPColumnObjval$handle() {
        return SCIPgetLPColumnObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPColumnObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPColumnObjval$address() {
        return SCIPgetLPColumnObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPColumnObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPColumnObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPColumnObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPColumnObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPLooseObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPLooseObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPLooseObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPLooseObjval$descriptor() {
        return SCIPgetLPLooseObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPLooseObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPLooseObjval$handle() {
        return SCIPgetLPLooseObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPLooseObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPLooseObjval$address() {
        return SCIPgetLPLooseObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPLooseObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPLooseObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPLooseObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPLooseObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetGlobalPseudoObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetGlobalPseudoObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetGlobalPseudoObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetGlobalPseudoObjval$descriptor() {
        return SCIPgetGlobalPseudoObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetGlobalPseudoObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetGlobalPseudoObjval$handle() {
        return SCIPgetGlobalPseudoObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetGlobalPseudoObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetGlobalPseudoObjval$address() {
        return SCIPgetGlobalPseudoObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetGlobalPseudoObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetGlobalPseudoObjval(MemorySegment scip) {
        var mh$ = SCIPgetGlobalPseudoObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetGlobalPseudoObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPseudoObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPseudoObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPseudoObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPseudoObjval$descriptor() {
        return SCIPgetPseudoObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPseudoObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPseudoObjval$handle() {
        return SCIPgetPseudoObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPseudoObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPseudoObjval$address() {
        return SCIPgetPseudoObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPseudoObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetPseudoObjval(MemorySegment scip) {
        var mh$ = SCIPgetPseudoObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPseudoObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRootLPRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRootLPRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRootLPRelax(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisRootLPRelax$descriptor() {
        return SCIPisRootLPRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRootLPRelax(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisRootLPRelax$handle() {
        return SCIPisRootLPRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRootLPRelax(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisRootLPRelax$address() {
        return SCIPisRootLPRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRootLPRelax(SCIP *scip)
     * }
     */
    public static int SCIPisRootLPRelax(MemorySegment scip) {
        var mh$ = SCIPisRootLPRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRootLPRelax", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPRootObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPRootObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPRootObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPRootObjval$descriptor() {
        return SCIPgetLPRootObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPRootObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPRootObjval$handle() {
        return SCIPgetLPRootObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPRootObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPRootObjval$address() {
        return SCIPgetLPRootObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPRootObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPRootObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPRootObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPRootObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPRootColumnObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPRootColumnObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPRootColumnObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPRootColumnObjval$descriptor() {
        return SCIPgetLPRootColumnObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPRootColumnObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPRootColumnObjval$handle() {
        return SCIPgetLPRootColumnObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPRootColumnObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPRootColumnObjval$address() {
        return SCIPgetLPRootColumnObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPRootColumnObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPRootColumnObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPRootColumnObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPRootColumnObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPRootLooseObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPRootLooseObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPRootLooseObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPRootLooseObjval$descriptor() {
        return SCIPgetLPRootLooseObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPRootLooseObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPRootLooseObjval$handle() {
        return SCIPgetLPRootLooseObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPRootLooseObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPRootLooseObjval$address() {
        return SCIPgetLPRootLooseObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPRootLooseObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetLPRootLooseObjval(MemorySegment scip) {
        var mh$ = SCIPgetLPRootLooseObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPRootLooseObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPFeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPFeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLPFeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPFeastol$descriptor() {
        return SCIPgetLPFeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLPFeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPFeastol$handle() {
        return SCIPgetLPFeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLPFeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPFeastol$address() {
        return SCIPgetLPFeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLPFeastol(SCIP *scip)
     * }
     */
    public static double SCIPgetLPFeastol(MemorySegment scip) {
        var mh$ = SCIPgetLPFeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPFeastol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetLPFeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetLPFeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetLPFeastol(SCIP *scip, double newfeastol)
     * }
     */
    public static FunctionDescriptor SCIPsetLPFeastol$descriptor() {
        return SCIPsetLPFeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetLPFeastol(SCIP *scip, double newfeastol)
     * }
     */
    public static MethodHandle SCIPsetLPFeastol$handle() {
        return SCIPsetLPFeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetLPFeastol(SCIP *scip, double newfeastol)
     * }
     */
    public static MemorySegment SCIPsetLPFeastol$address() {
        return SCIPsetLPFeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetLPFeastol(SCIP *scip, double newfeastol)
     * }
     */
    public static void SCIPsetLPFeastol(MemorySegment scip, double newfeastol) {
        var mh$ = SCIPsetLPFeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetLPFeastol", scip, newfeastol);
            }
            mh$.invokeExact(scip, newfeastol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetLPFeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetLPFeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPresetLPFeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPresetLPFeastol$descriptor() {
        return SCIPresetLPFeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPresetLPFeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPresetLPFeastol$handle() {
        return SCIPresetLPFeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPresetLPFeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPresetLPFeastol$address() {
        return SCIPresetLPFeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPresetLPFeastol(SCIP *scip)
     * }
     */
    public static void SCIPresetLPFeastol(MemorySegment scip) {
        var mh$ = SCIPresetLPFeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetLPFeastol", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPColsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPColsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPColsData(SCIP *scip, SCIP_COL ***cols, int *ncols)
     * }
     */
    public static FunctionDescriptor SCIPgetLPColsData$descriptor() {
        return SCIPgetLPColsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPColsData(SCIP *scip, SCIP_COL ***cols, int *ncols)
     * }
     */
    public static MethodHandle SCIPgetLPColsData$handle() {
        return SCIPgetLPColsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPColsData(SCIP *scip, SCIP_COL ***cols, int *ncols)
     * }
     */
    public static MemorySegment SCIPgetLPColsData$address() {
        return SCIPgetLPColsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPColsData(SCIP *scip, SCIP_COL ***cols, int *ncols)
     * }
     */
    public static int SCIPgetLPColsData(MemorySegment scip, MemorySegment cols, MemorySegment ncols) {
        var mh$ = SCIPgetLPColsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPColsData", scip, cols, ncols);
            }
            return (int)mh$.invokeExact(scip, cols, ncols);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_COL **SCIPgetLPCols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPCols$descriptor() {
        return SCIPgetLPCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_COL **SCIPgetLPCols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPCols$handle() {
        return SCIPgetLPCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_COL **SCIPgetLPCols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPCols$address() {
        return SCIPgetLPCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_COL **SCIPgetLPCols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPCols(MemorySegment scip) {
        var mh$ = SCIPgetLPCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPCols", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNLPCols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPCols$descriptor() {
        return SCIPgetNLPCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNLPCols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPCols$handle() {
        return SCIPgetNLPCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNLPCols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPCols$address() {
        return SCIPgetNLPCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNLPCols(SCIP *scip)
     * }
     */
    public static int SCIPgetNLPCols(MemorySegment scip) {
        var mh$ = SCIPgetNLPCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPCols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNUnfixedLPCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNUnfixedLPCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNUnfixedLPCols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNUnfixedLPCols$descriptor() {
        return SCIPgetNUnfixedLPCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNUnfixedLPCols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNUnfixedLPCols$handle() {
        return SCIPgetNUnfixedLPCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNUnfixedLPCols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNUnfixedLPCols$address() {
        return SCIPgetNUnfixedLPCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNUnfixedLPCols(SCIP *scip)
     * }
     */
    public static int SCIPgetNUnfixedLPCols(MemorySegment scip) {
        var mh$ = SCIPgetNUnfixedLPCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNUnfixedLPCols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPRowsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPRowsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPRowsData(SCIP *scip, SCIP_ROW ***rows, int *nrows)
     * }
     */
    public static FunctionDescriptor SCIPgetLPRowsData$descriptor() {
        return SCIPgetLPRowsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPRowsData(SCIP *scip, SCIP_ROW ***rows, int *nrows)
     * }
     */
    public static MethodHandle SCIPgetLPRowsData$handle() {
        return SCIPgetLPRowsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPRowsData(SCIP *scip, SCIP_ROW ***rows, int *nrows)
     * }
     */
    public static MemorySegment SCIPgetLPRowsData$address() {
        return SCIPgetLPRowsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPRowsData(SCIP *scip, SCIP_ROW ***rows, int *nrows)
     * }
     */
    public static int SCIPgetLPRowsData(MemorySegment scip, MemorySegment rows, MemorySegment nrows) {
        var mh$ = SCIPgetLPRowsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPRowsData", scip, rows, nrows);
            }
            return (int)mh$.invokeExact(scip, rows, nrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetLPRows(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLPRows$descriptor() {
        return SCIPgetLPRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetLPRows(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLPRows$handle() {
        return SCIPgetLPRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetLPRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPRows$address() {
        return SCIPgetLPRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_ROW **SCIPgetLPRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLPRows(MemorySegment scip) {
        var mh$ = SCIPgetLPRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPRows", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNLPRows(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPRows$descriptor() {
        return SCIPgetNLPRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNLPRows(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPRows$handle() {
        return SCIPgetNLPRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNLPRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPRows$address() {
        return SCIPgetNLPRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNLPRows(SCIP *scip)
     * }
     */
    public static int SCIPgetNLPRows(MemorySegment scip) {
        var mh$ = SCIPgetNLPRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPRows", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallColsInLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallColsInLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallColsInLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallColsInLP$descriptor() {
        return SCIPallColsInLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallColsInLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallColsInLP$handle() {
        return SCIPallColsInLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallColsInLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallColsInLP$address() {
        return SCIPallColsInLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallColsInLP(SCIP *scip)
     * }
     */
    public static int SCIPallColsInLP(MemorySegment scip) {
        var mh$ = SCIPallColsInLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallColsInLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLPSolBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLPSolBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPSolBasic(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisLPSolBasic$descriptor() {
        return SCIPisLPSolBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPSolBasic(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisLPSolBasic$handle() {
        return SCIPisLPSolBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLPSolBasic(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisLPSolBasic$address() {
        return SCIPisLPSolBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLPSolBasic(SCIP *scip)
     * }
     */
    public static int SCIPisLPSolBasic(MemorySegment scip) {
        var mh$ = SCIPisLPSolBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLPSolBasic", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBasisInd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBasisInd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBasisInd(SCIP *scip, int *basisind)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBasisInd$descriptor() {
        return SCIPgetLPBasisInd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBasisInd(SCIP *scip, int *basisind)
     * }
     */
    public static MethodHandle SCIPgetLPBasisInd$handle() {
        return SCIPgetLPBasisInd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBasisInd(SCIP *scip, int *basisind)
     * }
     */
    public static MemorySegment SCIPgetLPBasisInd$address() {
        return SCIPgetLPBasisInd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBasisInd(SCIP *scip, int *basisind)
     * }
     */
    public static int SCIPgetLPBasisInd(MemorySegment scip, MemorySegment basisind) {
        var mh$ = SCIPgetLPBasisInd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBasisInd", scip, basisind);
            }
            return (int)mh$.invokeExact(scip, basisind);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBInvRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBInvRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvRow(SCIP *scip, int r, double *coefs, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBInvRow$descriptor() {
        return SCIPgetLPBInvRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvRow(SCIP *scip, int r, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPgetLPBInvRow$handle() {
        return SCIPgetLPBInvRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvRow(SCIP *scip, int r, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPgetLPBInvRow$address() {
        return SCIPgetLPBInvRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvRow(SCIP *scip, int r, double *coefs, int *inds, int *ninds)
     * }
     */
    public static int SCIPgetLPBInvRow(MemorySegment scip, int r, MemorySegment coefs, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPgetLPBInvRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBInvRow", scip, r, coefs, inds, ninds);
            }
            return (int)mh$.invokeExact(scip, r, coefs, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBInvCol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBInvCol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvCol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBInvCol$descriptor() {
        return SCIPgetLPBInvCol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvCol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPgetLPBInvCol$handle() {
        return SCIPgetLPBInvCol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvCol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPgetLPBInvCol$address() {
        return SCIPgetLPBInvCol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvCol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static int SCIPgetLPBInvCol(MemorySegment scip, int c, MemorySegment coefs, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPgetLPBInvCol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBInvCol", scip, c, coefs, inds, ninds);
            }
            return (int)mh$.invokeExact(scip, c, coefs, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBInvARow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBInvARow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvARow(SCIP *scip, int r, double *binvrow, double *coefs, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBInvARow$descriptor() {
        return SCIPgetLPBInvARow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvARow(SCIP *scip, int r, double *binvrow, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPgetLPBInvARow$handle() {
        return SCIPgetLPBInvARow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvARow(SCIP *scip, int r, double *binvrow, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPgetLPBInvARow$address() {
        return SCIPgetLPBInvARow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvARow(SCIP *scip, int r, double *binvrow, double *coefs, int *inds, int *ninds)
     * }
     */
    public static int SCIPgetLPBInvARow(MemorySegment scip, int r, MemorySegment binvrow, MemorySegment coefs, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPgetLPBInvARow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBInvARow", scip, r, binvrow, coefs, inds, ninds);
            }
            return (int)mh$.invokeExact(scip, r, binvrow, coefs, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPBInvACol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPBInvACol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvACol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static FunctionDescriptor SCIPgetLPBInvACol$descriptor() {
        return SCIPgetLPBInvACol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvACol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MethodHandle SCIPgetLPBInvACol$handle() {
        return SCIPgetLPBInvACol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvACol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static MemorySegment SCIPgetLPBInvACol$address() {
        return SCIPgetLPBInvACol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPBInvACol(SCIP *scip, int c, double *coefs, int *inds, int *ninds)
     * }
     */
    public static int SCIPgetLPBInvACol(MemorySegment scip, int c, MemorySegment coefs, MemorySegment inds, MemorySegment ninds) {
        var mh$ = SCIPgetLPBInvACol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPBInvACol", scip, c, coefs, inds, ninds);
            }
            return (int)mh$.invokeExact(scip, c, coefs, inds, ninds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsumLPRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsumLPRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsumLPRows(SCIP *scip, double *weights, SCIP_REALARRAY *sumcoef, double *sumlhs, double *sumrhs)
     * }
     */
    public static FunctionDescriptor SCIPsumLPRows$descriptor() {
        return SCIPsumLPRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsumLPRows(SCIP *scip, double *weights, SCIP_REALARRAY *sumcoef, double *sumlhs, double *sumrhs)
     * }
     */
    public static MethodHandle SCIPsumLPRows$handle() {
        return SCIPsumLPRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsumLPRows(SCIP *scip, double *weights, SCIP_REALARRAY *sumcoef, double *sumlhs, double *sumrhs)
     * }
     */
    public static MemorySegment SCIPsumLPRows$address() {
        return SCIPsumLPRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsumLPRows(SCIP *scip, double *weights, SCIP_REALARRAY *sumcoef, double *sumlhs, double *sumrhs)
     * }
     */
    public static int SCIPsumLPRows(MemorySegment scip, MemorySegment weights, MemorySegment sumcoef, MemorySegment sumlhs, MemorySegment sumrhs) {
        var mh$ = SCIPsumLPRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsumLPRows", scip, weights, sumcoef, sumlhs, sumrhs);
            }
            return (int)mh$.invokeExact(scip, weights, sumcoef, sumlhs, sumrhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinterruptLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinterruptLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptLP(SCIP *scip, unsigned int interrupt)
     * }
     */
    public static FunctionDescriptor SCIPinterruptLP$descriptor() {
        return SCIPinterruptLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptLP(SCIP *scip, unsigned int interrupt)
     * }
     */
    public static MethodHandle SCIPinterruptLP$handle() {
        return SCIPinterruptLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptLP(SCIP *scip, unsigned int interrupt)
     * }
     */
    public static MemorySegment SCIPinterruptLP$address() {
        return SCIPinterruptLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptLP(SCIP *scip, unsigned int interrupt)
     * }
     */
    public static int SCIPinterruptLP(MemorySegment scip, int interrupt) {
        var mh$ = SCIPinterruptLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinterruptLP", scip, interrupt);
            }
            return (int)mh$.invokeExact(scip, interrupt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLP(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPwriteLP$descriptor() {
        return SCIPwriteLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLP(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPwriteLP$handle() {
        return SCIPwriteLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLP(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPwriteLP$address() {
        return SCIPwriteLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteLP(SCIP *scip, const char *filename)
     * }
     */
    public static int SCIPwriteLP(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPwriteLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteLP", scip, filename);
            }
            return (int)mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteMIP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteMIP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMIP(SCIP *scip, const char *filename, unsigned int genericnames, unsigned int origobj, unsigned int lazyconss)
     * }
     */
    public static FunctionDescriptor SCIPwriteMIP$descriptor() {
        return SCIPwriteMIP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMIP(SCIP *scip, const char *filename, unsigned int genericnames, unsigned int origobj, unsigned int lazyconss)
     * }
     */
    public static MethodHandle SCIPwriteMIP$handle() {
        return SCIPwriteMIP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMIP(SCIP *scip, const char *filename, unsigned int genericnames, unsigned int origobj, unsigned int lazyconss)
     * }
     */
    public static MemorySegment SCIPwriteMIP$address() {
        return SCIPwriteMIP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteMIP(SCIP *scip, const char *filename, unsigned int genericnames, unsigned int origobj, unsigned int lazyconss)
     * }
     */
    public static int SCIPwriteMIP(MemorySegment scip, MemorySegment filename, int genericnames, int origobj, int lazyconss) {
        var mh$ = SCIPwriteMIP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteMIP", scip, filename, genericnames, origobj, lazyconss);
            }
            return (int)mh$.invokeExact(scip, filename, genericnames, origobj, lazyconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPI(SCIP *scip, SCIP_LPI **lpi)
     * }
     */
    public static FunctionDescriptor SCIPgetLPI$descriptor() {
        return SCIPgetLPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPI(SCIP *scip, SCIP_LPI **lpi)
     * }
     */
    public static MethodHandle SCIPgetLPI$handle() {
        return SCIPgetLPI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPI(SCIP *scip, SCIP_LPI **lpi)
     * }
     */
    public static MemorySegment SCIPgetLPI$address() {
        return SCIPgetLPI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPI(SCIP *scip, SCIP_LPI **lpi)
     * }
     */
    public static int SCIPgetLPI(MemorySegment scip, MemorySegment lpi) {
        var mh$ = SCIPgetLPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPI", scip, lpi);
            }
            return (int)mh$.invokeExact(scip, lpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintLPSolutionQuality {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintLPSolutionQuality");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintLPSolutionQuality(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintLPSolutionQuality$descriptor() {
        return SCIPprintLPSolutionQuality.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintLPSolutionQuality(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintLPSolutionQuality$handle() {
        return SCIPprintLPSolutionQuality.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintLPSolutionQuality(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintLPSolutionQuality$address() {
        return SCIPprintLPSolutionQuality.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintLPSolutionQuality(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintLPSolutionQuality(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintLPSolutionQuality.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintLPSolutionQuality", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcomputeLPRelIntPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcomputeLPRelIntPoint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeLPRelIntPoint(SCIP *scip, unsigned int relaxrows, unsigned int inclobjcutoff, double timelimit, int iterlimit, SCIP_SOL **point)
     * }
     */
    public static FunctionDescriptor SCIPcomputeLPRelIntPoint$descriptor() {
        return SCIPcomputeLPRelIntPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeLPRelIntPoint(SCIP *scip, unsigned int relaxrows, unsigned int inclobjcutoff, double timelimit, int iterlimit, SCIP_SOL **point)
     * }
     */
    public static MethodHandle SCIPcomputeLPRelIntPoint$handle() {
        return SCIPcomputeLPRelIntPoint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeLPRelIntPoint(SCIP *scip, unsigned int relaxrows, unsigned int inclobjcutoff, double timelimit, int iterlimit, SCIP_SOL **point)
     * }
     */
    public static MemorySegment SCIPcomputeLPRelIntPoint$address() {
        return SCIPcomputeLPRelIntPoint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcomputeLPRelIntPoint(SCIP *scip, unsigned int relaxrows, unsigned int inclobjcutoff, double timelimit, int iterlimit, SCIP_SOL **point)
     * }
     */
    public static int SCIPcomputeLPRelIntPoint(MemorySegment scip, int relaxrows, int inclobjcutoff, double timelimit, int iterlimit, MemorySegment point) {
        var mh$ = SCIPcomputeLPRelIntPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcomputeLPRelIntPoint", scip, relaxrows, inclobjcutoff, timelimit, iterlimit, point);
            }
            return (int)mh$.invokeExact(scip, relaxrows, inclobjcutoff, timelimit, iterlimit, point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetColRedcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetColRedcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetColRedcost(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static FunctionDescriptor SCIPgetColRedcost$descriptor() {
        return SCIPgetColRedcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetColRedcost(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MethodHandle SCIPgetColRedcost$handle() {
        return SCIPgetColRedcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetColRedcost(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MemorySegment SCIPgetColRedcost$address() {
        return SCIPgetColRedcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetColRedcost(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static double SCIPgetColRedcost(MemorySegment scip, MemorySegment col) {
        var mh$ = SCIPgetColRedcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetColRedcost", scip, col);
            }
            return (double)mh$.invokeExact(scip, col);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetColFarkasCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetColFarkasCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetColFarkasCoef(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static FunctionDescriptor SCIPgetColFarkasCoef$descriptor() {
        return SCIPgetColFarkasCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetColFarkasCoef(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MethodHandle SCIPgetColFarkasCoef$handle() {
        return SCIPgetColFarkasCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetColFarkasCoef(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MemorySegment SCIPgetColFarkasCoef$address() {
        return SCIPgetColFarkasCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetColFarkasCoef(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static double SCIPgetColFarkasCoef(MemorySegment scip, MemorySegment col) {
        var mh$ = SCIPgetColFarkasCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetColFarkasCoef", scip, col);
            }
            return (double)mh$.invokeExact(scip, col);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkColNotRemovableLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkColNotRemovableLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPmarkColNotRemovableLocal(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static FunctionDescriptor SCIPmarkColNotRemovableLocal$descriptor() {
        return SCIPmarkColNotRemovableLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPmarkColNotRemovableLocal(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MethodHandle SCIPmarkColNotRemovableLocal$handle() {
        return SCIPmarkColNotRemovableLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPmarkColNotRemovableLocal(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static MemorySegment SCIPmarkColNotRemovableLocal$address() {
        return SCIPmarkColNotRemovableLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPmarkColNotRemovableLocal(SCIP *scip, SCIP_COL *col)
     * }
     */
    public static void SCIPmarkColNotRemovableLocal(MemorySegment scip, MemorySegment col) {
        var mh$ = SCIPmarkColNotRemovableLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkColNotRemovableLocal", scip, col);
            }
            mh$.invokeExact(scip, col);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRowConshdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRowConshdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateRowConshdlr$descriptor() {
        return SCIPcreateRowConshdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateRowConshdlr$handle() {
        return SCIPcreateRowConshdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateRowConshdlr$address() {
        return SCIPcreateRowConshdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateRowConshdlr(MemorySegment scip, MemorySegment row, MemorySegment conshdlr, MemorySegment name, int len, MemorySegment cols, MemorySegment vals, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateRowConshdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRowConshdlr", scip, row, conshdlr, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, conshdlr, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRowCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRowCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateRowCons$descriptor() {
        return SCIPcreateRowCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateRowCons$handle() {
        return SCIPcreateRowCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateRowCons$address() {
        return SCIPcreateRowCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateRowCons(MemorySegment scip, MemorySegment row, MemorySegment cons, MemorySegment name, int len, MemorySegment cols, MemorySegment vals, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateRowCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRowCons", scip, row, cons, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, cons, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRowSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRowSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateRowSepa$descriptor() {
        return SCIPcreateRowSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateRowSepa$handle() {
        return SCIPcreateRowSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateRowSepa$address() {
        return SCIPcreateRowSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateRowSepa(MemorySegment scip, MemorySegment row, MemorySegment sepa, MemorySegment name, int len, MemorySegment cols, MemorySegment vals, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateRowSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRowSepa", scip, row, sepa, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, sepa, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRowUnspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRowUnspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateRowUnspec$descriptor() {
        return SCIPcreateRowUnspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateRowUnspec$handle() {
        return SCIPcreateRowUnspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateRowUnspec$address() {
        return SCIPcreateRowUnspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateRowUnspec(MemorySegment scip, MemorySegment row, MemorySegment name, int len, MemorySegment cols, MemorySegment vals, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateRowUnspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRowUnspec", scip, row, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRow(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateRow$descriptor() {
        return SCIPcreateRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRow(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateRow$handle() {
        return SCIPcreateRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRow(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateRow$address() {
        return SCIPcreateRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRow(SCIP *scip, SCIP_ROW **row, const char *name, int len, SCIP_COL **cols, double *vals, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateRow(MemorySegment scip, MemorySegment row, MemorySegment name, int len, MemorySegment cols, MemorySegment vals, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRow", scip, row, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, name, len, cols, vals, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyRowConshdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyRowConshdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyRowConshdlr$descriptor() {
        return SCIPcreateEmptyRowConshdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateEmptyRowConshdlr$handle() {
        return SCIPcreateEmptyRowConshdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateEmptyRowConshdlr$address() {
        return SCIPcreateEmptyRowConshdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowConshdlr(SCIP *scip, SCIP_ROW **row, SCIP_CONSHDLR *conshdlr, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateEmptyRowConshdlr(MemorySegment scip, MemorySegment row, MemorySegment conshdlr, MemorySegment name, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateEmptyRowConshdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyRowConshdlr", scip, row, conshdlr, name, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, conshdlr, name, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyRowCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyRowCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyRowCons$descriptor() {
        return SCIPcreateEmptyRowCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateEmptyRowCons$handle() {
        return SCIPcreateEmptyRowCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateEmptyRowCons$address() {
        return SCIPcreateEmptyRowCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowCons(SCIP *scip, SCIP_ROW **row, SCIP_CONS *cons, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateEmptyRowCons(MemorySegment scip, MemorySegment row, MemorySegment cons, MemorySegment name, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateEmptyRowCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyRowCons", scip, row, cons, name, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, cons, name, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyRowSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyRowSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyRowSepa$descriptor() {
        return SCIPcreateEmptyRowSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateEmptyRowSepa$handle() {
        return SCIPcreateEmptyRowSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateEmptyRowSepa$address() {
        return SCIPcreateEmptyRowSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowSepa(SCIP *scip, SCIP_ROW **row, SCIP_SEPA *sepa, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateEmptyRowSepa(MemorySegment scip, MemorySegment row, MemorySegment sepa, MemorySegment name, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateEmptyRowSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyRowSepa", scip, row, sepa, name, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, sepa, name, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyRowUnspec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyRowUnspec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyRowUnspec$descriptor() {
        return SCIPcreateEmptyRowUnspec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateEmptyRowUnspec$handle() {
        return SCIPcreateEmptyRowUnspec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateEmptyRowUnspec$address() {
        return SCIPcreateEmptyRowUnspec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRowUnspec(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateEmptyRowUnspec(MemorySegment scip, MemorySegment row, MemorySegment name, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateEmptyRowUnspec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyRowUnspec", scip, row, name, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, name, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRow(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyRow$descriptor() {
        return SCIPcreateEmptyRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRow(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MethodHandle SCIPcreateEmptyRow$handle() {
        return SCIPcreateEmptyRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRow(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static MemorySegment SCIPcreateEmptyRow$address() {
        return SCIPcreateEmptyRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyRow(SCIP *scip, SCIP_ROW **row, const char *name, double lhs, double rhs, unsigned int local, unsigned int modifiable, unsigned int removable)
     * }
     */
    public static int SCIPcreateEmptyRow(MemorySegment scip, MemorySegment row, MemorySegment name, double lhs, double rhs, int local, int modifiable, int removable) {
        var mh$ = SCIPcreateEmptyRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyRow", scip, row, name, lhs, rhs, local, modifiable, removable);
            }
            return (int)mh$.invokeExact(scip, row, name, lhs, rhs, local, modifiable, removable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureRow(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPcaptureRow$descriptor() {
        return SCIPcaptureRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureRow(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPcaptureRow$handle() {
        return SCIPcaptureRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureRow(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPcaptureRow$address() {
        return SCIPcaptureRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureRow(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPcaptureRow(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPcaptureRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureRow", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseRow(SCIP *scip, SCIP_ROW **row)
     * }
     */
    public static FunctionDescriptor SCIPreleaseRow$descriptor() {
        return SCIPreleaseRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseRow(SCIP *scip, SCIP_ROW **row)
     * }
     */
    public static MethodHandle SCIPreleaseRow$handle() {
        return SCIPreleaseRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseRow(SCIP *scip, SCIP_ROW **row)
     * }
     */
    public static MemorySegment SCIPreleaseRow$address() {
        return SCIPreleaseRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseRow(SCIP *scip, SCIP_ROW **row)
     * }
     */
    public static int SCIPreleaseRow(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPreleaseRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseRow", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRowLhs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRowLhs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhs(SCIP *scip, SCIP_ROW *row, double lhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRowLhs$descriptor() {
        return SCIPchgRowLhs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhs(SCIP *scip, SCIP_ROW *row, double lhs)
     * }
     */
    public static MethodHandle SCIPchgRowLhs$handle() {
        return SCIPchgRowLhs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhs(SCIP *scip, SCIP_ROW *row, double lhs)
     * }
     */
    public static MemorySegment SCIPchgRowLhs$address() {
        return SCIPchgRowLhs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhs(SCIP *scip, SCIP_ROW *row, double lhs)
     * }
     */
    public static int SCIPchgRowLhs(MemorySegment scip, MemorySegment row, double lhs) {
        var mh$ = SCIPchgRowLhs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRowLhs", scip, row, lhs);
            }
            return (int)mh$.invokeExact(scip, row, lhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRowRhs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRowRhs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhs(SCIP *scip, SCIP_ROW *row, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRowRhs$descriptor() {
        return SCIPchgRowRhs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhs(SCIP *scip, SCIP_ROW *row, double rhs)
     * }
     */
    public static MethodHandle SCIPchgRowRhs$handle() {
        return SCIPchgRowRhs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhs(SCIP *scip, SCIP_ROW *row, double rhs)
     * }
     */
    public static MemorySegment SCIPchgRowRhs$address() {
        return SCIPchgRowRhs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhs(SCIP *scip, SCIP_ROW *row, double rhs)
     * }
     */
    public static int SCIPchgRowRhs(MemorySegment scip, MemorySegment row, double rhs) {
        var mh$ = SCIPchgRowRhs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRowRhs", scip, row, rhs);
            }
            return (int)mh$.invokeExact(scip, row, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcacheRowExtensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcacheRowExtensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcacheRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPcacheRowExtensions$descriptor() {
        return SCIPcacheRowExtensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcacheRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPcacheRowExtensions$handle() {
        return SCIPcacheRowExtensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcacheRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPcacheRowExtensions$address() {
        return SCIPcacheRowExtensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcacheRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPcacheRowExtensions(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPcacheRowExtensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcacheRowExtensions", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPflushRowExtensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPflushRowExtensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPflushRowExtensions$descriptor() {
        return SCIPflushRowExtensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPflushRowExtensions$handle() {
        return SCIPflushRowExtensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPflushRowExtensions$address() {
        return SCIPflushRowExtensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushRowExtensions(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPflushRowExtensions(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPflushRowExtensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPflushRowExtensions", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarToRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarToRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarToRow(SCIP *scip, SCIP_ROW *row, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPaddVarToRow$descriptor() {
        return SCIPaddVarToRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarToRow(SCIP *scip, SCIP_ROW *row, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPaddVarToRow$handle() {
        return SCIPaddVarToRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarToRow(SCIP *scip, SCIP_ROW *row, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPaddVarToRow$address() {
        return SCIPaddVarToRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarToRow(SCIP *scip, SCIP_ROW *row, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPaddVarToRow(MemorySegment scip, MemorySegment row, MemorySegment var_, double val) {
        var mh$ = SCIPaddVarToRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarToRow", scip, row, var_, val);
            }
            return (int)mh$.invokeExact(scip, row, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarsToRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarsToRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRow(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPaddVarsToRow$descriptor() {
        return SCIPaddVarsToRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRow(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MethodHandle SCIPaddVarsToRow$handle() {
        return SCIPaddVarsToRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRow(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MemorySegment SCIPaddVarsToRow$address() {
        return SCIPaddVarsToRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRow(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static int SCIPaddVarsToRow(MemorySegment scip, MemorySegment row, int nvars, MemorySegment vars, MemorySegment vals) {
        var mh$ = SCIPaddVarsToRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarsToRow", scip, row, nvars, vars, vals);
            }
            return (int)mh$.invokeExact(scip, row, nvars, vars, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVarsToRowSameCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVarsToRowSameCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRowSameCoef(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double val)
     * }
     */
    public static FunctionDescriptor SCIPaddVarsToRowSameCoef$descriptor() {
        return SCIPaddVarsToRowSameCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRowSameCoef(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double val)
     * }
     */
    public static MethodHandle SCIPaddVarsToRowSameCoef$handle() {
        return SCIPaddVarsToRowSameCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRowSameCoef(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double val)
     * }
     */
    public static MemorySegment SCIPaddVarsToRowSameCoef$address() {
        return SCIPaddVarsToRowSameCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVarsToRowSameCoef(SCIP *scip, SCIP_ROW *row, int nvars, SCIP_VAR **vars, double val)
     * }
     */
    public static int SCIPaddVarsToRowSameCoef(MemorySegment scip, MemorySegment row, int nvars, MemorySegment vars, double val) {
        var mh$ = SCIPaddVarsToRowSameCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVarsToRowSameCoef", scip, row, nvars, vars, val);
            }
            return (int)mh$.invokeExact(scip, row, nvars, vars, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcRowIntegralScalar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcRowIntegralScalar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcRowIntegralScalar(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, double *intscalar, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcalcRowIntegralScalar$descriptor() {
        return SCIPcalcRowIntegralScalar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcRowIntegralScalar(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, double *intscalar, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcalcRowIntegralScalar$handle() {
        return SCIPcalcRowIntegralScalar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcRowIntegralScalar(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, double *intscalar, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcalcRowIntegralScalar$address() {
        return SCIPcalcRowIntegralScalar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcalcRowIntegralScalar(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, double *intscalar, unsigned int *success)
     * }
     */
    public static int SCIPcalcRowIntegralScalar(MemorySegment scip, MemorySegment row, double mindelta, double maxdelta, long maxdnom, double maxscale, int usecontvars, MemorySegment intscalar, MemorySegment success) {
        var mh$ = SCIPcalcRowIntegralScalar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcRowIntegralScalar", scip, row, mindelta, maxdelta, maxdnom, maxscale, usecontvars, intscalar, success);
            }
            return (int)mh$.invokeExact(scip, row, mindelta, maxdelta, maxdnom, maxscale, usecontvars, intscalar, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmakeRowIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_LONG_LONG,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmakeRowIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeRowIntegral(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPmakeRowIntegral$descriptor() {
        return SCIPmakeRowIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeRowIntegral(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPmakeRowIntegral$handle() {
        return SCIPmakeRowIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeRowIntegral(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPmakeRowIntegral$address() {
        return SCIPmakeRowIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPmakeRowIntegral(SCIP *scip, SCIP_ROW *row, double mindelta, double maxdelta, long long maxdnom, double maxscale, unsigned int usecontvars, unsigned int *success)
     * }
     */
    public static int SCIPmakeRowIntegral(MemorySegment scip, MemorySegment row, double mindelta, double maxdelta, long maxdnom, double maxscale, int usecontvars, MemorySegment success) {
        var mh$ = SCIPmakeRowIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmakeRowIntegral", scip, row, mindelta, maxdelta, maxdnom, maxscale, usecontvars, success);
            }
            return (int)mh$.invokeExact(scip, row, mindelta, maxdelta, maxdnom, maxscale, usecontvars, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkRowNotRemovableLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkRowNotRemovableLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPmarkRowNotRemovableLocal(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPmarkRowNotRemovableLocal$descriptor() {
        return SCIPmarkRowNotRemovableLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPmarkRowNotRemovableLocal(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPmarkRowNotRemovableLocal$handle() {
        return SCIPmarkRowNotRemovableLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPmarkRowNotRemovableLocal(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPmarkRowNotRemovableLocal$address() {
        return SCIPmarkRowNotRemovableLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPmarkRowNotRemovableLocal(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static void SCIPmarkRowNotRemovableLocal(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPmarkRowNotRemovableLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkRowNotRemovableLocal", scip, row);
            }
            mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowNumIntCols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowNumIntCols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetRowNumIntCols(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowNumIntCols$descriptor() {
        return SCIPgetRowNumIntCols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetRowNumIntCols(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowNumIntCols$handle() {
        return SCIPgetRowNumIntCols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetRowNumIntCols(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowNumIntCols$address() {
        return SCIPgetRowNumIntCols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetRowNumIntCols(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPgetRowNumIntCols(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowNumIntCols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowNumIntCols", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowMinCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowMinCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowMinCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowMinCoef$descriptor() {
        return SCIPgetRowMinCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowMinCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowMinCoef$handle() {
        return SCIPgetRowMinCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowMinCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowMinCoef$address() {
        return SCIPgetRowMinCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowMinCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowMinCoef(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowMinCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowMinCoef", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowMaxCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowMaxCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowMaxCoef$descriptor() {
        return SCIPgetRowMaxCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowMaxCoef$handle() {
        return SCIPgetRowMaxCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowMaxCoef$address() {
        return SCIPgetRowMaxCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowMaxCoef(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowMaxCoef(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowMaxCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowMaxCoef", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowMinActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowMinActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowMinActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowMinActivity$descriptor() {
        return SCIPgetRowMinActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowMinActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowMinActivity$handle() {
        return SCIPgetRowMinActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowMinActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowMinActivity$address() {
        return SCIPgetRowMinActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowMinActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowMinActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowMinActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowMinActivity", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowMaxActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowMaxActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowMaxActivity$descriptor() {
        return SCIPgetRowMaxActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowMaxActivity$handle() {
        return SCIPgetRowMaxActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowMaxActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowMaxActivity$address() {
        return SCIPgetRowMaxActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowMaxActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowMaxActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowMaxActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowMaxActivity", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcRowLPActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcRowLPActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPrecalcRowLPActivity$descriptor() {
        return SCIPrecalcRowLPActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPrecalcRowLPActivity$handle() {
        return SCIPrecalcRowLPActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPrecalcRowLPActivity$address() {
        return SCIPrecalcRowLPActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPrecalcRowLPActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPrecalcRowLPActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcRowLPActivity", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowLPActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowLPActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowLPActivity$descriptor() {
        return SCIPgetRowLPActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowLPActivity$handle() {
        return SCIPgetRowLPActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowLPActivity$address() {
        return SCIPgetRowLPActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowLPActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowLPActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowLPActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowLPActivity", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowLPFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowLPFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowLPFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowLPFeasibility$descriptor() {
        return SCIPgetRowLPFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowLPFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowLPFeasibility$handle() {
        return SCIPgetRowLPFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowLPFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowLPFeasibility$address() {
        return SCIPgetRowLPFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowLPFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowLPFeasibility(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowLPFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowLPFeasibility", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcRowPseudoActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcRowPseudoActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPrecalcRowPseudoActivity$descriptor() {
        return SCIPrecalcRowPseudoActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPrecalcRowPseudoActivity$handle() {
        return SCIPrecalcRowPseudoActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPrecalcRowPseudoActivity$address() {
        return SCIPrecalcRowPseudoActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPrecalcRowPseudoActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPrecalcRowPseudoActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcRowPseudoActivity", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowPseudoActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowPseudoActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowPseudoActivity$descriptor() {
        return SCIPgetRowPseudoActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowPseudoActivity$handle() {
        return SCIPgetRowPseudoActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowPseudoActivity$address() {
        return SCIPgetRowPseudoActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowPseudoActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowPseudoActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowPseudoActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowPseudoActivity", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowPseudoFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowPseudoFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowPseudoFeasibility$descriptor() {
        return SCIPgetRowPseudoFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowPseudoFeasibility$handle() {
        return SCIPgetRowPseudoFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowPseudoFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowPseudoFeasibility$address() {
        return SCIPgetRowPseudoFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowPseudoFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowPseudoFeasibility(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowPseudoFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowPseudoFeasibility", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcRowActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcRowActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPrecalcRowActivity$descriptor() {
        return SCIPrecalcRowActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPrecalcRowActivity$handle() {
        return SCIPrecalcRowActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPrecalcRowActivity$address() {
        return SCIPrecalcRowActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPrecalcRowActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPrecalcRowActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcRowActivity", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowActivity$descriptor() {
        return SCIPgetRowActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowActivity$handle() {
        return SCIPgetRowActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowActivity$address() {
        return SCIPgetRowActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowActivity(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowActivity(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowActivity", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowFeasibility$descriptor() {
        return SCIPgetRowFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowFeasibility$handle() {
        return SCIPgetRowFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowFeasibility$address() {
        return SCIPgetRowFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowFeasibility(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowFeasibility(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowFeasibility", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowSolActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowSolActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowSolActivity(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetRowSolActivity$descriptor() {
        return SCIPgetRowSolActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowSolActivity(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetRowSolActivity$handle() {
        return SCIPgetRowSolActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowSolActivity(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetRowSolActivity$address() {
        return SCIPgetRowSolActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowSolActivity(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetRowSolActivity(MemorySegment scip, MemorySegment row, MemorySegment sol) {
        var mh$ = SCIPgetRowSolActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowSolActivity", scip, row, sol);
            }
            return (double)mh$.invokeExact(scip, row, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowSolFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowSolFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowSolFeasibility(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetRowSolFeasibility$descriptor() {
        return SCIPgetRowSolFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowSolFeasibility(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetRowSolFeasibility$handle() {
        return SCIPgetRowSolFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowSolFeasibility(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetRowSolFeasibility$address() {
        return SCIPgetRowSolFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowSolFeasibility(SCIP *scip, SCIP_ROW *row, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetRowSolFeasibility(MemorySegment scip, MemorySegment row, MemorySegment sol) {
        var mh$ = SCIPgetRowSolFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowSolFeasibility", scip, row, sol);
            }
            return (double)mh$.invokeExact(scip, row, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRowObjParallelism {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRowObjParallelism");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetRowObjParallelism(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPgetRowObjParallelism$descriptor() {
        return SCIPgetRowObjParallelism.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetRowObjParallelism(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPgetRowObjParallelism$handle() {
        return SCIPgetRowObjParallelism.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetRowObjParallelism(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPgetRowObjParallelism$address() {
        return SCIPgetRowObjParallelism.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetRowObjParallelism(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static double SCIPgetRowObjParallelism(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPgetRowObjParallelism.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRowObjParallelism", scip, row);
            }
            return (double)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRow(SCIP *scip, SCIP_ROW *row, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintRow$descriptor() {
        return SCIPprintRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRow(SCIP *scip, SCIP_ROW *row, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintRow$handle() {
        return SCIPprintRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRow(SCIP *scip, SCIP_ROW *row, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintRow$address() {
        return SCIPprintRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRow(SCIP *scip, SCIP_ROW *row, FILE *file)
     * }
     */
    public static int SCIPprintRow(MemorySegment scip, MemorySegment row, MemorySegment file) {
        var mh$ = SCIPprintRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintRow", scip, row, file);
            }
            return (int)mh$.invokeExact(scip, row, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDive(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstartDive$descriptor() {
        return SCIPstartDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDive(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstartDive$handle() {
        return SCIPstartDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDive(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstartDive$address() {
        return SCIPstartDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDive(SCIP *scip)
     * }
     */
    public static int SCIPstartDive(MemorySegment scip) {
        var mh$ = SCIPstartDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartDive", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPendDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPendDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDive(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPendDive$descriptor() {
        return SCIPendDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDive(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPendDive$handle() {
        return SCIPendDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDive(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPendDive$address() {
        return SCIPendDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDive(SCIP *scip)
     * }
     */
    public static int SCIPendDive(MemorySegment scip) {
        var mh$ = SCIPendDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPendDive", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgCutoffboundDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgCutoffboundDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCutoffboundDive(SCIP *scip, double newcutoffbound)
     * }
     */
    public static FunctionDescriptor SCIPchgCutoffboundDive$descriptor() {
        return SCIPchgCutoffboundDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCutoffboundDive(SCIP *scip, double newcutoffbound)
     * }
     */
    public static MethodHandle SCIPchgCutoffboundDive$handle() {
        return SCIPchgCutoffboundDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCutoffboundDive(SCIP *scip, double newcutoffbound)
     * }
     */
    public static MemorySegment SCIPchgCutoffboundDive$address() {
        return SCIPchgCutoffboundDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCutoffboundDive(SCIP *scip, double newcutoffbound)
     * }
     */
    public static int SCIPchgCutoffboundDive(MemorySegment scip, double newcutoffbound) {
        var mh$ = SCIPchgCutoffboundDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgCutoffboundDive", scip, newcutoffbound);
            }
            return (int)mh$.invokeExact(scip, newcutoffbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarObjDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarObjDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDive(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static FunctionDescriptor SCIPchgVarObjDive$descriptor() {
        return SCIPchgVarObjDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDive(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MethodHandle SCIPchgVarObjDive$handle() {
        return SCIPchgVarObjDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDive(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MemorySegment SCIPchgVarObjDive$address() {
        return SCIPchgVarObjDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDive(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static int SCIPchgVarObjDive(MemorySegment scip, MemorySegment var_, double newobj) {
        var mh$ = SCIPchgVarObjDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarObjDive", scip, var_, newobj);
            }
            return (int)mh$.invokeExact(scip, var_, newobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLbDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLbDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLbDive$descriptor() {
        return SCIPchgVarLbDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarLbDive$handle() {
        return SCIPchgVarLbDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarLbDive$address() {
        return SCIPchgVarLbDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarLbDive(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarLbDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLbDive", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUbDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUbDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUbDive$descriptor() {
        return SCIPchgVarUbDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarUbDive$handle() {
        return SCIPchgVarUbDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarUbDive$address() {
        return SCIPchgVarUbDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbDive(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarUbDive(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarUbDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUbDive", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRowDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRowDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowDive(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddRowDive$descriptor() {
        return SCIPaddRowDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowDive(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddRowDive$handle() {
        return SCIPaddRowDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowDive(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddRowDive$address() {
        return SCIPaddRowDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowDive(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddRowDive(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPaddRowDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRowDive", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRowLhsDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRowLhsDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhsDive(SCIP *scip, SCIP_ROW *row, double newlhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRowLhsDive$descriptor() {
        return SCIPchgRowLhsDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhsDive(SCIP *scip, SCIP_ROW *row, double newlhs)
     * }
     */
    public static MethodHandle SCIPchgRowLhsDive$handle() {
        return SCIPchgRowLhsDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhsDive(SCIP *scip, SCIP_ROW *row, double newlhs)
     * }
     */
    public static MemorySegment SCIPchgRowLhsDive$address() {
        return SCIPchgRowLhsDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowLhsDive(SCIP *scip, SCIP_ROW *row, double newlhs)
     * }
     */
    public static int SCIPchgRowLhsDive(MemorySegment scip, MemorySegment row, double newlhs) {
        var mh$ = SCIPchgRowLhsDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRowLhsDive", scip, row, newlhs);
            }
            return (int)mh$.invokeExact(scip, row, newlhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRowRhsDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRowRhsDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhsDive(SCIP *scip, SCIP_ROW *row, double newrhs)
     * }
     */
    public static FunctionDescriptor SCIPchgRowRhsDive$descriptor() {
        return SCIPchgRowRhsDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhsDive(SCIP *scip, SCIP_ROW *row, double newrhs)
     * }
     */
    public static MethodHandle SCIPchgRowRhsDive$handle() {
        return SCIPchgRowRhsDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhsDive(SCIP *scip, SCIP_ROW *row, double newrhs)
     * }
     */
    public static MemorySegment SCIPchgRowRhsDive$address() {
        return SCIPchgRowRhsDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRowRhsDive(SCIP *scip, SCIP_ROW *row, double newrhs)
     * }
     */
    public static int SCIPchgRowRhsDive(MemorySegment scip, MemorySegment row, double newrhs) {
        var mh$ = SCIPchgRowRhsDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRowRhsDive", scip, row, newrhs);
            }
            return (int)mh$.invokeExact(scip, row, newrhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarObjDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarObjDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarObjDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarObjDive$descriptor() {
        return SCIPgetVarObjDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarObjDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarObjDive$handle() {
        return SCIPgetVarObjDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarObjDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarObjDive$address() {
        return SCIPgetVarObjDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarObjDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarObjDive(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarObjDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarObjDive", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarLbDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarLbDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarLbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarLbDive$descriptor() {
        return SCIPgetVarLbDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarLbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarLbDive$handle() {
        return SCIPgetVarLbDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarLbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarLbDive$address() {
        return SCIPgetVarLbDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarLbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarLbDive(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarLbDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarLbDive", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarUbDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarUbDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarUbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarUbDive$descriptor() {
        return SCIPgetVarUbDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarUbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarUbDive$handle() {
        return SCIPgetVarUbDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarUbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarUbDive$address() {
        return SCIPgetVarUbDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarUbDive(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarUbDive(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarUbDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarUbDive", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveDiveLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveDiveLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveDiveLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPsolveDiveLP$descriptor() {
        return SCIPsolveDiveLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveDiveLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPsolveDiveLP$handle() {
        return SCIPsolveDiveLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveDiveLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPsolveDiveLP$address() {
        return SCIPsolveDiveLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveDiveLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static int SCIPsolveDiveLP(MemorySegment scip, int itlim, MemorySegment lperror, MemorySegment cutoff) {
        var mh$ = SCIPsolveDiveLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveDiveLP", scip, itlim, lperror, cutoff);
            }
            return (int)mh$.invokeExact(scip, itlim, lperror, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLastDivenode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLastDivenode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetLastDivenode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLastDivenode$descriptor() {
        return SCIPgetLastDivenode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetLastDivenode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLastDivenode$handle() {
        return SCIPgetLastDivenode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetLastDivenode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLastDivenode$address() {
        return SCIPgetLastDivenode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetLastDivenode(SCIP *scip)
     * }
     */
    public static long SCIPgetLastDivenode(MemorySegment scip) {
        var mh$ = SCIPgetLastDivenode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLastDivenode", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinDive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinDive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPinDive(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPinDive$descriptor() {
        return SCIPinDive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPinDive(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPinDive$handle() {
        return SCIPinDive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPinDive(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPinDive$address() {
        return SCIPinDive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPinDive(SCIP *scip)
     * }
     */
    public static int SCIPinDive(MemorySegment scip) {
        var mh$ = SCIPinDive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinDive", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLPDualDegeneracy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLPDualDegeneracy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPDualDegeneracy(SCIP *scip, double *degeneracy, double *varconsratio)
     * }
     */
    public static FunctionDescriptor SCIPgetLPDualDegeneracy$descriptor() {
        return SCIPgetLPDualDegeneracy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPDualDegeneracy(SCIP *scip, double *degeneracy, double *varconsratio)
     * }
     */
    public static MethodHandle SCIPgetLPDualDegeneracy$handle() {
        return SCIPgetLPDualDegeneracy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPDualDegeneracy(SCIP *scip, double *degeneracy, double *varconsratio)
     * }
     */
    public static MemorySegment SCIPgetLPDualDegeneracy$address() {
        return SCIPgetLPDualDegeneracy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLPDualDegeneracy(SCIP *scip, double *degeneracy, double *varconsratio)
     * }
     */
    public static int SCIPgetLPDualDegeneracy(MemorySegment scip, MemorySegment degeneracy, MemorySegment varconsratio) {
        var mh$ = SCIPgetLPDualDegeneracy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLPDualDegeneracy", scip, degeneracy, varconsratio);
            }
            return (int)mh$.invokeExact(scip, degeneracy, varconsratio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPblkmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPblkmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_BLKMEM *SCIPblkmem(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPblkmem$descriptor() {
        return SCIPblkmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_BLKMEM *SCIPblkmem(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPblkmem$handle() {
        return SCIPblkmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_BLKMEM *SCIPblkmem(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPblkmem$address() {
        return SCIPblkmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_BLKMEM *SCIPblkmem(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPblkmem(MemorySegment scip) {
        var mh$ = SCIPblkmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPblkmem", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPbuffer(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPbuffer$descriptor() {
        return SCIPbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPbuffer(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPbuffer$handle() {
        return SCIPbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPbuffer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPbuffer$address() {
        return SCIPbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPbuffer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPbuffer(MemorySegment scip) {
        var mh$ = SCIPbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbuffer", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcleanbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcleanbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPcleanbuffer(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPcleanbuffer$descriptor() {
        return SCIPcleanbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPcleanbuffer(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPcleanbuffer$handle() {
        return SCIPcleanbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPcleanbuffer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPcleanbuffer$address() {
        return SCIPcleanbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * BMS_BUFMEM *SCIPcleanbuffer(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPcleanbuffer(MemorySegment scip) {
        var mh$ = SCIPcleanbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcleanbuffer", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMemUsed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMemUsed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetMemUsed(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMemUsed$descriptor() {
        return SCIPgetMemUsed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetMemUsed(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMemUsed$handle() {
        return SCIPgetMemUsed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetMemUsed(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMemUsed$address() {
        return SCIPgetMemUsed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetMemUsed(SCIP *scip)
     * }
     */
    public static long SCIPgetMemUsed(MemorySegment scip) {
        var mh$ = SCIPgetMemUsed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMemUsed", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMemTotal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMemTotal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetMemTotal(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMemTotal$descriptor() {
        return SCIPgetMemTotal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetMemTotal(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMemTotal$handle() {
        return SCIPgetMemTotal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetMemTotal(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMemTotal$address() {
        return SCIPgetMemTotal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetMemTotal(SCIP *scip)
     * }
     */
    public static long SCIPgetMemTotal(MemorySegment scip) {
        var mh$ = SCIPgetMemTotal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMemTotal", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMemExternEstim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMemExternEstim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetMemExternEstim(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMemExternEstim$descriptor() {
        return SCIPgetMemExternEstim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetMemExternEstim(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMemExternEstim$handle() {
        return SCIPgetMemExternEstim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetMemExternEstim(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMemExternEstim$address() {
        return SCIPgetMemExternEstim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetMemExternEstim(SCIP *scip)
     * }
     */
    public static long SCIPgetMemExternEstim(MemorySegment scip) {
        var mh$ = SCIPgetMemExternEstim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMemExternEstim", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcalcMemGrowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcalcMemGrowSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPcalcMemGrowSize(SCIP *scip, int num)
     * }
     */
    public static FunctionDescriptor SCIPcalcMemGrowSize$descriptor() {
        return SCIPcalcMemGrowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPcalcMemGrowSize(SCIP *scip, int num)
     * }
     */
    public static MethodHandle SCIPcalcMemGrowSize$handle() {
        return SCIPcalcMemGrowSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPcalcMemGrowSize(SCIP *scip, int num)
     * }
     */
    public static MemorySegment SCIPcalcMemGrowSize$address() {
        return SCIPcalcMemGrowSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPcalcMemGrowSize(SCIP *scip, int num)
     * }
     */
    public static int SCIPcalcMemGrowSize(MemorySegment scip, int num) {
        var mh$ = SCIPcalcMemGrowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcalcMemGrowSize", scip, num);
            }
            return (int)mh$.invokeExact(scip, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPensureBlockMemoryArray_call {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPensureBlockMemoryArray_call");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPensureBlockMemoryArray_call(SCIP *scip, void **arrayptr, size_t elemsize, int *arraysize, int minsize)
     * }
     */
    public static FunctionDescriptor SCIPensureBlockMemoryArray_call$descriptor() {
        return SCIPensureBlockMemoryArray_call.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPensureBlockMemoryArray_call(SCIP *scip, void **arrayptr, size_t elemsize, int *arraysize, int minsize)
     * }
     */
    public static MethodHandle SCIPensureBlockMemoryArray_call$handle() {
        return SCIPensureBlockMemoryArray_call.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPensureBlockMemoryArray_call(SCIP *scip, void **arrayptr, size_t elemsize, int *arraysize, int minsize)
     * }
     */
    public static MemorySegment SCIPensureBlockMemoryArray_call$address() {
        return SCIPensureBlockMemoryArray_call.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPensureBlockMemoryArray_call(SCIP *scip, void **arrayptr, size_t elemsize, int *arraysize, int minsize)
     * }
     */
    public static int SCIPensureBlockMemoryArray_call(MemorySegment scip, MemorySegment arrayptr, long elemsize, MemorySegment arraysize, int minsize) {
        var mh$ = SCIPensureBlockMemoryArray_call.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPensureBlockMemoryArray_call", scip, arrayptr, elemsize, arraysize, minsize);
            }
            return (int)mh$.invokeExact(scip, arrayptr, elemsize, arraysize, minsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintMemoryDiagnostic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintMemoryDiagnostic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintMemoryDiagnostic(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPprintMemoryDiagnostic$descriptor() {
        return SCIPprintMemoryDiagnostic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintMemoryDiagnostic(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPprintMemoryDiagnostic$handle() {
        return SCIPprintMemoryDiagnostic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintMemoryDiagnostic(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPprintMemoryDiagnostic$address() {
        return SCIPprintMemoryDiagnostic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintMemoryDiagnostic(SCIP *scip)
     * }
     */
    public static void SCIPprintMemoryDiagnostic(MemorySegment scip) {
        var mh$ = SCIPprintMemoryDiagnostic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintMemoryDiagnostic", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetMessagehdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetMessagehdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetMessagehdlr(SCIP *scip, SCIP_MESSAGEHDLR *messagehdlr)
     * }
     */
    public static FunctionDescriptor SCIPsetMessagehdlr$descriptor() {
        return SCIPsetMessagehdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetMessagehdlr(SCIP *scip, SCIP_MESSAGEHDLR *messagehdlr)
     * }
     */
    public static MethodHandle SCIPsetMessagehdlr$handle() {
        return SCIPsetMessagehdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetMessagehdlr(SCIP *scip, SCIP_MESSAGEHDLR *messagehdlr)
     * }
     */
    public static MemorySegment SCIPsetMessagehdlr$address() {
        return SCIPsetMessagehdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetMessagehdlr(SCIP *scip, SCIP_MESSAGEHDLR *messagehdlr)
     * }
     */
    public static int SCIPsetMessagehdlr(MemorySegment scip, MemorySegment messagehdlr) {
        var mh$ = SCIPsetMessagehdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetMessagehdlr", scip, messagehdlr);
            }
            return (int)mh$.invokeExact(scip, messagehdlr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMessagehdlr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMessagehdlr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_MESSAGEHDLR *SCIPgetMessagehdlr(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMessagehdlr$descriptor() {
        return SCIPgetMessagehdlr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_MESSAGEHDLR *SCIPgetMessagehdlr(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMessagehdlr$handle() {
        return SCIPgetMessagehdlr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_MESSAGEHDLR *SCIPgetMessagehdlr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMessagehdlr$address() {
        return SCIPgetMessagehdlr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_MESSAGEHDLR *SCIPgetMessagehdlr(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMessagehdlr(MemorySegment scip) {
        var mh$ = SCIPgetMessagehdlr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMessagehdlr", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetMessagehdlrLogfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetMessagehdlrLogfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrLogfile(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPsetMessagehdlrLogfile$descriptor() {
        return SCIPsetMessagehdlrLogfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrLogfile(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPsetMessagehdlrLogfile$handle() {
        return SCIPsetMessagehdlrLogfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrLogfile(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPsetMessagehdlrLogfile$address() {
        return SCIPsetMessagehdlrLogfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrLogfile(SCIP *scip, const char *filename)
     * }
     */
    public static void SCIPsetMessagehdlrLogfile(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPsetMessagehdlrLogfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetMessagehdlrLogfile", scip, filename);
            }
            mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetMessagehdlrQuiet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetMessagehdlrQuiet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrQuiet(SCIP *scip, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetMessagehdlrQuiet$descriptor() {
        return SCIPsetMessagehdlrQuiet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrQuiet(SCIP *scip, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetMessagehdlrQuiet$handle() {
        return SCIPsetMessagehdlrQuiet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrQuiet(SCIP *scip, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetMessagehdlrQuiet$address() {
        return SCIPsetMessagehdlrQuiet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetMessagehdlrQuiet(SCIP *scip, unsigned int quiet)
     * }
     */
    public static void SCIPsetMessagehdlrQuiet(MemorySegment scip, int quiet) {
        var mh$ = SCIPsetMessagehdlrQuiet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetMessagehdlrQuiet", scip, quiet);
            }
            mh$.invokeExact(scip, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPwarningMessage(SCIP *scip, const char *formatstr, ...)
     * }
     */
    public static class SCIPwarningMessage {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwarningMessage");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPwarningMessage(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPwarningMessage(SCIP *scip, const char *formatstr, ...)
         * }
         */
        public static SCIPwarningMessage makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPwarningMessage(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, MemorySegment formatstr, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPwarningMessage", scip, formatstr, x2);
                }
                spreader.invokeExact(scip, formatstr, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPprintDebugMessage(SCIP *scip, const char *sourcefile, int sourceline, const char *formatstr, ...)
     * }
     */
    public static class SCIPprintDebugMessage {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_POINTER,
                scip_h.C_INT,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintDebugMessage");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPprintDebugMessage(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPprintDebugMessage(SCIP *scip, const char *sourcefile, int sourceline, const char *formatstr, ...)
         * }
         */
        public static SCIPprintDebugMessage makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPprintDebugMessage(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, MemorySegment sourcefile, int sourceline, MemorySegment formatstr, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPprintDebugMessage", scip, sourcefile, sourceline, formatstr, x4);
                }
                spreader.invokeExact(scip, sourcefile, sourceline, formatstr, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPdebugMessagePrint(SCIP *scip, const char *formatstr, ...)
     * }
     */
    public static class SCIPdebugMessagePrint {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdebugMessagePrint");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPdebugMessagePrint(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPdebugMessagePrint(SCIP *scip, const char *formatstr, ...)
         * }
         */
        public static SCIPdebugMessagePrint makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPdebugMessagePrint(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, MemorySegment formatstr, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPdebugMessagePrint", scip, formatstr, x2);
                }
                spreader.invokeExact(scip, formatstr, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPdialogMessage(SCIP *scip, FILE *file, const char *formatstr, ...)
     * }
     */
    public static class SCIPdialogMessage {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdialogMessage");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPdialogMessage(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPdialogMessage(SCIP *scip, FILE *file, const char *formatstr, ...)
         * }
         */
        public static SCIPdialogMessage makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPdialogMessage(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, MemorySegment file, MemorySegment formatstr, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPdialogMessage", scip, file, formatstr, x3);
                }
                spreader.invokeExact(scip, file, formatstr, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPinfoMessage(SCIP *scip, FILE *file, const char *formatstr, ...)
     * }
     */
    public static class SCIPinfoMessage {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinfoMessage");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPinfoMessage(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPinfoMessage(SCIP *scip, FILE *file, const char *formatstr, ...)
         * }
         */
        public static SCIPinfoMessage makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPinfoMessage(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, MemorySegment file, MemorySegment formatstr, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPinfoMessage", scip, file, formatstr, x3);
                }
                spreader.invokeExact(scip, file, formatstr, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void SCIPverbMessage(SCIP *scip, SCIP_VERBLEVEL msgverblevel, FILE *file, const char *formatstr, ...)
     * }
     */
    public static class SCIPverbMessage {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                scip_h.C_POINTER,
                scip_h.C_INT,
                scip_h.C_POINTER,
                scip_h.C_POINTER
            );
        private static final MemorySegment ADDR = scip_h.findOrThrow("SCIPverbMessage");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private SCIPverbMessage(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void SCIPverbMessage(SCIP *scip, SCIP_VERBLEVEL msgverblevel, FILE *file, const char *formatstr, ...)
         * }
         */
        public static SCIPverbMessage makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new SCIPverbMessage(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment scip, int msgverblevel, MemorySegment file, MemorySegment formatstr, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("SCIPverbMessage", scip, msgverblevel, file, formatstr, x4);
                }
                spreader.invokeExact(scip, msgverblevel, file, formatstr, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class SCIPgetVerbLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVerbLevel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VERBLEVEL SCIPgetVerbLevel(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetVerbLevel$descriptor() {
        return SCIPgetVerbLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VERBLEVEL SCIPgetVerbLevel(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetVerbLevel$handle() {
        return SCIPgetVerbLevel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VERBLEVEL SCIPgetVerbLevel(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetVerbLevel$address() {
        return SCIPgetVerbLevel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VERBLEVEL SCIPgetVerbLevel(SCIP *scip)
     * }
     */
    public static int SCIPgetVerbLevel(MemorySegment scip) {
        var mh$ = SCIPgetVerbLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVerbLevel", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisNLPEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisNLPEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPEnabled(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisNLPEnabled$descriptor() {
        return SCIPisNLPEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPEnabled(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisNLPEnabled$handle() {
        return SCIPisNLPEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPEnabled(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisNLPEnabled$address() {
        return SCIPisNLPEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisNLPEnabled(SCIP *scip)
     * }
     */
    public static int SCIPisNLPEnabled(MemorySegment scip) {
        var mh$ = SCIPisNLPEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisNLPEnabled", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPenableNLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPenableNLP$descriptor() {
        return SCIPenableNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPenableNLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPenableNLP$handle() {
        return SCIPenableNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPenableNLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPenableNLP$address() {
        return SCIPenableNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPenableNLP(SCIP *scip)
     * }
     */
    public static void SCIPenableNLP(MemorySegment scip) {
        var mh$ = SCIPenableNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableNLP", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisNLPConstructed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisNLPConstructed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPConstructed(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisNLPConstructed$descriptor() {
        return SCIPisNLPConstructed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPConstructed(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisNLPConstructed$handle() {
        return SCIPisNLPConstructed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisNLPConstructed(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisNLPConstructed$address() {
        return SCIPisNLPConstructed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisNLPConstructed(SCIP *scip)
     * }
     */
    public static int SCIPisNLPConstructed(MemorySegment scip) {
        var mh$ = SCIPisNLPConstructed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisNLPConstructed", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasNLPContinuousNonlinearity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasNLPContinuousNonlinearity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasNLPContinuousNonlinearity(SCIP *scip, unsigned int *result)
     * }
     */
    public static FunctionDescriptor SCIPhasNLPContinuousNonlinearity$descriptor() {
        return SCIPhasNLPContinuousNonlinearity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasNLPContinuousNonlinearity(SCIP *scip, unsigned int *result)
     * }
     */
    public static MethodHandle SCIPhasNLPContinuousNonlinearity$handle() {
        return SCIPhasNLPContinuousNonlinearity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasNLPContinuousNonlinearity(SCIP *scip, unsigned int *result)
     * }
     */
    public static MemorySegment SCIPhasNLPContinuousNonlinearity$address() {
        return SCIPhasNLPContinuousNonlinearity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPhasNLPContinuousNonlinearity(SCIP *scip, unsigned int *result)
     * }
     */
    public static int SCIPhasNLPContinuousNonlinearity(MemorySegment scip, MemorySegment result) {
        var mh$ = SCIPhasNLPContinuousNonlinearity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasNLPContinuousNonlinearity", scip, result);
            }
            return (int)mh$.invokeExact(scip, result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPVarsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPVarsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPVarsData$descriptor() {
        return SCIPgetNLPVarsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars)
     * }
     */
    public static MethodHandle SCIPgetNLPVarsData$handle() {
        return SCIPgetNLPVarsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsData$address() {
        return SCIPgetNLPVarsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars)
     * }
     */
    public static int SCIPgetNLPVarsData(MemorySegment scip, MemorySegment vars, MemorySegment nvars) {
        var mh$ = SCIPgetNLPVarsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPVarsData", scip, vars, nvars);
            }
            return (int)mh$.invokeExact(scip, vars, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetNLPVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPVars$descriptor() {
        return SCIPgetNLPVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetNLPVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPVars$handle() {
        return SCIPgetNLPVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetNLPVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVars$address() {
        return SCIPgetNLPVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetNLPVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVars(MemorySegment scip) {
        var mh$ = SCIPgetNLPVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPVars", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNLPVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNLPVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNLPVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNLPVars$descriptor() {
        return SCIPgetNNLPVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNLPVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNLPVars$handle() {
        return SCIPgetNNLPVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNLPVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNLPVars$address() {
        return SCIPgetNNLPVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNLPVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNNLPVars(MemorySegment scip) {
        var mh$ = SCIPgetNNLPVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNLPVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPVarsNonlinearity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPVarsNonlinearity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsNonlinearity(SCIP *scip, int *nlcount)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPVarsNonlinearity$descriptor() {
        return SCIPgetNLPVarsNonlinearity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsNonlinearity(SCIP *scip, int *nlcount)
     * }
     */
    public static MethodHandle SCIPgetNLPVarsNonlinearity$handle() {
        return SCIPgetNLPVarsNonlinearity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsNonlinearity(SCIP *scip, int *nlcount)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsNonlinearity$address() {
        return SCIPgetNLPVarsNonlinearity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPVarsNonlinearity(SCIP *scip, int *nlcount)
     * }
     */
    public static int SCIPgetNLPVarsNonlinearity(MemorySegment scip, MemorySegment nlcount) {
        var mh$ = SCIPgetNLPVarsNonlinearity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPVarsNonlinearity", scip, nlcount);
            }
            return (int)mh$.invokeExact(scip, nlcount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPVarsLbDualsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPVarsLbDualsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsLbDualsol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPVarsLbDualsol$descriptor() {
        return SCIPgetNLPVarsLbDualsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsLbDualsol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPVarsLbDualsol$handle() {
        return SCIPgetNLPVarsLbDualsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsLbDualsol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsLbDualsol$address() {
        return SCIPgetNLPVarsLbDualsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsLbDualsol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsLbDualsol(MemorySegment scip) {
        var mh$ = SCIPgetNLPVarsLbDualsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPVarsLbDualsol", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPVarsUbDualsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPVarsUbDualsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsUbDualsol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPVarsUbDualsol$descriptor() {
        return SCIPgetNLPVarsUbDualsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsUbDualsol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPVarsUbDualsol$handle() {
        return SCIPgetNLPVarsUbDualsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsUbDualsol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsUbDualsol$address() {
        return SCIPgetNLPVarsUbDualsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double *SCIPgetNLPVarsUbDualsol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPVarsUbDualsol(MemorySegment scip) {
        var mh$ = SCIPgetNLPVarsUbDualsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPVarsUbDualsol", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPNlRowsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPNlRowsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsData(SCIP *scip, SCIP_NLROW ***nlrows, int *nnlrows)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPNlRowsData$descriptor() {
        return SCIPgetNLPNlRowsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsData(SCIP *scip, SCIP_NLROW ***nlrows, int *nnlrows)
     * }
     */
    public static MethodHandle SCIPgetNLPNlRowsData$handle() {
        return SCIPgetNLPNlRowsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsData(SCIP *scip, SCIP_NLROW ***nlrows, int *nnlrows)
     * }
     */
    public static MemorySegment SCIPgetNLPNlRowsData$address() {
        return SCIPgetNLPNlRowsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsData(SCIP *scip, SCIP_NLROW ***nlrows, int *nnlrows)
     * }
     */
    public static int SCIPgetNLPNlRowsData(MemorySegment scip, MemorySegment nlrows, MemorySegment nnlrows) {
        var mh$ = SCIPgetNLPNlRowsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPNlRowsData", scip, nlrows, nnlrows);
            }
            return (int)mh$.invokeExact(scip, nlrows, nnlrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPNlRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPNlRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLROW **SCIPgetNLPNlRows(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPNlRows$descriptor() {
        return SCIPgetNLPNlRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLROW **SCIPgetNLPNlRows(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPNlRows$handle() {
        return SCIPgetNLPNlRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLROW **SCIPgetNLPNlRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPNlRows$address() {
        return SCIPgetNLPNlRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLROW **SCIPgetNLPNlRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPNlRows(MemorySegment scip) {
        var mh$ = SCIPgetNLPNlRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPNlRows", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNLPNlRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNLPNlRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNLPNlRows(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNLPNlRows$descriptor() {
        return SCIPgetNNLPNlRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNLPNlRows(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNLPNlRows$handle() {
        return SCIPgetNNLPNlRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNLPNlRows(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNLPNlRows$address() {
        return SCIPgetNNLPNlRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNLPNlRows(SCIP *scip)
     * }
     */
    public static int SCIPgetNNLPNlRows(MemorySegment scip) {
        var mh$ = SCIPgetNNLPNlRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNLPNlRows", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPNlRowsStat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPNlRowsStat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsStat(SCIP *scip, int *nlinear, int *nconvexineq, int *nnonconvexineq, int *nnonlineareq)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPNlRowsStat$descriptor() {
        return SCIPgetNLPNlRowsStat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsStat(SCIP *scip, int *nlinear, int *nconvexineq, int *nnonconvexineq, int *nnonlineareq)
     * }
     */
    public static MethodHandle SCIPgetNLPNlRowsStat$handle() {
        return SCIPgetNLPNlRowsStat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsStat(SCIP *scip, int *nlinear, int *nconvexineq, int *nnonconvexineq, int *nnonlineareq)
     * }
     */
    public static MemorySegment SCIPgetNLPNlRowsStat$address() {
        return SCIPgetNLPNlRowsStat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPNlRowsStat(SCIP *scip, int *nlinear, int *nconvexineq, int *nnonconvexineq, int *nnonlineareq)
     * }
     */
    public static int SCIPgetNLPNlRowsStat(MemorySegment scip, MemorySegment nlinear, MemorySegment nconvexineq, MemorySegment nnonconvexineq, MemorySegment nnonlineareq) {
        var mh$ = SCIPgetNLPNlRowsStat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPNlRowsStat", scip, nlinear, nconvexineq, nnonconvexineq, nnonlineareq);
            }
            return (int)mh$.invokeExact(scip, nlinear, nconvexineq, nnonconvexineq, nnonlineareq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPaddNlRow$descriptor() {
        return SCIPaddNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPaddNlRow$handle() {
        return SCIPaddNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPaddNlRow$address() {
        return SCIPaddNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPaddNlRow(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPaddNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNlRow", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPdelNlRow$descriptor() {
        return SCIPdelNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPdelNlRow$handle() {
        return SCIPdelNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPdelNlRow$address() {
        return SCIPdelNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPdelNlRow(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPdelNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelNlRow", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPflushNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPflushNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushNLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPflushNLP$descriptor() {
        return SCIPflushNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushNLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPflushNLP$handle() {
        return SCIPflushNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushNLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPflushNLP$address() {
        return SCIPflushNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflushNLP(SCIP *scip)
     * }
     */
    public static int SCIPflushNLP(MemorySegment scip) {
        var mh$ = SCIPflushNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPflushNLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNLPInitialGuess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNLPInitialGuess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuess(SCIP *scip, double *initialguess)
     * }
     */
    public static FunctionDescriptor SCIPsetNLPInitialGuess$descriptor() {
        return SCIPsetNLPInitialGuess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuess(SCIP *scip, double *initialguess)
     * }
     */
    public static MethodHandle SCIPsetNLPInitialGuess$handle() {
        return SCIPsetNLPInitialGuess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuess(SCIP *scip, double *initialguess)
     * }
     */
    public static MemorySegment SCIPsetNLPInitialGuess$address() {
        return SCIPsetNLPInitialGuess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuess(SCIP *scip, double *initialguess)
     * }
     */
    public static int SCIPsetNLPInitialGuess(MemorySegment scip, MemorySegment initialguess) {
        var mh$ = SCIPsetNLPInitialGuess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNLPInitialGuess", scip, initialguess);
            }
            return (int)mh$.invokeExact(scip, initialguess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNLPInitialGuessSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNLPInitialGuessSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuessSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPsetNLPInitialGuessSol$descriptor() {
        return SCIPsetNLPInitialGuessSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuessSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPsetNLPInitialGuessSol$handle() {
        return SCIPsetNLPInitialGuessSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuessSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPsetNLPInitialGuessSol$address() {
        return SCIPsetNLPInitialGuessSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNLPInitialGuessSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPsetNLPInitialGuessSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPsetNLPInitialGuessSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNLPInitialGuessSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveNLPParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            SCIP_NlpParam.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveNLPParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNLPParam(SCIP *scip, SCIP_NLPPARAM param)
     * }
     */
    public static FunctionDescriptor SCIPsolveNLPParam$descriptor() {
        return SCIPsolveNLPParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNLPParam(SCIP *scip, SCIP_NLPPARAM param)
     * }
     */
    public static MethodHandle SCIPsolveNLPParam$handle() {
        return SCIPsolveNLPParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNLPParam(SCIP *scip, SCIP_NLPPARAM param)
     * }
     */
    public static MemorySegment SCIPsolveNLPParam$address() {
        return SCIPsolveNLPParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNLPParam(SCIP *scip, SCIP_NLPPARAM param)
     * }
     */
    public static int SCIPsolveNLPParam(MemorySegment scip, MemorySegment param) {
        var mh$ = SCIPsolveNLPParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveNLPParam", scip, param);
            }
            return (int)mh$.invokeExact(scip, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPSolstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPSolstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNLPSolstat(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPSolstat$descriptor() {
        return SCIPgetNLPSolstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNLPSolstat(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPSolstat$handle() {
        return SCIPgetNLPSolstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNLPSolstat(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPSolstat$address() {
        return SCIPgetNLPSolstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNLPSolstat(SCIP *scip)
     * }
     */
    public static int SCIPgetNLPSolstat(MemorySegment scip) {
        var mh$ = SCIPgetNLPSolstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPSolstat", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPTermstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPTermstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNLPTermstat(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPTermstat$descriptor() {
        return SCIPgetNLPTermstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNLPTermstat(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPTermstat$handle() {
        return SCIPgetNLPTermstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNLPTermstat(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPTermstat$address() {
        return SCIPgetNLPTermstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNLPTermstat(SCIP *scip)
     * }
     */
    public static int SCIPgetNLPTermstat(MemorySegment scip) {
        var mh$ = SCIPgetNLPTermstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPTermstat", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPStatistics(SCIP *scip, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPStatistics$descriptor() {
        return SCIPgetNLPStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPStatistics(SCIP *scip, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static MethodHandle SCIPgetNLPStatistics$handle() {
        return SCIPgetNLPStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPStatistics(SCIP *scip, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static MemorySegment SCIPgetNLPStatistics$address() {
        return SCIPgetNLPStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPStatistics(SCIP *scip, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static int SCIPgetNLPStatistics(MemorySegment scip, MemorySegment statistics) {
        var mh$ = SCIPgetNLPStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPStatistics", scip, statistics);
            }
            return (int)mh$.invokeExact(scip, statistics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPObjval {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPObjval");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetNLPObjval(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPObjval$descriptor() {
        return SCIPgetNLPObjval.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetNLPObjval(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPObjval$handle() {
        return SCIPgetNLPObjval.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetNLPObjval(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPObjval$address() {
        return SCIPgetNLPObjval.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetNLPObjval(SCIP *scip)
     * }
     */
    public static double SCIPgetNLPObjval(MemorySegment scip) {
        var mh$ = SCIPgetNLPObjval.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPObjval", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasNLPSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasNLPSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPhasNLPSolution(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPhasNLPSolution$descriptor() {
        return SCIPhasNLPSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPhasNLPSolution(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPhasNLPSolution$handle() {
        return SCIPhasNLPSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPhasNLPSolution(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPhasNLPSolution$address() {
        return SCIPhasNLPSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPhasNLPSolution(SCIP *scip)
     * }
     */
    public static int SCIPhasNLPSolution(MemorySegment scip) {
        var mh$ = SCIPhasNLPSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasNLPSolution", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPFracVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPFracVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPFracVars(SCIP *scip, SCIP_VAR ***fracvars, double **fracvarssol, double **fracvarsfrac, int *nfracvars, int *npriofracvars)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPFracVars$descriptor() {
        return SCIPgetNLPFracVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPFracVars(SCIP *scip, SCIP_VAR ***fracvars, double **fracvarssol, double **fracvarsfrac, int *nfracvars, int *npriofracvars)
     * }
     */
    public static MethodHandle SCIPgetNLPFracVars$handle() {
        return SCIPgetNLPFracVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPFracVars(SCIP *scip, SCIP_VAR ***fracvars, double **fracvarssol, double **fracvarsfrac, int *nfracvars, int *npriofracvars)
     * }
     */
    public static MemorySegment SCIPgetNLPFracVars$address() {
        return SCIPgetNLPFracVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPFracVars(SCIP *scip, SCIP_VAR ***fracvars, double **fracvarssol, double **fracvarsfrac, int *nfracvars, int *npriofracvars)
     * }
     */
    public static int SCIPgetNLPFracVars(MemorySegment scip, MemorySegment fracvars, MemorySegment fracvarssol, MemorySegment fracvarsfrac, MemorySegment nfracvars, MemorySegment npriofracvars) {
        var mh$ = SCIPgetNLPFracVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPFracVars", scip, fracvars, fracvarssol, fracvarsfrac, nfracvars, npriofracvars);
            }
            return (int)mh$.invokeExact(scip, fracvars, fracvarssol, fracvarsfrac, nfracvars, npriofracvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteNLP(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPwriteNLP$descriptor() {
        return SCIPwriteNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteNLP(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPwriteNLP$handle() {
        return SCIPwriteNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteNLP(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPwriteNLP$address() {
        return SCIPwriteNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteNLP(SCIP *scip, const char *filename)
     * }
     */
    public static int SCIPwriteNLP(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPwriteNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteNLP", scip, filename);
            }
            return (int)mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPI");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPI(SCIP *scip, SCIP_NLPI **nlpi, SCIP_NLPIPROBLEM **nlpiproblem)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPI$descriptor() {
        return SCIPgetNLPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPI(SCIP *scip, SCIP_NLPI **nlpi, SCIP_NLPIPROBLEM **nlpiproblem)
     * }
     */
    public static MethodHandle SCIPgetNLPI$handle() {
        return SCIPgetNLPI.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPI(SCIP *scip, SCIP_NLPI **nlpi, SCIP_NLPIPROBLEM **nlpiproblem)
     * }
     */
    public static MemorySegment SCIPgetNLPI$address() {
        return SCIPgetNLPI.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNLPI(SCIP *scip, SCIP_NLPI **nlpi, SCIP_NLPIPROBLEM **nlpiproblem)
     * }
     */
    public static int SCIPgetNLPI(MemorySegment scip, MemorySegment nlpi, MemorySegment nlpiproblem) {
        var mh$ = SCIPgetNLPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPI", scip, nlpi, nlpiproblem);
            }
            return (int)mh$.invokeExact(scip, nlpi, nlpiproblem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartDiveNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartDiveNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDiveNLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstartDiveNLP$descriptor() {
        return SCIPstartDiveNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDiveNLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstartDiveNLP$handle() {
        return SCIPstartDiveNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDiveNLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstartDiveNLP$address() {
        return SCIPstartDiveNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartDiveNLP(SCIP *scip)
     * }
     */
    public static int SCIPstartDiveNLP(MemorySegment scip) {
        var mh$ = SCIPstartDiveNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartDiveNLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPendDiveNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPendDiveNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDiveNLP(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPendDiveNLP$descriptor() {
        return SCIPendDiveNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDiveNLP(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPendDiveNLP$handle() {
        return SCIPendDiveNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDiveNLP(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPendDiveNLP$address() {
        return SCIPendDiveNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendDiveNLP(SCIP *scip)
     * }
     */
    public static int SCIPendDiveNLP(MemorySegment scip) {
        var mh$ = SCIPendDiveNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPendDiveNLP", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarObjDiveNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarObjDiveNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDiveNLP(SCIP *scip, SCIP_VAR *var, double coef)
     * }
     */
    public static FunctionDescriptor SCIPchgVarObjDiveNLP$descriptor() {
        return SCIPchgVarObjDiveNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDiveNLP(SCIP *scip, SCIP_VAR *var, double coef)
     * }
     */
    public static MethodHandle SCIPchgVarObjDiveNLP$handle() {
        return SCIPchgVarObjDiveNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDiveNLP(SCIP *scip, SCIP_VAR *var, double coef)
     * }
     */
    public static MemorySegment SCIPchgVarObjDiveNLP$address() {
        return SCIPchgVarObjDiveNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjDiveNLP(SCIP *scip, SCIP_VAR *var, double coef)
     * }
     */
    public static int SCIPchgVarObjDiveNLP(MemorySegment scip, MemorySegment var_, double coef) {
        var mh$ = SCIPchgVarObjDiveNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarObjDiveNLP", scip, var_, coef);
            }
            return (int)mh$.invokeExact(scip, var_, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarBoundsDiveNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarBoundsDiveNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBoundsDiveNLP(SCIP *scip, SCIP_VAR *var, double lb, double ub)
     * }
     */
    public static FunctionDescriptor SCIPchgVarBoundsDiveNLP$descriptor() {
        return SCIPchgVarBoundsDiveNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBoundsDiveNLP(SCIP *scip, SCIP_VAR *var, double lb, double ub)
     * }
     */
    public static MethodHandle SCIPchgVarBoundsDiveNLP$handle() {
        return SCIPchgVarBoundsDiveNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBoundsDiveNLP(SCIP *scip, SCIP_VAR *var, double lb, double ub)
     * }
     */
    public static MemorySegment SCIPchgVarBoundsDiveNLP$address() {
        return SCIPchgVarBoundsDiveNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarBoundsDiveNLP(SCIP *scip, SCIP_VAR *var, double lb, double ub)
     * }
     */
    public static int SCIPchgVarBoundsDiveNLP(MemorySegment scip, MemorySegment var_, double lb, double ub) {
        var mh$ = SCIPchgVarBoundsDiveNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarBoundsDiveNLP", scip, var_, lb, ub);
            }
            return (int)mh$.invokeExact(scip, var_, lb, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarsBoundsDiveNLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarsBoundsDiveNLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarsBoundsDiveNLP(SCIP *scip, int nvars, SCIP_VAR **vars, double *lbs, double *ubs)
     * }
     */
    public static FunctionDescriptor SCIPchgVarsBoundsDiveNLP$descriptor() {
        return SCIPchgVarsBoundsDiveNLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarsBoundsDiveNLP(SCIP *scip, int nvars, SCIP_VAR **vars, double *lbs, double *ubs)
     * }
     */
    public static MethodHandle SCIPchgVarsBoundsDiveNLP$handle() {
        return SCIPchgVarsBoundsDiveNLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarsBoundsDiveNLP(SCIP *scip, int nvars, SCIP_VAR **vars, double *lbs, double *ubs)
     * }
     */
    public static MemorySegment SCIPchgVarsBoundsDiveNLP$address() {
        return SCIPchgVarsBoundsDiveNLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarsBoundsDiveNLP(SCIP *scip, int nvars, SCIP_VAR **vars, double *lbs, double *ubs)
     * }
     */
    public static int SCIPchgVarsBoundsDiveNLP(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment lbs, MemorySegment ubs) {
        var mh$ = SCIPchgVarsBoundsDiveNLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarsBoundsDiveNLP", scip, nvars, vars, lbs, ubs);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, lbs, ubs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double constant, int nlinvars, SCIP_VAR **linvars, double *lincoefs, SCIP_EXPR *expr, double lhs, double rhs, SCIP_EXPRCURV curvature)
     * }
     */
    public static FunctionDescriptor SCIPcreateNlRow$descriptor() {
        return SCIPcreateNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double constant, int nlinvars, SCIP_VAR **linvars, double *lincoefs, SCIP_EXPR *expr, double lhs, double rhs, SCIP_EXPRCURV curvature)
     * }
     */
    public static MethodHandle SCIPcreateNlRow$handle() {
        return SCIPcreateNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double constant, int nlinvars, SCIP_VAR **linvars, double *lincoefs, SCIP_EXPR *expr, double lhs, double rhs, SCIP_EXPRCURV curvature)
     * }
     */
    public static MemorySegment SCIPcreateNlRow$address() {
        return SCIPcreateNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double constant, int nlinvars, SCIP_VAR **linvars, double *lincoefs, SCIP_EXPR *expr, double lhs, double rhs, SCIP_EXPRCURV curvature)
     * }
     */
    public static int SCIPcreateNlRow(MemorySegment scip, MemorySegment nlrow, MemorySegment name, double constant, int nlinvars, MemorySegment linvars, MemorySegment lincoefs, MemorySegment expr, double lhs, double rhs, int curvature) {
        var mh$ = SCIPcreateNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateNlRow", scip, nlrow, name, constant, nlinvars, linvars, lincoefs, expr, lhs, rhs, curvature);
            }
            return (int)mh$.invokeExact(scip, nlrow, name, constant, nlinvars, linvars, lincoefs, expr, lhs, rhs, curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateEmptyNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateEmptyNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double lhs, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPcreateEmptyNlRow$descriptor() {
        return SCIPcreateEmptyNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double lhs, double rhs)
     * }
     */
    public static MethodHandle SCIPcreateEmptyNlRow$handle() {
        return SCIPcreateEmptyNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double lhs, double rhs)
     * }
     */
    public static MemorySegment SCIPcreateEmptyNlRow$address() {
        return SCIPcreateEmptyNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateEmptyNlRow(SCIP *scip, SCIP_NLROW **nlrow, const char *name, double lhs, double rhs)
     * }
     */
    public static int SCIPcreateEmptyNlRow(MemorySegment scip, MemorySegment nlrow, MemorySegment name, double lhs, double rhs) {
        var mh$ = SCIPcreateEmptyNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateEmptyNlRow", scip, nlrow, name, lhs, rhs);
            }
            return (int)mh$.invokeExact(scip, nlrow, name, lhs, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateNlRowFromRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateNlRowFromRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRowFromRow(SCIP *scip, SCIP_NLROW **nlrow, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPcreateNlRowFromRow$descriptor() {
        return SCIPcreateNlRowFromRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRowFromRow(SCIP *scip, SCIP_NLROW **nlrow, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPcreateNlRowFromRow$handle() {
        return SCIPcreateNlRowFromRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRowFromRow(SCIP *scip, SCIP_NLROW **nlrow, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPcreateNlRowFromRow$address() {
        return SCIPcreateNlRowFromRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlRowFromRow(SCIP *scip, SCIP_NLROW **nlrow, SCIP_ROW *row)
     * }
     */
    public static int SCIPcreateNlRowFromRow(MemorySegment scip, MemorySegment nlrow, MemorySegment row) {
        var mh$ = SCIPcreateNlRowFromRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateNlRowFromRow", scip, nlrow, row);
            }
            return (int)mh$.invokeExact(scip, nlrow, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPcaptureNlRow$descriptor() {
        return SCIPcaptureNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPcaptureNlRow$handle() {
        return SCIPcaptureNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPcaptureNlRow$address() {
        return SCIPcaptureNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureNlRow(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPcaptureNlRow(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPcaptureNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureNlRow", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseNlRow(SCIP *scip, SCIP_NLROW **nlrow)
     * }
     */
    public static FunctionDescriptor SCIPreleaseNlRow$descriptor() {
        return SCIPreleaseNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseNlRow(SCIP *scip, SCIP_NLROW **nlrow)
     * }
     */
    public static MethodHandle SCIPreleaseNlRow$handle() {
        return SCIPreleaseNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseNlRow(SCIP *scip, SCIP_NLROW **nlrow)
     * }
     */
    public static MemorySegment SCIPreleaseNlRow$address() {
        return SCIPreleaseNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseNlRow(SCIP *scip, SCIP_NLROW **nlrow)
     * }
     */
    public static int SCIPreleaseNlRow(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPreleaseNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseNlRow", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlRowLhs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlRowLhs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLhs(SCIP *scip, SCIP_NLROW *nlrow, double lhs)
     * }
     */
    public static FunctionDescriptor SCIPchgNlRowLhs$descriptor() {
        return SCIPchgNlRowLhs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLhs(SCIP *scip, SCIP_NLROW *nlrow, double lhs)
     * }
     */
    public static MethodHandle SCIPchgNlRowLhs$handle() {
        return SCIPchgNlRowLhs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLhs(SCIP *scip, SCIP_NLROW *nlrow, double lhs)
     * }
     */
    public static MemorySegment SCIPchgNlRowLhs$address() {
        return SCIPchgNlRowLhs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLhs(SCIP *scip, SCIP_NLROW *nlrow, double lhs)
     * }
     */
    public static int SCIPchgNlRowLhs(MemorySegment scip, MemorySegment nlrow, double lhs) {
        var mh$ = SCIPchgNlRowLhs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlRowLhs", scip, nlrow, lhs);
            }
            return (int)mh$.invokeExact(scip, nlrow, lhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlRowRhs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlRowRhs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowRhs(SCIP *scip, SCIP_NLROW *nlrow, double rhs)
     * }
     */
    public static FunctionDescriptor SCIPchgNlRowRhs$descriptor() {
        return SCIPchgNlRowRhs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowRhs(SCIP *scip, SCIP_NLROW *nlrow, double rhs)
     * }
     */
    public static MethodHandle SCIPchgNlRowRhs$handle() {
        return SCIPchgNlRowRhs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowRhs(SCIP *scip, SCIP_NLROW *nlrow, double rhs)
     * }
     */
    public static MemorySegment SCIPchgNlRowRhs$address() {
        return SCIPchgNlRowRhs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowRhs(SCIP *scip, SCIP_NLROW *nlrow, double rhs)
     * }
     */
    public static int SCIPchgNlRowRhs(MemorySegment scip, MemorySegment nlrow, double rhs) {
        var mh$ = SCIPchgNlRowRhs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlRowRhs", scip, nlrow, rhs);
            }
            return (int)mh$.invokeExact(scip, nlrow, rhs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlRowConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlRowConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowConstant(SCIP *scip, SCIP_NLROW *nlrow, double constant)
     * }
     */
    public static FunctionDescriptor SCIPchgNlRowConstant$descriptor() {
        return SCIPchgNlRowConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowConstant(SCIP *scip, SCIP_NLROW *nlrow, double constant)
     * }
     */
    public static MethodHandle SCIPchgNlRowConstant$handle() {
        return SCIPchgNlRowConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowConstant(SCIP *scip, SCIP_NLROW *nlrow, double constant)
     * }
     */
    public static MemorySegment SCIPchgNlRowConstant$address() {
        return SCIPchgNlRowConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowConstant(SCIP *scip, SCIP_NLROW *nlrow, double constant)
     * }
     */
    public static int SCIPchgNlRowConstant(MemorySegment scip, MemorySegment nlrow, double constant) {
        var mh$ = SCIPchgNlRowConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlRowConstant", scip, nlrow, constant);
            }
            return (int)mh$.invokeExact(scip, nlrow, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNlRowCurvature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNlRowCurvature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetNlRowCurvature(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPRCURV curvature)
     * }
     */
    public static FunctionDescriptor SCIPsetNlRowCurvature$descriptor() {
        return SCIPsetNlRowCurvature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetNlRowCurvature(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPRCURV curvature)
     * }
     */
    public static MethodHandle SCIPsetNlRowCurvature$handle() {
        return SCIPsetNlRowCurvature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetNlRowCurvature(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPRCURV curvature)
     * }
     */
    public static MemorySegment SCIPsetNlRowCurvature$address() {
        return SCIPsetNlRowCurvature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetNlRowCurvature(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPRCURV curvature)
     * }
     */
    public static void SCIPsetNlRowCurvature(MemorySegment scip, MemorySegment nlrow, int curvature) {
        var mh$ = SCIPsetNlRowCurvature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNlRowCurvature", scip, nlrow, curvature);
            }
            mh$.invokeExact(scip, nlrow, curvature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddLinearCoefToNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddLinearCoefToNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefToNlRow(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPaddLinearCoefToNlRow$descriptor() {
        return SCIPaddLinearCoefToNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefToNlRow(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPaddLinearCoefToNlRow$handle() {
        return SCIPaddLinearCoefToNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefToNlRow(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPaddLinearCoefToNlRow$address() {
        return SCIPaddLinearCoefToNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefToNlRow(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPaddLinearCoefToNlRow(MemorySegment scip, MemorySegment nlrow, MemorySegment var_, double val) {
        var mh$ = SCIPaddLinearCoefToNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddLinearCoefToNlRow", scip, nlrow, var_, val);
            }
            return (int)mh$.invokeExact(scip, nlrow, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddLinearCoefsToNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddLinearCoefsToNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefsToNlRow(SCIP *scip, SCIP_NLROW *nlrow, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPaddLinearCoefsToNlRow$descriptor() {
        return SCIPaddLinearCoefsToNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefsToNlRow(SCIP *scip, SCIP_NLROW *nlrow, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MethodHandle SCIPaddLinearCoefsToNlRow$handle() {
        return SCIPaddLinearCoefsToNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefsToNlRow(SCIP *scip, SCIP_NLROW *nlrow, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MemorySegment SCIPaddLinearCoefsToNlRow$address() {
        return SCIPaddLinearCoefsToNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLinearCoefsToNlRow(SCIP *scip, SCIP_NLROW *nlrow, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static int SCIPaddLinearCoefsToNlRow(MemorySegment scip, MemorySegment nlrow, int nvars, MemorySegment vars, MemorySegment vals) {
        var mh$ = SCIPaddLinearCoefsToNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddLinearCoefsToNlRow", scip, nlrow, nvars, vars, vals);
            }
            return (int)mh$.invokeExact(scip, nlrow, nvars, vars, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlRowLinearCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlRowLinearCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLinearCoef(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double coef)
     * }
     */
    public static FunctionDescriptor SCIPchgNlRowLinearCoef$descriptor() {
        return SCIPchgNlRowLinearCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLinearCoef(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double coef)
     * }
     */
    public static MethodHandle SCIPchgNlRowLinearCoef$handle() {
        return SCIPchgNlRowLinearCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLinearCoef(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double coef)
     * }
     */
    public static MemorySegment SCIPchgNlRowLinearCoef$address() {
        return SCIPchgNlRowLinearCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlRowLinearCoef(SCIP *scip, SCIP_NLROW *nlrow, SCIP_VAR *var, double coef)
     * }
     */
    public static int SCIPchgNlRowLinearCoef(MemorySegment scip, MemorySegment nlrow, MemorySegment var_, double coef) {
        var mh$ = SCIPchgNlRowLinearCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlRowLinearCoef", scip, nlrow, var_, coef);
            }
            return (int)mh$.invokeExact(scip, nlrow, var_, coef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNlRowExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNlRowExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlRowExpr(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPsetNlRowExpr$descriptor() {
        return SCIPsetNlRowExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlRowExpr(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPsetNlRowExpr$handle() {
        return SCIPsetNlRowExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlRowExpr(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPsetNlRowExpr$address() {
        return SCIPsetNlRowExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlRowExpr(SCIP *scip, SCIP_NLROW *nlrow, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPsetNlRowExpr(MemorySegment scip, MemorySegment nlrow, MemorySegment expr) {
        var mh$ = SCIPsetNlRowExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNlRowExpr", scip, nlrow, expr);
            }
            return (int)mh$.invokeExact(scip, nlrow, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcNlRowNLPActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcNlRowNLPActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPrecalcNlRowNLPActivity$descriptor() {
        return SCIPrecalcNlRowNLPActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPrecalcNlRowNLPActivity$handle() {
        return SCIPrecalcNlRowNLPActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPrecalcNlRowNLPActivity$address() {
        return SCIPrecalcNlRowNLPActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPrecalcNlRowNLPActivity(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPrecalcNlRowNLPActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcNlRowNLPActivity", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowNLPActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowNLPActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowNLPActivity$descriptor() {
        return SCIPgetNlRowNLPActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static MethodHandle SCIPgetNlRowNLPActivity$handle() {
        return SCIPgetNlRowNLPActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static MemorySegment SCIPgetNlRowNLPActivity$address() {
        return SCIPgetNlRowNLPActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static int SCIPgetNlRowNLPActivity(MemorySegment scip, MemorySegment nlrow, MemorySegment activity) {
        var mh$ = SCIPgetNlRowNLPActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowNLPActivity", scip, nlrow, activity);
            }
            return (int)mh$.invokeExact(scip, nlrow, activity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowNLPFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowNLPFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowNLPFeasibility$descriptor() {
        return SCIPgetNlRowNLPFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static MethodHandle SCIPgetNlRowNLPFeasibility$handle() {
        return SCIPgetNlRowNLPFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static MemorySegment SCIPgetNlRowNLPFeasibility$address() {
        return SCIPgetNlRowNLPFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowNLPFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static int SCIPgetNlRowNLPFeasibility(MemorySegment scip, MemorySegment nlrow, MemorySegment feasibility) {
        var mh$ = SCIPgetNlRowNLPFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowNLPFeasibility", scip, nlrow, feasibility);
            }
            return (int)mh$.invokeExact(scip, nlrow, feasibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcNlRowPseudoActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcNlRowPseudoActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPrecalcNlRowPseudoActivity$descriptor() {
        return SCIPrecalcNlRowPseudoActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPrecalcNlRowPseudoActivity$handle() {
        return SCIPrecalcNlRowPseudoActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPrecalcNlRowPseudoActivity$address() {
        return SCIPrecalcNlRowPseudoActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPrecalcNlRowPseudoActivity(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPrecalcNlRowPseudoActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcNlRowPseudoActivity", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowPseudoActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowPseudoActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow, double *pseudoactivity)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowPseudoActivity$descriptor() {
        return SCIPgetNlRowPseudoActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow, double *pseudoactivity)
     * }
     */
    public static MethodHandle SCIPgetNlRowPseudoActivity$handle() {
        return SCIPgetNlRowPseudoActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow, double *pseudoactivity)
     * }
     */
    public static MemorySegment SCIPgetNlRowPseudoActivity$address() {
        return SCIPgetNlRowPseudoActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoActivity(SCIP *scip, SCIP_NLROW *nlrow, double *pseudoactivity)
     * }
     */
    public static int SCIPgetNlRowPseudoActivity(MemorySegment scip, MemorySegment nlrow, MemorySegment pseudoactivity) {
        var mh$ = SCIPgetNlRowPseudoActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowPseudoActivity", scip, nlrow, pseudoactivity);
            }
            return (int)mh$.invokeExact(scip, nlrow, pseudoactivity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowPseudoFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowPseudoFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *pseudofeasibility)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowPseudoFeasibility$descriptor() {
        return SCIPgetNlRowPseudoFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *pseudofeasibility)
     * }
     */
    public static MethodHandle SCIPgetNlRowPseudoFeasibility$handle() {
        return SCIPgetNlRowPseudoFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *pseudofeasibility)
     * }
     */
    public static MemorySegment SCIPgetNlRowPseudoFeasibility$address() {
        return SCIPgetNlRowPseudoFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowPseudoFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *pseudofeasibility)
     * }
     */
    public static int SCIPgetNlRowPseudoFeasibility(MemorySegment scip, MemorySegment nlrow, MemorySegment pseudofeasibility) {
        var mh$ = SCIPgetNlRowPseudoFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowPseudoFeasibility", scip, nlrow, pseudofeasibility);
            }
            return (int)mh$.invokeExact(scip, nlrow, pseudofeasibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecalcNlRowActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecalcNlRowActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static FunctionDescriptor SCIPrecalcNlRowActivity$descriptor() {
        return SCIPrecalcNlRowActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MethodHandle SCIPrecalcNlRowActivity$handle() {
        return SCIPrecalcNlRowActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static MemorySegment SCIPrecalcNlRowActivity$address() {
        return SCIPrecalcNlRowActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecalcNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow)
     * }
     */
    public static int SCIPrecalcNlRowActivity(MemorySegment scip, MemorySegment nlrow) {
        var mh$ = SCIPrecalcNlRowActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecalcNlRowActivity", scip, nlrow);
            }
            return (int)mh$.invokeExact(scip, nlrow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowActivity$descriptor() {
        return SCIPgetNlRowActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static MethodHandle SCIPgetNlRowActivity$handle() {
        return SCIPgetNlRowActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static MemorySegment SCIPgetNlRowActivity$address() {
        return SCIPgetNlRowActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivity(SCIP *scip, SCIP_NLROW *nlrow, double *activity)
     * }
     */
    public static int SCIPgetNlRowActivity(MemorySegment scip, MemorySegment nlrow, MemorySegment activity) {
        var mh$ = SCIPgetNlRowActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowActivity", scip, nlrow, activity);
            }
            return (int)mh$.invokeExact(scip, nlrow, activity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowFeasibility$descriptor() {
        return SCIPgetNlRowFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static MethodHandle SCIPgetNlRowFeasibility$handle() {
        return SCIPgetNlRowFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static MemorySegment SCIPgetNlRowFeasibility$address() {
        return SCIPgetNlRowFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowFeasibility(SCIP *scip, SCIP_NLROW *nlrow, double *feasibility)
     * }
     */
    public static int SCIPgetNlRowFeasibility(MemorySegment scip, MemorySegment nlrow, MemorySegment feasibility) {
        var mh$ = SCIPgetNlRowFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowFeasibility", scip, nlrow, feasibility);
            }
            return (int)mh$.invokeExact(scip, nlrow, feasibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowSolActivity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowSolActivity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolActivity(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *activity)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowSolActivity$descriptor() {
        return SCIPgetNlRowSolActivity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolActivity(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *activity)
     * }
     */
    public static MethodHandle SCIPgetNlRowSolActivity$handle() {
        return SCIPgetNlRowSolActivity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolActivity(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *activity)
     * }
     */
    public static MemorySegment SCIPgetNlRowSolActivity$address() {
        return SCIPgetNlRowSolActivity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolActivity(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *activity)
     * }
     */
    public static int SCIPgetNlRowSolActivity(MemorySegment scip, MemorySegment nlrow, MemorySegment sol, MemorySegment activity) {
        var mh$ = SCIPgetNlRowSolActivity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowSolActivity", scip, nlrow, sol, activity);
            }
            return (int)mh$.invokeExact(scip, nlrow, sol, activity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowSolFeasibility {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowSolFeasibility");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolFeasibility(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *feasibility)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowSolFeasibility$descriptor() {
        return SCIPgetNlRowSolFeasibility.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolFeasibility(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *feasibility)
     * }
     */
    public static MethodHandle SCIPgetNlRowSolFeasibility$handle() {
        return SCIPgetNlRowSolFeasibility.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolFeasibility(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *feasibility)
     * }
     */
    public static MemorySegment SCIPgetNlRowSolFeasibility$address() {
        return SCIPgetNlRowSolFeasibility.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowSolFeasibility(SCIP *scip, SCIP_NLROW *nlrow, SCIP_SOL *sol, double *feasibility)
     * }
     */
    public static int SCIPgetNlRowSolFeasibility(MemorySegment scip, MemorySegment nlrow, MemorySegment sol, MemorySegment feasibility) {
        var mh$ = SCIPgetNlRowSolFeasibility.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowSolFeasibility", scip, nlrow, sol, feasibility);
            }
            return (int)mh$.invokeExact(scip, nlrow, sol, feasibility);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlRowActivityBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlRowActivityBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivityBounds(SCIP *scip, SCIP_NLROW *nlrow, double *minactivity, double *maxactivity)
     * }
     */
    public static FunctionDescriptor SCIPgetNlRowActivityBounds$descriptor() {
        return SCIPgetNlRowActivityBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivityBounds(SCIP *scip, SCIP_NLROW *nlrow, double *minactivity, double *maxactivity)
     * }
     */
    public static MethodHandle SCIPgetNlRowActivityBounds$handle() {
        return SCIPgetNlRowActivityBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivityBounds(SCIP *scip, SCIP_NLROW *nlrow, double *minactivity, double *maxactivity)
     * }
     */
    public static MemorySegment SCIPgetNlRowActivityBounds$address() {
        return SCIPgetNlRowActivityBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlRowActivityBounds(SCIP *scip, SCIP_NLROW *nlrow, double *minactivity, double *maxactivity)
     * }
     */
    public static int SCIPgetNlRowActivityBounds(MemorySegment scip, MemorySegment nlrow, MemorySegment minactivity, MemorySegment maxactivity) {
        var mh$ = SCIPgetNlRowActivityBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlRowActivityBounds", scip, nlrow, minactivity, maxactivity);
            }
            return (int)mh$.invokeExact(scip, nlrow, minactivity, maxactivity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintNlRow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintNlRow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNlRow(SCIP *scip, SCIP_NLROW *nlrow, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintNlRow$descriptor() {
        return SCIPprintNlRow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNlRow(SCIP *scip, SCIP_NLROW *nlrow, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintNlRow$handle() {
        return SCIPprintNlRow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNlRow(SCIP *scip, SCIP_NLROW *nlrow, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintNlRow$address() {
        return SCIPprintNlRow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNlRow(SCIP *scip, SCIP_NLROW *nlrow, FILE *file)
     * }
     */
    public static int SCIPprintNlRow(MemorySegment scip, MemorySegment nlrow, MemorySegment file) {
        var mh$ = SCIPprintNlRow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintNlRow", scip, nlrow, file);
            }
            return (int)mh$.invokeExact(scip, nlrow, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiComp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiComp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiComp(void *elem1, void *elem2)
     * }
     */
    public static FunctionDescriptor SCIPnlpiComp$descriptor() {
        return SCIPnlpiComp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiComp(void *elem1, void *elem2)
     * }
     */
    public static MethodHandle SCIPnlpiComp$handle() {
        return SCIPnlpiComp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiComp(void *elem1, void *elem2)
     * }
     */
    public static MemorySegment SCIPnlpiComp$address() {
        return SCIPnlpiComp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiComp(void *elem1, void *elem2)
     * }
     */
    public static int SCIPnlpiComp(MemorySegment elem1, MemorySegment elem2) {
        var mh$ = SCIPnlpiComp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiComp", elem1, elem2);
            }
            return (int)mh$.invokeExact(elem1, elem2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPIDATA *SCIPnlpiGetData(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetData$descriptor() {
        return SCIPnlpiGetData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPIDATA *SCIPnlpiGetData(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetData$handle() {
        return SCIPnlpiGetData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPIDATA *SCIPnlpiGetData(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetData$address() {
        return SCIPnlpiGetData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPIDATA *SCIPnlpiGetData(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetData(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetData", nlpi);
            }
            return (MemorySegment)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetName(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetName$descriptor() {
        return SCIPnlpiGetName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetName(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetName$handle() {
        return SCIPnlpiGetName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetName(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetName$address() {
        return SCIPnlpiGetName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnlpiGetName(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetName(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetName", nlpi);
            }
            return (MemorySegment)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetDesc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetDesc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetDesc(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetDesc$descriptor() {
        return SCIPnlpiGetDesc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetDesc(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetDesc$handle() {
        return SCIPnlpiGetDesc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPnlpiGetDesc(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetDesc$address() {
        return SCIPnlpiGetDesc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPnlpiGetDesc(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetDesc(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetDesc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetDesc", nlpi);
            }
            return (MemorySegment)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiGetPriority(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetPriority$descriptor() {
        return SCIPnlpiGetPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiGetPriority(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetPriority$handle() {
        return SCIPnlpiGetPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiGetPriority(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetPriority$address() {
        return SCIPnlpiGetPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiGetPriority(SCIP_NLPI *nlpi)
     * }
     */
    public static int SCIPnlpiGetPriority(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetPriority", nlpi);
            }
            return (int)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetNProblems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetNProblems");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNProblems(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetNProblems$descriptor() {
        return SCIPnlpiGetNProblems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNProblems(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetNProblems$handle() {
        return SCIPnlpiGetNProblems.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNProblems(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetNProblems$address() {
        return SCIPnlpiGetNProblems.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiGetNProblems(SCIP_NLPI *nlpi)
     * }
     */
    public static int SCIPnlpiGetNProblems(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetNProblems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetNProblems", nlpi);
            }
            return (int)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetProblemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetProblemTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnlpiGetProblemTime(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetProblemTime$descriptor() {
        return SCIPnlpiGetProblemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnlpiGetProblemTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetProblemTime$handle() {
        return SCIPnlpiGetProblemTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnlpiGetProblemTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetProblemTime$address() {
        return SCIPnlpiGetProblemTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnlpiGetProblemTime(SCIP_NLPI *nlpi)
     * }
     */
    public static double SCIPnlpiGetProblemTime(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetProblemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetProblemTime", nlpi);
            }
            return (double)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetNSolves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetNSolves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolves(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetNSolves$descriptor() {
        return SCIPnlpiGetNSolves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolves(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetNSolves$handle() {
        return SCIPnlpiGetNSolves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolves(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetNSolves$address() {
        return SCIPnlpiGetNSolves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolves(SCIP_NLPI *nlpi)
     * }
     */
    public static int SCIPnlpiGetNSolves(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetNSolves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetNSolves", nlpi);
            }
            return (int)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetSolveTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetSolveTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnlpiGetSolveTime(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetSolveTime$descriptor() {
        return SCIPnlpiGetSolveTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnlpiGetSolveTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetSolveTime$handle() {
        return SCIPnlpiGetSolveTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnlpiGetSolveTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetSolveTime$address() {
        return SCIPnlpiGetSolveTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnlpiGetSolveTime(SCIP_NLPI *nlpi)
     * }
     */
    public static double SCIPnlpiGetSolveTime(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetSolveTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetSolveTime", nlpi);
            }
            return (double)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetEvalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetEvalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPnlpiGetEvalTime(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetEvalTime$descriptor() {
        return SCIPnlpiGetEvalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPnlpiGetEvalTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetEvalTime$handle() {
        return SCIPnlpiGetEvalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPnlpiGetEvalTime(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetEvalTime$address() {
        return SCIPnlpiGetEvalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPnlpiGetEvalTime(SCIP_NLPI *nlpi)
     * }
     */
    public static double SCIPnlpiGetEvalTime(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetEvalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetEvalTime", nlpi);
            }
            return (double)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetNIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetNIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPnlpiGetNIterations(SCIP_NLPI *nlpi)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetNIterations$descriptor() {
        return SCIPnlpiGetNIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPnlpiGetNIterations(SCIP_NLPI *nlpi)
     * }
     */
    public static MethodHandle SCIPnlpiGetNIterations$handle() {
        return SCIPnlpiGetNIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPnlpiGetNIterations(SCIP_NLPI *nlpi)
     * }
     */
    public static MemorySegment SCIPnlpiGetNIterations$address() {
        return SCIPnlpiGetNIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPnlpiGetNIterations(SCIP_NLPI *nlpi)
     * }
     */
    public static long SCIPnlpiGetNIterations(MemorySegment nlpi) {
        var mh$ = SCIPnlpiGetNIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetNIterations", nlpi);
            }
            return (long)mh$.invokeExact(nlpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetNTermStat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetNTermStat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNTermStat(SCIP_NLPI *nlpi, SCIP_NLPTERMSTAT termstatus)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetNTermStat$descriptor() {
        return SCIPnlpiGetNTermStat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNTermStat(SCIP_NLPI *nlpi, SCIP_NLPTERMSTAT termstatus)
     * }
     */
    public static MethodHandle SCIPnlpiGetNTermStat$handle() {
        return SCIPnlpiGetNTermStat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNTermStat(SCIP_NLPI *nlpi, SCIP_NLPTERMSTAT termstatus)
     * }
     */
    public static MemorySegment SCIPnlpiGetNTermStat$address() {
        return SCIPnlpiGetNTermStat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiGetNTermStat(SCIP_NLPI *nlpi, SCIP_NLPTERMSTAT termstatus)
     * }
     */
    public static int SCIPnlpiGetNTermStat(MemorySegment nlpi, int termstatus) {
        var mh$ = SCIPnlpiGetNTermStat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetNTermStat", nlpi, termstatus);
            }
            return (int)mh$.invokeExact(nlpi, termstatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiGetNSolStat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiGetNSolStat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolStat(SCIP_NLPI *nlpi, SCIP_NLPSOLSTAT solstatus)
     * }
     */
    public static FunctionDescriptor SCIPnlpiGetNSolStat$descriptor() {
        return SCIPnlpiGetNSolStat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolStat(SCIP_NLPI *nlpi, SCIP_NLPSOLSTAT solstatus)
     * }
     */
    public static MethodHandle SCIPnlpiGetNSolStat$handle() {
        return SCIPnlpiGetNSolStat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolStat(SCIP_NLPI *nlpi, SCIP_NLPSOLSTAT solstatus)
     * }
     */
    public static MemorySegment SCIPnlpiGetNSolStat$address() {
        return SCIPnlpiGetNSolStat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPnlpiGetNSolStat(SCIP_NLPI *nlpi, SCIP_NLPSOLSTAT solstatus)
     * }
     */
    public static int SCIPnlpiGetNSolStat(MemorySegment nlpi, int solstatus) {
        var mh$ = SCIPnlpiGetNSolStat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiGetNSolStat", nlpi, solstatus);
            }
            return (int)mh$.invokeExact(nlpi, solstatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnlpiMergeStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnlpiMergeStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPnlpiMergeStatistics(SCIP_NLPI *targetnlpi, SCIP_NLPI *sourcenlpi, unsigned int reset)
     * }
     */
    public static FunctionDescriptor SCIPnlpiMergeStatistics$descriptor() {
        return SCIPnlpiMergeStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPnlpiMergeStatistics(SCIP_NLPI *targetnlpi, SCIP_NLPI *sourcenlpi, unsigned int reset)
     * }
     */
    public static MethodHandle SCIPnlpiMergeStatistics$handle() {
        return SCIPnlpiMergeStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPnlpiMergeStatistics(SCIP_NLPI *targetnlpi, SCIP_NLPI *sourcenlpi, unsigned int reset)
     * }
     */
    public static MemorySegment SCIPnlpiMergeStatistics$address() {
        return SCIPnlpiMergeStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPnlpiMergeStatistics(SCIP_NLPI *targetnlpi, SCIP_NLPI *sourcenlpi, unsigned int reset)
     * }
     */
    public static void SCIPnlpiMergeStatistics(MemorySegment targetnlpi, MemorySegment sourcenlpi, int reset) {
        var mh$ = SCIPnlpiMergeStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnlpiMergeStatistics", targetnlpi, sourcenlpi, reset);
            }
            mh$.invokeExact(targetnlpi, sourcenlpi, reset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNlpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNlpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpi(SCIP *scip, const char *name, const char *description, int priority, SCIP_RETCODE (*nlpicopy)(SCIP *, SCIP_NLPI *), SCIP_RETCODE (*nlpifree)(SCIP *, SCIP_NLPI *, SCIP_NLPIDATA **), void *(*nlpigetsolverpointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpicreateproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **, const char *), SCIP_RETCODE (*nlpifreeproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **), void *(*nlpigetproblempointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpiaddvars)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const char **), SCIP_RETCODE (*nlpiaddconstraints)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const int *, int *const *, double *const *, SCIP_EXPR **, const char **), SCIP_RETCODE (*nlpisetobjective)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, SCIP_EXPR *, const double), SCIP_RETCODE (*nlpichgvarbounds)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, const int, const int *, const double *, const double *), SCIP_RETCODE (*nlpichgconssides)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, const double *), SCIP_RETCODE (*nlpidelvarset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpidelconsset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpichglinearcoefs)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, int, const int *, const double *), SCIP_RETCODE (*nlpichgexpr)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, SCIP_EXPR *), SCIP_RETCODE (*nlpichgobjconstant)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double), SCIP_RETCODE (*nlpisetinitialguess)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double *, double *, double *, double *), SCIP_RETCODE (*nlpisolve)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPPARAM), SCIP_NLPSOLSTAT (*nlpigetsolstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_NLPTERMSTAT (*nlpigettermstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpigetsolution)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double **, double **, double **, double **, double *), SCIP_RETCODE (*nlpigetstatistics)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPSTATISTICS *), SCIP_NLPIDATA *nlpidata)
     * }
     */
    public static FunctionDescriptor SCIPincludeNlpi$descriptor() {
        return SCIPincludeNlpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpi(SCIP *scip, const char *name, const char *description, int priority, SCIP_RETCODE (*nlpicopy)(SCIP *, SCIP_NLPI *), SCIP_RETCODE (*nlpifree)(SCIP *, SCIP_NLPI *, SCIP_NLPIDATA **), void *(*nlpigetsolverpointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpicreateproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **, const char *), SCIP_RETCODE (*nlpifreeproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **), void *(*nlpigetproblempointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpiaddvars)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const char **), SCIP_RETCODE (*nlpiaddconstraints)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const int *, int *const *, double *const *, SCIP_EXPR **, const char **), SCIP_RETCODE (*nlpisetobjective)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, SCIP_EXPR *, const double), SCIP_RETCODE (*nlpichgvarbounds)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, const int, const int *, const double *, const double *), SCIP_RETCODE (*nlpichgconssides)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, const double *), SCIP_RETCODE (*nlpidelvarset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpidelconsset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpichglinearcoefs)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, int, const int *, const double *), SCIP_RETCODE (*nlpichgexpr)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, SCIP_EXPR *), SCIP_RETCODE (*nlpichgobjconstant)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double), SCIP_RETCODE (*nlpisetinitialguess)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double *, double *, double *, double *), SCIP_RETCODE (*nlpisolve)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPPARAM), SCIP_NLPSOLSTAT (*nlpigetsolstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_NLPTERMSTAT (*nlpigettermstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpigetsolution)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double **, double **, double **, double **, double *), SCIP_RETCODE (*nlpigetstatistics)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPSTATISTICS *), SCIP_NLPIDATA *nlpidata)
     * }
     */
    public static MethodHandle SCIPincludeNlpi$handle() {
        return SCIPincludeNlpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpi(SCIP *scip, const char *name, const char *description, int priority, SCIP_RETCODE (*nlpicopy)(SCIP *, SCIP_NLPI *), SCIP_RETCODE (*nlpifree)(SCIP *, SCIP_NLPI *, SCIP_NLPIDATA **), void *(*nlpigetsolverpointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpicreateproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **, const char *), SCIP_RETCODE (*nlpifreeproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **), void *(*nlpigetproblempointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpiaddvars)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const char **), SCIP_RETCODE (*nlpiaddconstraints)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const int *, int *const *, double *const *, SCIP_EXPR **, const char **), SCIP_RETCODE (*nlpisetobjective)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, SCIP_EXPR *, const double), SCIP_RETCODE (*nlpichgvarbounds)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, const int, const int *, const double *, const double *), SCIP_RETCODE (*nlpichgconssides)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, const double *), SCIP_RETCODE (*nlpidelvarset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpidelconsset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpichglinearcoefs)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, int, const int *, const double *), SCIP_RETCODE (*nlpichgexpr)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, SCIP_EXPR *), SCIP_RETCODE (*nlpichgobjconstant)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double), SCIP_RETCODE (*nlpisetinitialguess)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double *, double *, double *, double *), SCIP_RETCODE (*nlpisolve)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPPARAM), SCIP_NLPSOLSTAT (*nlpigetsolstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_NLPTERMSTAT (*nlpigettermstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpigetsolution)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double **, double **, double **, double **, double *), SCIP_RETCODE (*nlpigetstatistics)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPSTATISTICS *), SCIP_NLPIDATA *nlpidata)
     * }
     */
    public static MemorySegment SCIPincludeNlpi$address() {
        return SCIPincludeNlpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNlpi(SCIP *scip, const char *name, const char *description, int priority, SCIP_RETCODE (*nlpicopy)(SCIP *, SCIP_NLPI *), SCIP_RETCODE (*nlpifree)(SCIP *, SCIP_NLPI *, SCIP_NLPIDATA **), void *(*nlpigetsolverpointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpicreateproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **, const char *), SCIP_RETCODE (*nlpifreeproblem)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM **), void *(*nlpigetproblempointer)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpiaddvars)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const char **), SCIP_RETCODE (*nlpiaddconstraints)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const double *, const double *, const int *, int *const *, double *const *, SCIP_EXPR **, const char **), SCIP_RETCODE (*nlpisetobjective)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, SCIP_EXPR *, const double), SCIP_RETCODE (*nlpichgvarbounds)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, const int, const int *, const double *, const double *), SCIP_RETCODE (*nlpichgconssides)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, const int *, const double *, const double *), SCIP_RETCODE (*nlpidelvarset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpidelconsset)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int *, int), SCIP_RETCODE (*nlpichglinearcoefs)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, int, const int *, const double *), SCIP_RETCODE (*nlpichgexpr)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, int, SCIP_EXPR *), SCIP_RETCODE (*nlpichgobjconstant)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double), SCIP_RETCODE (*nlpisetinitialguess)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double *, double *, double *, double *), SCIP_RETCODE (*nlpisolve)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPPARAM), SCIP_NLPSOLSTAT (*nlpigetsolstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_NLPTERMSTAT (*nlpigettermstat)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *), SCIP_RETCODE (*nlpigetsolution)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, double **, double **, double **, double **, double *), SCIP_RETCODE (*nlpigetstatistics)(SCIP *, SCIP_NLPI *, SCIP_NLPIPROBLEM *, SCIP_NLPSTATISTICS *), SCIP_NLPIDATA *nlpidata)
     * }
     */
    public static int SCIPincludeNlpi(MemorySegment scip, MemorySegment name, MemorySegment description, int priority, MemorySegment nlpicopy, MemorySegment nlpifree, MemorySegment nlpigetsolverpointer, MemorySegment nlpicreateproblem, MemorySegment nlpifreeproblem, MemorySegment nlpigetproblempointer, MemorySegment nlpiaddvars, MemorySegment nlpiaddconstraints, MemorySegment nlpisetobjective, MemorySegment nlpichgvarbounds, MemorySegment nlpichgconssides, MemorySegment nlpidelvarset, MemorySegment nlpidelconsset, MemorySegment nlpichglinearcoefs, MemorySegment nlpichgexpr, MemorySegment nlpichgobjconstant, MemorySegment nlpisetinitialguess, MemorySegment nlpisolve, MemorySegment nlpigetsolstat, MemorySegment nlpigettermstat, MemorySegment nlpigetsolution, MemorySegment nlpigetstatistics, MemorySegment nlpidata) {
        var mh$ = SCIPincludeNlpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNlpi", scip, name, description, priority, nlpicopy, nlpifree, nlpigetsolverpointer, nlpicreateproblem, nlpifreeproblem, nlpigetproblempointer, nlpiaddvars, nlpiaddconstraints, nlpisetobjective, nlpichgvarbounds, nlpichgconssides, nlpidelvarset, nlpidelconsset, nlpichglinearcoefs, nlpichgexpr, nlpichgobjconstant, nlpisetinitialguess, nlpisolve, nlpigetsolstat, nlpigettermstat, nlpigetsolution, nlpigetstatistics, nlpidata);
            }
            return (int)mh$.invokeExact(scip, name, description, priority, nlpicopy, nlpifree, nlpigetsolverpointer, nlpicreateproblem, nlpifreeproblem, nlpigetproblempointer, nlpiaddvars, nlpiaddconstraints, nlpisetobjective, nlpichgvarbounds, nlpichgconssides, nlpidelvarset, nlpidelconsset, nlpichglinearcoefs, nlpichgexpr, nlpichgobjconstant, nlpisetinitialguess, nlpisolve, nlpigetsolstat, nlpigettermstat, nlpigetsolution, nlpigetstatistics, nlpidata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindNlpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindNlpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPI *SCIPfindNlpi(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindNlpi$descriptor() {
        return SCIPfindNlpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPI *SCIPfindNlpi(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindNlpi$handle() {
        return SCIPfindNlpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPI *SCIPfindNlpi(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNlpi$address() {
        return SCIPfindNlpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPI *SCIPfindNlpi(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNlpi(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindNlpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindNlpi", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPI **SCIPgetNlpis(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpis$descriptor() {
        return SCIPgetNlpis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPI **SCIPgetNlpis(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNlpis$handle() {
        return SCIPgetNlpis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPI **SCIPgetNlpis(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNlpis$address() {
        return SCIPgetNlpis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPI **SCIPgetNlpis(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNlpis(MemorySegment scip) {
        var mh$ = SCIPgetNlpis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpis", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNlpis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNlpis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNlpis(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNlpis$descriptor() {
        return SCIPgetNNlpis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNlpis(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNlpis$handle() {
        return SCIPgetNNlpis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNlpis(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNlpis$address() {
        return SCIPgetNNlpis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNlpis(SCIP *scip)
     * }
     */
    public static int SCIPgetNNlpis(MemorySegment scip) {
        var mh$ = SCIPgetNNlpis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNlpis", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNlpiPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNlpiPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiPriority(SCIP *scip, SCIP_NLPI *nlpi, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetNlpiPriority$descriptor() {
        return SCIPsetNlpiPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiPriority(SCIP *scip, SCIP_NLPI *nlpi, int priority)
     * }
     */
    public static MethodHandle SCIPsetNlpiPriority$handle() {
        return SCIPsetNlpiPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiPriority(SCIP *scip, SCIP_NLPI *nlpi, int priority)
     * }
     */
    public static MemorySegment SCIPsetNlpiPriority$address() {
        return SCIPsetNlpiPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiPriority(SCIP *scip, SCIP_NLPI *nlpi, int priority)
     * }
     */
    public static int SCIPsetNlpiPriority(MemorySegment scip, MemorySegment nlpi, int priority) {
        var mh$ = SCIPsetNlpiPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNlpiPriority", scip, nlpi, priority);
            }
            return (int)mh$.invokeExact(scip, nlpi, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiSolverPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiSolverPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiSolverPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiSolverPointer$descriptor() {
        return SCIPgetNlpiSolverPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiSolverPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MethodHandle SCIPgetNlpiSolverPointer$handle() {
        return SCIPgetNlpiSolverPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiSolverPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiSolverPointer$address() {
        return SCIPgetNlpiSolverPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPgetNlpiSolverPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiSolverPointer(MemorySegment scip, MemorySegment nlpi, MemorySegment problem) {
        var mh$ = SCIPgetNlpiSolverPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiSolverPointer", scip, nlpi, problem);
            }
            return (MemorySegment)mh$.invokeExact(scip, nlpi, problem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateNlpiProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateNlpiProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPcreateNlpiProblem$descriptor() {
        return SCIPcreateNlpiProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem, const char *name)
     * }
     */
    public static MethodHandle SCIPcreateNlpiProblem$handle() {
        return SCIPcreateNlpiProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem, const char *name)
     * }
     */
    public static MemorySegment SCIPcreateNlpiProblem$address() {
        return SCIPcreateNlpiProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem, const char *name)
     * }
     */
    public static int SCIPcreateNlpiProblem(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment name) {
        var mh$ = SCIPcreateNlpiProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateNlpiProblem", scip, nlpi, problem, name);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeNlpiProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeNlpiProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem)
     * }
     */
    public static FunctionDescriptor SCIPfreeNlpiProblem$descriptor() {
        return SCIPfreeNlpiProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem)
     * }
     */
    public static MethodHandle SCIPfreeNlpiProblem$handle() {
        return SCIPfreeNlpiProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem)
     * }
     */
    public static MemorySegment SCIPfreeNlpiProblem$address() {
        return SCIPfreeNlpiProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **problem)
     * }
     */
    public static int SCIPfreeNlpiProblem(MemorySegment scip, MemorySegment nlpi, MemorySegment problem) {
        var mh$ = SCIPfreeNlpiProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeNlpiProblem", scip, nlpi, problem);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiProblemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiProblemPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiProblemPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiProblemPointer$descriptor() {
        return SCIPgetNlpiProblemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiProblemPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MethodHandle SCIPgetNlpiProblemPointer$handle() {
        return SCIPgetNlpiProblemPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *SCIPgetNlpiProblemPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiProblemPointer$address() {
        return SCIPgetNlpiProblemPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *SCIPgetNlpiProblemPointer(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiProblemPointer(MemorySegment scip, MemorySegment nlpi, MemorySegment problem) {
        var mh$ = SCIPgetNlpiProblemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiProblemPointer", scip, nlpi, problem);
            }
            return (MemorySegment)mh$.invokeExact(scip, nlpi, problem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNlpiVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNlpiVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiVars(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nvars, const double *lbs, const double *ubs, const char **varnames)
     * }
     */
    public static FunctionDescriptor SCIPaddNlpiVars$descriptor() {
        return SCIPaddNlpiVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiVars(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nvars, const double *lbs, const double *ubs, const char **varnames)
     * }
     */
    public static MethodHandle SCIPaddNlpiVars$handle() {
        return SCIPaddNlpiVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiVars(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nvars, const double *lbs, const double *ubs, const char **varnames)
     * }
     */
    public static MemorySegment SCIPaddNlpiVars$address() {
        return SCIPaddNlpiVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiVars(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nvars, const double *lbs, const double *ubs, const char **varnames)
     * }
     */
    public static int SCIPaddNlpiVars(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int nvars, MemorySegment lbs, MemorySegment ubs, MemorySegment varnames) {
        var mh$ = SCIPaddNlpiVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNlpiVars", scip, nlpi, problem, nvars, lbs, ubs, varnames);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, nvars, lbs, ubs, varnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNlpiConstraints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNlpiConstraints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiConstraints(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const double *lhss, const double *rhss, const int *nlininds, int *const *lininds, double *const *linvals, SCIP_EXPR **exprs, const char **names)
     * }
     */
    public static FunctionDescriptor SCIPaddNlpiConstraints$descriptor() {
        return SCIPaddNlpiConstraints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiConstraints(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const double *lhss, const double *rhss, const int *nlininds, int *const *lininds, double *const *linvals, SCIP_EXPR **exprs, const char **names)
     * }
     */
    public static MethodHandle SCIPaddNlpiConstraints$handle() {
        return SCIPaddNlpiConstraints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiConstraints(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const double *lhss, const double *rhss, const int *nlininds, int *const *lininds, double *const *linvals, SCIP_EXPR **exprs, const char **names)
     * }
     */
    public static MemorySegment SCIPaddNlpiConstraints$address() {
        return SCIPaddNlpiConstraints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiConstraints(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const double *lhss, const double *rhss, const int *nlininds, int *const *lininds, double *const *linvals, SCIP_EXPR **exprs, const char **names)
     * }
     */
    public static int SCIPaddNlpiConstraints(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int nconss, MemorySegment lhss, MemorySegment rhss, MemorySegment nlininds, MemorySegment lininds, MemorySegment linvals, MemorySegment exprs, MemorySegment names) {
        var mh$ = SCIPaddNlpiConstraints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNlpiConstraints", scip, nlpi, problem, nconss, lhss, rhss, nlininds, lininds, linvals, exprs, names);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, nconss, lhss, rhss, nlininds, lininds, linvals, exprs, names);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNlpiObjective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNlpiObjective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiObjective(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nlins, const int *lininds, const double *linvals, SCIP_EXPR *expr, const double constant)
     * }
     */
    public static FunctionDescriptor SCIPsetNlpiObjective$descriptor() {
        return SCIPsetNlpiObjective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiObjective(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nlins, const int *lininds, const double *linvals, SCIP_EXPR *expr, const double constant)
     * }
     */
    public static MethodHandle SCIPsetNlpiObjective$handle() {
        return SCIPsetNlpiObjective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiObjective(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nlins, const int *lininds, const double *linvals, SCIP_EXPR *expr, const double constant)
     * }
     */
    public static MemorySegment SCIPsetNlpiObjective$address() {
        return SCIPsetNlpiObjective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiObjective(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nlins, const int *lininds, const double *linvals, SCIP_EXPR *expr, const double constant)
     * }
     */
    public static int SCIPsetNlpiObjective(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int nlins, MemorySegment lininds, MemorySegment linvals, MemorySegment expr, double constant) {
        var mh$ = SCIPsetNlpiObjective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNlpiObjective", scip, nlpi, problem, nlins, lininds, linvals, expr, constant);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, nlins, lininds, linvals, expr, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlpiVarBounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlpiVarBounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiVarBounds(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, const int nvars, const int *indices, const double *lbs, const double *ubs)
     * }
     */
    public static FunctionDescriptor SCIPchgNlpiVarBounds$descriptor() {
        return SCIPchgNlpiVarBounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiVarBounds(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, const int nvars, const int *indices, const double *lbs, const double *ubs)
     * }
     */
    public static MethodHandle SCIPchgNlpiVarBounds$handle() {
        return SCIPchgNlpiVarBounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiVarBounds(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, const int nvars, const int *indices, const double *lbs, const double *ubs)
     * }
     */
    public static MemorySegment SCIPchgNlpiVarBounds$address() {
        return SCIPchgNlpiVarBounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiVarBounds(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, const int nvars, const int *indices, const double *lbs, const double *ubs)
     * }
     */
    public static int SCIPchgNlpiVarBounds(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int nvars, MemorySegment indices, MemorySegment lbs, MemorySegment ubs) {
        var mh$ = SCIPchgNlpiVarBounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlpiVarBounds", scip, nlpi, problem, nvars, indices, lbs, ubs);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, nvars, indices, lbs, ubs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlpiConsSides {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlpiConsSides");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiConsSides(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const int *indices, const double *lhss, const double *rhss)
     * }
     */
    public static FunctionDescriptor SCIPchgNlpiConsSides$descriptor() {
        return SCIPchgNlpiConsSides.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiConsSides(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const int *indices, const double *lhss, const double *rhss)
     * }
     */
    public static MethodHandle SCIPchgNlpiConsSides$handle() {
        return SCIPchgNlpiConsSides.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiConsSides(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const int *indices, const double *lhss, const double *rhss)
     * }
     */
    public static MemorySegment SCIPchgNlpiConsSides$address() {
        return SCIPchgNlpiConsSides.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiConsSides(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int nconss, const int *indices, const double *lhss, const double *rhss)
     * }
     */
    public static int SCIPchgNlpiConsSides(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int nconss, MemorySegment indices, MemorySegment lhss, MemorySegment rhss) {
        var mh$ = SCIPchgNlpiConsSides.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlpiConsSides", scip, nlpi, problem, nconss, indices, lhss, rhss);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, nconss, indices, lhss, rhss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelNlpiVarSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelNlpiVarSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiVarSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static FunctionDescriptor SCIPdelNlpiVarSet$descriptor() {
        return SCIPdelNlpiVarSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiVarSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static MethodHandle SCIPdelNlpiVarSet$handle() {
        return SCIPdelNlpiVarSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiVarSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static MemorySegment SCIPdelNlpiVarSet$address() {
        return SCIPdelNlpiVarSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiVarSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static int SCIPdelNlpiVarSet(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment dstats, int dstatssize) {
        var mh$ = SCIPdelNlpiVarSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelNlpiVarSet", scip, nlpi, problem, dstats, dstatssize);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, dstats, dstatssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelNlpiConsSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelNlpiConsSet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiConsSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static FunctionDescriptor SCIPdelNlpiConsSet$descriptor() {
        return SCIPdelNlpiConsSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiConsSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static MethodHandle SCIPdelNlpiConsSet$handle() {
        return SCIPdelNlpiConsSet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiConsSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static MemorySegment SCIPdelNlpiConsSet$address() {
        return SCIPdelNlpiConsSet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelNlpiConsSet(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int *dstats, int dstatssize)
     * }
     */
    public static int SCIPdelNlpiConsSet(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment dstats, int dstatssize) {
        var mh$ = SCIPdelNlpiConsSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelNlpiConsSet", scip, nlpi, problem, dstats, dstatssize);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, dstats, dstatssize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlpiLinearCoefs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlpiLinearCoefs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiLinearCoefs(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idx, int nvals, const int *varidxs, const double *vals)
     * }
     */
    public static FunctionDescriptor SCIPchgNlpiLinearCoefs$descriptor() {
        return SCIPchgNlpiLinearCoefs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiLinearCoefs(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idx, int nvals, const int *varidxs, const double *vals)
     * }
     */
    public static MethodHandle SCIPchgNlpiLinearCoefs$handle() {
        return SCIPchgNlpiLinearCoefs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiLinearCoefs(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idx, int nvals, const int *varidxs, const double *vals)
     * }
     */
    public static MemorySegment SCIPchgNlpiLinearCoefs$address() {
        return SCIPchgNlpiLinearCoefs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiLinearCoefs(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idx, int nvals, const int *varidxs, const double *vals)
     * }
     */
    public static int SCIPchgNlpiLinearCoefs(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int idx, int nvals, MemorySegment varidxs, MemorySegment vals) {
        var mh$ = SCIPchgNlpiLinearCoefs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlpiLinearCoefs", scip, nlpi, problem, idx, nvals, varidxs, vals);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, idx, nvals, varidxs, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlpiExpr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlpiExpr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiExpr(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idxcons, SCIP_EXPR *expr)
     * }
     */
    public static FunctionDescriptor SCIPchgNlpiExpr$descriptor() {
        return SCIPchgNlpiExpr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiExpr(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idxcons, SCIP_EXPR *expr)
     * }
     */
    public static MethodHandle SCIPchgNlpiExpr$handle() {
        return SCIPchgNlpiExpr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiExpr(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idxcons, SCIP_EXPR *expr)
     * }
     */
    public static MemorySegment SCIPchgNlpiExpr$address() {
        return SCIPchgNlpiExpr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiExpr(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, int idxcons, SCIP_EXPR *expr)
     * }
     */
    public static int SCIPchgNlpiExpr(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, int idxcons, MemorySegment expr) {
        var mh$ = SCIPchgNlpiExpr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlpiExpr", scip, nlpi, problem, idxcons, expr);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, idxcons, expr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgNlpiObjConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgNlpiObjConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiObjConstant(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double objconstant)
     * }
     */
    public static FunctionDescriptor SCIPchgNlpiObjConstant$descriptor() {
        return SCIPchgNlpiObjConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiObjConstant(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double objconstant)
     * }
     */
    public static MethodHandle SCIPchgNlpiObjConstant$handle() {
        return SCIPchgNlpiObjConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiObjConstant(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double objconstant)
     * }
     */
    public static MemorySegment SCIPchgNlpiObjConstant$address() {
        return SCIPchgNlpiObjConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgNlpiObjConstant(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double objconstant)
     * }
     */
    public static int SCIPchgNlpiObjConstant(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, double objconstant) {
        var mh$ = SCIPchgNlpiObjConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgNlpiObjConstant", scip, nlpi, problem, objconstant);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, objconstant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNlpiInitialGuess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNlpiInitialGuess");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiInitialGuess(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double *primalvalues, double *consdualvalues, double *varlbdualvalues, double *varubdualvalues)
     * }
     */
    public static FunctionDescriptor SCIPsetNlpiInitialGuess$descriptor() {
        return SCIPsetNlpiInitialGuess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiInitialGuess(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double *primalvalues, double *consdualvalues, double *varlbdualvalues, double *varubdualvalues)
     * }
     */
    public static MethodHandle SCIPsetNlpiInitialGuess$handle() {
        return SCIPsetNlpiInitialGuess.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiInitialGuess(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double *primalvalues, double *consdualvalues, double *varlbdualvalues, double *varubdualvalues)
     * }
     */
    public static MemorySegment SCIPsetNlpiInitialGuess$address() {
        return SCIPsetNlpiInitialGuess.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNlpiInitialGuess(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double *primalvalues, double *consdualvalues, double *varlbdualvalues, double *varubdualvalues)
     * }
     */
    public static int SCIPsetNlpiInitialGuess(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment primalvalues, MemorySegment consdualvalues, MemorySegment varlbdualvalues, MemorySegment varubdualvalues) {
        var mh$ = SCIPsetNlpiInitialGuess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNlpiInitialGuess", scip, nlpi, problem, primalvalues, consdualvalues, varlbdualvalues, varubdualvalues);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, primalvalues, consdualvalues, varlbdualvalues, varubdualvalues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveNlpiParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            SCIP_NlpParam.layout()
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveNlpiParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNlpiParam(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPPARAM param)
     * }
     */
    public static FunctionDescriptor SCIPsolveNlpiParam$descriptor() {
        return SCIPsolveNlpiParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNlpiParam(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPPARAM param)
     * }
     */
    public static MethodHandle SCIPsolveNlpiParam$handle() {
        return SCIPsolveNlpiParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNlpiParam(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPPARAM param)
     * }
     */
    public static MemorySegment SCIPsolveNlpiParam$address() {
        return SCIPsolveNlpiParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveNlpiParam(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPPARAM param)
     * }
     */
    public static int SCIPsolveNlpiParam(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment param) {
        var mh$ = SCIPsolveNlpiParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveNlpiParam", scip, nlpi, problem, param);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiSolstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiSolstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNlpiSolstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiSolstat$descriptor() {
        return SCIPgetNlpiSolstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNlpiSolstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MethodHandle SCIPgetNlpiSolstat$handle() {
        return SCIPgetNlpiSolstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNlpiSolstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiSolstat$address() {
        return SCIPgetNlpiSolstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPSOLSTAT SCIPgetNlpiSolstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static int SCIPgetNlpiSolstat(MemorySegment scip, MemorySegment nlpi, MemorySegment problem) {
        var mh$ = SCIPgetNlpiSolstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiSolstat", scip, nlpi, problem);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiTermstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiTermstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNlpiTermstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiTermstat$descriptor() {
        return SCIPgetNlpiTermstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNlpiTermstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MethodHandle SCIPgetNlpiTermstat$handle() {
        return SCIPgetNlpiTermstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNlpiTermstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static MemorySegment SCIPgetNlpiTermstat$address() {
        return SCIPgetNlpiTermstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NLPTERMSTAT SCIPgetNlpiTermstat(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem)
     * }
     */
    public static int SCIPgetNlpiTermstat(MemorySegment scip, MemorySegment nlpi, MemorySegment problem) {
        var mh$ = SCIPgetNlpiTermstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiTermstat", scip, nlpi, problem);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiSolution {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiSolution");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiSolution(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double **primalvalues, double **consdualvalues, double **varlbdualvalues, double **varubdualvalues, double *objval)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiSolution$descriptor() {
        return SCIPgetNlpiSolution.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiSolution(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double **primalvalues, double **consdualvalues, double **varlbdualvalues, double **varubdualvalues, double *objval)
     * }
     */
    public static MethodHandle SCIPgetNlpiSolution$handle() {
        return SCIPgetNlpiSolution.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiSolution(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double **primalvalues, double **consdualvalues, double **varlbdualvalues, double **varubdualvalues, double *objval)
     * }
     */
    public static MemorySegment SCIPgetNlpiSolution$address() {
        return SCIPgetNlpiSolution.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiSolution(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, double **primalvalues, double **consdualvalues, double **varlbdualvalues, double **varubdualvalues, double *objval)
     * }
     */
    public static int SCIPgetNlpiSolution(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment primalvalues, MemorySegment consdualvalues, MemorySegment varlbdualvalues, MemorySegment varubdualvalues, MemorySegment objval) {
        var mh$ = SCIPgetNlpiSolution.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiSolution", scip, nlpi, problem, primalvalues, consdualvalues, varlbdualvalues, varubdualvalues, objval);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, primalvalues, consdualvalues, varlbdualvalues, varubdualvalues, objval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNlpiStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNlpiStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiStatistics(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static FunctionDescriptor SCIPgetNlpiStatistics$descriptor() {
        return SCIPgetNlpiStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiStatistics(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static MethodHandle SCIPgetNlpiStatistics$handle() {
        return SCIPgetNlpiStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiStatistics(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static MemorySegment SCIPgetNlpiStatistics$address() {
        return SCIPgetNlpiStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNlpiStatistics(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *problem, SCIP_NLPSTATISTICS *statistics)
     * }
     */
    public static int SCIPgetNlpiStatistics(MemorySegment scip, MemorySegment nlpi, MemorySegment problem, MemorySegment statistics) {
        var mh$ = SCIPgetNlpiStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNlpiStatistics", scip, nlpi, problem, statistics);
            }
            return (int)mh$.invokeExact(scip, nlpi, problem, statistics);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateNlpiProblemFromNlRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateNlpiProblemFromNlRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblemFromNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **nlpiprob, const char *name, SCIP_NLROW **nlrows, int nnlrows, SCIP_HASHMAP *var2idx, SCIP_HASHMAP *nlrow2idx, double *nlscore, double cutoffbound, unsigned int setobj, unsigned int onlyconvex)
     * }
     */
    public static FunctionDescriptor SCIPcreateNlpiProblemFromNlRows$descriptor() {
        return SCIPcreateNlpiProblemFromNlRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblemFromNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **nlpiprob, const char *name, SCIP_NLROW **nlrows, int nnlrows, SCIP_HASHMAP *var2idx, SCIP_HASHMAP *nlrow2idx, double *nlscore, double cutoffbound, unsigned int setobj, unsigned int onlyconvex)
     * }
     */
    public static MethodHandle SCIPcreateNlpiProblemFromNlRows$handle() {
        return SCIPcreateNlpiProblemFromNlRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblemFromNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **nlpiprob, const char *name, SCIP_NLROW **nlrows, int nnlrows, SCIP_HASHMAP *var2idx, SCIP_HASHMAP *nlrow2idx, double *nlscore, double cutoffbound, unsigned int setobj, unsigned int onlyconvex)
     * }
     */
    public static MemorySegment SCIPcreateNlpiProblemFromNlRows$address() {
        return SCIPcreateNlpiProblemFromNlRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNlpiProblemFromNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM **nlpiprob, const char *name, SCIP_NLROW **nlrows, int nnlrows, SCIP_HASHMAP *var2idx, SCIP_HASHMAP *nlrow2idx, double *nlscore, double cutoffbound, unsigned int setobj, unsigned int onlyconvex)
     * }
     */
    public static int SCIPcreateNlpiProblemFromNlRows(MemorySegment scip, MemorySegment nlpi, MemorySegment nlpiprob, MemorySegment name, MemorySegment nlrows, int nnlrows, MemorySegment var2idx, MemorySegment nlrow2idx, MemorySegment nlscore, double cutoffbound, int setobj, int onlyconvex) {
        var mh$ = SCIPcreateNlpiProblemFromNlRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateNlpiProblemFromNlRows", scip, nlpi, nlpiprob, name, nlrows, nnlrows, var2idx, nlrow2idx, nlscore, cutoffbound, setobj, onlyconvex);
            }
            return (int)mh$.invokeExact(scip, nlpi, nlpiprob, name, nlrows, nnlrows, var2idx, nlrow2idx, nlscore, cutoffbound, setobj, onlyconvex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateNlpiProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateNlpiProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2nlpiidx, SCIP_VAR **nlpivars, int nlpinvars, double cutoffbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateNlpiProblem$descriptor() {
        return SCIPupdateNlpiProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2nlpiidx, SCIP_VAR **nlpivars, int nlpinvars, double cutoffbound)
     * }
     */
    public static MethodHandle SCIPupdateNlpiProblem$handle() {
        return SCIPupdateNlpiProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2nlpiidx, SCIP_VAR **nlpivars, int nlpinvars, double cutoffbound)
     * }
     */
    public static MemorySegment SCIPupdateNlpiProblem$address() {
        return SCIPupdateNlpiProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNlpiProblem(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2nlpiidx, SCIP_VAR **nlpivars, int nlpinvars, double cutoffbound)
     * }
     */
    public static int SCIPupdateNlpiProblem(MemorySegment scip, MemorySegment nlpi, MemorySegment nlpiprob, MemorySegment var2nlpiidx, MemorySegment nlpivars, int nlpinvars, double cutoffbound) {
        var mh$ = SCIPupdateNlpiProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateNlpiProblem", scip, nlpi, nlpiprob, var2nlpiidx, nlpivars, nlpinvars, cutoffbound);
            }
            return (int)mh$.invokeExact(scip, nlpi, nlpiprob, var2nlpiidx, nlpivars, nlpinvars, cutoffbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNlpiProblemRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNlpiProblemRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_ROW **rows, int nrows)
     * }
     */
    public static FunctionDescriptor SCIPaddNlpiProblemRows$descriptor() {
        return SCIPaddNlpiProblemRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_ROW **rows, int nrows)
     * }
     */
    public static MethodHandle SCIPaddNlpiProblemRows$handle() {
        return SCIPaddNlpiProblemRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_ROW **rows, int nrows)
     * }
     */
    public static MemorySegment SCIPaddNlpiProblemRows$address() {
        return SCIPaddNlpiProblemRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_ROW **rows, int nrows)
     * }
     */
    public static int SCIPaddNlpiProblemRows(MemorySegment scip, MemorySegment nlpi, MemorySegment nlpiprob, MemorySegment var2idx, MemorySegment rows, int nrows) {
        var mh$ = SCIPaddNlpiProblemRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNlpiProblemRows", scip, nlpi, nlpiprob, var2idx, rows, nrows);
            }
            return (int)mh$.invokeExact(scip, nlpi, nlpiprob, var2idx, rows, nrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNlpiProblemNlRows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNlpiProblemNlRows");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_NLROW **nlrows, int nnlrows)
     * }
     */
    public static FunctionDescriptor SCIPaddNlpiProblemNlRows$descriptor() {
        return SCIPaddNlpiProblemNlRows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_NLROW **nlrows, int nnlrows)
     * }
     */
    public static MethodHandle SCIPaddNlpiProblemNlRows$handle() {
        return SCIPaddNlpiProblemNlRows.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_NLROW **nlrows, int nnlrows)
     * }
     */
    public static MemorySegment SCIPaddNlpiProblemNlRows$address() {
        return SCIPaddNlpiProblemNlRows.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddNlpiProblemNlRows(SCIP *scip, SCIP_NLPI *nlpi, SCIP_NLPIPROBLEM *nlpiprob, SCIP_HASHMAP *var2idx, SCIP_NLROW **nlrows, int nnlrows)
     * }
     */
    public static int SCIPaddNlpiProblemNlRows(MemorySegment scip, MemorySegment nlpi, MemorySegment nlpiprob, MemorySegment var2idx, MemorySegment nlrows, int nnlrows) {
        var mh$ = SCIPaddNlpiProblemNlRows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNlpiProblemNlRows", scip, nlpi, nlpiprob, var2idx, nlrows, nnlrows);
            }
            return (int)mh$.invokeExact(scip, nlpi, nlpiprob, var2idx, nlrows, nnlrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodesel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodesel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodesel(SCIP *scip, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodesel$descriptor() {
        return SCIPincludeNodesel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodesel(SCIP *scip, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MethodHandle SCIPincludeNodesel$handle() {
        return SCIPincludeNodesel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodesel(SCIP *scip, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MemorySegment SCIPincludeNodesel$address() {
        return SCIPincludeNodesel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodesel(SCIP *scip, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *), SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static int SCIPincludeNodesel(MemorySegment scip, MemorySegment name, MemorySegment desc, int stdpriority, int memsavepriority, MemorySegment nodeselcopy, MemorySegment nodeselfree, MemorySegment nodeselinit, MemorySegment nodeselexit, MemorySegment nodeselinitsol, MemorySegment nodeselexitsol, MemorySegment nodeselselect, MemorySegment nodeselcomp, MemorySegment nodeseldata) {
        var mh$ = SCIPincludeNodesel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodesel", scip, name, desc, stdpriority, memsavepriority, nodeselcopy, nodeselfree, nodeselinit, nodeselexit, nodeselinitsol, nodeselexitsol, nodeselselect, nodeselcomp, nodeseldata);
            }
            return (int)mh$.invokeExact(scip, name, desc, stdpriority, memsavepriority, nodeselcopy, nodeselfree, nodeselinit, nodeselexit, nodeselinitsol, nodeselexitsol, nodeselselect, nodeselcomp, nodeseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeNodeselBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeNodeselBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBasic(SCIP *scip, SCIP_NODESEL **nodesel, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static FunctionDescriptor SCIPincludeNodeselBasic$descriptor() {
        return SCIPincludeNodeselBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBasic(SCIP *scip, SCIP_NODESEL **nodesel, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MethodHandle SCIPincludeNodeselBasic$handle() {
        return SCIPincludeNodeselBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBasic(SCIP *scip, SCIP_NODESEL **nodesel, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static MemorySegment SCIPincludeNodeselBasic$address() {
        return SCIPincludeNodeselBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeNodeselBasic(SCIP *scip, SCIP_NODESEL **nodesel, const char *name, const char *desc, int stdpriority, int memsavepriority, SCIP_RETCODE (*nodeselselect)(SCIP *, SCIP_NODESEL *, SCIP_NODE **), int (*nodeselcomp)(SCIP *, SCIP_NODESEL *, SCIP_NODE *, SCIP_NODE *), SCIP_NODESELDATA *nodeseldata)
     * }
     */
    public static int SCIPincludeNodeselBasic(MemorySegment scip, MemorySegment nodesel, MemorySegment name, MemorySegment desc, int stdpriority, int memsavepriority, MemorySegment nodeselselect, MemorySegment nodeselcomp, MemorySegment nodeseldata) {
        var mh$ = SCIPincludeNodeselBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeNodeselBasic", scip, nodesel, name, desc, stdpriority, memsavepriority, nodeselselect, nodeselcomp, nodeseldata);
            }
            return (int)mh$.invokeExact(scip, nodesel, name, desc, stdpriority, memsavepriority, nodeselselect, nodeselcomp, nodeseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselCopy(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselCopy$descriptor() {
        return SCIPsetNodeselCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselCopy(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselCopy$handle() {
        return SCIPsetNodeselCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselCopy(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselCopy$address() {
        return SCIPsetNodeselCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselCopy(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselcopy)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselCopy(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselcopy) {
        var mh$ = SCIPsetNodeselCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselCopy", scip, nodesel, nodeselcopy);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselFree(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselFree$descriptor() {
        return SCIPsetNodeselFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselFree(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselFree$handle() {
        return SCIPsetNodeselFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselFree(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselFree$address() {
        return SCIPsetNodeselFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselFree(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselfree)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselFree(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselfree) {
        var mh$ = SCIPsetNodeselFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselFree", scip, nodesel, nodeselfree);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselInit$descriptor() {
        return SCIPsetNodeselInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselInit$handle() {
        return SCIPsetNodeselInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselInit$address() {
        return SCIPsetNodeselInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselInit(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselinit) {
        var mh$ = SCIPsetNodeselInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselInit", scip, nodesel, nodeselinit);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselExit$descriptor() {
        return SCIPsetNodeselExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselExit$handle() {
        return SCIPsetNodeselExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselExit$address() {
        return SCIPsetNodeselExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExit(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexit)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselExit(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselexit) {
        var mh$ = SCIPsetNodeselExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselExit", scip, nodesel, nodeselexit);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselInitsol$descriptor() {
        return SCIPsetNodeselInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselInitsol$handle() {
        return SCIPsetNodeselInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselInitsol$address() {
        return SCIPsetNodeselInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselInitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselinitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselInitsol(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselinitsol) {
        var mh$ = SCIPsetNodeselInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselInitsol", scip, nodesel, nodeselinitsol);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselExitsol$descriptor() {
        return SCIPsetNodeselExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MethodHandle SCIPsetNodeselExitsol$handle() {
        return SCIPsetNodeselExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static MemorySegment SCIPsetNodeselExitsol$address() {
        return SCIPsetNodeselExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselExitsol(SCIP *scip, SCIP_NODESEL *nodesel, SCIP_RETCODE (*nodeselexitsol)(SCIP *, SCIP_NODESEL *))
     * }
     */
    public static int SCIPsetNodeselExitsol(MemorySegment scip, MemorySegment nodesel, MemorySegment nodeselexitsol) {
        var mh$ = SCIPsetNodeselExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselExitsol", scip, nodesel, nodeselexitsol);
            }
            return (int)mh$.invokeExact(scip, nodesel, nodeselexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindNodesel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindNodesel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPfindNodesel(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindNodesel$descriptor() {
        return SCIPfindNodesel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPfindNodesel(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindNodesel$handle() {
        return SCIPfindNodesel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPfindNodesel(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNodesel$address() {
        return SCIPfindNodesel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPfindNodesel(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindNodesel(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindNodesel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindNodesel", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNodesels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNodesels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODESEL **SCIPgetNodesels(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNodesels$descriptor() {
        return SCIPgetNodesels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODESEL **SCIPgetNodesels(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNodesels$handle() {
        return SCIPgetNodesels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODESEL **SCIPgetNodesels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNodesels$address() {
        return SCIPgetNodesels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODESEL **SCIPgetNodesels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNodesels(MemorySegment scip) {
        var mh$ = SCIPgetNodesels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNodesels", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodesels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodesels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNodesels(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodesels$descriptor() {
        return SCIPgetNNodesels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNodesels(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodesels$handle() {
        return SCIPgetNNodesels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNodesels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodesels$address() {
        return SCIPgetNNodesels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNodesels(SCIP *scip)
     * }
     */
    public static int SCIPgetNNodesels(MemorySegment scip) {
        var mh$ = SCIPgetNNodesels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodesels", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselStdPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselStdPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselStdPriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselStdPriority$descriptor() {
        return SCIPsetNodeselStdPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselStdPriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static MethodHandle SCIPsetNodeselStdPriority$handle() {
        return SCIPsetNodeselStdPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselStdPriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static MemorySegment SCIPsetNodeselStdPriority$address() {
        return SCIPsetNodeselStdPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselStdPriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static int SCIPsetNodeselStdPriority(MemorySegment scip, MemorySegment nodesel, int priority) {
        var mh$ = SCIPsetNodeselStdPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselStdPriority", scip, nodesel, priority);
            }
            return (int)mh$.invokeExact(scip, nodesel, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetNodeselMemsavePriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetNodeselMemsavePriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselMemsavePriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetNodeselMemsavePriority$descriptor() {
        return SCIPsetNodeselMemsavePriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselMemsavePriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static MethodHandle SCIPsetNodeselMemsavePriority$handle() {
        return SCIPsetNodeselMemsavePriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselMemsavePriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static MemorySegment SCIPsetNodeselMemsavePriority$address() {
        return SCIPsetNodeselMemsavePriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetNodeselMemsavePriority(SCIP *scip, SCIP_NODESEL *nodesel, int priority)
     * }
     */
    public static int SCIPsetNodeselMemsavePriority(MemorySegment scip, MemorySegment nodesel, int priority) {
        var mh$ = SCIPsetNodeselMemsavePriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetNodeselMemsavePriority", scip, nodesel, priority);
            }
            return (int)mh$.invokeExact(scip, nodesel, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNodesel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNodesel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPgetNodesel(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNodesel$descriptor() {
        return SCIPgetNodesel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPgetNodesel(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNodesel$handle() {
        return SCIPgetNodesel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPgetNodesel(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNodesel$address() {
        return SCIPgetNodesel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODESEL *SCIPgetNodesel(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNodesel(MemorySegment scip) {
        var mh$ = SCIPgetNodesel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNodesel", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPepsilon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPepsilon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPepsilon(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPepsilon$descriptor() {
        return SCIPepsilon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPepsilon(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPepsilon$handle() {
        return SCIPepsilon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPepsilon(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPepsilon$address() {
        return SCIPepsilon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPepsilon(SCIP *scip)
     * }
     */
    public static double SCIPepsilon(MemorySegment scip) {
        var mh$ = SCIPepsilon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPepsilon", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsumepsilon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsumepsilon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPsumepsilon(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsumepsilon$descriptor() {
        return SCIPsumepsilon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPsumepsilon(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsumepsilon$handle() {
        return SCIPsumepsilon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPsumepsilon(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsumepsilon$address() {
        return SCIPsumepsilon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPsumepsilon(SCIP *scip)
     * }
     */
    public static double SCIPsumepsilon(MemorySegment scip) {
        var mh$ = SCIPsumepsilon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsumepsilon", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPfeastol$descriptor() {
        return SCIPfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPfeastol$handle() {
        return SCIPfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPfeastol$address() {
        return SCIPfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfeastol(SCIP *scip)
     * }
     */
    public static double SCIPfeastol(MemorySegment scip) {
        var mh$ = SCIPfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeastol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlpfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlpfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPlpfeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPlpfeastol$descriptor() {
        return SCIPlpfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPlpfeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPlpfeastol$handle() {
        return SCIPlpfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPlpfeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPlpfeastol$address() {
        return SCIPlpfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPlpfeastol(SCIP *scip)
     * }
     */
    public static double SCIPlpfeastol(MemorySegment scip) {
        var mh$ = SCIPlpfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlpfeastol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdualfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdualfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdualfeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdualfeastol$descriptor() {
        return SCIPdualfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdualfeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdualfeastol$handle() {
        return SCIPdualfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdualfeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdualfeastol$address() {
        return SCIPdualfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdualfeastol(SCIP *scip)
     * }
     */
    public static double SCIPdualfeastol(MemorySegment scip) {
        var mh$ = SCIPdualfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdualfeastol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbarrierconvtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbarrierconvtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPbarrierconvtol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPbarrierconvtol$descriptor() {
        return SCIPbarrierconvtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPbarrierconvtol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPbarrierconvtol$handle() {
        return SCIPbarrierconvtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPbarrierconvtol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPbarrierconvtol$address() {
        return SCIPbarrierconvtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPbarrierconvtol(SCIP *scip)
     * }
     */
    public static double SCIPbarrierconvtol(MemorySegment scip) {
        var mh$ = SCIPbarrierconvtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbarrierconvtol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutoffbounddelta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutoffbounddelta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPcutoffbounddelta(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPcutoffbounddelta$descriptor() {
        return SCIPcutoffbounddelta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPcutoffbounddelta(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPcutoffbounddelta$handle() {
        return SCIPcutoffbounddelta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPcutoffbounddelta(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPcutoffbounddelta$address() {
        return SCIPcutoffbounddelta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPcutoffbounddelta(SCIP *scip)
     * }
     */
    public static double SCIPcutoffbounddelta(MemorySegment scip) {
        var mh$ = SCIPcutoffbounddelta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutoffbounddelta", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrelaxfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrelaxfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPrelaxfeastol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPrelaxfeastol$descriptor() {
        return SCIPrelaxfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPrelaxfeastol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPrelaxfeastol$handle() {
        return SCIPrelaxfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPrelaxfeastol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPrelaxfeastol$address() {
        return SCIPrelaxfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPrelaxfeastol(SCIP *scip)
     * }
     */
    public static double SCIPrelaxfeastol(MemorySegment scip) {
        var mh$ = SCIPrelaxfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrelaxfeastol", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgFeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgFeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgFeastol(SCIP *scip, double feastol)
     * }
     */
    public static FunctionDescriptor SCIPchgFeastol$descriptor() {
        return SCIPchgFeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgFeastol(SCIP *scip, double feastol)
     * }
     */
    public static MethodHandle SCIPchgFeastol$handle() {
        return SCIPchgFeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgFeastol(SCIP *scip, double feastol)
     * }
     */
    public static MemorySegment SCIPchgFeastol$address() {
        return SCIPchgFeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgFeastol(SCIP *scip, double feastol)
     * }
     */
    public static int SCIPchgFeastol(MemorySegment scip, double feastol) {
        var mh$ = SCIPchgFeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgFeastol", scip, feastol);
            }
            return (int)mh$.invokeExact(scip, feastol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgLpfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgLpfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLpfeastol(SCIP *scip, double lpfeastol, unsigned int printnewvalue)
     * }
     */
    public static FunctionDescriptor SCIPchgLpfeastol$descriptor() {
        return SCIPchgLpfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLpfeastol(SCIP *scip, double lpfeastol, unsigned int printnewvalue)
     * }
     */
    public static MethodHandle SCIPchgLpfeastol$handle() {
        return SCIPchgLpfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLpfeastol(SCIP *scip, double lpfeastol, unsigned int printnewvalue)
     * }
     */
    public static MemorySegment SCIPchgLpfeastol$address() {
        return SCIPchgLpfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLpfeastol(SCIP *scip, double lpfeastol, unsigned int printnewvalue)
     * }
     */
    public static int SCIPchgLpfeastol(MemorySegment scip, double lpfeastol, int printnewvalue) {
        var mh$ = SCIPchgLpfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgLpfeastol", scip, lpfeastol, printnewvalue);
            }
            return (int)mh$.invokeExact(scip, lpfeastol, printnewvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgDualfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgDualfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgDualfeastol(SCIP *scip, double dualfeastol)
     * }
     */
    public static FunctionDescriptor SCIPchgDualfeastol$descriptor() {
        return SCIPchgDualfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgDualfeastol(SCIP *scip, double dualfeastol)
     * }
     */
    public static MethodHandle SCIPchgDualfeastol$handle() {
        return SCIPchgDualfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgDualfeastol(SCIP *scip, double dualfeastol)
     * }
     */
    public static MemorySegment SCIPchgDualfeastol$address() {
        return SCIPchgDualfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgDualfeastol(SCIP *scip, double dualfeastol)
     * }
     */
    public static int SCIPchgDualfeastol(MemorySegment scip, double dualfeastol) {
        var mh$ = SCIPchgDualfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgDualfeastol", scip, dualfeastol);
            }
            return (int)mh$.invokeExact(scip, dualfeastol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgBarrierconvtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgBarrierconvtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBarrierconvtol(SCIP *scip, double barrierconvtol)
     * }
     */
    public static FunctionDescriptor SCIPchgBarrierconvtol$descriptor() {
        return SCIPchgBarrierconvtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBarrierconvtol(SCIP *scip, double barrierconvtol)
     * }
     */
    public static MethodHandle SCIPchgBarrierconvtol$handle() {
        return SCIPchgBarrierconvtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBarrierconvtol(SCIP *scip, double barrierconvtol)
     * }
     */
    public static MemorySegment SCIPchgBarrierconvtol$address() {
        return SCIPchgBarrierconvtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBarrierconvtol(SCIP *scip, double barrierconvtol)
     * }
     */
    public static int SCIPchgBarrierconvtol(MemorySegment scip, double barrierconvtol) {
        var mh$ = SCIPchgBarrierconvtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgBarrierconvtol", scip, barrierconvtol);
            }
            return (int)mh$.invokeExact(scip, barrierconvtol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRelaxfeastol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRelaxfeastol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPchgRelaxfeastol(SCIP *scip, double relaxfeastol)
     * }
     */
    public static FunctionDescriptor SCIPchgRelaxfeastol$descriptor() {
        return SCIPchgRelaxfeastol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPchgRelaxfeastol(SCIP *scip, double relaxfeastol)
     * }
     */
    public static MethodHandle SCIPchgRelaxfeastol$handle() {
        return SCIPchgRelaxfeastol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPchgRelaxfeastol(SCIP *scip, double relaxfeastol)
     * }
     */
    public static MemorySegment SCIPchgRelaxfeastol$address() {
        return SCIPchgRelaxfeastol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPchgRelaxfeastol(SCIP *scip, double relaxfeastol)
     * }
     */
    public static double SCIPchgRelaxfeastol(MemorySegment scip, double relaxfeastol) {
        var mh$ = SCIPchgRelaxfeastol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRelaxfeastol", scip, relaxfeastol);
            }
            return (double)mh$.invokeExact(scip, relaxfeastol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPmarkLimitChanged {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPmarkLimitChanged");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPmarkLimitChanged(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPmarkLimitChanged$descriptor() {
        return SCIPmarkLimitChanged.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPmarkLimitChanged(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPmarkLimitChanged$handle() {
        return SCIPmarkLimitChanged.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPmarkLimitChanged(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPmarkLimitChanged$address() {
        return SCIPmarkLimitChanged.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPmarkLimitChanged(SCIP *scip)
     * }
     */
    public static void SCIPmarkLimitChanged(MemorySegment scip) {
        var mh$ = SCIPmarkLimitChanged.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPmarkLimitChanged", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPinfinity(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPinfinity$descriptor() {
        return SCIPinfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPinfinity(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPinfinity$handle() {
        return SCIPinfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPinfinity(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPinfinity$address() {
        return SCIPinfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPinfinity(SCIP *scip)
     * }
     */
    public static double SCIPinfinity(MemorySegment scip) {
        var mh$ = SCIPinfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinfinity", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetHugeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetHugeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetHugeValue(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetHugeValue$descriptor() {
        return SCIPgetHugeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetHugeValue(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetHugeValue$handle() {
        return SCIPgetHugeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetHugeValue(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetHugeValue$address() {
        return SCIPgetHugeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetHugeValue(SCIP *scip)
     * }
     */
    public static double SCIPgetHugeValue(MemorySegment scip) {
        var mh$ = SCIPgetHugeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetHugeValue", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisEQ$descriptor() {
        return SCIPisEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisEQ$handle() {
        return SCIPisEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisEQ$address() {
        return SCIPisEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisLT$descriptor() {
        return SCIPisLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisLT$handle() {
        return SCIPisLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisLT$address() {
        return SCIPisLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisLE$descriptor() {
        return SCIPisLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisLE$handle() {
        return SCIPisLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisLE$address() {
        return SCIPisLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisGT$descriptor() {
        return SCIPisGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisGT$handle() {
        return SCIPisGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisGT$address() {
        return SCIPisGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisGE$descriptor() {
        return SCIPisGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisGE$handle() {
        return SCIPisGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisGE$address() {
        return SCIPisGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisInfinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisInfinity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisInfinity(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisInfinity$descriptor() {
        return SCIPisInfinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisInfinity(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisInfinity$handle() {
        return SCIPisInfinity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisInfinity(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisInfinity$address() {
        return SCIPisInfinity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisInfinity(SCIP *scip, double val)
     * }
     */
    public static int SCIPisInfinity(MemorySegment scip, double val) {
        var mh$ = SCIPisInfinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisInfinity", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisHugeValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisHugeValue");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisHugeValue(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisHugeValue$descriptor() {
        return SCIPisHugeValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisHugeValue(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisHugeValue$handle() {
        return SCIPisHugeValue.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisHugeValue(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisHugeValue$address() {
        return SCIPisHugeValue.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisHugeValue(SCIP *scip, double val)
     * }
     */
    public static int SCIPisHugeValue(MemorySegment scip, double val) {
        var mh$ = SCIPisHugeValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisHugeValue", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisZero(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisZero$descriptor() {
        return SCIPisZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisZero(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisZero$handle() {
        return SCIPisZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisZero(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisZero$address() {
        return SCIPisZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisZero(SCIP *scip, double val)
     * }
     */
    public static int SCIPisZero(MemorySegment scip, double val) {
        var mh$ = SCIPisZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisZero", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisPositive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisPositive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisPositive(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisPositive$descriptor() {
        return SCIPisPositive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisPositive(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisPositive$handle() {
        return SCIPisPositive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisPositive(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisPositive$address() {
        return SCIPisPositive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisPositive(SCIP *scip, double val)
     * }
     */
    public static int SCIPisPositive(MemorySegment scip, double val) {
        var mh$ = SCIPisPositive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisPositive", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisNegative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisNegative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisNegative(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisNegative$descriptor() {
        return SCIPisNegative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisNegative(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisNegative$handle() {
        return SCIPisNegative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisNegative(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisNegative$address() {
        return SCIPisNegative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisNegative(SCIP *scip, double val)
     * }
     */
    public static int SCIPisNegative(MemorySegment scip, double val) {
        var mh$ = SCIPisNegative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisNegative", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisIntegral$descriptor() {
        return SCIPisIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisIntegral$handle() {
        return SCIPisIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisIntegral$address() {
        return SCIPisIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisScalingIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisScalingIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisScalingIntegral(SCIP *scip, double val, double scalar)
     * }
     */
    public static FunctionDescriptor SCIPisScalingIntegral$descriptor() {
        return SCIPisScalingIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisScalingIntegral(SCIP *scip, double val, double scalar)
     * }
     */
    public static MethodHandle SCIPisScalingIntegral$handle() {
        return SCIPisScalingIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisScalingIntegral(SCIP *scip, double val, double scalar)
     * }
     */
    public static MemorySegment SCIPisScalingIntegral$address() {
        return SCIPisScalingIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisScalingIntegral(SCIP *scip, double val, double scalar)
     * }
     */
    public static int SCIPisScalingIntegral(MemorySegment scip, double val, double scalar) {
        var mh$ = SCIPisScalingIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisScalingIntegral", scip, val, scalar);
            }
            return (int)mh$.invokeExact(scip, val, scalar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFracIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFracIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFracIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFracIntegral$descriptor() {
        return SCIPisFracIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFracIntegral$handle() {
        return SCIPisFracIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFracIntegral$address() {
        return SCIPisFracIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFracIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFracIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisFracIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFracIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfloor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfloor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfloor(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfloor$descriptor() {
        return SCIPfloor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfloor(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfloor$handle() {
        return SCIPfloor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfloor(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfloor$address() {
        return SCIPfloor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfloor(SCIP *scip, double val)
     * }
     */
    public static double SCIPfloor(MemorySegment scip, double val) {
        var mh$ = SCIPfloor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfloor", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPceil(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPceil$descriptor() {
        return SCIPceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPceil(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPceil$handle() {
        return SCIPceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPceil(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPceil$address() {
        return SCIPceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPceil(SCIP *scip, double val)
     * }
     */
    public static double SCIPceil(MemorySegment scip, double val) {
        var mh$ = SCIPceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPceil", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPround(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPround$descriptor() {
        return SCIPround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPround(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPround$handle() {
        return SCIPround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPround(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPround$address() {
        return SCIPround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPround(SCIP *scip, double val)
     * }
     */
    public static double SCIPround(MemorySegment scip, double val) {
        var mh$ = SCIPround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPround", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfrac(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfrac$descriptor() {
        return SCIPfrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfrac(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfrac$handle() {
        return SCIPfrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfrac(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfrac$address() {
        return SCIPfrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfrac(SCIP *scip, double val)
     * }
     */
    public static double SCIPfrac(MemorySegment scip, double val) {
        var mh$ = SCIPfrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfrac", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumEQ$descriptor() {
        return SCIPisSumEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumEQ$handle() {
        return SCIPisSumEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumEQ$address() {
        return SCIPisSumEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumLT$descriptor() {
        return SCIPisSumLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumLT$handle() {
        return SCIPisSumLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumLT$address() {
        return SCIPisSumLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumLE$descriptor() {
        return SCIPisSumLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumLE$handle() {
        return SCIPisSumLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumLE$address() {
        return SCIPisSumLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumGT$descriptor() {
        return SCIPisSumGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumGT$handle() {
        return SCIPisSumGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumGT$address() {
        return SCIPisSumGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumGE$descriptor() {
        return SCIPisSumGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumGE$handle() {
        return SCIPisSumGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumGE$address() {
        return SCIPisSumGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumZero(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisSumZero$descriptor() {
        return SCIPisSumZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumZero(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisSumZero$handle() {
        return SCIPisSumZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumZero(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisSumZero$address() {
        return SCIPisSumZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumZero(SCIP *scip, double val)
     * }
     */
    public static int SCIPisSumZero(MemorySegment scip, double val) {
        var mh$ = SCIPisSumZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumZero", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumPositive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumPositive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumPositive(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisSumPositive$descriptor() {
        return SCIPisSumPositive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumPositive(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisSumPositive$handle() {
        return SCIPisSumPositive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumPositive(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisSumPositive$address() {
        return SCIPisSumPositive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumPositive(SCIP *scip, double val)
     * }
     */
    public static int SCIPisSumPositive(MemorySegment scip, double val) {
        var mh$ = SCIPisSumPositive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumPositive", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumNegative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumNegative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumNegative(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisSumNegative$descriptor() {
        return SCIPisSumNegative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumNegative(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisSumNegative$handle() {
        return SCIPisSumNegative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumNegative(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisSumNegative$address() {
        return SCIPisSumNegative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumNegative(SCIP *scip, double val)
     * }
     */
    public static int SCIPisSumNegative(MemorySegment scip, double val) {
        var mh$ = SCIPisSumNegative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumNegative", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisFeasEQ$descriptor() {
        return SCIPisFeasEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisFeasEQ$handle() {
        return SCIPisFeasEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisFeasEQ$address() {
        return SCIPisFeasEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisFeasEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisFeasEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisFeasLT$descriptor() {
        return SCIPisFeasLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisFeasLT$handle() {
        return SCIPisFeasLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisFeasLT$address() {
        return SCIPisFeasLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisFeasLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisFeasLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisFeasLE$descriptor() {
        return SCIPisFeasLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisFeasLE$handle() {
        return SCIPisFeasLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisFeasLE$address() {
        return SCIPisFeasLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisFeasLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisFeasLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisFeasGT$descriptor() {
        return SCIPisFeasGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisFeasGT$handle() {
        return SCIPisFeasGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisFeasGT$address() {
        return SCIPisFeasGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisFeasGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisFeasGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisFeasGE$descriptor() {
        return SCIPisFeasGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisFeasGE$handle() {
        return SCIPisFeasGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisFeasGE$address() {
        return SCIPisFeasGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisFeasGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisFeasGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasZero(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFeasZero$descriptor() {
        return SCIPisFeasZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasZero(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFeasZero$handle() {
        return SCIPisFeasZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasZero(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFeasZero$address() {
        return SCIPisFeasZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasZero(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFeasZero(MemorySegment scip, double val) {
        var mh$ = SCIPisFeasZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasZero", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasPositive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasPositive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasPositive(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFeasPositive$descriptor() {
        return SCIPisFeasPositive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasPositive(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFeasPositive$handle() {
        return SCIPisFeasPositive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasPositive(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFeasPositive$address() {
        return SCIPisFeasPositive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasPositive(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFeasPositive(MemorySegment scip, double val) {
        var mh$ = SCIPisFeasPositive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasPositive", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasNegative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasNegative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasNegative(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFeasNegative$descriptor() {
        return SCIPisFeasNegative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasNegative(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFeasNegative$handle() {
        return SCIPisFeasNegative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasNegative(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFeasNegative$address() {
        return SCIPisFeasNegative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasNegative(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFeasNegative(MemorySegment scip, double val) {
        var mh$ = SCIPisFeasNegative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasNegative", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFeasIntegral$descriptor() {
        return SCIPisFeasIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFeasIntegral$handle() {
        return SCIPisFeasIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFeasIntegral$address() {
        return SCIPisFeasIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFeasIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisFeasIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisFeasFracIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisFeasFracIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisFeasFracIntegral$descriptor() {
        return SCIPisFeasFracIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisFeasFracIntegral$handle() {
        return SCIPisFeasFracIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisFeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisFeasFracIntegral$address() {
        return SCIPisFeasFracIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisFeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisFeasFracIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisFeasFracIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisFeasFracIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeasFloor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeasFloor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfeasFloor(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfeasFloor$descriptor() {
        return SCIPfeasFloor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfeasFloor(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfeasFloor$handle() {
        return SCIPfeasFloor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfeasFloor(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfeasFloor$address() {
        return SCIPfeasFloor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfeasFloor(SCIP *scip, double val)
     * }
     */
    public static double SCIPfeasFloor(MemorySegment scip, double val) {
        var mh$ = SCIPfeasFloor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeasFloor", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeasCeil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeasCeil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfeasCeil(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfeasCeil$descriptor() {
        return SCIPfeasCeil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfeasCeil(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfeasCeil$handle() {
        return SCIPfeasCeil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfeasCeil(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfeasCeil$address() {
        return SCIPfeasCeil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfeasCeil(SCIP *scip, double val)
     * }
     */
    public static double SCIPfeasCeil(MemorySegment scip, double val) {
        var mh$ = SCIPfeasCeil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeasCeil", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeasRound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeasRound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfeasRound(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfeasRound$descriptor() {
        return SCIPfeasRound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfeasRound(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfeasRound$handle() {
        return SCIPfeasRound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfeasRound(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfeasRound$address() {
        return SCIPfeasRound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfeasRound(SCIP *scip, double val)
     * }
     */
    public static double SCIPfeasRound(MemorySegment scip, double val) {
        var mh$ = SCIPfeasRound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeasRound", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfeasFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfeasFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPfeasFrac(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPfeasFrac$descriptor() {
        return SCIPfeasFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPfeasFrac(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPfeasFrac$handle() {
        return SCIPfeasFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPfeasFrac(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPfeasFrac$address() {
        return SCIPfeasFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPfeasFrac(SCIP *scip, double val)
     * }
     */
    public static double SCIPfeasFrac(MemorySegment scip, double val) {
        var mh$ = SCIPfeasFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfeasFrac", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasEQ$descriptor() {
        return SCIPisDualfeasEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisDualfeasEQ$handle() {
        return SCIPisDualfeasEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisDualfeasEQ$address() {
        return SCIPisDualfeasEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisDualfeasEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisDualfeasEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasLT$descriptor() {
        return SCIPisDualfeasLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisDualfeasLT$handle() {
        return SCIPisDualfeasLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisDualfeasLT$address() {
        return SCIPisDualfeasLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisDualfeasLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisDualfeasLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasLE$descriptor() {
        return SCIPisDualfeasLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisDualfeasLE$handle() {
        return SCIPisDualfeasLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisDualfeasLE$address() {
        return SCIPisDualfeasLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisDualfeasLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisDualfeasLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasGT$descriptor() {
        return SCIPisDualfeasGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisDualfeasGT$handle() {
        return SCIPisDualfeasGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisDualfeasGT$address() {
        return SCIPisDualfeasGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisDualfeasGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisDualfeasGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasGE$descriptor() {
        return SCIPisDualfeasGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisDualfeasGE$handle() {
        return SCIPisDualfeasGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisDualfeasGE$address() {
        return SCIPisDualfeasGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisDualfeasGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisDualfeasGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasZero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasZero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasZero(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasZero$descriptor() {
        return SCIPisDualfeasZero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasZero(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisDualfeasZero$handle() {
        return SCIPisDualfeasZero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasZero(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisDualfeasZero$address() {
        return SCIPisDualfeasZero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasZero(SCIP *scip, double val)
     * }
     */
    public static int SCIPisDualfeasZero(MemorySegment scip, double val) {
        var mh$ = SCIPisDualfeasZero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasZero", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasPositive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasPositive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasPositive(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasPositive$descriptor() {
        return SCIPisDualfeasPositive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasPositive(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisDualfeasPositive$handle() {
        return SCIPisDualfeasPositive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasPositive(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisDualfeasPositive$address() {
        return SCIPisDualfeasPositive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasPositive(SCIP *scip, double val)
     * }
     */
    public static int SCIPisDualfeasPositive(MemorySegment scip, double val) {
        var mh$ = SCIPisDualfeasPositive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasPositive", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasNegative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasNegative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasNegative(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasNegative$descriptor() {
        return SCIPisDualfeasNegative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasNegative(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisDualfeasNegative$handle() {
        return SCIPisDualfeasNegative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasNegative(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisDualfeasNegative$address() {
        return SCIPisDualfeasNegative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasNegative(SCIP *scip, double val)
     * }
     */
    public static int SCIPisDualfeasNegative(MemorySegment scip, double val) {
        var mh$ = SCIPisDualfeasNegative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasNegative", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasIntegral$descriptor() {
        return SCIPisDualfeasIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisDualfeasIntegral$handle() {
        return SCIPisDualfeasIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisDualfeasIntegral$address() {
        return SCIPisDualfeasIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisDualfeasIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisDualfeasIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualfeasFracIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualfeasFracIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPisDualfeasFracIntegral$descriptor() {
        return SCIPisDualfeasFracIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPisDualfeasFracIntegral$handle() {
        return SCIPisDualfeasFracIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPisDualfeasFracIntegral$address() {
        return SCIPisDualfeasFracIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualfeasFracIntegral(SCIP *scip, double val)
     * }
     */
    public static int SCIPisDualfeasFracIntegral(MemorySegment scip, double val) {
        var mh$ = SCIPisDualfeasFracIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualfeasFracIntegral", scip, val);
            }
            return (int)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdualfeasFloor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdualfeasFloor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdualfeasFloor(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPdualfeasFloor$descriptor() {
        return SCIPdualfeasFloor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdualfeasFloor(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPdualfeasFloor$handle() {
        return SCIPdualfeasFloor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdualfeasFloor(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPdualfeasFloor$address() {
        return SCIPdualfeasFloor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdualfeasFloor(SCIP *scip, double val)
     * }
     */
    public static double SCIPdualfeasFloor(MemorySegment scip, double val) {
        var mh$ = SCIPdualfeasFloor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdualfeasFloor", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdualfeasCeil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdualfeasCeil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdualfeasCeil(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPdualfeasCeil$descriptor() {
        return SCIPdualfeasCeil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdualfeasCeil(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPdualfeasCeil$handle() {
        return SCIPdualfeasCeil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdualfeasCeil(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPdualfeasCeil$address() {
        return SCIPdualfeasCeil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdualfeasCeil(SCIP *scip, double val)
     * }
     */
    public static double SCIPdualfeasCeil(MemorySegment scip, double val) {
        var mh$ = SCIPdualfeasCeil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdualfeasCeil", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdualfeasRound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdualfeasRound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdualfeasRound(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPdualfeasRound$descriptor() {
        return SCIPdualfeasRound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdualfeasRound(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPdualfeasRound$handle() {
        return SCIPdualfeasRound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdualfeasRound(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPdualfeasRound$address() {
        return SCIPdualfeasRound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdualfeasRound(SCIP *scip, double val)
     * }
     */
    public static double SCIPdualfeasRound(MemorySegment scip, double val) {
        var mh$ = SCIPdualfeasRound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdualfeasRound", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdualfeasFrac {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdualfeasFrac");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPdualfeasFrac(SCIP *scip, double val)
     * }
     */
    public static FunctionDescriptor SCIPdualfeasFrac$descriptor() {
        return SCIPdualfeasFrac.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPdualfeasFrac(SCIP *scip, double val)
     * }
     */
    public static MethodHandle SCIPdualfeasFrac$handle() {
        return SCIPdualfeasFrac.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPdualfeasFrac(SCIP *scip, double val)
     * }
     */
    public static MemorySegment SCIPdualfeasFrac$address() {
        return SCIPdualfeasFrac.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPdualfeasFrac(SCIP *scip, double val)
     * }
     */
    public static double SCIPdualfeasFrac(MemorySegment scip, double val) {
        var mh$ = SCIPdualfeasFrac.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdualfeasFrac", scip, val);
            }
            return (double)mh$.invokeExact(scip, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLbBetter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLbBetter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLbBetter(SCIP *scip, double newlb, double oldlb, double oldub)
     * }
     */
    public static FunctionDescriptor SCIPisLbBetter$descriptor() {
        return SCIPisLbBetter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLbBetter(SCIP *scip, double newlb, double oldlb, double oldub)
     * }
     */
    public static MethodHandle SCIPisLbBetter$handle() {
        return SCIPisLbBetter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLbBetter(SCIP *scip, double newlb, double oldlb, double oldub)
     * }
     */
    public static MemorySegment SCIPisLbBetter$address() {
        return SCIPisLbBetter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLbBetter(SCIP *scip, double newlb, double oldlb, double oldub)
     * }
     */
    public static int SCIPisLbBetter(MemorySegment scip, double newlb, double oldlb, double oldub) {
        var mh$ = SCIPisLbBetter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLbBetter", scip, newlb, oldlb, oldub);
            }
            return (int)mh$.invokeExact(scip, newlb, oldlb, oldub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisUbBetter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisUbBetter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisUbBetter(SCIP *scip, double newub, double oldlb, double oldub)
     * }
     */
    public static FunctionDescriptor SCIPisUbBetter$descriptor() {
        return SCIPisUbBetter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisUbBetter(SCIP *scip, double newub, double oldlb, double oldub)
     * }
     */
    public static MethodHandle SCIPisUbBetter$handle() {
        return SCIPisUbBetter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisUbBetter(SCIP *scip, double newub, double oldlb, double oldub)
     * }
     */
    public static MemorySegment SCIPisUbBetter$address() {
        return SCIPisUbBetter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisUbBetter(SCIP *scip, double newub, double oldlb, double oldub)
     * }
     */
    public static int SCIPisUbBetter(MemorySegment scip, double newub, double oldlb, double oldub) {
        var mh$ = SCIPisUbBetter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisUbBetter", scip, newub, oldlb, oldub);
            }
            return (int)mh$.invokeExact(scip, newub, oldlb, oldub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisRelEQ$descriptor() {
        return SCIPisRelEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisRelEQ$handle() {
        return SCIPisRelEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisRelEQ$address() {
        return SCIPisRelEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisRelEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisRelEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisRelLT$descriptor() {
        return SCIPisRelLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisRelLT$handle() {
        return SCIPisRelLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisRelLT$address() {
        return SCIPisRelLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisRelLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisRelLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisRelLE$descriptor() {
        return SCIPisRelLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisRelLE$handle() {
        return SCIPisRelLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisRelLE$address() {
        return SCIPisRelLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisRelLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisRelLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisRelGT$descriptor() {
        return SCIPisRelGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisRelGT$handle() {
        return SCIPisRelGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisRelGT$address() {
        return SCIPisRelGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisRelGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisRelGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRelGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRelGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisRelGE$descriptor() {
        return SCIPisRelGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisRelGE$handle() {
        return SCIPisRelGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisRelGE$address() {
        return SCIPisRelGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisRelGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisRelGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRelGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumRelEQ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumRelEQ");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumRelEQ$descriptor() {
        return SCIPisSumRelEQ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumRelEQ$handle() {
        return SCIPisSumRelEQ.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumRelEQ$address() {
        return SCIPisSumRelEQ.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelEQ(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumRelEQ(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumRelEQ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumRelEQ", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumRelLT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumRelLT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumRelLT$descriptor() {
        return SCIPisSumRelLT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumRelLT$handle() {
        return SCIPisSumRelLT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumRelLT$address() {
        return SCIPisSumRelLT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumRelLT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumRelLT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumRelLT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumRelLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumRelLE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumRelLE$descriptor() {
        return SCIPisSumRelLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumRelLE$handle() {
        return SCIPisSumRelLE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumRelLE$address() {
        return SCIPisSumRelLE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelLE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumRelLE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumRelLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumRelLE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumRelGT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumRelGT");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumRelGT$descriptor() {
        return SCIPisSumRelGT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumRelGT$handle() {
        return SCIPisSumRelGT.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumRelGT$address() {
        return SCIPisSumRelGT.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGT(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumRelGT(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumRelGT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumRelGT", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSumRelGE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSumRelGE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static FunctionDescriptor SCIPisSumRelGE$descriptor() {
        return SCIPisSumRelGE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MethodHandle SCIPisSumRelGE$handle() {
        return SCIPisSumRelGE.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static MemorySegment SCIPisSumRelGE$address() {
        return SCIPisSumRelGE.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSumRelGE(SCIP *scip, double val1, double val2)
     * }
     */
    public static int SCIPisSumRelGE(MemorySegment scip, double val1, double val2) {
        var mh$ = SCIPisSumRelGE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSumRelGE", scip, val1, val2);
            }
            return (int)mh$.invokeExact(scip, val1, val2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconvertRealToInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconvertRealToInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPconvertRealToInt(SCIP *scip, double real)
     * }
     */
    public static FunctionDescriptor SCIPconvertRealToInt$descriptor() {
        return SCIPconvertRealToInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPconvertRealToInt(SCIP *scip, double real)
     * }
     */
    public static MethodHandle SCIPconvertRealToInt$handle() {
        return SCIPconvertRealToInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPconvertRealToInt(SCIP *scip, double real)
     * }
     */
    public static MemorySegment SCIPconvertRealToInt$address() {
        return SCIPconvertRealToInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPconvertRealToInt(SCIP *scip, double real)
     * }
     */
    public static int SCIPconvertRealToInt(MemorySegment scip, double real) {
        var mh$ = SCIPconvertRealToInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconvertRealToInt", scip, real);
            }
            return (int)mh$.invokeExact(scip, real);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPconvertRealToLongint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPconvertRealToLongint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPconvertRealToLongint(SCIP *scip, double real)
     * }
     */
    public static FunctionDescriptor SCIPconvertRealToLongint$descriptor() {
        return SCIPconvertRealToLongint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPconvertRealToLongint(SCIP *scip, double real)
     * }
     */
    public static MethodHandle SCIPconvertRealToLongint$handle() {
        return SCIPconvertRealToLongint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPconvertRealToLongint(SCIP *scip, double real)
     * }
     */
    public static MemorySegment SCIPconvertRealToLongint$address() {
        return SCIPconvertRealToLongint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPconvertRealToLongint(SCIP *scip, double real)
     * }
     */
    public static long SCIPconvertRealToLongint(MemorySegment scip, double real) {
        var mh$ = SCIPconvertRealToLongint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPconvertRealToLongint", scip, real);
            }
            return (long)mh$.invokeExact(scip, real);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisUpdateUnreliable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisUpdateUnreliable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisUpdateUnreliable(SCIP *scip, double newvalue, double oldvalue)
     * }
     */
    public static FunctionDescriptor SCIPisUpdateUnreliable$descriptor() {
        return SCIPisUpdateUnreliable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisUpdateUnreliable(SCIP *scip, double newvalue, double oldvalue)
     * }
     */
    public static MethodHandle SCIPisUpdateUnreliable$handle() {
        return SCIPisUpdateUnreliable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisUpdateUnreliable(SCIP *scip, double newvalue, double oldvalue)
     * }
     */
    public static MemorySegment SCIPisUpdateUnreliable$address() {
        return SCIPisUpdateUnreliable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisUpdateUnreliable(SCIP *scip, double newvalue, double oldvalue)
     * }
     */
    public static int SCIPisUpdateUnreliable(MemorySegment scip, double newvalue, double oldvalue) {
        var mh$ = SCIPisUpdateUnreliable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisUpdateUnreliable", scip, newvalue, oldvalue);
            }
            return (int)mh$.invokeExact(scip, newvalue, oldvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintReal(SCIP *scip, FILE *file, double val, int width, int precision)
     * }
     */
    public static FunctionDescriptor SCIPprintReal$descriptor() {
        return SCIPprintReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintReal(SCIP *scip, FILE *file, double val, int width, int precision)
     * }
     */
    public static MethodHandle SCIPprintReal$handle() {
        return SCIPprintReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintReal(SCIP *scip, FILE *file, double val, int width, int precision)
     * }
     */
    public static MemorySegment SCIPprintReal$address() {
        return SCIPprintReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintReal(SCIP *scip, FILE *file, double val, int width, int precision)
     * }
     */
    public static void SCIPprintReal(MemorySegment scip, MemorySegment file, double val, int width, int precision) {
        var mh$ = SCIPprintReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintReal", scip, file, val, width, precision);
            }
            mh$.invokeExact(scip, file, val, width, precision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseReal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseReal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPparseReal(SCIP *scip, const char *str, double *value, char **endptr)
     * }
     */
    public static FunctionDescriptor SCIPparseReal$descriptor() {
        return SCIPparseReal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPparseReal(SCIP *scip, const char *str, double *value, char **endptr)
     * }
     */
    public static MethodHandle SCIPparseReal$handle() {
        return SCIPparseReal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPparseReal(SCIP *scip, const char *str, double *value, char **endptr)
     * }
     */
    public static MemorySegment SCIPparseReal$address() {
        return SCIPparseReal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPparseReal(SCIP *scip, const char *str, double *value, char **endptr)
     * }
     */
    public static int SCIPparseReal(MemorySegment scip, MemorySegment str, MemorySegment value, MemorySegment endptr) {
        var mh$ = SCIPparseReal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseReal", scip, str, value, endptr);
            }
            return (int)mh$.invokeExact(scip, str, value, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddBoolParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddBoolParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBoolParam(SCIP *scip, const char *name, const char *desc, unsigned int *valueptr, unsigned int isadvanced, unsigned int defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddBoolParam$descriptor() {
        return SCIPaddBoolParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBoolParam(SCIP *scip, const char *name, const char *desc, unsigned int *valueptr, unsigned int isadvanced, unsigned int defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddBoolParam$handle() {
        return SCIPaddBoolParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBoolParam(SCIP *scip, const char *name, const char *desc, unsigned int *valueptr, unsigned int isadvanced, unsigned int defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddBoolParam$address() {
        return SCIPaddBoolParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddBoolParam(SCIP *scip, const char *name, const char *desc, unsigned int *valueptr, unsigned int isadvanced, unsigned int defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddBoolParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, int defaultvalue, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddBoolParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddBoolParam", scip, name, desc, valueptr, isadvanced, defaultvalue, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddIntParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddIntParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIntParam(SCIP *scip, const char *name, const char *desc, int *valueptr, unsigned int isadvanced, int defaultvalue, int minvalue, int maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddIntParam$descriptor() {
        return SCIPaddIntParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIntParam(SCIP *scip, const char *name, const char *desc, int *valueptr, unsigned int isadvanced, int defaultvalue, int minvalue, int maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddIntParam$handle() {
        return SCIPaddIntParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIntParam(SCIP *scip, const char *name, const char *desc, int *valueptr, unsigned int isadvanced, int defaultvalue, int minvalue, int maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddIntParam$address() {
        return SCIPaddIntParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddIntParam(SCIP *scip, const char *name, const char *desc, int *valueptr, unsigned int isadvanced, int defaultvalue, int minvalue, int maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddIntParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, int defaultvalue, int minvalue, int maxvalue, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddIntParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddIntParam", scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddLongintParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddLongintParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLongintParam(SCIP *scip, const char *name, const char *desc, long long *valueptr, unsigned int isadvanced, long long defaultvalue, long long minvalue, long long maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddLongintParam$descriptor() {
        return SCIPaddLongintParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLongintParam(SCIP *scip, const char *name, const char *desc, long long *valueptr, unsigned int isadvanced, long long defaultvalue, long long minvalue, long long maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddLongintParam$handle() {
        return SCIPaddLongintParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLongintParam(SCIP *scip, const char *name, const char *desc, long long *valueptr, unsigned int isadvanced, long long defaultvalue, long long minvalue, long long maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddLongintParam$address() {
        return SCIPaddLongintParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddLongintParam(SCIP *scip, const char *name, const char *desc, long long *valueptr, unsigned int isadvanced, long long defaultvalue, long long minvalue, long long maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddLongintParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, long defaultvalue, long minvalue, long maxvalue, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddLongintParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddLongintParam", scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRealParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRealParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRealParam(SCIP *scip, const char *name, const char *desc, double *valueptr, unsigned int isadvanced, double defaultvalue, double minvalue, double maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddRealParam$descriptor() {
        return SCIPaddRealParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRealParam(SCIP *scip, const char *name, const char *desc, double *valueptr, unsigned int isadvanced, double defaultvalue, double minvalue, double maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddRealParam$handle() {
        return SCIPaddRealParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRealParam(SCIP *scip, const char *name, const char *desc, double *valueptr, unsigned int isadvanced, double defaultvalue, double minvalue, double maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddRealParam$address() {
        return SCIPaddRealParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRealParam(SCIP *scip, const char *name, const char *desc, double *valueptr, unsigned int isadvanced, double defaultvalue, double minvalue, double maxvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddRealParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, double defaultvalue, double minvalue, double maxvalue, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddRealParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRealParam", scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, minvalue, maxvalue, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCharParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_CHAR,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCharParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCharParam(SCIP *scip, const char *name, const char *desc, char *valueptr, unsigned int isadvanced, char defaultvalue, const char *allowedvalues, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddCharParam$descriptor() {
        return SCIPaddCharParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCharParam(SCIP *scip, const char *name, const char *desc, char *valueptr, unsigned int isadvanced, char defaultvalue, const char *allowedvalues, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddCharParam$handle() {
        return SCIPaddCharParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCharParam(SCIP *scip, const char *name, const char *desc, char *valueptr, unsigned int isadvanced, char defaultvalue, const char *allowedvalues, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddCharParam$address() {
        return SCIPaddCharParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCharParam(SCIP *scip, const char *name, const char *desc, char *valueptr, unsigned int isadvanced, char defaultvalue, const char *allowedvalues, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddCharParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, byte defaultvalue, MemorySegment allowedvalues, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddCharParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCharParam", scip, name, desc, valueptr, isadvanced, defaultvalue, allowedvalues, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, allowedvalues, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddStringParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddStringParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddStringParam(SCIP *scip, const char *name, const char *desc, char **valueptr, unsigned int isadvanced, const char *defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static FunctionDescriptor SCIPaddStringParam$descriptor() {
        return SCIPaddStringParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddStringParam(SCIP *scip, const char *name, const char *desc, char **valueptr, unsigned int isadvanced, const char *defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MethodHandle SCIPaddStringParam$handle() {
        return SCIPaddStringParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddStringParam(SCIP *scip, const char *name, const char *desc, char **valueptr, unsigned int isadvanced, const char *defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static MemorySegment SCIPaddStringParam$address() {
        return SCIPaddStringParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddStringParam(SCIP *scip, const char *name, const char *desc, char **valueptr, unsigned int isadvanced, const char *defaultvalue, SCIP_RETCODE (*paramchgd)(SCIP *, SCIP_PARAM *), SCIP_PARAMDATA *paramdata)
     * }
     */
    public static int SCIPaddStringParam(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment valueptr, int isadvanced, MemorySegment defaultvalue, MemorySegment paramchgd, MemorySegment paramdata) {
        var mh$ = SCIPaddStringParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddStringParam", scip, name, desc, valueptr, isadvanced, defaultvalue, paramchgd, paramdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, valueptr, isadvanced, defaultvalue, paramchgd, paramdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisParamFixed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisParamFixed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisParamFixed(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPisParamFixed$descriptor() {
        return SCIPisParamFixed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisParamFixed(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPisParamFixed$handle() {
        return SCIPisParamFixed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisParamFixed(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPisParamFixed$address() {
        return SCIPisParamFixed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisParamFixed(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPisParamFixed(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPisParamFixed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisParamFixed", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PARAM *SCIPgetParam(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPgetParam$descriptor() {
        return SCIPgetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PARAM *SCIPgetParam(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPgetParam$handle() {
        return SCIPgetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PARAM *SCIPgetParam(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPgetParam$address() {
        return SCIPgetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PARAM *SCIPgetParam(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPgetParam(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPgetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetParam", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBoolParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBoolParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBoolParam(SCIP *scip, const char *name, unsigned int *value)
     * }
     */
    public static FunctionDescriptor SCIPgetBoolParam$descriptor() {
        return SCIPgetBoolParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBoolParam(SCIP *scip, const char *name, unsigned int *value)
     * }
     */
    public static MethodHandle SCIPgetBoolParam$handle() {
        return SCIPgetBoolParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBoolParam(SCIP *scip, const char *name, unsigned int *value)
     * }
     */
    public static MemorySegment SCIPgetBoolParam$address() {
        return SCIPgetBoolParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBoolParam(SCIP *scip, const char *name, unsigned int *value)
     * }
     */
    public static int SCIPgetBoolParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetBoolParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBoolParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetIntParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetIntParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetIntParam(SCIP *scip, const char *name, int *value)
     * }
     */
    public static FunctionDescriptor SCIPgetIntParam$descriptor() {
        return SCIPgetIntParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetIntParam(SCIP *scip, const char *name, int *value)
     * }
     */
    public static MethodHandle SCIPgetIntParam$handle() {
        return SCIPgetIntParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetIntParam(SCIP *scip, const char *name, int *value)
     * }
     */
    public static MemorySegment SCIPgetIntParam$address() {
        return SCIPgetIntParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetIntParam(SCIP *scip, const char *name, int *value)
     * }
     */
    public static int SCIPgetIntParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetIntParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetIntParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLongintParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLongintParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLongintParam(SCIP *scip, const char *name, long long *value)
     * }
     */
    public static FunctionDescriptor SCIPgetLongintParam$descriptor() {
        return SCIPgetLongintParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLongintParam(SCIP *scip, const char *name, long long *value)
     * }
     */
    public static MethodHandle SCIPgetLongintParam$handle() {
        return SCIPgetLongintParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLongintParam(SCIP *scip, const char *name, long long *value)
     * }
     */
    public static MemorySegment SCIPgetLongintParam$address() {
        return SCIPgetLongintParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLongintParam(SCIP *scip, const char *name, long long *value)
     * }
     */
    public static int SCIPgetLongintParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetLongintParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLongintParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRealParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRealParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRealParam(SCIP *scip, const char *name, double *value)
     * }
     */
    public static FunctionDescriptor SCIPgetRealParam$descriptor() {
        return SCIPgetRealParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRealParam(SCIP *scip, const char *name, double *value)
     * }
     */
    public static MethodHandle SCIPgetRealParam$handle() {
        return SCIPgetRealParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRealParam(SCIP *scip, const char *name, double *value)
     * }
     */
    public static MemorySegment SCIPgetRealParam$address() {
        return SCIPgetRealParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetRealParam(SCIP *scip, const char *name, double *value)
     * }
     */
    public static int SCIPgetRealParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetRealParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRealParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCharParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCharParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetCharParam(SCIP *scip, const char *name, char *value)
     * }
     */
    public static FunctionDescriptor SCIPgetCharParam$descriptor() {
        return SCIPgetCharParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetCharParam(SCIP *scip, const char *name, char *value)
     * }
     */
    public static MethodHandle SCIPgetCharParam$handle() {
        return SCIPgetCharParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetCharParam(SCIP *scip, const char *name, char *value)
     * }
     */
    public static MemorySegment SCIPgetCharParam$address() {
        return SCIPgetCharParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetCharParam(SCIP *scip, const char *name, char *value)
     * }
     */
    public static int SCIPgetCharParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetCharParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCharParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetStringParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetStringParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetStringParam(SCIP *scip, const char *name, char **value)
     * }
     */
    public static FunctionDescriptor SCIPgetStringParam$descriptor() {
        return SCIPgetStringParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetStringParam(SCIP *scip, const char *name, char **value)
     * }
     */
    public static MethodHandle SCIPgetStringParam$handle() {
        return SCIPgetStringParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetStringParam(SCIP *scip, const char *name, char **value)
     * }
     */
    public static MemorySegment SCIPgetStringParam$address() {
        return SCIPgetStringParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetStringParam(SCIP *scip, const char *name, char **value)
     * }
     */
    public static int SCIPgetStringParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPgetStringParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetStringParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfixParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfixParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixParam(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfixParam$descriptor() {
        return SCIPfixParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixParam(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfixParam$handle() {
        return SCIPfixParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixParam(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfixParam$address() {
        return SCIPfixParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixParam(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPfixParam(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfixParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfixParam", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPunfixParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPunfixParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunfixParam(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPunfixParam$descriptor() {
        return SCIPunfixParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunfixParam(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPunfixParam$handle() {
        return SCIPunfixParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunfixParam(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPunfixParam$address() {
        return SCIPunfixParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunfixParam(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPunfixParam(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPunfixParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPunfixParam", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgBoolParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgBoolParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBoolParam(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static FunctionDescriptor SCIPchgBoolParam$descriptor() {
        return SCIPchgBoolParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBoolParam(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static MethodHandle SCIPchgBoolParam$handle() {
        return SCIPchgBoolParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBoolParam(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static MemorySegment SCIPchgBoolParam$address() {
        return SCIPchgBoolParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgBoolParam(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static int SCIPchgBoolParam(MemorySegment scip, MemorySegment param, int value) {
        var mh$ = SCIPchgBoolParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgBoolParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetBoolParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetBoolParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolParam(SCIP *scip, const char *name, unsigned int value)
     * }
     */
    public static FunctionDescriptor SCIPsetBoolParam$descriptor() {
        return SCIPsetBoolParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolParam(SCIP *scip, const char *name, unsigned int value)
     * }
     */
    public static MethodHandle SCIPsetBoolParam$handle() {
        return SCIPsetBoolParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolParam(SCIP *scip, const char *name, unsigned int value)
     * }
     */
    public static MemorySegment SCIPsetBoolParam$address() {
        return SCIPsetBoolParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetBoolParam(SCIP *scip, const char *name, unsigned int value)
     * }
     */
    public static int SCIPsetBoolParam(MemorySegment scip, MemorySegment name, int value) {
        var mh$ = SCIPsetBoolParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetBoolParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisBoolParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisBoolParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisBoolParamValid(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static FunctionDescriptor SCIPisBoolParamValid$descriptor() {
        return SCIPisBoolParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisBoolParamValid(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static MethodHandle SCIPisBoolParamValid$handle() {
        return SCIPisBoolParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisBoolParamValid(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static MemorySegment SCIPisBoolParamValid$address() {
        return SCIPisBoolParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisBoolParamValid(SCIP *scip, SCIP_PARAM *param, unsigned int value)
     * }
     */
    public static int SCIPisBoolParamValid(MemorySegment scip, MemorySegment param, int value) {
        var mh$ = SCIPisBoolParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisBoolParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgIntParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgIntParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgIntParam(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static FunctionDescriptor SCIPchgIntParam$descriptor() {
        return SCIPchgIntParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgIntParam(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static MethodHandle SCIPchgIntParam$handle() {
        return SCIPchgIntParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgIntParam(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static MemorySegment SCIPchgIntParam$address() {
        return SCIPchgIntParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgIntParam(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static int SCIPchgIntParam(MemorySegment scip, MemorySegment param, int value) {
        var mh$ = SCIPchgIntParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgIntParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetIntParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetIntParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntParam(SCIP *scip, const char *name, int value)
     * }
     */
    public static FunctionDescriptor SCIPsetIntParam$descriptor() {
        return SCIPsetIntParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntParam(SCIP *scip, const char *name, int value)
     * }
     */
    public static MethodHandle SCIPsetIntParam$handle() {
        return SCIPsetIntParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntParam(SCIP *scip, const char *name, int value)
     * }
     */
    public static MemorySegment SCIPsetIntParam$address() {
        return SCIPsetIntParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetIntParam(SCIP *scip, const char *name, int value)
     * }
     */
    public static int SCIPsetIntParam(MemorySegment scip, MemorySegment name, int value) {
        var mh$ = SCIPsetIntParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetIntParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisIntParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisIntParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntParamValid(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static FunctionDescriptor SCIPisIntParamValid$descriptor() {
        return SCIPisIntParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntParamValid(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static MethodHandle SCIPisIntParamValid$handle() {
        return SCIPisIntParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisIntParamValid(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static MemorySegment SCIPisIntParamValid$address() {
        return SCIPisIntParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisIntParamValid(SCIP *scip, SCIP_PARAM *param, int value)
     * }
     */
    public static int SCIPisIntParamValid(MemorySegment scip, MemorySegment param, int value) {
        var mh$ = SCIPisIntParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisIntParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgLongintParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgLongintParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLongintParam(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static FunctionDescriptor SCIPchgLongintParam$descriptor() {
        return SCIPchgLongintParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLongintParam(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static MethodHandle SCIPchgLongintParam$handle() {
        return SCIPchgLongintParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLongintParam(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static MemorySegment SCIPchgLongintParam$address() {
        return SCIPchgLongintParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgLongintParam(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static int SCIPchgLongintParam(MemorySegment scip, MemorySegment param, long value) {
        var mh$ = SCIPchgLongintParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgLongintParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetLongintParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetLongintParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLongintParam(SCIP *scip, const char *name, long long value)
     * }
     */
    public static FunctionDescriptor SCIPsetLongintParam$descriptor() {
        return SCIPsetLongintParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLongintParam(SCIP *scip, const char *name, long long value)
     * }
     */
    public static MethodHandle SCIPsetLongintParam$handle() {
        return SCIPsetLongintParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLongintParam(SCIP *scip, const char *name, long long value)
     * }
     */
    public static MemorySegment SCIPsetLongintParam$address() {
        return SCIPsetLongintParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetLongintParam(SCIP *scip, const char *name, long long value)
     * }
     */
    public static int SCIPsetLongintParam(MemorySegment scip, MemorySegment name, long value) {
        var mh$ = SCIPsetLongintParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetLongintParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisLongintParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisLongintParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisLongintParamValid(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static FunctionDescriptor SCIPisLongintParamValid$descriptor() {
        return SCIPisLongintParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisLongintParamValid(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static MethodHandle SCIPisLongintParamValid$handle() {
        return SCIPisLongintParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisLongintParamValid(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static MemorySegment SCIPisLongintParamValid$address() {
        return SCIPisLongintParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisLongintParamValid(SCIP *scip, SCIP_PARAM *param, long long value)
     * }
     */
    public static int SCIPisLongintParamValid(MemorySegment scip, MemorySegment param, long value) {
        var mh$ = SCIPisLongintParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisLongintParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgRealParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgRealParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRealParam(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static FunctionDescriptor SCIPchgRealParam$descriptor() {
        return SCIPchgRealParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRealParam(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static MethodHandle SCIPchgRealParam$handle() {
        return SCIPchgRealParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRealParam(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static MemorySegment SCIPchgRealParam$address() {
        return SCIPchgRealParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgRealParam(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static int SCIPchgRealParam(MemorySegment scip, MemorySegment param, double value) {
        var mh$ = SCIPchgRealParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgRealParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRealParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRealParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealParam(SCIP *scip, const char *name, double value)
     * }
     */
    public static FunctionDescriptor SCIPsetRealParam$descriptor() {
        return SCIPsetRealParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealParam(SCIP *scip, const char *name, double value)
     * }
     */
    public static MethodHandle SCIPsetRealParam$handle() {
        return SCIPsetRealParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealParam(SCIP *scip, const char *name, double value)
     * }
     */
    public static MemorySegment SCIPsetRealParam$address() {
        return SCIPsetRealParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRealParam(SCIP *scip, const char *name, double value)
     * }
     */
    public static int SCIPsetRealParam(MemorySegment scip, MemorySegment name, double value) {
        var mh$ = SCIPsetRealParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRealParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisRealParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisRealParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisRealParamValid(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static FunctionDescriptor SCIPisRealParamValid$descriptor() {
        return SCIPisRealParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisRealParamValid(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static MethodHandle SCIPisRealParamValid$handle() {
        return SCIPisRealParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisRealParamValid(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static MemorySegment SCIPisRealParamValid$address() {
        return SCIPisRealParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisRealParamValid(SCIP *scip, SCIP_PARAM *param, double value)
     * }
     */
    public static int SCIPisRealParamValid(MemorySegment scip, MemorySegment param, double value) {
        var mh$ = SCIPisRealParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisRealParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgCharParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgCharParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCharParam(SCIP *scip, SCIP_PARAM *param, char value)
     * }
     */
    public static FunctionDescriptor SCIPchgCharParam$descriptor() {
        return SCIPchgCharParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCharParam(SCIP *scip, SCIP_PARAM *param, char value)
     * }
     */
    public static MethodHandle SCIPchgCharParam$handle() {
        return SCIPchgCharParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCharParam(SCIP *scip, SCIP_PARAM *param, char value)
     * }
     */
    public static MemorySegment SCIPchgCharParam$address() {
        return SCIPchgCharParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgCharParam(SCIP *scip, SCIP_PARAM *param, char value)
     * }
     */
    public static int SCIPchgCharParam(MemorySegment scip, MemorySegment param, byte value) {
        var mh$ = SCIPchgCharParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgCharParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCharParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCharParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCharParam(SCIP *scip, const char *name, char value)
     * }
     */
    public static FunctionDescriptor SCIPsetCharParam$descriptor() {
        return SCIPsetCharParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCharParam(SCIP *scip, const char *name, char value)
     * }
     */
    public static MethodHandle SCIPsetCharParam$handle() {
        return SCIPsetCharParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCharParam(SCIP *scip, const char *name, char value)
     * }
     */
    public static MemorySegment SCIPsetCharParam$address() {
        return SCIPsetCharParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCharParam(SCIP *scip, const char *name, char value)
     * }
     */
    public static int SCIPsetCharParam(MemorySegment scip, MemorySegment name, byte value) {
        var mh$ = SCIPsetCharParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCharParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisCharParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisCharParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisCharParamValid(SCIP *scip, SCIP_PARAM *param, const char value)
     * }
     */
    public static FunctionDescriptor SCIPisCharParamValid$descriptor() {
        return SCIPisCharParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisCharParamValid(SCIP *scip, SCIP_PARAM *param, const char value)
     * }
     */
    public static MethodHandle SCIPisCharParamValid$handle() {
        return SCIPisCharParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisCharParamValid(SCIP *scip, SCIP_PARAM *param, const char value)
     * }
     */
    public static MemorySegment SCIPisCharParamValid$address() {
        return SCIPisCharParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisCharParamValid(SCIP *scip, SCIP_PARAM *param, const char value)
     * }
     */
    public static int SCIPisCharParamValid(MemorySegment scip, MemorySegment param, byte value) {
        var mh$ = SCIPisCharParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisCharParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgStringParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgStringParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgStringParam(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static FunctionDescriptor SCIPchgStringParam$descriptor() {
        return SCIPchgStringParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgStringParam(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static MethodHandle SCIPchgStringParam$handle() {
        return SCIPchgStringParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgStringParam(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static MemorySegment SCIPchgStringParam$address() {
        return SCIPchgStringParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgStringParam(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static int SCIPchgStringParam(MemorySegment scip, MemorySegment param, MemorySegment value) {
        var mh$ = SCIPchgStringParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgStringParam", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetStringParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetStringParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetStringParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor SCIPsetStringParam$descriptor() {
        return SCIPsetStringParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetStringParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static MethodHandle SCIPsetStringParam$handle() {
        return SCIPsetStringParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetStringParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static MemorySegment SCIPsetStringParam$address() {
        return SCIPsetStringParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetStringParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static int SCIPsetStringParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPsetStringParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetStringParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisStringParamValid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisStringParamValid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisStringParamValid(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static FunctionDescriptor SCIPisStringParamValid$descriptor() {
        return SCIPisStringParamValid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisStringParamValid(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static MethodHandle SCIPisStringParamValid$handle() {
        return SCIPisStringParamValid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisStringParamValid(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static MemorySegment SCIPisStringParamValid$address() {
        return SCIPisStringParamValid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisStringParamValid(SCIP *scip, SCIP_PARAM *param, const char *value)
     * }
     */
    public static int SCIPisStringParamValid(MemorySegment scip, MemorySegment param, MemorySegment value) {
        var mh$ = SCIPisStringParamValid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisStringParamValid", scip, param, value);
            }
            return (int)mh$.invokeExact(scip, param, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static FunctionDescriptor SCIPsetParam$descriptor() {
        return SCIPsetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static MethodHandle SCIPsetParam$handle() {
        return SCIPsetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static MemorySegment SCIPsetParam$address() {
        return SCIPsetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetParam(SCIP *scip, const char *name, const char *value)
     * }
     */
    public static int SCIPsetParam(MemorySegment scip, MemorySegment name, MemorySegment value) {
        var mh$ = SCIPsetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetParam", scip, name, value);
            }
            return (int)mh$.invokeExact(scip, name, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadParams(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPreadParams$descriptor() {
        return SCIPreadParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadParams(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPreadParams$handle() {
        return SCIPreadParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadParams(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPreadParams$address() {
        return SCIPreadParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadParams(SCIP *scip, const char *filename)
     * }
     */
    public static int SCIPreadParams(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPreadParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadParams", scip, filename);
            }
            return (int)mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParam(SCIP *scip, SCIP_PARAM *param, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static FunctionDescriptor SCIPwriteParam$descriptor() {
        return SCIPwriteParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParam(SCIP *scip, SCIP_PARAM *param, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static MethodHandle SCIPwriteParam$handle() {
        return SCIPwriteParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParam(SCIP *scip, SCIP_PARAM *param, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static MemorySegment SCIPwriteParam$address() {
        return SCIPwriteParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParam(SCIP *scip, SCIP_PARAM *param, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static int SCIPwriteParam(MemorySegment scip, MemorySegment param, MemorySegment filename, int comments, int onlychanged) {
        var mh$ = SCIPwriteParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteParam", scip, param, filename, comments, onlychanged);
            }
            return (int)mh$.invokeExact(scip, param, filename, comments, onlychanged);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParams(SCIP *scip, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static FunctionDescriptor SCIPwriteParams$descriptor() {
        return SCIPwriteParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParams(SCIP *scip, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static MethodHandle SCIPwriteParams$handle() {
        return SCIPwriteParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParams(SCIP *scip, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static MemorySegment SCIPwriteParams$address() {
        return SCIPwriteParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteParams(SCIP *scip, const char *filename, unsigned int comments, unsigned int onlychanged)
     * }
     */
    public static int SCIPwriteParams(MemorySegment scip, MemorySegment filename, int comments, int onlychanged) {
        var mh$ = SCIPwriteParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteParams", scip, filename, comments, onlychanged);
            }
            return (int)mh$.invokeExact(scip, filename, comments, onlychanged);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetParam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParam(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPresetParam$descriptor() {
        return SCIPresetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParam(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPresetParam$handle() {
        return SCIPresetParam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParam(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPresetParam$address() {
        return SCIPresetParam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParam(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPresetParam(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPresetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetParam", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParams(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPresetParams$descriptor() {
        return SCIPresetParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParams(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPresetParams$handle() {
        return SCIPresetParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParams(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPresetParams$address() {
        return SCIPresetParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetParams(SCIP *scip)
     * }
     */
    public static int SCIPresetParams(MemorySegment scip) {
        var mh$ = SCIPresetParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetParams", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetEmphasis {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetEmphasis");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEmphasis(SCIP *scip, SCIP_PARAMEMPHASIS paramemphasis, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetEmphasis$descriptor() {
        return SCIPsetEmphasis.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEmphasis(SCIP *scip, SCIP_PARAMEMPHASIS paramemphasis, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetEmphasis$handle() {
        return SCIPsetEmphasis.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEmphasis(SCIP *scip, SCIP_PARAMEMPHASIS paramemphasis, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetEmphasis$address() {
        return SCIPsetEmphasis.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetEmphasis(SCIP *scip, SCIP_PARAMEMPHASIS paramemphasis, unsigned int quiet)
     * }
     */
    public static int SCIPsetEmphasis(MemorySegment scip, int paramemphasis, int quiet) {
        var mh$ = SCIPsetEmphasis.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetEmphasis", scip, paramemphasis, quiet);
            }
            return (int)mh$.invokeExact(scip, paramemphasis, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSubscipsOff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSubscipsOff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSubscipsOff(SCIP *scip, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetSubscipsOff$descriptor() {
        return SCIPsetSubscipsOff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSubscipsOff(SCIP *scip, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetSubscipsOff$handle() {
        return SCIPsetSubscipsOff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSubscipsOff(SCIP *scip, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetSubscipsOff$address() {
        return SCIPsetSubscipsOff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSubscipsOff(SCIP *scip, unsigned int quiet)
     * }
     */
    public static int SCIPsetSubscipsOff(MemorySegment scip, int quiet) {
        var mh$ = SCIPsetSubscipsOff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSubscipsOff", scip, quiet);
            }
            return (int)mh$.invokeExact(scip, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetHeuristics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetHeuristics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeuristics(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetHeuristics$descriptor() {
        return SCIPsetHeuristics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeuristics(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetHeuristics$handle() {
        return SCIPsetHeuristics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeuristics(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetHeuristics$address() {
        return SCIPsetHeuristics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetHeuristics(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static int SCIPsetHeuristics(MemorySegment scip, int paramsetting, int quiet) {
        var mh$ = SCIPsetHeuristics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetHeuristics", scip, paramsetting, quiet);
            }
            return (int)mh$.invokeExact(scip, paramsetting, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolving {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolving");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolving(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetPresolving$descriptor() {
        return SCIPsetPresolving.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolving(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetPresolving$handle() {
        return SCIPsetPresolving.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolving(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetPresolving$address() {
        return SCIPsetPresolving.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolving(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static int SCIPsetPresolving(MemorySegment scip, int paramsetting, int quiet) {
        var mh$ = SCIPsetPresolving.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolving", scip, paramsetting, quiet);
            }
            return (int)mh$.invokeExact(scip, paramsetting, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSeparating {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSeparating");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSeparating(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static FunctionDescriptor SCIPsetSeparating$descriptor() {
        return SCIPsetSeparating.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSeparating(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MethodHandle SCIPsetSeparating$handle() {
        return SCIPsetSeparating.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSeparating(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static MemorySegment SCIPsetSeparating$address() {
        return SCIPsetSeparating.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSeparating(SCIP *scip, SCIP_PARAMSETTING paramsetting, unsigned int quiet)
     * }
     */
    public static int SCIPsetSeparating(MemorySegment scip, int paramsetting, int quiet) {
        var mh$ = SCIPsetSeparating.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSeparating", scip, paramsetting, quiet);
            }
            return (int)mh$.invokeExact(scip, paramsetting, quiet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PARAM **SCIPgetParams(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetParams$descriptor() {
        return SCIPgetParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PARAM **SCIPgetParams(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetParams$handle() {
        return SCIPgetParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PARAM **SCIPgetParams(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetParams$address() {
        return SCIPgetParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PARAM **SCIPgetParams(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetParams(MemorySegment scip) {
        var mh$ = SCIPgetParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetParams", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNParams {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNParams");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNParams(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNParams$descriptor() {
        return SCIPgetNParams.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNParams(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNParams$handle() {
        return SCIPgetNParams.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNParams(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNParams$address() {
        return SCIPgetNParams.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNParams(SCIP *scip)
     * }
     */
    public static int SCIPgetNParams(MemorySegment scip) {
        var mh$ = SCIPgetNParams.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNParams", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSubscipsOff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSubscipsOff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetSubscipsOff(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSubscipsOff$descriptor() {
        return SCIPgetSubscipsOff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetSubscipsOff(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSubscipsOff$handle() {
        return SCIPgetSubscipsOff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetSubscipsOff(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSubscipsOff$address() {
        return SCIPgetSubscipsOff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetSubscipsOff(SCIP *scip)
     * }
     */
    public static int SCIPgetSubscipsOff(MemorySegment scip) {
        var mh$ = SCIPgetSubscipsOff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSubscipsOff", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresol(SCIP *scip, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static FunctionDescriptor SCIPincludePresol$descriptor() {
        return SCIPincludePresol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresol(SCIP *scip, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MethodHandle SCIPincludePresol$handle() {
        return SCIPincludePresol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresol(SCIP *scip, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MemorySegment SCIPincludePresol$address() {
        return SCIPincludePresol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresol(SCIP *scip, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *), SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static int SCIPincludePresol(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int maxrounds, int timing, MemorySegment presolcopy, MemorySegment presolfree, MemorySegment presolinit, MemorySegment presolexit, MemorySegment presolinitpre, MemorySegment presolexitpre, MemorySegment presolexec, MemorySegment presoldata) {
        var mh$ = SCIPincludePresol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresol", scip, name, desc, priority, maxrounds, timing, presolcopy, presolfree, presolinit, presolexit, presolinitpre, presolexitpre, presolexec, presoldata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, maxrounds, timing, presolcopy, presolfree, presolinit, presolexit, presolinitpre, presolexitpre, presolexec, presoldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePresolBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePresolBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBasic(SCIP *scip, SCIP_PRESOL **presolptr, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static FunctionDescriptor SCIPincludePresolBasic$descriptor() {
        return SCIPincludePresolBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBasic(SCIP *scip, SCIP_PRESOL **presolptr, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MethodHandle SCIPincludePresolBasic$handle() {
        return SCIPincludePresolBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBasic(SCIP *scip, SCIP_PRESOL **presolptr, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static MemorySegment SCIPincludePresolBasic$address() {
        return SCIPincludePresolBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePresolBasic(SCIP *scip, SCIP_PRESOL **presolptr, const char *name, const char *desc, int priority, int maxrounds, SCIP_PRESOLTIMING timing, SCIP_RETCODE (*presolexec)(SCIP *, SCIP_PRESOL *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_PRESOLDATA *presoldata)
     * }
     */
    public static int SCIPincludePresolBasic(MemorySegment scip, MemorySegment presolptr, MemorySegment name, MemorySegment desc, int priority, int maxrounds, int timing, MemorySegment presolexec, MemorySegment presoldata) {
        var mh$ = SCIPincludePresolBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePresolBasic", scip, presolptr, name, desc, priority, maxrounds, timing, presolexec, presoldata);
            }
            return (int)mh$.invokeExact(scip, presolptr, name, desc, priority, maxrounds, timing, presolexec, presoldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolCopy(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolCopy$descriptor() {
        return SCIPsetPresolCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolCopy(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolCopy$handle() {
        return SCIPsetPresolCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolCopy(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolCopy$address() {
        return SCIPsetPresolCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolCopy(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolcopy)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolCopy(MemorySegment scip, MemorySegment presol, MemorySegment presolcopy) {
        var mh$ = SCIPsetPresolCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolCopy", scip, presol, presolcopy);
            }
            return (int)mh$.invokeExact(scip, presol, presolcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolFree(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolFree$descriptor() {
        return SCIPsetPresolFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolFree(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolFree$handle() {
        return SCIPsetPresolFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolFree(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolFree$address() {
        return SCIPsetPresolFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolFree(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolfree)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolFree(MemorySegment scip, MemorySegment presol, MemorySegment presolfree) {
        var mh$ = SCIPsetPresolFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolFree", scip, presol, presolfree);
            }
            return (int)mh$.invokeExact(scip, presol, presolfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolInit$descriptor() {
        return SCIPsetPresolInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolInit$handle() {
        return SCIPsetPresolInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolInit$address() {
        return SCIPsetPresolInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolInit(MemorySegment scip, MemorySegment presol, MemorySegment presolinit) {
        var mh$ = SCIPsetPresolInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolInit", scip, presol, presolinit);
            }
            return (int)mh$.invokeExact(scip, presol, presolinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolExit$descriptor() {
        return SCIPsetPresolExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolExit$handle() {
        return SCIPsetPresolExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolExit$address() {
        return SCIPsetPresolExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExit(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexit)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolExit(MemorySegment scip, MemorySegment presol, MemorySegment presolexit) {
        var mh$ = SCIPsetPresolExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolExit", scip, presol, presolexit);
            }
            return (int)mh$.invokeExact(scip, presol, presolexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolInitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolInitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolInitpre$descriptor() {
        return SCIPsetPresolInitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolInitpre$handle() {
        return SCIPsetPresolInitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolInitpre$address() {
        return SCIPsetPresolInitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolInitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolinitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolInitpre(MemorySegment scip, MemorySegment presol, MemorySegment presolinitpre) {
        var mh$ = SCIPsetPresolInitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolInitpre", scip, presol, presolinitpre);
            }
            return (int)mh$.invokeExact(scip, presol, presolinitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolExitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolExitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static FunctionDescriptor SCIPsetPresolExitpre$descriptor() {
        return SCIPsetPresolExitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MethodHandle SCIPsetPresolExitpre$handle() {
        return SCIPsetPresolExitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static MemorySegment SCIPsetPresolExitpre$address() {
        return SCIPsetPresolExitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolExitpre(SCIP *scip, SCIP_PRESOL *presol, SCIP_RETCODE (*presolexitpre)(SCIP *, SCIP_PRESOL *))
     * }
     */
    public static int SCIPsetPresolExitpre(MemorySegment scip, MemorySegment presol, MemorySegment presolexitpre) {
        var mh$ = SCIPsetPresolExitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolExitpre", scip, presol, presolexitpre);
            }
            return (int)mh$.invokeExact(scip, presol, presolexitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindPresol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindPresol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOL *SCIPfindPresol(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindPresol$descriptor() {
        return SCIPfindPresol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOL *SCIPfindPresol(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindPresol$handle() {
        return SCIPfindPresol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOL *SCIPfindPresol(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindPresol$address() {
        return SCIPfindPresol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOL *SCIPfindPresol(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindPresol(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindPresol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindPresol", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPresols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPresols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRESOL **SCIPgetPresols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPresols$descriptor() {
        return SCIPgetPresols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRESOL **SCIPgetPresols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPresols$handle() {
        return SCIPgetPresols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRESOL **SCIPgetPresols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPresols$address() {
        return SCIPgetPresols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRESOL **SCIPgetPresols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPresols(MemorySegment scip) {
        var mh$ = SCIPgetPresols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPresols", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPresols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPresols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPresols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPresols$descriptor() {
        return SCIPgetNPresols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPresols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPresols$handle() {
        return SCIPgetNPresols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPresols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPresols$address() {
        return SCIPgetNPresols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPresols(SCIP *scip)
     * }
     */
    public static int SCIPgetNPresols(MemorySegment scip) {
        var mh$ = SCIPgetNPresols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPresols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPresolPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPresolPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolPriority(SCIP *scip, SCIP_PRESOL *presol, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetPresolPriority$descriptor() {
        return SCIPsetPresolPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolPriority(SCIP *scip, SCIP_PRESOL *presol, int priority)
     * }
     */
    public static MethodHandle SCIPsetPresolPriority$handle() {
        return SCIPsetPresolPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolPriority(SCIP *scip, SCIP_PRESOL *presol, int priority)
     * }
     */
    public static MemorySegment SCIPsetPresolPriority$address() {
        return SCIPsetPresolPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPresolPriority(SCIP *scip, SCIP_PRESOL *presol, int priority)
     * }
     */
    public static int SCIPsetPresolPriority(MemorySegment scip, MemorySegment presol, int priority) {
        var mh$ = SCIPsetPresolPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPresolPriority", scip, presol, priority);
            }
            return (int)mh$.invokeExact(scip, presol, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPresolRounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPresolRounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPresolRounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPresolRounds$descriptor() {
        return SCIPgetNPresolRounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPresolRounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPresolRounds$handle() {
        return SCIPgetNPresolRounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPresolRounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPresolRounds$address() {
        return SCIPgetNPresolRounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPresolRounds(SCIP *scip)
     * }
     */
    public static int SCIPgetNPresolRounds(MemorySegment scip) {
        var mh$ = SCIPgetNPresolRounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPresolRounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePricer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePricer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricer(SCIP *scip, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *), SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static FunctionDescriptor SCIPincludePricer$descriptor() {
        return SCIPincludePricer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricer(SCIP *scip, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *), SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MethodHandle SCIPincludePricer$handle() {
        return SCIPincludePricer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricer(SCIP *scip, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *), SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MemorySegment SCIPincludePricer$address() {
        return SCIPincludePricer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricer(SCIP *scip, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *), SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *), SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static int SCIPincludePricer(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int delay, MemorySegment pricercopy, MemorySegment pricerfree, MemorySegment pricerinit, MemorySegment pricerexit, MemorySegment pricerinitsol, MemorySegment pricerexitsol, MemorySegment pricerredcost, MemorySegment pricerfarkas, MemorySegment pricerdata) {
        var mh$ = SCIPincludePricer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePricer", scip, name, desc, priority, delay, pricercopy, pricerfree, pricerinit, pricerexit, pricerinitsol, pricerexitsol, pricerredcost, pricerfarkas, pricerdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, delay, pricercopy, pricerfree, pricerinit, pricerexit, pricerinitsol, pricerexitsol, pricerredcost, pricerfarkas, pricerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePricerBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePricerBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricerBasic(SCIP *scip, SCIP_PRICER **pricerptr, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static FunctionDescriptor SCIPincludePricerBasic$descriptor() {
        return SCIPincludePricerBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricerBasic(SCIP *scip, SCIP_PRICER **pricerptr, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MethodHandle SCIPincludePricerBasic$handle() {
        return SCIPincludePricerBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricerBasic(SCIP *scip, SCIP_PRICER **pricerptr, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static MemorySegment SCIPincludePricerBasic$address() {
        return SCIPincludePricerBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePricerBasic(SCIP *scip, SCIP_PRICER **pricerptr, const char *name, const char *desc, int priority, unsigned int delay, SCIP_RETCODE (*pricerredcost)(SCIP *, SCIP_PRICER *, double *, unsigned int *, SCIP_RESULT *), SCIP_RETCODE (*pricerfarkas)(SCIP *, SCIP_PRICER *, SCIP_RESULT *), SCIP_PRICERDATA *pricerdata)
     * }
     */
    public static int SCIPincludePricerBasic(MemorySegment scip, MemorySegment pricerptr, MemorySegment name, MemorySegment desc, int priority, int delay, MemorySegment pricerredcost, MemorySegment pricerfarkas, MemorySegment pricerdata) {
        var mh$ = SCIPincludePricerBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePricerBasic", scip, pricerptr, name, desc, priority, delay, pricerredcost, pricerfarkas, pricerdata);
            }
            return (int)mh$.invokeExact(scip, pricerptr, name, desc, priority, delay, pricerredcost, pricerfarkas, pricerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerCopy(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerCopy$descriptor() {
        return SCIPsetPricerCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerCopy(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *))
     * }
     */
    public static MethodHandle SCIPsetPricerCopy$handle() {
        return SCIPsetPricerCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerCopy(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *))
     * }
     */
    public static MemorySegment SCIPsetPricerCopy$address() {
        return SCIPsetPricerCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerCopy(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricercopy)(SCIP *, SCIP_PRICER *, unsigned int *))
     * }
     */
    public static int SCIPsetPricerCopy(MemorySegment scip, MemorySegment pricer, MemorySegment pricercopy) {
        var mh$ = SCIPsetPricerCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerCopy", scip, pricer, pricercopy);
            }
            return (int)mh$.invokeExact(scip, pricer, pricercopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerFree(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerFree$descriptor() {
        return SCIPsetPricerFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerFree(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MethodHandle SCIPsetPricerFree$handle() {
        return SCIPsetPricerFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerFree(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MemorySegment SCIPsetPricerFree$address() {
        return SCIPsetPricerFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerFree(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerfree)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static int SCIPsetPricerFree(MemorySegment scip, MemorySegment pricer, MemorySegment pricerfree) {
        var mh$ = SCIPsetPricerFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerFree", scip, pricer, pricerfree);
            }
            return (int)mh$.invokeExact(scip, pricer, pricerfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerInit$descriptor() {
        return SCIPsetPricerInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MethodHandle SCIPsetPricerInit$handle() {
        return SCIPsetPricerInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MemorySegment SCIPsetPricerInit$address() {
        return SCIPsetPricerInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static int SCIPsetPricerInit(MemorySegment scip, MemorySegment pricer, MemorySegment pricerinit) {
        var mh$ = SCIPsetPricerInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerInit", scip, pricer, pricerinit);
            }
            return (int)mh$.invokeExact(scip, pricer, pricerinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerExit$descriptor() {
        return SCIPsetPricerExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MethodHandle SCIPsetPricerExit$handle() {
        return SCIPsetPricerExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MemorySegment SCIPsetPricerExit$address() {
        return SCIPsetPricerExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExit(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexit)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static int SCIPsetPricerExit(MemorySegment scip, MemorySegment pricer, MemorySegment pricerexit) {
        var mh$ = SCIPsetPricerExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerExit", scip, pricer, pricerexit);
            }
            return (int)mh$.invokeExact(scip, pricer, pricerexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerInitsol$descriptor() {
        return SCIPsetPricerInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MethodHandle SCIPsetPricerInitsol$handle() {
        return SCIPsetPricerInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MemorySegment SCIPsetPricerInitsol$address() {
        return SCIPsetPricerInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerInitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerinitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static int SCIPsetPricerInitsol(MemorySegment scip, MemorySegment pricer, MemorySegment pricerinitsol) {
        var mh$ = SCIPsetPricerInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerInitsol", scip, pricer, pricerinitsol);
            }
            return (int)mh$.invokeExact(scip, pricer, pricerinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static FunctionDescriptor SCIPsetPricerExitsol$descriptor() {
        return SCIPsetPricerExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MethodHandle SCIPsetPricerExitsol$handle() {
        return SCIPsetPricerExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static MemorySegment SCIPsetPricerExitsol$address() {
        return SCIPsetPricerExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerExitsol(SCIP *scip, SCIP_PRICER *pricer, SCIP_RETCODE (*pricerexitsol)(SCIP *, SCIP_PRICER *))
     * }
     */
    public static int SCIPsetPricerExitsol(MemorySegment scip, MemorySegment pricer, MemorySegment pricerexitsol) {
        var mh$ = SCIPsetPricerExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerExitsol", scip, pricer, pricerexitsol);
            }
            return (int)mh$.invokeExact(scip, pricer, pricerexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindPricer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindPricer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRICER *SCIPfindPricer(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindPricer$descriptor() {
        return SCIPfindPricer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRICER *SCIPfindPricer(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindPricer$handle() {
        return SCIPfindPricer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRICER *SCIPfindPricer(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindPricer$address() {
        return SCIPfindPricer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRICER *SCIPfindPricer(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindPricer(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindPricer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindPricer", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPricers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPricers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PRICER **SCIPgetPricers(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPricers$descriptor() {
        return SCIPgetPricers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PRICER **SCIPgetPricers(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPricers$handle() {
        return SCIPgetPricers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PRICER **SCIPgetPricers(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPricers$address() {
        return SCIPgetPricers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PRICER **SCIPgetPricers(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPricers(MemorySegment scip) {
        var mh$ = SCIPgetPricers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPricers", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPricers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPricers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPricers(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPricers$descriptor() {
        return SCIPgetNPricers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPricers(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPricers$handle() {
        return SCIPgetNPricers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPricers(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPricers$address() {
        return SCIPgetNPricers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPricers(SCIP *scip)
     * }
     */
    public static int SCIPgetNPricers(MemorySegment scip) {
        var mh$ = SCIPgetNPricers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPricers", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNActivePricers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNActivePricers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNActivePricers(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNActivePricers$descriptor() {
        return SCIPgetNActivePricers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNActivePricers(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNActivePricers$handle() {
        return SCIPgetNActivePricers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNActivePricers(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNActivePricers$address() {
        return SCIPgetNActivePricers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNActivePricers(SCIP *scip)
     * }
     */
    public static int SCIPgetNActivePricers(MemorySegment scip) {
        var mh$ = SCIPgetNActivePricers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNActivePricers", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPricerPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPricerPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerPriority(SCIP *scip, SCIP_PRICER *pricer, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetPricerPriority$descriptor() {
        return SCIPsetPricerPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerPriority(SCIP *scip, SCIP_PRICER *pricer, int priority)
     * }
     */
    public static MethodHandle SCIPsetPricerPriority$handle() {
        return SCIPsetPricerPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerPriority(SCIP *scip, SCIP_PRICER *pricer, int priority)
     * }
     */
    public static MemorySegment SCIPsetPricerPriority$address() {
        return SCIPsetPricerPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPricerPriority(SCIP *scip, SCIP_PRICER *pricer, int priority)
     * }
     */
    public static int SCIPsetPricerPriority(MemorySegment scip, MemorySegment pricer, int priority) {
        var mh$ = SCIPsetPricerPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPricerPriority", scip, pricer, priority);
            }
            return (int)mh$.invokeExact(scip, pricer, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPactivatePricer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPactivatePricer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPactivatePricer$descriptor() {
        return SCIPactivatePricer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPactivatePricer$handle() {
        return SCIPactivatePricer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPactivatePricer$address() {
        return SCIPactivatePricer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPactivatePricer(MemorySegment scip, MemorySegment pricer) {
        var mh$ = SCIPactivatePricer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPactivatePricer", scip, pricer);
            }
            return (int)mh$.invokeExact(scip, pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeactivatePricer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeactivatePricer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static FunctionDescriptor SCIPdeactivatePricer$descriptor() {
        return SCIPdeactivatePricer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static MethodHandle SCIPdeactivatePricer$handle() {
        return SCIPdeactivatePricer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static MemorySegment SCIPdeactivatePricer$address() {
        return SCIPdeactivatePricer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeactivatePricer(SCIP *scip, SCIP_PRICER *pricer)
     * }
     */
    public static int SCIPdeactivatePricer(MemorySegment scip, MemorySegment pricer) {
        var mh$ = SCIPdeactivatePricer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeactivatePricer", scip, pricer);
            }
            return (int)mh$.invokeExact(scip, pricer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProb(SCIP *scip, const char *name, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **), SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *), SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int), SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *), SCIP_PROBDATA *probdata)
     * }
     */
    public static FunctionDescriptor SCIPcreateProb$descriptor() {
        return SCIPcreateProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProb(SCIP *scip, const char *name, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **), SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *), SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int), SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *), SCIP_PROBDATA *probdata)
     * }
     */
    public static MethodHandle SCIPcreateProb$handle() {
        return SCIPcreateProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProb(SCIP *scip, const char *name, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **), SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *), SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int), SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *), SCIP_PROBDATA *probdata)
     * }
     */
    public static MemorySegment SCIPcreateProb$address() {
        return SCIPcreateProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProb(SCIP *scip, const char *name, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **), SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **), SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *), SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int), SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *), SCIP_PROBDATA *probdata)
     * }
     */
    public static int SCIPcreateProb(MemorySegment scip, MemorySegment name, MemorySegment probdelorig, MemorySegment probtrans, MemorySegment probdeltrans, MemorySegment probinitsol, MemorySegment probexitsol, MemorySegment probcopy, MemorySegment probdata) {
        var mh$ = SCIPcreateProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateProb", scip, name, probdelorig, probtrans, probdeltrans, probinitsol, probexitsol, probcopy, probdata);
            }
            return (int)mh$.invokeExact(scip, name, probdelorig, probtrans, probdeltrans, probinitsol, probexitsol, probcopy, probdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateProbBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateProbBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProbBasic(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPcreateProbBasic$descriptor() {
        return SCIPcreateProbBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProbBasic(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPcreateProbBasic$handle() {
        return SCIPcreateProbBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProbBasic(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPcreateProbBasic$address() {
        return SCIPcreateProbBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateProbBasic(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPcreateProbBasic(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPcreateProbBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateProbBasic", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbDelorig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbDelorig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDelorig(SCIP *scip, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static FunctionDescriptor SCIPsetProbDelorig$descriptor() {
        return SCIPsetProbDelorig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDelorig(SCIP *scip, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static MethodHandle SCIPsetProbDelorig$handle() {
        return SCIPsetProbDelorig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDelorig(SCIP *scip, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static MemorySegment SCIPsetProbDelorig$address() {
        return SCIPsetProbDelorig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDelorig(SCIP *scip, SCIP_RETCODE (*probdelorig)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static int SCIPsetProbDelorig(MemorySegment scip, MemorySegment probdelorig) {
        var mh$ = SCIPsetProbDelorig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbDelorig", scip, probdelorig);
            }
            return (int)mh$.invokeExact(scip, probdelorig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbTrans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbTrans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbTrans(SCIP *scip, SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **))
     * }
     */
    public static FunctionDescriptor SCIPsetProbTrans$descriptor() {
        return SCIPsetProbTrans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbTrans(SCIP *scip, SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **))
     * }
     */
    public static MethodHandle SCIPsetProbTrans$handle() {
        return SCIPsetProbTrans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbTrans(SCIP *scip, SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **))
     * }
     */
    public static MemorySegment SCIPsetProbTrans$address() {
        return SCIPsetProbTrans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbTrans(SCIP *scip, SCIP_RETCODE (*probtrans)(SCIP *, SCIP_PROBDATA *, SCIP_PROBDATA **))
     * }
     */
    public static int SCIPsetProbTrans(MemorySegment scip, MemorySegment probtrans) {
        var mh$ = SCIPsetProbTrans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbTrans", scip, probtrans);
            }
            return (int)mh$.invokeExact(scip, probtrans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbDeltrans {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbDeltrans");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDeltrans(SCIP *scip, SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static FunctionDescriptor SCIPsetProbDeltrans$descriptor() {
        return SCIPsetProbDeltrans.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDeltrans(SCIP *scip, SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static MethodHandle SCIPsetProbDeltrans$handle() {
        return SCIPsetProbDeltrans.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDeltrans(SCIP *scip, SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static MemorySegment SCIPsetProbDeltrans$address() {
        return SCIPsetProbDeltrans.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbDeltrans(SCIP *scip, SCIP_RETCODE (*probdeltrans)(SCIP *, SCIP_PROBDATA **))
     * }
     */
    public static int SCIPsetProbDeltrans(MemorySegment scip, MemorySegment probdeltrans) {
        var mh$ = SCIPsetProbDeltrans.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbDeltrans", scip, probdeltrans);
            }
            return (int)mh$.invokeExact(scip, probdeltrans);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbInitsol(SCIP *scip, SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *))
     * }
     */
    public static FunctionDescriptor SCIPsetProbInitsol$descriptor() {
        return SCIPsetProbInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbInitsol(SCIP *scip, SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *))
     * }
     */
    public static MethodHandle SCIPsetProbInitsol$handle() {
        return SCIPsetProbInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbInitsol(SCIP *scip, SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *))
     * }
     */
    public static MemorySegment SCIPsetProbInitsol$address() {
        return SCIPsetProbInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbInitsol(SCIP *scip, SCIP_RETCODE (*probinitsol)(SCIP *, SCIP_PROBDATA *))
     * }
     */
    public static int SCIPsetProbInitsol(MemorySegment scip, MemorySegment probinitsol) {
        var mh$ = SCIPsetProbInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbInitsol", scip, probinitsol);
            }
            return (int)mh$.invokeExact(scip, probinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbExitsol(SCIP *scip, SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int))
     * }
     */
    public static FunctionDescriptor SCIPsetProbExitsol$descriptor() {
        return SCIPsetProbExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbExitsol(SCIP *scip, SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int))
     * }
     */
    public static MethodHandle SCIPsetProbExitsol$handle() {
        return SCIPsetProbExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbExitsol(SCIP *scip, SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int))
     * }
     */
    public static MemorySegment SCIPsetProbExitsol$address() {
        return SCIPsetProbExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbExitsol(SCIP *scip, SCIP_RETCODE (*probexitsol)(SCIP *, SCIP_PROBDATA *, unsigned int))
     * }
     */
    public static int SCIPsetProbExitsol(MemorySegment scip, MemorySegment probexitsol) {
        var mh$ = SCIPsetProbExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbExitsol", scip, probexitsol);
            }
            return (int)mh$.invokeExact(scip, probexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbCopy(SCIP *scip, SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetProbCopy$descriptor() {
        return SCIPsetProbCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbCopy(SCIP *scip, SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetProbCopy$handle() {
        return SCIPsetProbCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbCopy(SCIP *scip, SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetProbCopy$address() {
        return SCIPsetProbCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbCopy(SCIP *scip, SCIP_RETCODE (*probcopy)(SCIP *, SCIP *, SCIP_PROBDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_PROBDATA **, unsigned int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetProbCopy(MemorySegment scip, MemorySegment probcopy) {
        var mh$ = SCIPsetProbCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbCopy", scip, probcopy);
            }
            return (int)mh$.invokeExact(scip, probcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadProb(SCIP *scip, const char *filename, const char *extension)
     * }
     */
    public static FunctionDescriptor SCIPreadProb$descriptor() {
        return SCIPreadProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadProb(SCIP *scip, const char *filename, const char *extension)
     * }
     */
    public static MethodHandle SCIPreadProb$handle() {
        return SCIPreadProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadProb(SCIP *scip, const char *filename, const char *extension)
     * }
     */
    public static MemorySegment SCIPreadProb$address() {
        return SCIPreadProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadProb(SCIP *scip, const char *filename, const char *extension)
     * }
     */
    public static int SCIPreadProb(MemorySegment scip, MemorySegment filename, MemorySegment extension) {
        var mh$ = SCIPreadProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadProb", scip, filename, extension);
            }
            return (int)mh$.invokeExact(scip, filename, extension);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteOrigProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteOrigProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOrigProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static FunctionDescriptor SCIPwriteOrigProblem$descriptor() {
        return SCIPwriteOrigProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOrigProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static MethodHandle SCIPwriteOrigProblem$handle() {
        return SCIPwriteOrigProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOrigProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static MemorySegment SCIPwriteOrigProblem$address() {
        return SCIPwriteOrigProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteOrigProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static int SCIPwriteOrigProblem(MemorySegment scip, MemorySegment filename, MemorySegment extension, int genericnames) {
        var mh$ = SCIPwriteOrigProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteOrigProblem", scip, filename, extension, genericnames);
            }
            return (int)mh$.invokeExact(scip, filename, extension, genericnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteTransProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteTransProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteTransProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static FunctionDescriptor SCIPwriteTransProblem$descriptor() {
        return SCIPwriteTransProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteTransProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static MethodHandle SCIPwriteTransProblem$handle() {
        return SCIPwriteTransProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteTransProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static MemorySegment SCIPwriteTransProblem$address() {
        return SCIPwriteTransProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteTransProblem(SCIP *scip, const char *filename, const char *extension, unsigned int genericnames)
     * }
     */
    public static int SCIPwriteTransProblem(MemorySegment scip, MemorySegment filename, MemorySegment extension, int genericnames) {
        var mh$ = SCIPwriteTransProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteTransProblem", scip, filename, extension, genericnames);
            }
            return (int)mh$.invokeExact(scip, filename, extension, genericnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeProb(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPfreeProb$descriptor() {
        return SCIPfreeProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeProb(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPfreeProb$handle() {
        return SCIPfreeProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeProb(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPfreeProb$address() {
        return SCIPfreeProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeProb(SCIP *scip)
     * }
     */
    public static int SCIPfreeProb(MemorySegment scip) {
        var mh$ = SCIPfreeProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeProb", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpermuteProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpermuteProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpermuteProb(SCIP *scip, unsigned int randseed, unsigned int permuteconss, unsigned int permutebinvars, unsigned int permuteintvars, unsigned int permuteimplvars, unsigned int permutecontvars)
     * }
     */
    public static FunctionDescriptor SCIPpermuteProb$descriptor() {
        return SCIPpermuteProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpermuteProb(SCIP *scip, unsigned int randseed, unsigned int permuteconss, unsigned int permutebinvars, unsigned int permuteintvars, unsigned int permuteimplvars, unsigned int permutecontvars)
     * }
     */
    public static MethodHandle SCIPpermuteProb$handle() {
        return SCIPpermuteProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpermuteProb(SCIP *scip, unsigned int randseed, unsigned int permuteconss, unsigned int permutebinvars, unsigned int permuteintvars, unsigned int permuteimplvars, unsigned int permutecontvars)
     * }
     */
    public static MemorySegment SCIPpermuteProb$address() {
        return SCIPpermuteProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpermuteProb(SCIP *scip, unsigned int randseed, unsigned int permuteconss, unsigned int permutebinvars, unsigned int permuteintvars, unsigned int permuteimplvars, unsigned int permutecontvars)
     * }
     */
    public static int SCIPpermuteProb(MemorySegment scip, int randseed, int permuteconss, int permutebinvars, int permuteintvars, int permuteimplvars, int permutecontvars) {
        var mh$ = SCIPpermuteProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpermuteProb", scip, randseed, permuteconss, permutebinvars, permuteintvars, permuteimplvars, permutecontvars);
            }
            return (int)mh$.invokeExact(scip, randseed, permuteconss, permutebinvars, permuteintvars, permuteimplvars, permutecontvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROBDATA *SCIPgetProbData(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetProbData$descriptor() {
        return SCIPgetProbData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROBDATA *SCIPgetProbData(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetProbData$handle() {
        return SCIPgetProbData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROBDATA *SCIPgetProbData(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProbData$address() {
        return SCIPgetProbData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROBDATA *SCIPgetProbData(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProbData(MemorySegment scip) {
        var mh$ = SCIPgetProbData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbData", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbData(SCIP *scip, SCIP_PROBDATA *probdata)
     * }
     */
    public static FunctionDescriptor SCIPsetProbData$descriptor() {
        return SCIPsetProbData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbData(SCIP *scip, SCIP_PROBDATA *probdata)
     * }
     */
    public static MethodHandle SCIPsetProbData$handle() {
        return SCIPsetProbData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbData(SCIP *scip, SCIP_PROBDATA *probdata)
     * }
     */
    public static MemorySegment SCIPsetProbData$address() {
        return SCIPsetProbData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbData(SCIP *scip, SCIP_PROBDATA *probdata)
     * }
     */
    public static int SCIPsetProbData(MemorySegment scip, MemorySegment probdata) {
        var mh$ = SCIPsetProbData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbData", scip, probdata);
            }
            return (int)mh$.invokeExact(scip, probdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *SCIPgetProbName(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetProbName$descriptor() {
        return SCIPgetProbName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *SCIPgetProbName(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetProbName$handle() {
        return SCIPgetProbName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *SCIPgetProbName(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProbName$address() {
        return SCIPgetProbName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *SCIPgetProbName(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProbName(MemorySegment scip) {
        var mh$ = SCIPgetProbName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbName", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbName(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPsetProbName$descriptor() {
        return SCIPsetProbName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbName(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPsetProbName$handle() {
        return SCIPsetProbName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbName(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPsetProbName$address() {
        return SCIPsetProbName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbName(SCIP *scip, const char *name)
     * }
     */
    public static int SCIPsetProbName(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPsetProbName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbName", scip, name);
            }
            return (int)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgReoptObjective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgReoptObjective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgReoptObjective(SCIP *scip, SCIP_OBJSENSE objsense, SCIP_VAR **vars, double *coefs, int nvars)
     * }
     */
    public static FunctionDescriptor SCIPchgReoptObjective$descriptor() {
        return SCIPchgReoptObjective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgReoptObjective(SCIP *scip, SCIP_OBJSENSE objsense, SCIP_VAR **vars, double *coefs, int nvars)
     * }
     */
    public static MethodHandle SCIPchgReoptObjective$handle() {
        return SCIPchgReoptObjective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgReoptObjective(SCIP *scip, SCIP_OBJSENSE objsense, SCIP_VAR **vars, double *coefs, int nvars)
     * }
     */
    public static MemorySegment SCIPchgReoptObjective$address() {
        return SCIPchgReoptObjective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgReoptObjective(SCIP *scip, SCIP_OBJSENSE objsense, SCIP_VAR **vars, double *coefs, int nvars)
     * }
     */
    public static int SCIPchgReoptObjective(MemorySegment scip, int objsense, MemorySegment vars, MemorySegment coefs, int nvars) {
        var mh$ = SCIPchgReoptObjective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgReoptObjective", scip, objsense, vars, coefs, nvars);
            }
            return (int)mh$.invokeExact(scip, objsense, vars, coefs, nvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetObjsense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetObjsense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_OBJSENSE SCIPgetObjsense(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetObjsense$descriptor() {
        return SCIPgetObjsense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_OBJSENSE SCIPgetObjsense(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetObjsense$handle() {
        return SCIPgetObjsense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_OBJSENSE SCIPgetObjsense(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetObjsense$address() {
        return SCIPgetObjsense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_OBJSENSE SCIPgetObjsense(SCIP *scip)
     * }
     */
    public static int SCIPgetObjsense(MemorySegment scip) {
        var mh$ = SCIPgetObjsense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetObjsense", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetObjsense {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetObjsense");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjsense(SCIP *scip, SCIP_OBJSENSE objsense)
     * }
     */
    public static FunctionDescriptor SCIPsetObjsense$descriptor() {
        return SCIPsetObjsense.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjsense(SCIP *scip, SCIP_OBJSENSE objsense)
     * }
     */
    public static MethodHandle SCIPsetObjsense$handle() {
        return SCIPsetObjsense.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjsense(SCIP *scip, SCIP_OBJSENSE objsense)
     * }
     */
    public static MemorySegment SCIPsetObjsense$address() {
        return SCIPsetObjsense.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjsense(SCIP *scip, SCIP_OBJSENSE objsense)
     * }
     */
    public static int SCIPsetObjsense(MemorySegment scip, int objsense) {
        var mh$ = SCIPsetObjsense.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetObjsense", scip, objsense);
            }
            return (int)mh$.invokeExact(scip, objsense);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddObjoffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddObjoffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddObjoffset(SCIP *scip, double addval)
     * }
     */
    public static FunctionDescriptor SCIPaddObjoffset$descriptor() {
        return SCIPaddObjoffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddObjoffset(SCIP *scip, double addval)
     * }
     */
    public static MethodHandle SCIPaddObjoffset$handle() {
        return SCIPaddObjoffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddObjoffset(SCIP *scip, double addval)
     * }
     */
    public static MemorySegment SCIPaddObjoffset$address() {
        return SCIPaddObjoffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddObjoffset(SCIP *scip, double addval)
     * }
     */
    public static int SCIPaddObjoffset(MemorySegment scip, double addval) {
        var mh$ = SCIPaddObjoffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddObjoffset", scip, addval);
            }
            return (int)mh$.invokeExact(scip, addval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddOrigObjoffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddOrigObjoffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddOrigObjoffset(SCIP *scip, double addval)
     * }
     */
    public static FunctionDescriptor SCIPaddOrigObjoffset$descriptor() {
        return SCIPaddOrigObjoffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddOrigObjoffset(SCIP *scip, double addval)
     * }
     */
    public static MethodHandle SCIPaddOrigObjoffset$handle() {
        return SCIPaddOrigObjoffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddOrigObjoffset(SCIP *scip, double addval)
     * }
     */
    public static MemorySegment SCIPaddOrigObjoffset$address() {
        return SCIPaddOrigObjoffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddOrigObjoffset(SCIP *scip, double addval)
     * }
     */
    public static int SCIPaddOrigObjoffset(MemorySegment scip, double addval) {
        var mh$ = SCIPaddOrigObjoffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddOrigObjoffset", scip, addval);
            }
            return (int)mh$.invokeExact(scip, addval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOrigObjoffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOrigObjoffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjoffset(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetOrigObjoffset$descriptor() {
        return SCIPgetOrigObjoffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjoffset(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetOrigObjoffset$handle() {
        return SCIPgetOrigObjoffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjoffset(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigObjoffset$address() {
        return SCIPgetOrigObjoffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetOrigObjoffset(SCIP *scip)
     * }
     */
    public static double SCIPgetOrigObjoffset(MemorySegment scip) {
        var mh$ = SCIPgetOrigObjoffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOrigObjoffset", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOrigObjscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOrigObjscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjscale(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetOrigObjscale$descriptor() {
        return SCIPgetOrigObjscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjscale(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetOrigObjscale$handle() {
        return SCIPgetOrigObjscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetOrigObjscale(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigObjscale$address() {
        return SCIPgetOrigObjscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetOrigObjscale(SCIP *scip)
     * }
     */
    public static double SCIPgetOrigObjscale(MemorySegment scip) {
        var mh$ = SCIPgetOrigObjscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOrigObjscale", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransObjoffset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransObjoffset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTransObjoffset(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTransObjoffset$descriptor() {
        return SCIPgetTransObjoffset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTransObjoffset(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTransObjoffset$handle() {
        return SCIPgetTransObjoffset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTransObjoffset(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTransObjoffset$address() {
        return SCIPgetTransObjoffset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTransObjoffset(SCIP *scip)
     * }
     */
    public static double SCIPgetTransObjoffset(MemorySegment scip) {
        var mh$ = SCIPgetTransObjoffset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransObjoffset", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransObjscale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransObjscale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTransObjscale(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTransObjscale$descriptor() {
        return SCIPgetTransObjscale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTransObjscale(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTransObjscale$handle() {
        return SCIPgetTransObjscale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTransObjscale(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTransObjscale$address() {
        return SCIPgetTransObjscale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTransObjscale(SCIP *scip)
     * }
     */
    public static double SCIPgetTransObjscale(MemorySegment scip) {
        var mh$ = SCIPgetTransObjscale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransObjscale", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetObjlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetObjlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjlimit(SCIP *scip, double objlimit)
     * }
     */
    public static FunctionDescriptor SCIPsetObjlimit$descriptor() {
        return SCIPsetObjlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjlimit(SCIP *scip, double objlimit)
     * }
     */
    public static MethodHandle SCIPsetObjlimit$handle() {
        return SCIPsetObjlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjlimit(SCIP *scip, double objlimit)
     * }
     */
    public static MemorySegment SCIPsetObjlimit$address() {
        return SCIPsetObjlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjlimit(SCIP *scip, double objlimit)
     * }
     */
    public static int SCIPsetObjlimit(MemorySegment scip, double objlimit) {
        var mh$ = SCIPsetObjlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetObjlimit", scip, objlimit);
            }
            return (int)mh$.invokeExact(scip, objlimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetObjlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetObjlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetObjlimit(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetObjlimit$descriptor() {
        return SCIPgetObjlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetObjlimit(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetObjlimit$handle() {
        return SCIPgetObjlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetObjlimit(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetObjlimit$address() {
        return SCIPgetObjlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetObjlimit(SCIP *scip)
     * }
     */
    public static double SCIPgetObjlimit(MemorySegment scip) {
        var mh$ = SCIPgetObjlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetObjlimit", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetObjIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetObjIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjIntegral(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsetObjIntegral$descriptor() {
        return SCIPsetObjIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjIntegral(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsetObjIntegral$handle() {
        return SCIPsetObjIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjIntegral(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsetObjIntegral$address() {
        return SCIPsetObjIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetObjIntegral(SCIP *scip)
     * }
     */
    public static int SCIPsetObjIntegral(MemorySegment scip) {
        var mh$ = SCIPsetObjIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetObjIntegral", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisObjIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisObjIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjIntegral(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisObjIntegral$descriptor() {
        return SCIPisObjIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjIntegral(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisObjIntegral$handle() {
        return SCIPisObjIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjIntegral(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisObjIntegral$address() {
        return SCIPisObjIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisObjIntegral(SCIP *scip)
     * }
     */
    public static int SCIPisObjIntegral(MemorySegment scip) {
        var mh$ = SCIPisObjIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisObjIntegral", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetObjNorm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetObjNorm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetObjNorm(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetObjNorm$descriptor() {
        return SCIPgetObjNorm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetObjNorm(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetObjNorm$handle() {
        return SCIPgetObjNorm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetObjNorm(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetObjNorm$address() {
        return SCIPgetObjNorm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetObjNorm(SCIP *scip)
     * }
     */
    public static double SCIPgetObjNorm(MemorySegment scip) {
        var mh$ = SCIPgetObjNorm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetObjNorm", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPaddVar$descriptor() {
        return SCIPaddVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPaddVar$handle() {
        return SCIPaddVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPaddVar$address() {
        return SCIPaddVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPaddVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPaddVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddPricedVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddPricedVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPricedVar(SCIP *scip, SCIP_VAR *var, double score)
     * }
     */
    public static FunctionDescriptor SCIPaddPricedVar$descriptor() {
        return SCIPaddPricedVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPricedVar(SCIP *scip, SCIP_VAR *var, double score)
     * }
     */
    public static MethodHandle SCIPaddPricedVar$handle() {
        return SCIPaddPricedVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPricedVar(SCIP *scip, SCIP_VAR *var, double score)
     * }
     */
    public static MemorySegment SCIPaddPricedVar$address() {
        return SCIPaddPricedVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddPricedVar(SCIP *scip, SCIP_VAR *var, double score)
     * }
     */
    public static int SCIPaddPricedVar(MemorySegment scip, MemorySegment var_, double score) {
        var mh$ = SCIPaddPricedVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddPricedVar", scip, var_, score);
            }
            return (int)mh$.invokeExact(scip, var_, score);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelVar(SCIP *scip, SCIP_VAR *var, unsigned int *deleted)
     * }
     */
    public static FunctionDescriptor SCIPdelVar$descriptor() {
        return SCIPdelVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelVar(SCIP *scip, SCIP_VAR *var, unsigned int *deleted)
     * }
     */
    public static MethodHandle SCIPdelVar$handle() {
        return SCIPdelVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelVar(SCIP *scip, SCIP_VAR *var, unsigned int *deleted)
     * }
     */
    public static MemorySegment SCIPdelVar$address() {
        return SCIPdelVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelVar(SCIP *scip, SCIP_VAR *var, unsigned int *deleted)
     * }
     */
    public static int SCIPdelVar(MemorySegment scip, MemorySegment var_, MemorySegment deleted) {
        var mh$ = SCIPdelVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelVar", scip, var_, deleted);
            }
            return (int)mh$.invokeExact(scip, var_, deleted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static FunctionDescriptor SCIPgetVarsData$descriptor() {
        return SCIPgetVarsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MethodHandle SCIPgetVarsData$handle() {
        return SCIPgetVarsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MemorySegment SCIPgetVarsData$address() {
        return SCIPgetVarsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static int SCIPgetVarsData(MemorySegment scip, MemorySegment vars, MemorySegment nvars, MemorySegment nbinvars, MemorySegment nintvars, MemorySegment nimplvars, MemorySegment ncontvars) {
        var mh$ = SCIPgetVarsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarsData", scip, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetVars$descriptor() {
        return SCIPgetVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetVars$handle() {
        return SCIPgetVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetVars$address() {
        return SCIPgetVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetVars(MemorySegment scip) {
        var mh$ = SCIPgetVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVars", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNVars$descriptor() {
        return SCIPgetNVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNVars$handle() {
        return SCIPgetNVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNVars$address() {
        return SCIPgetNVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNVars(MemorySegment scip) {
        var mh$ = SCIPgetNVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBinVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBinVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNBinVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBinVars$descriptor() {
        return SCIPgetNBinVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNBinVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBinVars$handle() {
        return SCIPgetNBinVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNBinVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBinVars$address() {
        return SCIPgetNBinVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNBinVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNBinVars(MemorySegment scip) {
        var mh$ = SCIPgetNBinVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBinVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNIntVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNIntVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNIntVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNIntVars$descriptor() {
        return SCIPgetNIntVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNIntVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNIntVars$handle() {
        return SCIPgetNIntVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNIntVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNIntVars$address() {
        return SCIPgetNIntVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNIntVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNIntVars(MemorySegment scip) {
        var mh$ = SCIPgetNIntVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNIntVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNImplVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNImplVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNImplVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNImplVars$descriptor() {
        return SCIPgetNImplVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNImplVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNImplVars$handle() {
        return SCIPgetNImplVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNImplVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNImplVars$address() {
        return SCIPgetNImplVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNImplVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNImplVars(MemorySegment scip) {
        var mh$ = SCIPgetNImplVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNImplVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNContVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNContVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNContVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNContVars$descriptor() {
        return SCIPgetNContVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNContVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNContVars$handle() {
        return SCIPgetNContVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNContVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNContVars$address() {
        return SCIPgetNContVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNContVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNContVars(MemorySegment scip) {
        var mh$ = SCIPgetNContVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNContVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNObjVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNObjVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNObjVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNObjVars$descriptor() {
        return SCIPgetNObjVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNObjVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNObjVars$handle() {
        return SCIPgetNObjVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNObjVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNObjVars$address() {
        return SCIPgetNObjVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNObjVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNObjVars(MemorySegment scip) {
        var mh$ = SCIPgetNObjVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNObjVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFixedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFixedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetFixedVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFixedVars$descriptor() {
        return SCIPgetFixedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetFixedVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFixedVars$handle() {
        return SCIPgetFixedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetFixedVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFixedVars$address() {
        return SCIPgetFixedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetFixedVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFixedVars(MemorySegment scip) {
        var mh$ = SCIPgetFixedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFixedVars", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNFixedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNFixedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNFixedVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNFixedVars$descriptor() {
        return SCIPgetNFixedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNFixedVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNFixedVars$handle() {
        return SCIPgetNFixedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNFixedVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNFixedVars$address() {
        return SCIPgetNFixedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNFixedVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNFixedVars(MemorySegment scip) {
        var mh$ = SCIPgetNFixedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNFixedVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOrigVarsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOrigVarsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOrigVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static FunctionDescriptor SCIPgetOrigVarsData$descriptor() {
        return SCIPgetOrigVarsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOrigVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MethodHandle SCIPgetOrigVarsData$handle() {
        return SCIPgetOrigVarsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOrigVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MemorySegment SCIPgetOrigVarsData$address() {
        return SCIPgetOrigVarsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOrigVarsData(SCIP *scip, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static int SCIPgetOrigVarsData(MemorySegment scip, MemorySegment vars, MemorySegment nvars, MemorySegment nbinvars, MemorySegment nintvars, MemorySegment nimplvars, MemorySegment ncontvars) {
        var mh$ = SCIPgetOrigVarsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOrigVarsData", scip, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOrigVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOrigVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetOrigVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetOrigVars$descriptor() {
        return SCIPgetOrigVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetOrigVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetOrigVars$handle() {
        return SCIPgetOrigVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetOrigVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigVars$address() {
        return SCIPgetOrigVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR **SCIPgetOrigVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigVars(MemorySegment scip) {
        var mh$ = SCIPgetOrigVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOrigVars", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigVars$descriptor() {
        return SCIPgetNOrigVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigVars$handle() {
        return SCIPgetNOrigVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigVars$address() {
        return SCIPgetNOrigVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigVars(MemorySegment scip) {
        var mh$ = SCIPgetNOrigVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigBinVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigBinVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigBinVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigBinVars$descriptor() {
        return SCIPgetNOrigBinVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigBinVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigBinVars$handle() {
        return SCIPgetNOrigBinVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigBinVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigBinVars$address() {
        return SCIPgetNOrigBinVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigBinVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigBinVars(MemorySegment scip) {
        var mh$ = SCIPgetNOrigBinVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigBinVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigIntVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigIntVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigIntVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigIntVars$descriptor() {
        return SCIPgetNOrigIntVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigIntVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigIntVars$handle() {
        return SCIPgetNOrigIntVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigIntVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigIntVars$address() {
        return SCIPgetNOrigIntVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigIntVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigIntVars(MemorySegment scip) {
        var mh$ = SCIPgetNOrigIntVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigIntVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigImplVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigImplVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigImplVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigImplVars$descriptor() {
        return SCIPgetNOrigImplVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigImplVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigImplVars$handle() {
        return SCIPgetNOrigImplVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigImplVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigImplVars$address() {
        return SCIPgetNOrigImplVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigImplVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigImplVars(MemorySegment scip) {
        var mh$ = SCIPgetNOrigImplVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigImplVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigContVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigContVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigContVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigContVars$descriptor() {
        return SCIPgetNOrigContVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigContVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigContVars$handle() {
        return SCIPgetNOrigContVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigContVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigContVars$address() {
        return SCIPgetNOrigContVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigContVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigContVars(MemorySegment scip) {
        var mh$ = SCIPgetNOrigContVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigContVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNTotalVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNTotalVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNTotalVars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNTotalVars$descriptor() {
        return SCIPgetNTotalVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNTotalVars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNTotalVars$handle() {
        return SCIPgetNTotalVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNTotalVars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNTotalVars$address() {
        return SCIPgetNTotalVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNTotalVars(SCIP *scip)
     * }
     */
    public static int SCIPgetNTotalVars(MemorySegment scip) {
        var mh$ = SCIPgetNTotalVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNTotalVars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolVarsData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolVarsData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVarsData(SCIP *scip, SCIP_SOL *sol, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static FunctionDescriptor SCIPgetSolVarsData$descriptor() {
        return SCIPgetSolVarsData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVarsData(SCIP *scip, SCIP_SOL *sol, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MethodHandle SCIPgetSolVarsData$handle() {
        return SCIPgetSolVarsData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVarsData(SCIP *scip, SCIP_SOL *sol, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static MemorySegment SCIPgetSolVarsData$address() {
        return SCIPgetSolVarsData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVarsData(SCIP *scip, SCIP_SOL *sol, SCIP_VAR ***vars, int *nvars, int *nbinvars, int *nintvars, int *nimplvars, int *ncontvars)
     * }
     */
    public static int SCIPgetSolVarsData(MemorySegment scip, MemorySegment sol, MemorySegment vars, MemorySegment nvars, MemorySegment nbinvars, MemorySegment nintvars, MemorySegment nimplvars, MemorySegment ncontvars) {
        var mh$ = SCIPgetSolVarsData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolVarsData", scip, sol, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
            }
            return (int)mh$.invokeExact(scip, sol, vars, nvars, nbinvars, nintvars, nimplvars, ncontvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPfindVar(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindVar$descriptor() {
        return SCIPfindVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPfindVar(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindVar$handle() {
        return SCIPfindVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_VAR *SCIPfindVar(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindVar$address() {
        return SCIPfindVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_VAR *SCIPfindVar(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindVar(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindVar", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPallVarsInProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPallVarsInProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPallVarsInProb(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPallVarsInProb$descriptor() {
        return SCIPallVarsInProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPallVarsInProb(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPallVarsInProb$handle() {
        return SCIPallVarsInProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPallVarsInProb(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPallVarsInProb$address() {
        return SCIPallVarsInProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPallVarsInProb(SCIP *scip)
     * }
     */
    public static int SCIPallVarsInProb(MemorySegment scip) {
        var mh$ = SCIPallVarsInProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPallVarsInProb", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPaddCons$descriptor() {
        return SCIPaddCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPaddCons$handle() {
        return SCIPaddCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPaddCons$address() {
        return SCIPaddCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPaddCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPaddCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdelCons$descriptor() {
        return SCIPdelCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdelCons$handle() {
        return SCIPdelCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdelCons$address() {
        return SCIPdelCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelCons(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdelCons(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdelCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelCons", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindOrigCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindOrigCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindOrigCons(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindOrigCons$descriptor() {
        return SCIPfindOrigCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindOrigCons(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindOrigCons$handle() {
        return SCIPfindOrigCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindOrigCons(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindOrigCons$address() {
        return SCIPfindOrigCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindOrigCons(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindOrigCons(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindOrigCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindOrigCons", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindCons(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindCons$descriptor() {
        return SCIPfindCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindCons(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindCons$handle() {
        return SCIPfindCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindCons(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCons$address() {
        return SCIPfindCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS *SCIPfindCons(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCons(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindCons", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNUpgrConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNUpgrConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNUpgrConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNUpgrConss$descriptor() {
        return SCIPgetNUpgrConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNUpgrConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNUpgrConss$handle() {
        return SCIPgetNUpgrConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNUpgrConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNUpgrConss$address() {
        return SCIPgetNUpgrConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNUpgrConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNUpgrConss(MemorySegment scip) {
        var mh$ = SCIPgetNUpgrConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNUpgrConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConss$descriptor() {
        return SCIPgetNConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConss$handle() {
        return SCIPgetNConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConss$address() {
        return SCIPgetNConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNConss(MemorySegment scip) {
        var mh$ = SCIPgetNConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetConss$descriptor() {
        return SCIPgetConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetConss$handle() {
        return SCIPgetConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConss$address() {
        return SCIPgetConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetConss(MemorySegment scip) {
        var mh$ = SCIPgetConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetConss", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNOrigConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNOrigConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNOrigConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNOrigConss$descriptor() {
        return SCIPgetNOrigConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNOrigConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNOrigConss$handle() {
        return SCIPgetNOrigConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNOrigConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNOrigConss$address() {
        return SCIPgetNOrigConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNOrigConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNOrigConss(MemorySegment scip) {
        var mh$ = SCIPgetNOrigConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNOrigConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOrigConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOrigConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetOrigConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetOrigConss$descriptor() {
        return SCIPgetOrigConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetOrigConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetOrigConss$handle() {
        return SCIPgetOrigConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetOrigConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigConss$address() {
        return SCIPgetOrigConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CONS **SCIPgetOrigConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetOrigConss(MemorySegment scip) {
        var mh$ = SCIPgetOrigConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOrigConss", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCheckConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCheckConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCheckConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCheckConss$descriptor() {
        return SCIPgetNCheckConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCheckConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCheckConss$handle() {
        return SCIPgetNCheckConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCheckConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCheckConss$address() {
        return SCIPgetNCheckConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCheckConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNCheckConss(MemorySegment scip) {
        var mh$ = SCIPgetNCheckConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCheckConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConflict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConflict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflict(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static FunctionDescriptor SCIPaddConflict$descriptor() {
        return SCIPaddConflict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflict(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static MethodHandle SCIPaddConflict$handle() {
        return SCIPaddConflict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflict(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static MemorySegment SCIPaddConflict$address() {
        return SCIPaddConflict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConflict(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode, SCIP_CONFTYPE conftype, unsigned int iscutoffinvolved)
     * }
     */
    public static int SCIPaddConflict(MemorySegment scip, MemorySegment node, MemorySegment cons, MemorySegment validnode, int conftype, int iscutoffinvolved) {
        var mh$ = SCIPaddConflict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConflict", scip, node, cons, validnode, conftype, iscutoffinvolved);
            }
            return (int)mh$.invokeExact(scip, node, cons, validnode, conftype, iscutoffinvolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearConflictStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearConflictStore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearConflictStore(SCIP *scip, SCIP_EVENT *event)
     * }
     */
    public static FunctionDescriptor SCIPclearConflictStore$descriptor() {
        return SCIPclearConflictStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearConflictStore(SCIP *scip, SCIP_EVENT *event)
     * }
     */
    public static MethodHandle SCIPclearConflictStore$handle() {
        return SCIPclearConflictStore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearConflictStore(SCIP *scip, SCIP_EVENT *event)
     * }
     */
    public static MemorySegment SCIPclearConflictStore$address() {
        return SCIPclearConflictStore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearConflictStore(SCIP *scip, SCIP_EVENT *event)
     * }
     */
    public static int SCIPclearConflictStore(MemorySegment scip, MemorySegment event) {
        var mh$ = SCIPclearConflictStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearConflictStore", scip, event);
            }
            return (int)mh$.invokeExact(scip, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static FunctionDescriptor SCIPaddConsNode$descriptor() {
        return SCIPaddConsNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static MethodHandle SCIPaddConsNode$handle() {
        return SCIPaddConsNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static MemorySegment SCIPaddConsNode$address() {
        return SCIPaddConsNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static int SCIPaddConsNode(MemorySegment scip, MemorySegment node, MemorySegment cons, MemorySegment validnode) {
        var mh$ = SCIPaddConsNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsNode", scip, node, cons, validnode);
            }
            return (int)mh$.invokeExact(scip, node, cons, validnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddConsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddConsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocal(SCIP *scip, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static FunctionDescriptor SCIPaddConsLocal$descriptor() {
        return SCIPaddConsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocal(SCIP *scip, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static MethodHandle SCIPaddConsLocal$handle() {
        return SCIPaddConsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocal(SCIP *scip, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static MemorySegment SCIPaddConsLocal$address() {
        return SCIPaddConsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddConsLocal(SCIP *scip, SCIP_CONS *cons, SCIP_NODE *validnode)
     * }
     */
    public static int SCIPaddConsLocal(MemorySegment scip, MemorySegment cons, MemorySegment validnode) {
        var mh$ = SCIPaddConsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddConsLocal", scip, cons, validnode);
            }
            return (int)mh$.invokeExact(scip, cons, validnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelConsNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelConsNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdelConsNode$descriptor() {
        return SCIPdelConsNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdelConsNode$handle() {
        return SCIPdelConsNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdelConsNode$address() {
        return SCIPdelConsNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsNode(SCIP *scip, SCIP_NODE *node, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdelConsNode(MemorySegment scip, MemorySegment node, MemorySegment cons) {
        var mh$ = SCIPdelConsNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelConsNode", scip, node, cons);
            }
            return (int)mh$.invokeExact(scip, node, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdelConsLocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdelConsLocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsLocal(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static FunctionDescriptor SCIPdelConsLocal$descriptor() {
        return SCIPdelConsLocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsLocal(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MethodHandle SCIPdelConsLocal$handle() {
        return SCIPdelConsLocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsLocal(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static MemorySegment SCIPdelConsLocal$address() {
        return SCIPdelConsLocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdelConsLocal(SCIP *scip, SCIP_CONS *cons)
     * }
     */
    public static int SCIPdelConsLocal(MemorySegment scip, MemorySegment cons) {
        var mh$ = SCIPdelConsLocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdelConsLocal", scip, cons);
            }
            return (int)mh$.invokeExact(scip, cons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLocalOrigEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLocalOrigEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLocalOrigEstimate(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLocalOrigEstimate$descriptor() {
        return SCIPgetLocalOrigEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLocalOrigEstimate(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLocalOrigEstimate$handle() {
        return SCIPgetLocalOrigEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLocalOrigEstimate(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLocalOrigEstimate$address() {
        return SCIPgetLocalOrigEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLocalOrigEstimate(SCIP *scip)
     * }
     */
    public static double SCIPgetLocalOrigEstimate(MemorySegment scip) {
        var mh$ = SCIPgetLocalOrigEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLocalOrigEstimate", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLocalTransEstimate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLocalTransEstimate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLocalTransEstimate(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLocalTransEstimate$descriptor() {
        return SCIPgetLocalTransEstimate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLocalTransEstimate(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLocalTransEstimate$handle() {
        return SCIPgetLocalTransEstimate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLocalTransEstimate(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLocalTransEstimate$address() {
        return SCIPgetLocalTransEstimate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLocalTransEstimate(SCIP *scip)
     * }
     */
    public static double SCIPgetLocalTransEstimate(MemorySegment scip) {
        var mh$ = SCIPgetLocalTransEstimate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLocalTransEstimate", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLocalDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLocalDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLocalDualbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLocalDualbound$descriptor() {
        return SCIPgetLocalDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLocalDualbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLocalDualbound$handle() {
        return SCIPgetLocalDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLocalDualbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLocalDualbound$address() {
        return SCIPgetLocalDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLocalDualbound(SCIP *scip)
     * }
     */
    public static double SCIPgetLocalDualbound(MemorySegment scip) {
        var mh$ = SCIPgetLocalDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLocalDualbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLocalLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLocalLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLocalLowerbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLocalLowerbound$descriptor() {
        return SCIPgetLocalLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLocalLowerbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLocalLowerbound$handle() {
        return SCIPgetLocalLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLocalLowerbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLocalLowerbound$address() {
        return SCIPgetLocalLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLocalLowerbound(SCIP *scip)
     * }
     */
    public static double SCIPgetLocalLowerbound(MemorySegment scip) {
        var mh$ = SCIPgetLocalLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLocalLowerbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNodeDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNodeDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetNodeDualbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPgetNodeDualbound$descriptor() {
        return SCIPgetNodeDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetNodeDualbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPgetNodeDualbound$handle() {
        return SCIPgetNodeDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetNodeDualbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPgetNodeDualbound$address() {
        return SCIPgetNodeDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetNodeDualbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static double SCIPgetNodeDualbound(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPgetNodeDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNodeDualbound", scip, node);
            }
            return (double)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNodeLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNodeLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetNodeLowerbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPgetNodeLowerbound$descriptor() {
        return SCIPgetNodeLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetNodeLowerbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPgetNodeLowerbound$handle() {
        return SCIPgetNodeLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetNodeLowerbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPgetNodeLowerbound$address() {
        return SCIPgetNodeLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetNodeLowerbound(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static double SCIPgetNodeLowerbound(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPgetNodeLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNodeLowerbound", scip, node);
            }
            return (double)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateLocalDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateLocalDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalDualbound(SCIP *scip, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateLocalDualbound$descriptor() {
        return SCIPupdateLocalDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalDualbound(SCIP *scip, double newbound)
     * }
     */
    public static MethodHandle SCIPupdateLocalDualbound$handle() {
        return SCIPupdateLocalDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalDualbound(SCIP *scip, double newbound)
     * }
     */
    public static MemorySegment SCIPupdateLocalDualbound$address() {
        return SCIPupdateLocalDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalDualbound(SCIP *scip, double newbound)
     * }
     */
    public static int SCIPupdateLocalDualbound(MemorySegment scip, double newbound) {
        var mh$ = SCIPupdateLocalDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateLocalDualbound", scip, newbound);
            }
            return (int)mh$.invokeExact(scip, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateLocalLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateLocalLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalLowerbound(SCIP *scip, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateLocalLowerbound$descriptor() {
        return SCIPupdateLocalLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalLowerbound(SCIP *scip, double newbound)
     * }
     */
    public static MethodHandle SCIPupdateLocalLowerbound$handle() {
        return SCIPupdateLocalLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalLowerbound(SCIP *scip, double newbound)
     * }
     */
    public static MemorySegment SCIPupdateLocalLowerbound$address() {
        return SCIPupdateLocalLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateLocalLowerbound(SCIP *scip, double newbound)
     * }
     */
    public static int SCIPupdateLocalLowerbound(MemorySegment scip, double newbound) {
        var mh$ = SCIPupdateLocalLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateLocalLowerbound", scip, newbound);
            }
            return (int)mh$.invokeExact(scip, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateNodeDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateNodeDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeDualbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateNodeDualbound$descriptor() {
        return SCIPupdateNodeDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeDualbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static MethodHandle SCIPupdateNodeDualbound$handle() {
        return SCIPupdateNodeDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeDualbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static MemorySegment SCIPupdateNodeDualbound$address() {
        return SCIPupdateNodeDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeDualbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static int SCIPupdateNodeDualbound(MemorySegment scip, MemorySegment node, double newbound) {
        var mh$ = SCIPupdateNodeDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateNodeDualbound", scip, node, newbound);
            }
            return (int)mh$.invokeExact(scip, node, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateNodeLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateNodeLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeLowerbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateNodeLowerbound$descriptor() {
        return SCIPupdateNodeLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeLowerbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static MethodHandle SCIPupdateNodeLowerbound$handle() {
        return SCIPupdateNodeLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeLowerbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static MemorySegment SCIPupdateNodeLowerbound$address() {
        return SCIPupdateNodeLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateNodeLowerbound(SCIP *scip, SCIP_NODE *node, double newbound)
     * }
     */
    public static int SCIPupdateNodeLowerbound(MemorySegment scip, MemorySegment node, double newbound) {
        var mh$ = SCIPupdateNodeLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateNodeLowerbound", scip, node, newbound);
            }
            return (int)mh$.invokeExact(scip, node, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgChildPrio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgChildPrio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgChildPrio(SCIP *scip, SCIP_NODE *child, double priority)
     * }
     */
    public static FunctionDescriptor SCIPchgChildPrio$descriptor() {
        return SCIPchgChildPrio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgChildPrio(SCIP *scip, SCIP_NODE *child, double priority)
     * }
     */
    public static MethodHandle SCIPchgChildPrio$handle() {
        return SCIPchgChildPrio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgChildPrio(SCIP *scip, SCIP_NODE *child, double priority)
     * }
     */
    public static MemorySegment SCIPchgChildPrio$address() {
        return SCIPchgChildPrio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgChildPrio(SCIP *scip, SCIP_NODE *child, double priority)
     * }
     */
    public static int SCIPchgChildPrio(MemorySegment scip, MemorySegment child, double priority) {
        var mh$ = SCIPchgChildPrio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgChildPrio", scip, child, priority);
            }
            return (int)mh$.invokeExact(scip, child, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPinProbing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPinProbing$descriptor() {
        return SCIPinProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPinProbing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPinProbing$handle() {
        return SCIPinProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPinProbing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPinProbing$address() {
        return SCIPinProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPinProbing(SCIP *scip)
     * }
     */
    public static int SCIPinProbing(MemorySegment scip) {
        var mh$ = SCIPinProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinProbing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartProbing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstartProbing$descriptor() {
        return SCIPstartProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartProbing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstartProbing$handle() {
        return SCIPstartProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartProbing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstartProbing$address() {
        return SCIPstartProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartProbing(SCIP *scip)
     * }
     */
    public static int SCIPstartProbing(MemorySegment scip) {
        var mh$ = SCIPstartProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartProbing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPnewProbingNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPnewProbingNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnewProbingNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPnewProbingNode$descriptor() {
        return SCIPnewProbingNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnewProbingNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPnewProbingNode$handle() {
        return SCIPnewProbingNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnewProbingNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPnewProbingNode$address() {
        return SCIPnewProbingNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPnewProbingNode(SCIP *scip)
     * }
     */
    public static int SCIPnewProbingNode(MemorySegment scip) {
        var mh$ = SCIPnewProbingNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPnewProbingNode", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbingDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbingDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetProbingDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetProbingDepth$descriptor() {
        return SCIPgetProbingDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetProbingDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetProbingDepth$handle() {
        return SCIPgetProbingDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetProbingDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProbingDepth$address() {
        return SCIPgetProbingDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetProbingDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetProbingDepth(MemorySegment scip) {
        var mh$ = SCIPgetProbingDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbingDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPbacktrackProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPbacktrackProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbacktrackProbing(SCIP *scip, int probingdepth)
     * }
     */
    public static FunctionDescriptor SCIPbacktrackProbing$descriptor() {
        return SCIPbacktrackProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbacktrackProbing(SCIP *scip, int probingdepth)
     * }
     */
    public static MethodHandle SCIPbacktrackProbing$handle() {
        return SCIPbacktrackProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbacktrackProbing(SCIP *scip, int probingdepth)
     * }
     */
    public static MemorySegment SCIPbacktrackProbing$address() {
        return SCIPbacktrackProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPbacktrackProbing(SCIP *scip, int probingdepth)
     * }
     */
    public static int SCIPbacktrackProbing(MemorySegment scip, int probingdepth) {
        var mh$ = SCIPbacktrackProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPbacktrackProbing", scip, probingdepth);
            }
            return (int)mh$.invokeExact(scip, probingdepth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPendProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPendProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendProbing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPendProbing$descriptor() {
        return SCIPendProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendProbing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPendProbing$handle() {
        return SCIPendProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendProbing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPendProbing$address() {
        return SCIPendProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPendProbing(SCIP *scip)
     * }
     */
    public static int SCIPendProbing(MemorySegment scip) {
        var mh$ = SCIPendProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPendProbing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarLbProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarLbProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarLbProbing$descriptor() {
        return SCIPchgVarLbProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarLbProbing$handle() {
        return SCIPchgVarLbProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarLbProbing$address() {
        return SCIPchgVarLbProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarLbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarLbProbing(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarLbProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarLbProbing", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarUbProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarUbProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static FunctionDescriptor SCIPchgVarUbProbing$descriptor() {
        return SCIPchgVarUbProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MethodHandle SCIPchgVarUbProbing$handle() {
        return SCIPchgVarUbProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static MemorySegment SCIPchgVarUbProbing$address() {
        return SCIPchgVarUbProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarUbProbing(SCIP *scip, SCIP_VAR *var, double newbound)
     * }
     */
    public static int SCIPchgVarUbProbing(MemorySegment scip, MemorySegment var_, double newbound) {
        var mh$ = SCIPchgVarUbProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarUbProbing", scip, var_, newbound);
            }
            return (int)mh$.invokeExact(scip, var_, newbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarObjProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarObjProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarObjProbing(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarObjProbing$descriptor() {
        return SCIPgetVarObjProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarObjProbing(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarObjProbing$handle() {
        return SCIPgetVarObjProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarObjProbing(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarObjProbing$address() {
        return SCIPgetVarObjProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarObjProbing(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarObjProbing(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarObjProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarObjProbing", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfixVarProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfixVarProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVarProbing(SCIP *scip, SCIP_VAR *var, double fixedval)
     * }
     */
    public static FunctionDescriptor SCIPfixVarProbing$descriptor() {
        return SCIPfixVarProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVarProbing(SCIP *scip, SCIP_VAR *var, double fixedval)
     * }
     */
    public static MethodHandle SCIPfixVarProbing$handle() {
        return SCIPfixVarProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVarProbing(SCIP *scip, SCIP_VAR *var, double fixedval)
     * }
     */
    public static MemorySegment SCIPfixVarProbing$address() {
        return SCIPfixVarProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfixVarProbing(SCIP *scip, SCIP_VAR *var, double fixedval)
     * }
     */
    public static int SCIPfixVarProbing(MemorySegment scip, MemorySegment var_, double fixedval) {
        var mh$ = SCIPfixVarProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfixVarProbing", scip, var_, fixedval);
            }
            return (int)mh$.invokeExact(scip, var_, fixedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarObjProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarObjProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjProbing(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static FunctionDescriptor SCIPchgVarObjProbing$descriptor() {
        return SCIPchgVarObjProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjProbing(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MethodHandle SCIPchgVarObjProbing$handle() {
        return SCIPchgVarObjProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjProbing(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static MemorySegment SCIPchgVarObjProbing$address() {
        return SCIPchgVarObjProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarObjProbing(SCIP *scip, SCIP_VAR *var, double newobj)
     * }
     */
    public static int SCIPchgVarObjProbing(MemorySegment scip, MemorySegment var_, double newobj) {
        var mh$ = SCIPchgVarObjProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarObjProbing", scip, var_, newobj);
            }
            return (int)mh$.invokeExact(scip, var_, newobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisObjChangedProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisObjChangedProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjChangedProbing(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisObjChangedProbing$descriptor() {
        return SCIPisObjChangedProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjChangedProbing(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisObjChangedProbing$handle() {
        return SCIPisObjChangedProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisObjChangedProbing(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisObjChangedProbing$address() {
        return SCIPisObjChangedProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisObjChangedProbing(SCIP *scip)
     * }
     */
    public static int SCIPisObjChangedProbing(MemorySegment scip) {
        var mh$ = SCIPisObjChangedProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisObjChangedProbing", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropagateProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropagateProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbing(SCIP *scip, int maxproprounds, unsigned int *cutoff, long long *ndomredsfound)
     * }
     */
    public static FunctionDescriptor SCIPpropagateProbing$descriptor() {
        return SCIPpropagateProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbing(SCIP *scip, int maxproprounds, unsigned int *cutoff, long long *ndomredsfound)
     * }
     */
    public static MethodHandle SCIPpropagateProbing$handle() {
        return SCIPpropagateProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbing(SCIP *scip, int maxproprounds, unsigned int *cutoff, long long *ndomredsfound)
     * }
     */
    public static MemorySegment SCIPpropagateProbing$address() {
        return SCIPpropagateProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbing(SCIP *scip, int maxproprounds, unsigned int *cutoff, long long *ndomredsfound)
     * }
     */
    public static int SCIPpropagateProbing(MemorySegment scip, int maxproprounds, MemorySegment cutoff, MemorySegment ndomredsfound) {
        var mh$ = SCIPpropagateProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropagateProbing", scip, maxproprounds, cutoff, ndomredsfound);
            }
            return (int)mh$.invokeExact(scip, maxproprounds, cutoff, ndomredsfound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpropagateProbingImplications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpropagateProbingImplications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbingImplications(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPpropagateProbingImplications$descriptor() {
        return SCIPpropagateProbingImplications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbingImplications(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPpropagateProbingImplications$handle() {
        return SCIPpropagateProbingImplications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbingImplications(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPpropagateProbingImplications$address() {
        return SCIPpropagateProbingImplications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpropagateProbingImplications(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static int SCIPpropagateProbingImplications(MemorySegment scip, MemorySegment cutoff) {
        var mh$ = SCIPpropagateProbingImplications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpropagateProbingImplications", scip, cutoff);
            }
            return (int)mh$.invokeExact(scip, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveProbingLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveProbingLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPsolveProbingLP$descriptor() {
        return SCIPsolveProbingLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPsolveProbingLP$handle() {
        return SCIPsolveProbingLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPsolveProbingLP$address() {
        return SCIPsolveProbingLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLP(SCIP *scip, int itlim, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static int SCIPsolveProbingLP(MemorySegment scip, int itlim, MemorySegment lperror, MemorySegment cutoff) {
        var mh$ = SCIPsolveProbingLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveProbingLP", scip, itlim, lperror, cutoff);
            }
            return (int)mh$.invokeExact(scip, itlim, lperror, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveProbingLPWithPricing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveProbingLPWithPricing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLPWithPricing(SCIP *scip, unsigned int pretendroot, unsigned int displayinfo, int maxpricerounds, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPsolveProbingLPWithPricing$descriptor() {
        return SCIPsolveProbingLPWithPricing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLPWithPricing(SCIP *scip, unsigned int pretendroot, unsigned int displayinfo, int maxpricerounds, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPsolveProbingLPWithPricing$handle() {
        return SCIPsolveProbingLPWithPricing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLPWithPricing(SCIP *scip, unsigned int pretendroot, unsigned int displayinfo, int maxpricerounds, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPsolveProbingLPWithPricing$address() {
        return SCIPsolveProbingLPWithPricing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingLPWithPricing(SCIP *scip, unsigned int pretendroot, unsigned int displayinfo, int maxpricerounds, unsigned int *lperror, unsigned int *cutoff)
     * }
     */
    public static int SCIPsolveProbingLPWithPricing(MemorySegment scip, int pretendroot, int displayinfo, int maxpricerounds, MemorySegment lperror, MemorySegment cutoff) {
        var mh$ = SCIPsolveProbingLPWithPricing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveProbingLPWithPricing", scip, pretendroot, displayinfo, maxpricerounds, lperror, cutoff);
            }
            return (int)mh$.invokeExact(scip, pretendroot, displayinfo, maxpricerounds, lperror, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetProbingLPState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetProbingLPState");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbingLPState(SCIP *scip, SCIP_LPISTATE **lpistate, SCIP_LPINORMS **lpinorms, unsigned int primalfeas, unsigned int dualfeas)
     * }
     */
    public static FunctionDescriptor SCIPsetProbingLPState$descriptor() {
        return SCIPsetProbingLPState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbingLPState(SCIP *scip, SCIP_LPISTATE **lpistate, SCIP_LPINORMS **lpinorms, unsigned int primalfeas, unsigned int dualfeas)
     * }
     */
    public static MethodHandle SCIPsetProbingLPState$handle() {
        return SCIPsetProbingLPState.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbingLPState(SCIP *scip, SCIP_LPISTATE **lpistate, SCIP_LPINORMS **lpinorms, unsigned int primalfeas, unsigned int dualfeas)
     * }
     */
    public static MemorySegment SCIPsetProbingLPState$address() {
        return SCIPsetProbingLPState.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetProbingLPState(SCIP *scip, SCIP_LPISTATE **lpistate, SCIP_LPINORMS **lpinorms, unsigned int primalfeas, unsigned int dualfeas)
     * }
     */
    public static int SCIPsetProbingLPState(MemorySegment scip, MemorySegment lpistate, MemorySegment lpinorms, int primalfeas, int dualfeas) {
        var mh$ = SCIPsetProbingLPState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetProbingLPState", scip, lpistate, lpinorms, primalfeas, dualfeas);
            }
            return (int)mh$.invokeExact(scip, lpistate, lpinorms, primalfeas, dualfeas);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddRowProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddRowProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowProbing(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static FunctionDescriptor SCIPaddRowProbing$descriptor() {
        return SCIPaddRowProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowProbing(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MethodHandle SCIPaddRowProbing$handle() {
        return SCIPaddRowProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowProbing(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static MemorySegment SCIPaddRowProbing$address() {
        return SCIPaddRowProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddRowProbing(SCIP *scip, SCIP_ROW *row)
     * }
     */
    public static int SCIPaddRowProbing(MemorySegment scip, MemorySegment row) {
        var mh$ = SCIPaddRowProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddRowProbing", scip, row);
            }
            return (int)mh$.invokeExact(scip, row);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyCutsProbing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyCutsProbing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyCutsProbing(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPapplyCutsProbing$descriptor() {
        return SCIPapplyCutsProbing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyCutsProbing(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPapplyCutsProbing$handle() {
        return SCIPapplyCutsProbing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyCutsProbing(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPapplyCutsProbing$address() {
        return SCIPapplyCutsProbing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyCutsProbing(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static int SCIPapplyCutsProbing(MemorySegment scip, MemorySegment cutoff) {
        var mh$ = SCIPapplyCutsProbing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyCutsProbing", scip, cutoff);
            }
            return (int)mh$.invokeExact(scip, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveProbingRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveProbingRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingRelax(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static FunctionDescriptor SCIPsolveProbingRelax$descriptor() {
        return SCIPsolveProbingRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingRelax(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MethodHandle SCIPsolveProbingRelax$handle() {
        return SCIPsolveProbingRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingRelax(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static MemorySegment SCIPsolveProbingRelax$address() {
        return SCIPsolveProbingRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveProbingRelax(SCIP *scip, unsigned int *cutoff)
     * }
     */
    public static int SCIPsolveProbingRelax(MemorySegment scip, MemorySegment cutoff) {
        var mh$ = SCIPsolveProbingRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveProbingRelax", scip, cutoff);
            }
            return (int)mh$.invokeExact(scip, cutoff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsnprintfProbingStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsnprintfProbingStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *SCIPsnprintfProbingStats(SCIP *scip, char *strbuf, int len)
     * }
     */
    public static FunctionDescriptor SCIPsnprintfProbingStats$descriptor() {
        return SCIPsnprintfProbingStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *SCIPsnprintfProbingStats(SCIP *scip, char *strbuf, int len)
     * }
     */
    public static MethodHandle SCIPsnprintfProbingStats$handle() {
        return SCIPsnprintfProbingStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *SCIPsnprintfProbingStats(SCIP *scip, char *strbuf, int len)
     * }
     */
    public static MemorySegment SCIPsnprintfProbingStats$address() {
        return SCIPsnprintfProbingStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *SCIPsnprintfProbingStats(SCIP *scip, char *strbuf, int len)
     * }
     */
    public static MemorySegment SCIPsnprintfProbingStats(MemorySegment scip, MemorySegment strbuf, int len) {
        var mh$ = SCIPsnprintfProbingStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsnprintfProbingStats", scip, strbuf, len);
            }
            return (MemorySegment)mh$.invokeExact(scip, strbuf, len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDivesetScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDivesetScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDivesetScore(SCIP *scip, SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype, SCIP_VAR *divecand, double divecandsol, double divecandfrac, double *candscore, unsigned int *roundup)
     * }
     */
    public static FunctionDescriptor SCIPgetDivesetScore$descriptor() {
        return SCIPgetDivesetScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDivesetScore(SCIP *scip, SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype, SCIP_VAR *divecand, double divecandsol, double divecandfrac, double *candscore, unsigned int *roundup)
     * }
     */
    public static MethodHandle SCIPgetDivesetScore$handle() {
        return SCIPgetDivesetScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDivesetScore(SCIP *scip, SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype, SCIP_VAR *divecand, double divecandsol, double divecandfrac, double *candscore, unsigned int *roundup)
     * }
     */
    public static MemorySegment SCIPgetDivesetScore$address() {
        return SCIPgetDivesetScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDivesetScore(SCIP *scip, SCIP_DIVESET *diveset, SCIP_DIVETYPE divetype, SCIP_VAR *divecand, double divecandsol, double divecandfrac, double *candscore, unsigned int *roundup)
     * }
     */
    public static int SCIPgetDivesetScore(MemorySegment scip, MemorySegment diveset, int divetype, MemorySegment divecand, double divecandsol, double divecandfrac, MemorySegment candscore, MemorySegment roundup) {
        var mh$ = SCIPgetDivesetScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDivesetScore", scip, diveset, divetype, divecand, divecandsol, divecandfrac, candscore, roundup);
            }
            return (int)mh$.invokeExact(scip, diveset, divetype, divecand, divecandsol, divecandfrac, candscore, roundup);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateDivesetLPStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateDivesetLPStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetLPStats(SCIP *scip, SCIP_DIVESET *diveset, long long niterstoadd, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPupdateDivesetLPStats$descriptor() {
        return SCIPupdateDivesetLPStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetLPStats(SCIP *scip, SCIP_DIVESET *diveset, long long niterstoadd, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPupdateDivesetLPStats$handle() {
        return SCIPupdateDivesetLPStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetLPStats(SCIP *scip, SCIP_DIVESET *diveset, long long niterstoadd, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPupdateDivesetLPStats$address() {
        return SCIPupdateDivesetLPStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateDivesetLPStats(SCIP *scip, SCIP_DIVESET *diveset, long long niterstoadd, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static void SCIPupdateDivesetLPStats(MemorySegment scip, MemorySegment diveset, long niterstoadd, int divecontext) {
        var mh$ = SCIPupdateDivesetLPStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateDivesetLPStats", scip, diveset, niterstoadd, divecontext);
            }
            mh$.invokeExact(scip, diveset, niterstoadd, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateDivesetStats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_LONG_LONG,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateDivesetStats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetStats(SCIP *scip, SCIP_DIVESET *diveset, int nprobingnodes, int nbacktracks, long long nsolsfound, long long nbestsolsfound, long long nconflictsfound, unsigned int leavewassol, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static FunctionDescriptor SCIPupdateDivesetStats$descriptor() {
        return SCIPupdateDivesetStats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetStats(SCIP *scip, SCIP_DIVESET *diveset, int nprobingnodes, int nbacktracks, long long nsolsfound, long long nbestsolsfound, long long nconflictsfound, unsigned int leavewassol, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MethodHandle SCIPupdateDivesetStats$handle() {
        return SCIPupdateDivesetStats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateDivesetStats(SCIP *scip, SCIP_DIVESET *diveset, int nprobingnodes, int nbacktracks, long long nsolsfound, long long nbestsolsfound, long long nconflictsfound, unsigned int leavewassol, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static MemorySegment SCIPupdateDivesetStats$address() {
        return SCIPupdateDivesetStats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateDivesetStats(SCIP *scip, SCIP_DIVESET *diveset, int nprobingnodes, int nbacktracks, long long nsolsfound, long long nbestsolsfound, long long nconflictsfound, unsigned int leavewassol, SCIP_DIVECONTEXT divecontext)
     * }
     */
    public static void SCIPupdateDivesetStats(MemorySegment scip, MemorySegment diveset, int nprobingnodes, int nbacktracks, long nsolsfound, long nbestsolsfound, long nconflictsfound, int leavewassol, int divecontext) {
        var mh$ = SCIPupdateDivesetStats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateDivesetStats", scip, diveset, nprobingnodes, nbacktracks, nsolsfound, nbestsolsfound, nconflictsfound, leavewassol, divecontext);
            }
            mh$.invokeExact(scip, diveset, nprobingnodes, nbacktracks, nsolsfound, nbestsolsfound, nconflictsfound, leavewassol, divecontext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDiveBoundChanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDiveBoundChanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDiveBoundChanges(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *sol, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static FunctionDescriptor SCIPgetDiveBoundChanges$descriptor() {
        return SCIPgetDiveBoundChanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDiveBoundChanges(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *sol, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static MethodHandle SCIPgetDiveBoundChanges$handle() {
        return SCIPgetDiveBoundChanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDiveBoundChanges(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *sol, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static MemorySegment SCIPgetDiveBoundChanges$address() {
        return SCIPgetDiveBoundChanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDiveBoundChanges(SCIP *scip, SCIP_DIVESET *diveset, SCIP_SOL *sol, unsigned int *success, unsigned int *infeasible)
     * }
     */
    public static int SCIPgetDiveBoundChanges(MemorySegment scip, MemorySegment diveset, MemorySegment sol, MemorySegment success, MemorySegment infeasible) {
        var mh$ = SCIPgetDiveBoundChanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDiveBoundChanges", scip, diveset, sol, success, infeasible);
            }
            return (int)mh$.invokeExact(scip, diveset, sol, success, infeasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddDiveBoundChange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddDiveBoundChange");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDiveBoundChange(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, double value, unsigned int preferred)
     * }
     */
    public static FunctionDescriptor SCIPaddDiveBoundChange$descriptor() {
        return SCIPaddDiveBoundChange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDiveBoundChange(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, double value, unsigned int preferred)
     * }
     */
    public static MethodHandle SCIPaddDiveBoundChange$handle() {
        return SCIPaddDiveBoundChange.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDiveBoundChange(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, double value, unsigned int preferred)
     * }
     */
    public static MemorySegment SCIPaddDiveBoundChange$address() {
        return SCIPaddDiveBoundChange.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddDiveBoundChange(SCIP *scip, SCIP_VAR *var, SCIP_BRANCHDIR dir, double value, unsigned int preferred)
     * }
     */
    public static int SCIPaddDiveBoundChange(MemorySegment scip, MemorySegment var_, int dir, double value, int preferred) {
        var mh$ = SCIPaddDiveBoundChange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddDiveBoundChange", scip, var_, dir, value, preferred);
            }
            return (int)mh$.invokeExact(scip, var_, dir, value, preferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDiveBoundChangeData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDiveBoundChangeData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetDiveBoundChangeData(SCIP *scip, SCIP_VAR ***variables, SCIP_BRANCHDIR **directions, double **values, int *ndivebdchgs, unsigned int preferred)
     * }
     */
    public static FunctionDescriptor SCIPgetDiveBoundChangeData$descriptor() {
        return SCIPgetDiveBoundChangeData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetDiveBoundChangeData(SCIP *scip, SCIP_VAR ***variables, SCIP_BRANCHDIR **directions, double **values, int *ndivebdchgs, unsigned int preferred)
     * }
     */
    public static MethodHandle SCIPgetDiveBoundChangeData$handle() {
        return SCIPgetDiveBoundChangeData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetDiveBoundChangeData(SCIP *scip, SCIP_VAR ***variables, SCIP_BRANCHDIR **directions, double **values, int *ndivebdchgs, unsigned int preferred)
     * }
     */
    public static MemorySegment SCIPgetDiveBoundChangeData$address() {
        return SCIPgetDiveBoundChangeData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetDiveBoundChangeData(SCIP *scip, SCIP_VAR ***variables, SCIP_BRANCHDIR **directions, double **values, int *ndivebdchgs, unsigned int preferred)
     * }
     */
    public static void SCIPgetDiveBoundChangeData(MemorySegment scip, MemorySegment variables, MemorySegment directions, MemorySegment values, MemorySegment ndivebdchgs, int preferred) {
        var mh$ = SCIPgetDiveBoundChangeData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDiveBoundChangeData", scip, variables, directions, values, ndivebdchgs, preferred);
            }
            mh$.invokeExact(scip, variables, directions, values, ndivebdchgs, preferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearDiveBoundChanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearDiveBoundChanges");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPclearDiveBoundChanges(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPclearDiveBoundChanges$descriptor() {
        return SCIPclearDiveBoundChanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPclearDiveBoundChanges(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPclearDiveBoundChanges$handle() {
        return SCIPclearDiveBoundChanges.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPclearDiveBoundChanges(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPclearDiveBoundChanges$address() {
        return SCIPclearDiveBoundChanges.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPclearDiveBoundChanges(SCIP *scip)
     * }
     */
    public static void SCIPclearDiveBoundChanges(MemorySegment scip) {
        var mh$ = SCIPclearDiveBoundChanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearDiveBoundChanges", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeProp(SCIP *scip, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int), SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeProp$descriptor() {
        return SCIPincludeProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeProp(SCIP *scip, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int), SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static MethodHandle SCIPincludeProp$handle() {
        return SCIPincludeProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeProp(SCIP *scip, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int), SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static MemorySegment SCIPincludeProp$address() {
        return SCIPincludeProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeProp(SCIP *scip, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *), SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int), SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static int SCIPincludeProp(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int freq, int delay, int timingmask, int presolpriority, int presolmaxrounds, int presoltiming, MemorySegment propcopy, MemorySegment propfree, MemorySegment propinit, MemorySegment propexit, MemorySegment propinitpre, MemorySegment propexitpre, MemorySegment propinitsol, MemorySegment propexitsol, MemorySegment proppresol, MemorySegment propexec, MemorySegment propresprop, MemorySegment propdata) {
        var mh$ = SCIPincludeProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeProp", scip, name, desc, priority, freq, delay, timingmask, presolpriority, presolmaxrounds, presoltiming, propcopy, propfree, propinit, propexit, propinitpre, propexitpre, propinitsol, propexitsol, proppresol, propexec, propresprop, propdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, freq, delay, timingmask, presolpriority, presolmaxrounds, presoltiming, propcopy, propfree, propinit, propexit, propinitpre, propexitpre, propinitsol, propexitsol, proppresol, propexec, propresprop, propdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludePropBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludePropBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropBasic(SCIP *scip, SCIP_PROP **propptr, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static FunctionDescriptor SCIPincludePropBasic$descriptor() {
        return SCIPincludePropBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropBasic(SCIP *scip, SCIP_PROP **propptr, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static MethodHandle SCIPincludePropBasic$handle() {
        return SCIPincludePropBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropBasic(SCIP *scip, SCIP_PROP **propptr, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static MemorySegment SCIPincludePropBasic$address() {
        return SCIPincludePropBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludePropBasic(SCIP *scip, SCIP_PROP **propptr, const char *name, const char *desc, int priority, int freq, unsigned int delay, SCIP_PROPTIMING timingmask, SCIP_RETCODE (*propexec)(SCIP *, SCIP_PROP *, SCIP_PROPTIMING, SCIP_RESULT *), SCIP_PROPDATA *propdata)
     * }
     */
    public static int SCIPincludePropBasic(MemorySegment scip, MemorySegment propptr, MemorySegment name, MemorySegment desc, int priority, int freq, int delay, int timingmask, MemorySegment propexec, MemorySegment propdata) {
        var mh$ = SCIPincludePropBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludePropBasic", scip, propptr, name, desc, priority, freq, delay, timingmask, propexec, propdata);
            }
            return (int)mh$.invokeExact(scip, propptr, name, desc, priority, freq, delay, timingmask, propexec, propdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropCopy(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropCopy$descriptor() {
        return SCIPsetPropCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropCopy(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropCopy$handle() {
        return SCIPsetPropCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropCopy(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropCopy$address() {
        return SCIPsetPropCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropCopy(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propcopy)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropCopy(MemorySegment scip, MemorySegment prop, MemorySegment propcopy) {
        var mh$ = SCIPsetPropCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropCopy", scip, prop, propcopy);
            }
            return (int)mh$.invokeExact(scip, prop, propcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropFree(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropFree$descriptor() {
        return SCIPsetPropFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropFree(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropFree$handle() {
        return SCIPsetPropFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropFree(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropFree$address() {
        return SCIPsetPropFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropFree(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propfree)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropFree(MemorySegment scip, MemorySegment prop, MemorySegment propfree) {
        var mh$ = SCIPsetPropFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropFree", scip, prop, propfree);
            }
            return (int)mh$.invokeExact(scip, prop, propfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropInit$descriptor() {
        return SCIPsetPropInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropInit$handle() {
        return SCIPsetPropInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropInit$address() {
        return SCIPsetPropInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropInit(MemorySegment scip, MemorySegment prop, MemorySegment propinit) {
        var mh$ = SCIPsetPropInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropInit", scip, prop, propinit);
            }
            return (int)mh$.invokeExact(scip, prop, propinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropExit$descriptor() {
        return SCIPsetPropExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropExit$handle() {
        return SCIPsetPropExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropExit$address() {
        return SCIPsetPropExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExit(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexit)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropExit(MemorySegment scip, MemorySegment prop, MemorySegment propexit) {
        var mh$ = SCIPsetPropExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropExit", scip, prop, propexit);
            }
            return (int)mh$.invokeExact(scip, prop, propexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropInitsol$descriptor() {
        return SCIPsetPropInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropInitsol$handle() {
        return SCIPsetPropInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropInitsol$address() {
        return SCIPsetPropInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitsol)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropInitsol(MemorySegment scip, MemorySegment prop, MemorySegment propinitsol) {
        var mh$ = SCIPsetPropInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropInitsol", scip, prop, propinitsol);
            }
            return (int)mh$.invokeExact(scip, prop, propinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int))
     * }
     */
    public static FunctionDescriptor SCIPsetPropExitsol$descriptor() {
        return SCIPsetPropExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int))
     * }
     */
    public static MethodHandle SCIPsetPropExitsol$handle() {
        return SCIPsetPropExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int))
     * }
     */
    public static MemorySegment SCIPsetPropExitsol$address() {
        return SCIPsetPropExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitsol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitsol)(SCIP *, SCIP_PROP *, unsigned int))
     * }
     */
    public static int SCIPsetPropExitsol(MemorySegment scip, MemorySegment prop, MemorySegment propexitsol) {
        var mh$ = SCIPsetPropExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropExitsol", scip, prop, propexitsol);
            }
            return (int)mh$.invokeExact(scip, prop, propexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropInitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropInitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropInitpre$descriptor() {
        return SCIPsetPropInitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropInitpre$handle() {
        return SCIPsetPropInitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropInitpre$address() {
        return SCIPsetPropInitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropInitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propinitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropInitpre(MemorySegment scip, MemorySegment prop, MemorySegment propinitpre) {
        var mh$ = SCIPsetPropInitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropInitpre", scip, prop, propinitpre);
            }
            return (int)mh$.invokeExact(scip, prop, propinitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropExitpre {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropExitpre");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropExitpre$descriptor() {
        return SCIPsetPropExitpre.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MethodHandle SCIPsetPropExitpre$handle() {
        return SCIPsetPropExitpre.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static MemorySegment SCIPsetPropExitpre$address() {
        return SCIPsetPropExitpre.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropExitpre(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propexitpre)(SCIP *, SCIP_PROP *))
     * }
     */
    public static int SCIPsetPropExitpre(MemorySegment scip, MemorySegment prop, MemorySegment propexitpre) {
        var mh$ = SCIPsetPropExitpre.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropExitpre", scip, prop, propexitpre);
            }
            return (int)mh$.invokeExact(scip, prop, propexitpre);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropPresol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropPresol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static FunctionDescriptor SCIPsetPropPresol$descriptor() {
        return SCIPsetPropPresol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MethodHandle SCIPsetPropPresol$handle() {
        return SCIPsetPropPresol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static MemorySegment SCIPsetPropPresol$address() {
        return SCIPsetPropPresol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresol(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*proppresol)(SCIP *, SCIP_PROP *, int, SCIP_PRESOLTIMING, int, int, int, int, int, int, int, int, int, int, int *, int *, int *, int *, int *, int *, int *, int *, int *, int *, SCIP_RESULT *), int presolpriority, int presolmaxrounds, SCIP_PRESOLTIMING presoltiming)
     * }
     */
    public static int SCIPsetPropPresol(MemorySegment scip, MemorySegment prop, MemorySegment proppresol, int presolpriority, int presolmaxrounds, int presoltiming) {
        var mh$ = SCIPsetPropPresol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropPresol", scip, prop, proppresol, presolpriority, presolmaxrounds, presoltiming);
            }
            return (int)mh$.invokeExact(scip, prop, proppresol, presolpriority, presolmaxrounds, presoltiming);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropResprop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropResprop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropResprop(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetPropResprop$descriptor() {
        return SCIPsetPropResprop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropResprop(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetPropResprop$handle() {
        return SCIPsetPropResprop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropResprop(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetPropResprop$address() {
        return SCIPsetPropResprop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropResprop(SCIP *scip, SCIP_PROP *prop, SCIP_RETCODE (*propresprop)(SCIP *, SCIP_PROP *, SCIP_VAR *, int, SCIP_BOUNDTYPE, SCIP_BDCHGIDX *, double, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetPropResprop(MemorySegment scip, MemorySegment prop, MemorySegment propresprop) {
        var mh$ = SCIPsetPropResprop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropResprop", scip, prop, propresprop);
            }
            return (int)mh$.invokeExact(scip, prop, propresprop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindProp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindProp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPfindProp(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindProp$descriptor() {
        return SCIPfindProp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPfindProp(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindProp$handle() {
        return SCIPfindProp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROP *SCIPfindProp(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindProp$address() {
        return SCIPfindProp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROP *SCIPfindProp(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindProp(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindProp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindProp", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_PROP **SCIPgetProps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetProps$descriptor() {
        return SCIPgetProps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_PROP **SCIPgetProps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetProps$handle() {
        return SCIPgetProps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_PROP **SCIPgetProps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProps$address() {
        return SCIPgetProps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_PROP **SCIPgetProps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetProps(MemorySegment scip) {
        var mh$ = SCIPgetProps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProps", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNProps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNProps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNProps(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNProps$descriptor() {
        return SCIPgetNProps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNProps(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNProps$handle() {
        return SCIPgetNProps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNProps(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNProps$address() {
        return SCIPgetNProps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNProps(SCIP *scip)
     * }
     */
    public static int SCIPgetNProps(MemorySegment scip) {
        var mh$ = SCIPgetNProps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNProps", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPriority(SCIP *scip, SCIP_PROP *prop, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetPropPriority$descriptor() {
        return SCIPsetPropPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPriority(SCIP *scip, SCIP_PROP *prop, int priority)
     * }
     */
    public static MethodHandle SCIPsetPropPriority$handle() {
        return SCIPsetPropPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPriority(SCIP *scip, SCIP_PROP *prop, int priority)
     * }
     */
    public static MemorySegment SCIPsetPropPriority$address() {
        return SCIPsetPropPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPriority(SCIP *scip, SCIP_PROP *prop, int priority)
     * }
     */
    public static int SCIPsetPropPriority(MemorySegment scip, MemorySegment prop, int priority) {
        var mh$ = SCIPsetPropPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropPriority", scip, prop, priority);
            }
            return (int)mh$.invokeExact(scip, prop, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetPropPresolPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetPropPresolPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresolPriority(SCIP *scip, SCIP_PROP *prop, int presolpriority)
     * }
     */
    public static FunctionDescriptor SCIPsetPropPresolPriority$descriptor() {
        return SCIPsetPropPresolPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresolPriority(SCIP *scip, SCIP_PROP *prop, int presolpriority)
     * }
     */
    public static MethodHandle SCIPsetPropPresolPriority$handle() {
        return SCIPsetPropPresolPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresolPriority(SCIP *scip, SCIP_PROP *prop, int presolpriority)
     * }
     */
    public static MemorySegment SCIPsetPropPresolPriority$address() {
        return SCIPsetPropPresolPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetPropPresolPriority(SCIP *scip, SCIP_PROP *prop, int presolpriority)
     * }
     */
    public static int SCIPsetPropPresolPriority(MemorySegment scip, MemorySegment prop, int presolpriority) {
        var mh$ = SCIPsetPropPresolPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetPropPresolPriority", scip, prop, presolpriority);
            }
            return (int)mh$.invokeExact(scip, prop, presolpriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen, unsigned int initialseed, unsigned int useglobalseed)
     * }
     */
    public static FunctionDescriptor SCIPcreateRandom$descriptor() {
        return SCIPcreateRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen, unsigned int initialseed, unsigned int useglobalseed)
     * }
     */
    public static MethodHandle SCIPcreateRandom$handle() {
        return SCIPcreateRandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen, unsigned int initialseed, unsigned int useglobalseed)
     * }
     */
    public static MemorySegment SCIPcreateRandom$address() {
        return SCIPcreateRandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen, unsigned int initialseed, unsigned int useglobalseed)
     * }
     */
    public static int SCIPcreateRandom(MemorySegment scip, MemorySegment randnumgen, int initialseed, int useglobalseed) {
        var mh$ = SCIPcreateRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRandom", scip, randnumgen, initialseed, useglobalseed);
            }
            return (int)mh$.invokeExact(scip, randnumgen, initialseed, useglobalseed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeRandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen)
     * }
     */
    public static FunctionDescriptor SCIPfreeRandom$descriptor() {
        return SCIPfreeRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen)
     * }
     */
    public static MethodHandle SCIPfreeRandom$handle() {
        return SCIPfreeRandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen)
     * }
     */
    public static MemorySegment SCIPfreeRandom$address() {
        return SCIPfreeRandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeRandom(SCIP *scip, SCIP_RANDNUMGEN **randnumgen)
     * }
     */
    public static void SCIPfreeRandom(MemorySegment scip, MemorySegment randnumgen) {
        var mh$ = SCIPfreeRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeRandom", scip, randnumgen);
            }
            mh$.invokeExact(scip, randnumgen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRandomSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRandomSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetRandomSeed(SCIP *scip, SCIP_RANDNUMGEN *randnumgen, unsigned int seed)
     * }
     */
    public static FunctionDescriptor SCIPsetRandomSeed$descriptor() {
        return SCIPsetRandomSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetRandomSeed(SCIP *scip, SCIP_RANDNUMGEN *randnumgen, unsigned int seed)
     * }
     */
    public static MethodHandle SCIPsetRandomSeed$handle() {
        return SCIPsetRandomSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetRandomSeed(SCIP *scip, SCIP_RANDNUMGEN *randnumgen, unsigned int seed)
     * }
     */
    public static MemorySegment SCIPsetRandomSeed$address() {
        return SCIPsetRandomSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetRandomSeed(SCIP *scip, SCIP_RANDNUMGEN *randnumgen, unsigned int seed)
     * }
     */
    public static void SCIPsetRandomSeed(MemorySegment scip, MemorySegment randnumgen, int seed) {
        var mh$ = SCIPsetRandomSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRandomSeed", scip, randnumgen, seed);
            }
            mh$.invokeExact(scip, randnumgen, seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitializeRandomSeed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitializeRandomSeed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPinitializeRandomSeed(SCIP *scip, unsigned int initialseedvalue)
     * }
     */
    public static FunctionDescriptor SCIPinitializeRandomSeed$descriptor() {
        return SCIPinitializeRandomSeed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPinitializeRandomSeed(SCIP *scip, unsigned int initialseedvalue)
     * }
     */
    public static MethodHandle SCIPinitializeRandomSeed$handle() {
        return SCIPinitializeRandomSeed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPinitializeRandomSeed(SCIP *scip, unsigned int initialseedvalue)
     * }
     */
    public static MemorySegment SCIPinitializeRandomSeed$address() {
        return SCIPinitializeRandomSeed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPinitializeRandomSeed(SCIP *scip, unsigned int initialseedvalue)
     * }
     */
    public static int SCIPinitializeRandomSeed(MemorySegment scip, int initialseedvalue) {
        var mh$ = SCIPinitializeRandomSeed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitializeRandomSeed", scip, initialseedvalue);
            }
            return (int)mh$.invokeExact(scip, initialseedvalue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReader(SCIP *scip, const char *name, const char *desc, const char *extension, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *), SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *), SCIP_READERDATA *readerdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeReader$descriptor() {
        return SCIPincludeReader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReader(SCIP *scip, const char *name, const char *desc, const char *extension, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *), SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *), SCIP_READERDATA *readerdata)
     * }
     */
    public static MethodHandle SCIPincludeReader$handle() {
        return SCIPincludeReader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReader(SCIP *scip, const char *name, const char *desc, const char *extension, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *), SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *), SCIP_READERDATA *readerdata)
     * }
     */
    public static MemorySegment SCIPincludeReader$address() {
        return SCIPincludeReader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReader(SCIP *scip, const char *name, const char *desc, const char *extension, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *), SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *), SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *), SCIP_READERDATA *readerdata)
     * }
     */
    public static int SCIPincludeReader(MemorySegment scip, MemorySegment name, MemorySegment desc, MemorySegment extension, MemorySegment readercopy, MemorySegment readerfree, MemorySegment readerread, MemorySegment readerwrite, MemorySegment readerdata) {
        var mh$ = SCIPincludeReader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReader", scip, name, desc, extension, readercopy, readerfree, readerread, readerwrite, readerdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, extension, readercopy, readerfree, readerread, readerwrite, readerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeReaderBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeReaderBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBasic(SCIP *scip, SCIP_READER **readerptr, const char *name, const char *desc, const char *extension, SCIP_READERDATA *readerdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeReaderBasic$descriptor() {
        return SCIPincludeReaderBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBasic(SCIP *scip, SCIP_READER **readerptr, const char *name, const char *desc, const char *extension, SCIP_READERDATA *readerdata)
     * }
     */
    public static MethodHandle SCIPincludeReaderBasic$handle() {
        return SCIPincludeReaderBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBasic(SCIP *scip, SCIP_READER **readerptr, const char *name, const char *desc, const char *extension, SCIP_READERDATA *readerdata)
     * }
     */
    public static MemorySegment SCIPincludeReaderBasic$address() {
        return SCIPincludeReaderBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeReaderBasic(SCIP *scip, SCIP_READER **readerptr, const char *name, const char *desc, const char *extension, SCIP_READERDATA *readerdata)
     * }
     */
    public static int SCIPincludeReaderBasic(MemorySegment scip, MemorySegment readerptr, MemorySegment name, MemorySegment desc, MemorySegment extension, MemorySegment readerdata) {
        var mh$ = SCIPincludeReaderBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeReaderBasic", scip, readerptr, name, desc, extension, readerdata);
            }
            return (int)mh$.invokeExact(scip, readerptr, name, desc, extension, readerdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetReaderCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetReaderCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderCopy(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *))
     * }
     */
    public static FunctionDescriptor SCIPsetReaderCopy$descriptor() {
        return SCIPsetReaderCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderCopy(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *))
     * }
     */
    public static MethodHandle SCIPsetReaderCopy$handle() {
        return SCIPsetReaderCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderCopy(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *))
     * }
     */
    public static MemorySegment SCIPsetReaderCopy$address() {
        return SCIPsetReaderCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderCopy(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readercopy)(SCIP *, SCIP_READER *))
     * }
     */
    public static int SCIPsetReaderCopy(MemorySegment scip, MemorySegment reader, MemorySegment readercopy) {
        var mh$ = SCIPsetReaderCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetReaderCopy", scip, reader, readercopy);
            }
            return (int)mh$.invokeExact(scip, reader, readercopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetReaderFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetReaderFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderFree(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *))
     * }
     */
    public static FunctionDescriptor SCIPsetReaderFree$descriptor() {
        return SCIPsetReaderFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderFree(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *))
     * }
     */
    public static MethodHandle SCIPsetReaderFree$handle() {
        return SCIPsetReaderFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderFree(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *))
     * }
     */
    public static MemorySegment SCIPsetReaderFree$address() {
        return SCIPsetReaderFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderFree(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerfree)(SCIP *, SCIP_READER *))
     * }
     */
    public static int SCIPsetReaderFree(MemorySegment scip, MemorySegment reader, MemorySegment readerfree) {
        var mh$ = SCIPsetReaderFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetReaderFree", scip, reader, readerfree);
            }
            return (int)mh$.invokeExact(scip, reader, readerfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetReaderRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetReaderRead");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderRead(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetReaderRead$descriptor() {
        return SCIPsetReaderRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderRead(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetReaderRead$handle() {
        return SCIPsetReaderRead.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderRead(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetReaderRead$address() {
        return SCIPsetReaderRead.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderRead(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerread)(SCIP *, SCIP_READER *, const char *, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetReaderRead(MemorySegment scip, MemorySegment reader, MemorySegment readerread) {
        var mh$ = SCIPsetReaderRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetReaderRead", scip, reader, readerread);
            }
            return (int)mh$.invokeExact(scip, reader, readerread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetReaderWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetReaderWrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderWrite(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static FunctionDescriptor SCIPsetReaderWrite$descriptor() {
        return SCIPsetReaderWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderWrite(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MethodHandle SCIPsetReaderWrite$handle() {
        return SCIPsetReaderWrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderWrite(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static MemorySegment SCIPsetReaderWrite$address() {
        return SCIPsetReaderWrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReaderWrite(SCIP *scip, SCIP_READER *reader, SCIP_RETCODE (*readerwrite)(SCIP *, SCIP_READER *, FILE *, const char *, SCIP_PROBDATA *, unsigned int, SCIP_OBJSENSE, double, double, SCIP_VAR **, int, int, int, int, int, SCIP_VAR **, int, int, SCIP_CONS **, int, int, int, unsigned int, SCIP_RESULT *))
     * }
     */
    public static int SCIPsetReaderWrite(MemorySegment scip, MemorySegment reader, MemorySegment readerwrite) {
        var mh$ = SCIPsetReaderWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetReaderWrite", scip, reader, readerwrite);
            }
            return (int)mh$.invokeExact(scip, reader, readerwrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindReader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindReader");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_READER *SCIPfindReader(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindReader$descriptor() {
        return SCIPfindReader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_READER *SCIPfindReader(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindReader$handle() {
        return SCIPfindReader.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_READER *SCIPfindReader(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindReader$address() {
        return SCIPfindReader.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_READER *SCIPfindReader(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindReader(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindReader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindReader", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReaders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReaders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_READER **SCIPgetReaders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetReaders$descriptor() {
        return SCIPgetReaders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_READER **SCIPgetReaders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetReaders$handle() {
        return SCIPgetReaders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_READER **SCIPgetReaders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetReaders$address() {
        return SCIPgetReaders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_READER **SCIPgetReaders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetReaders(MemorySegment scip) {
        var mh$ = SCIPgetReaders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReaders", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNReaders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNReaders");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNReaders(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNReaders$descriptor() {
        return SCIPgetNReaders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNReaders(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNReaders$handle() {
        return SCIPgetNReaders.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNReaders(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNReaders$address() {
        return SCIPgetNReaders.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNReaders(SCIP *scip)
     * }
     */
    public static int SCIPgetNReaders(MemorySegment scip) {
        var mh$ = SCIPgetNReaders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNReaders", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelax(SCIP *scip, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeRelax$descriptor() {
        return SCIPincludeRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelax(SCIP *scip, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MethodHandle SCIPincludeRelax$handle() {
        return SCIPincludeRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelax(SCIP *scip, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MemorySegment SCIPincludeRelax$address() {
        return SCIPincludeRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelax(SCIP *scip, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *), SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static int SCIPincludeRelax(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int freq, MemorySegment relaxcopy, MemorySegment relaxfree, MemorySegment relaxinit, MemorySegment relaxexit, MemorySegment relaxinitsol, MemorySegment relaxexitsol, MemorySegment relaxexec, MemorySegment relaxdata) {
        var mh$ = SCIPincludeRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeRelax", scip, name, desc, priority, freq, relaxcopy, relaxfree, relaxinit, relaxexit, relaxinitsol, relaxexitsol, relaxexec, relaxdata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, freq, relaxcopy, relaxfree, relaxinit, relaxexit, relaxinitsol, relaxexitsol, relaxexec, relaxdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeRelaxBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeRelaxBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelaxBasic(SCIP *scip, SCIP_RELAX **relaxptr, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static FunctionDescriptor SCIPincludeRelaxBasic$descriptor() {
        return SCIPincludeRelaxBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelaxBasic(SCIP *scip, SCIP_RELAX **relaxptr, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MethodHandle SCIPincludeRelaxBasic$handle() {
        return SCIPincludeRelaxBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelaxBasic(SCIP *scip, SCIP_RELAX **relaxptr, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static MemorySegment SCIPincludeRelaxBasic$address() {
        return SCIPincludeRelaxBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeRelaxBasic(SCIP *scip, SCIP_RELAX **relaxptr, const char *name, const char *desc, int priority, int freq, SCIP_RETCODE (*relaxexec)(SCIP *, SCIP_RELAX *, double *, SCIP_RESULT *), SCIP_RELAXDATA *relaxdata)
     * }
     */
    public static int SCIPincludeRelaxBasic(MemorySegment scip, MemorySegment relaxptr, MemorySegment name, MemorySegment desc, int priority, int freq, MemorySegment relaxexec, MemorySegment relaxdata) {
        var mh$ = SCIPincludeRelaxBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeRelaxBasic", scip, relaxptr, name, desc, priority, freq, relaxexec, relaxdata);
            }
            return (int)mh$.invokeExact(scip, relaxptr, name, desc, priority, freq, relaxexec, relaxdata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxCopy(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxCopy$descriptor() {
        return SCIPsetRelaxCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxCopy(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxCopy$handle() {
        return SCIPsetRelaxCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxCopy(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxCopy$address() {
        return SCIPsetRelaxCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxCopy(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxcopy)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxCopy(MemorySegment scip, MemorySegment relax, MemorySegment relaxcopy) {
        var mh$ = SCIPsetRelaxCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxCopy", scip, relax, relaxcopy);
            }
            return (int)mh$.invokeExact(scip, relax, relaxcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxFree(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxFree$descriptor() {
        return SCIPsetRelaxFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxFree(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxFree$handle() {
        return SCIPsetRelaxFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxFree(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxFree$address() {
        return SCIPsetRelaxFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxFree(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxfree)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxFree(MemorySegment scip, MemorySegment relax, MemorySegment relaxfree) {
        var mh$ = SCIPsetRelaxFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxFree", scip, relax, relaxfree);
            }
            return (int)mh$.invokeExact(scip, relax, relaxfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxInit$descriptor() {
        return SCIPsetRelaxInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxInit$handle() {
        return SCIPsetRelaxInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxInit$address() {
        return SCIPsetRelaxInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxInit(MemorySegment scip, MemorySegment relax, MemorySegment relaxinit) {
        var mh$ = SCIPsetRelaxInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxInit", scip, relax, relaxinit);
            }
            return (int)mh$.invokeExact(scip, relax, relaxinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxExit$descriptor() {
        return SCIPsetRelaxExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxExit$handle() {
        return SCIPsetRelaxExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxExit$address() {
        return SCIPsetRelaxExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExit(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexit)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxExit(MemorySegment scip, MemorySegment relax, MemorySegment relaxexit) {
        var mh$ = SCIPsetRelaxExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxExit", scip, relax, relaxexit);
            }
            return (int)mh$.invokeExact(scip, relax, relaxexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxInitsol$descriptor() {
        return SCIPsetRelaxInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxInitsol$handle() {
        return SCIPsetRelaxInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxInitsol$address() {
        return SCIPsetRelaxInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxInitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxinitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxInitsol(MemorySegment scip, MemorySegment relax, MemorySegment relaxinitsol) {
        var mh$ = SCIPsetRelaxInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxInitsol", scip, relax, relaxinitsol);
            }
            return (int)mh$.invokeExact(scip, relax, relaxinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxExitsol$descriptor() {
        return SCIPsetRelaxExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MethodHandle SCIPsetRelaxExitsol$handle() {
        return SCIPsetRelaxExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static MemorySegment SCIPsetRelaxExitsol$address() {
        return SCIPsetRelaxExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxExitsol(SCIP *scip, SCIP_RELAX *relax, SCIP_RETCODE (*relaxexitsol)(SCIP *, SCIP_RELAX *))
     * }
     */
    public static int SCIPsetRelaxExitsol(MemorySegment scip, MemorySegment relax, MemorySegment relaxexitsol) {
        var mh$ = SCIPsetRelaxExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxExitsol", scip, relax, relaxexitsol);
            }
            return (int)mh$.invokeExact(scip, relax, relaxexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindRelax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindRelax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPfindRelax(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindRelax$descriptor() {
        return SCIPfindRelax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPfindRelax(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindRelax$handle() {
        return SCIPfindRelax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPfindRelax(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindRelax$address() {
        return SCIPfindRelax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RELAX *SCIPfindRelax(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindRelax(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindRelax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindRelax", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRelaxs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRelaxs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RELAX **SCIPgetRelaxs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetRelaxs$descriptor() {
        return SCIPgetRelaxs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RELAX **SCIPgetRelaxs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetRelaxs$handle() {
        return SCIPgetRelaxs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RELAX **SCIPgetRelaxs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRelaxs$address() {
        return SCIPgetRelaxs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RELAX **SCIPgetRelaxs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRelaxs(MemorySegment scip) {
        var mh$ = SCIPgetRelaxs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRelaxs", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRelaxs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRelaxs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNRelaxs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRelaxs$descriptor() {
        return SCIPgetNRelaxs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNRelaxs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRelaxs$handle() {
        return SCIPgetNRelaxs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNRelaxs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRelaxs$address() {
        return SCIPgetNRelaxs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNRelaxs(SCIP *scip)
     * }
     */
    public static int SCIPgetNRelaxs(MemorySegment scip) {
        var mh$ = SCIPgetNRelaxs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRelaxs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetRelaxPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetRelaxPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxPriority(SCIP *scip, SCIP_RELAX *relax, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetRelaxPriority$descriptor() {
        return SCIPsetRelaxPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxPriority(SCIP *scip, SCIP_RELAX *relax, int priority)
     * }
     */
    public static MethodHandle SCIPsetRelaxPriority$handle() {
        return SCIPsetRelaxPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxPriority(SCIP *scip, SCIP_RELAX *relax, int priority)
     * }
     */
    public static MemorySegment SCIPsetRelaxPriority$address() {
        return SCIPsetRelaxPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetRelaxPriority(SCIP *scip, SCIP_RELAX *relax, int priority)
     * }
     */
    public static int SCIPsetRelaxPriority(MemorySegment scip, MemorySegment relax, int priority) {
        var mh$ = SCIPsetRelaxPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetRelaxPriority", scip, relax, priority);
            }
            return (int)mh$.invokeExact(scip, relax, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptChildIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptChildIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptChildIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptChildIDs$descriptor() {
        return SCIPgetReoptChildIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptChildIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static MethodHandle SCIPgetReoptChildIDs$handle() {
        return SCIPgetReoptChildIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptChildIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static MemorySegment SCIPgetReoptChildIDs$address() {
        return SCIPgetReoptChildIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptChildIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static int SCIPgetReoptChildIDs(MemorySegment scip, MemorySegment node, MemorySegment ids, int mem, MemorySegment nids) {
        var mh$ = SCIPgetReoptChildIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptChildIDs", scip, node, ids, mem, nids);
            }
            return (int)mh$.invokeExact(scip, node, ids, mem, nids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptLeaveIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptLeaveIDs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptLeaveIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptLeaveIDs$descriptor() {
        return SCIPgetReoptLeaveIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptLeaveIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static MethodHandle SCIPgetReoptLeaveIDs$handle() {
        return SCIPgetReoptLeaveIDs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptLeaveIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static MemorySegment SCIPgetReoptLeaveIDs$address() {
        return SCIPgetReoptLeaveIDs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptLeaveIDs(SCIP *scip, SCIP_NODE *node, unsigned int *ids, int mem, int *nids)
     * }
     */
    public static int SCIPgetReoptLeaveIDs(MemorySegment scip, MemorySegment node, MemorySegment ids, int mem, MemorySegment nids) {
        var mh$ = SCIPgetReoptLeaveIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptLeaveIDs", scip, node, ids, mem, nids);
            }
            return (int)mh$.invokeExact(scip, node, ids, mem, nids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNReoptnodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNReoptnodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNReoptnodes(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPgetNReoptnodes$descriptor() {
        return SCIPgetNReoptnodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNReoptnodes(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPgetNReoptnodes$handle() {
        return SCIPgetNReoptnodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNReoptnodes(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPgetNReoptnodes$address() {
        return SCIPgetNReoptnodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNReoptnodes(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPgetNReoptnodes(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPgetNReoptnodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNReoptnodes", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNReoptLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNReoptLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNReoptLeaves(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPgetNReoptLeaves$descriptor() {
        return SCIPgetNReoptLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNReoptLeaves(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPgetNReoptLeaves$handle() {
        return SCIPgetNReoptLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNReoptLeaves(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPgetNReoptLeaves$address() {
        return SCIPgetNReoptLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNReoptLeaves(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPgetNReoptLeaves(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPgetNReoptLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNReoptLeaves", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptnode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptnode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_REOPTNODE *SCIPgetReoptnode(SCIP *scip, unsigned int id)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptnode$descriptor() {
        return SCIPgetReoptnode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_REOPTNODE *SCIPgetReoptnode(SCIP *scip, unsigned int id)
     * }
     */
    public static MethodHandle SCIPgetReoptnode$handle() {
        return SCIPgetReoptnode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_REOPTNODE *SCIPgetReoptnode(SCIP *scip, unsigned int id)
     * }
     */
    public static MemorySegment SCIPgetReoptnode$address() {
        return SCIPgetReoptnode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_REOPTNODE *SCIPgetReoptnode(SCIP *scip, unsigned int id)
     * }
     */
    public static MemorySegment SCIPgetReoptnode(MemorySegment scip, int id) {
        var mh$ = SCIPgetReoptnode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptnode", scip, id);
            }
            return (MemorySegment)mh$.invokeExact(scip, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddReoptnodeBndchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddReoptnodeBndchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeBndchg(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR *var, double bound, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static FunctionDescriptor SCIPaddReoptnodeBndchg$descriptor() {
        return SCIPaddReoptnodeBndchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeBndchg(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR *var, double bound, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static MethodHandle SCIPaddReoptnodeBndchg$handle() {
        return SCIPaddReoptnodeBndchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeBndchg(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR *var, double bound, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static MemorySegment SCIPaddReoptnodeBndchg$address() {
        return SCIPaddReoptnodeBndchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeBndchg(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR *var, double bound, SCIP_BOUNDTYPE boundtype)
     * }
     */
    public static int SCIPaddReoptnodeBndchg(MemorySegment scip, MemorySegment reoptnode, MemorySegment var_, double bound, int boundtype) {
        var mh$ = SCIPaddReoptnodeBndchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddReoptnodeBndchg", scip, reoptnode, var_, bound, boundtype);
            }
            return (int)mh$.invokeExact(scip, reoptnode, var_, bound, boundtype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetReoptCompression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetReoptCompression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReoptCompression(SCIP *scip, SCIP_REOPTNODE **representation, int nrepresentatives, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPsetReoptCompression$descriptor() {
        return SCIPsetReoptCompression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReoptCompression(SCIP *scip, SCIP_REOPTNODE **representation, int nrepresentatives, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPsetReoptCompression$handle() {
        return SCIPsetReoptCompression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReoptCompression(SCIP *scip, SCIP_REOPTNODE **representation, int nrepresentatives, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPsetReoptCompression$address() {
        return SCIPsetReoptCompression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetReoptCompression(SCIP *scip, SCIP_REOPTNODE **representation, int nrepresentatives, unsigned int *success)
     * }
     */
    public static int SCIPsetReoptCompression(MemorySegment scip, MemorySegment representation, int nrepresentatives, MemorySegment success) {
        var mh$ = SCIPsetReoptCompression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetReoptCompression", scip, representation, nrepresentatives, success);
            }
            return (int)mh$.invokeExact(scip, representation, nrepresentatives, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddReoptnodeCons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddReoptnodeCons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeCons(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, double lhs, double rhs, int nvars, REOPT_CONSTYPE constype, unsigned int linear)
     * }
     */
    public static FunctionDescriptor SCIPaddReoptnodeCons$descriptor() {
        return SCIPaddReoptnodeCons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeCons(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, double lhs, double rhs, int nvars, REOPT_CONSTYPE constype, unsigned int linear)
     * }
     */
    public static MethodHandle SCIPaddReoptnodeCons$handle() {
        return SCIPaddReoptnodeCons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeCons(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, double lhs, double rhs, int nvars, REOPT_CONSTYPE constype, unsigned int linear)
     * }
     */
    public static MemorySegment SCIPaddReoptnodeCons$address() {
        return SCIPaddReoptnodeCons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptnodeCons(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, double lhs, double rhs, int nvars, REOPT_CONSTYPE constype, unsigned int linear)
     * }
     */
    public static int SCIPaddReoptnodeCons(MemorySegment scip, MemorySegment reoptnode, MemorySegment vars, MemorySegment vals, MemorySegment boundtypes, double lhs, double rhs, int nvars, int constype, int linear) {
        var mh$ = SCIPaddReoptnodeCons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddReoptnodeCons", scip, reoptnode, vars, vals, boundtypes, lhs, rhs, nvars, constype, linear);
            }
            return (int)mh$.invokeExact(scip, reoptnode, vars, vals, boundtypes, lhs, rhs, nvars, constype, linear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptnodePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptnodePath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetReoptnodePath(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, int mem, int *nvars, int *nafterdualvars)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptnodePath$descriptor() {
        return SCIPgetReoptnodePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetReoptnodePath(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, int mem, int *nvars, int *nafterdualvars)
     * }
     */
    public static MethodHandle SCIPgetReoptnodePath$handle() {
        return SCIPgetReoptnodePath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetReoptnodePath(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, int mem, int *nvars, int *nafterdualvars)
     * }
     */
    public static MemorySegment SCIPgetReoptnodePath$address() {
        return SCIPgetReoptnodePath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetReoptnodePath(SCIP *scip, SCIP_REOPTNODE *reoptnode, SCIP_VAR **vars, double *vals, SCIP_BOUNDTYPE *boundtypes, int mem, int *nvars, int *nafterdualvars)
     * }
     */
    public static void SCIPgetReoptnodePath(MemorySegment scip, MemorySegment reoptnode, MemorySegment vars, MemorySegment vals, MemorySegment boundtypes, int mem, MemorySegment nvars, MemorySegment nafterdualvars) {
        var mh$ = SCIPgetReoptnodePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptnodePath", scip, reoptnode, vars, vals, boundtypes, mem, nvars, nafterdualvars);
            }
            mh$.invokeExact(scip, reoptnode, vars, vals, boundtypes, mem, nvars, nafterdualvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinitRepresentation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinitRepresentation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static FunctionDescriptor SCIPinitRepresentation$descriptor() {
        return SCIPinitRepresentation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MethodHandle SCIPinitRepresentation$handle() {
        return SCIPinitRepresentation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MemorySegment SCIPinitRepresentation$address() {
        return SCIPinitRepresentation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinitRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static int SCIPinitRepresentation(MemorySegment scip, MemorySegment representatives, int nrepresentatives) {
        var mh$ = SCIPinitRepresentation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinitRepresentation", scip, representatives, nrepresentatives);
            }
            return (int)mh$.invokeExact(scip, representatives, nrepresentatives);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetRepresentation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetRepresentation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static FunctionDescriptor SCIPresetRepresentation$descriptor() {
        return SCIPresetRepresentation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MethodHandle SCIPresetRepresentation$handle() {
        return SCIPresetRepresentation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MemorySegment SCIPresetRepresentation$address() {
        return SCIPresetRepresentation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static int SCIPresetRepresentation(MemorySegment scip, MemorySegment representatives, int nrepresentatives) {
        var mh$ = SCIPresetRepresentation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetRepresentation", scip, representatives, nrepresentatives);
            }
            return (int)mh$.invokeExact(scip, representatives, nrepresentatives);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeRepresentation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeRepresentation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static FunctionDescriptor SCIPfreeRepresentation$descriptor() {
        return SCIPfreeRepresentation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MethodHandle SCIPfreeRepresentation$handle() {
        return SCIPfreeRepresentation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static MemorySegment SCIPfreeRepresentation$address() {
        return SCIPfreeRepresentation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeRepresentation(SCIP *scip, SCIP_REOPTNODE **representatives, int nrepresentatives)
     * }
     */
    public static int SCIPfreeRepresentation(MemorySegment scip, MemorySegment representatives, int nrepresentatives) {
        var mh$ = SCIPfreeRepresentation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeRepresentation", scip, representatives, nrepresentatives);
            }
            return (int)mh$.invokeExact(scip, representatives, nrepresentatives);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPapplyReopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPapplyReopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyReopt(SCIP *scip, SCIP_REOPTNODE *reoptnode, unsigned int id, double estimate, SCIP_NODE **childnodes, int *ncreatedchilds, int *naddedconss, int childnodessize, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPapplyReopt$descriptor() {
        return SCIPapplyReopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyReopt(SCIP *scip, SCIP_REOPTNODE *reoptnode, unsigned int id, double estimate, SCIP_NODE **childnodes, int *ncreatedchilds, int *naddedconss, int childnodessize, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPapplyReopt$handle() {
        return SCIPapplyReopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyReopt(SCIP *scip, SCIP_REOPTNODE *reoptnode, unsigned int id, double estimate, SCIP_NODE **childnodes, int *ncreatedchilds, int *naddedconss, int childnodessize, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPapplyReopt$address() {
        return SCIPapplyReopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPapplyReopt(SCIP *scip, SCIP_REOPTNODE *reoptnode, unsigned int id, double estimate, SCIP_NODE **childnodes, int *ncreatedchilds, int *naddedconss, int childnodessize, unsigned int *success)
     * }
     */
    public static int SCIPapplyReopt(MemorySegment scip, MemorySegment reoptnode, int id, double estimate, MemorySegment childnodes, MemorySegment ncreatedchilds, MemorySegment naddedconss, int childnodessize, MemorySegment success) {
        var mh$ = SCIPapplyReopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPapplyReopt", scip, reoptnode, id, estimate, childnodes, ncreatedchilds, naddedconss, childnodessize, success);
            }
            return (int)mh$.invokeExact(scip, reoptnode, id, estimate, childnodes, ncreatedchilds, naddedconss, childnodessize, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetReoptnodeDualcons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetReoptnodeDualcons");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetReoptnodeDualcons(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPresetReoptnodeDualcons$descriptor() {
        return SCIPresetReoptnodeDualcons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetReoptnodeDualcons(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPresetReoptnodeDualcons$handle() {
        return SCIPresetReoptnodeDualcons.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetReoptnodeDualcons(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPresetReoptnodeDualcons$address() {
        return SCIPresetReoptnodeDualcons.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetReoptnodeDualcons(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPresetReoptnodeDualcons(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPresetReoptnodeDualcons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetReoptnodeDualcons", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsplitReoptRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsplitReoptRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitReoptRoot(SCIP *scip, int *ncreatedchilds, int *naddedconss)
     * }
     */
    public static FunctionDescriptor SCIPsplitReoptRoot$descriptor() {
        return SCIPsplitReoptRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitReoptRoot(SCIP *scip, int *ncreatedchilds, int *naddedconss)
     * }
     */
    public static MethodHandle SCIPsplitReoptRoot$handle() {
        return SCIPsplitReoptRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitReoptRoot(SCIP *scip, int *ncreatedchilds, int *naddedconss)
     * }
     */
    public static MemorySegment SCIPsplitReoptRoot$address() {
        return SCIPsplitReoptRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsplitReoptRoot(SCIP *scip, int *ncreatedchilds, int *naddedconss)
     * }
     */
    public static int SCIPsplitReoptRoot(MemorySegment scip, MemorySegment ncreatedchilds, MemorySegment naddedconss) {
        var mh$ = SCIPsplitReoptRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsplitReoptRoot", scip, ncreatedchilds, naddedconss);
            }
            return (int)mh$.invokeExact(scip, ncreatedchilds, naddedconss);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreoptimizeNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreoptimizeNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPreoptimizeNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPreoptimizeNode$descriptor() {
        return SCIPreoptimizeNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPreoptimizeNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPreoptimizeNode$handle() {
        return SCIPreoptimizeNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPreoptimizeNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPreoptimizeNode$address() {
        return SCIPreoptimizeNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPreoptimizeNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPreoptimizeNode(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPreoptimizeNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreoptimizeNode", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeleteReoptnode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeleteReoptnode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteReoptnode(SCIP *scip, SCIP_REOPTNODE **reoptnode)
     * }
     */
    public static FunctionDescriptor SCIPdeleteReoptnode$descriptor() {
        return SCIPdeleteReoptnode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteReoptnode(SCIP *scip, SCIP_REOPTNODE **reoptnode)
     * }
     */
    public static MethodHandle SCIPdeleteReoptnode$handle() {
        return SCIPdeleteReoptnode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteReoptnode(SCIP *scip, SCIP_REOPTNODE **reoptnode)
     * }
     */
    public static MemorySegment SCIPdeleteReoptnode$address() {
        return SCIPdeleteReoptnode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPdeleteReoptnode(SCIP *scip, SCIP_REOPTNODE **reoptnode)
     * }
     */
    public static int SCIPdeleteReoptnode(MemorySegment scip, MemorySegment reoptnode) {
        var mh$ = SCIPdeleteReoptnode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeleteReoptnode", scip, reoptnode);
            }
            return (int)mh$.invokeExact(scip, reoptnode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptSimilarity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptSimilarity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetReoptSimilarity(SCIP *scip, int run1, int run2)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptSimilarity$descriptor() {
        return SCIPgetReoptSimilarity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetReoptSimilarity(SCIP *scip, int run1, int run2)
     * }
     */
    public static MethodHandle SCIPgetReoptSimilarity$handle() {
        return SCIPgetReoptSimilarity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetReoptSimilarity(SCIP *scip, int run1, int run2)
     * }
     */
    public static MemorySegment SCIPgetReoptSimilarity$address() {
        return SCIPgetReoptSimilarity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetReoptSimilarity(SCIP *scip, int run1, int run2)
     * }
     */
    public static double SCIPgetReoptSimilarity(MemorySegment scip, int run1, int run2) {
        var mh$ = SCIPgetReoptSimilarity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptSimilarity", scip, run1, run2);
            }
            return (double)mh$.invokeExact(scip, run1, run2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarCoefChg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarCoefChg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPgetVarCoefChg(SCIP *scip, int varidx, unsigned int *negated, unsigned int *entering, unsigned int *leaving)
     * }
     */
    public static FunctionDescriptor SCIPgetVarCoefChg$descriptor() {
        return SCIPgetVarCoefChg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPgetVarCoefChg(SCIP *scip, int varidx, unsigned int *negated, unsigned int *entering, unsigned int *leaving)
     * }
     */
    public static MethodHandle SCIPgetVarCoefChg$handle() {
        return SCIPgetVarCoefChg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPgetVarCoefChg(SCIP *scip, int varidx, unsigned int *negated, unsigned int *entering, unsigned int *leaving)
     * }
     */
    public static MemorySegment SCIPgetVarCoefChg$address() {
        return SCIPgetVarCoefChg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPgetVarCoefChg(SCIP *scip, int varidx, unsigned int *negated, unsigned int *entering, unsigned int *leaving)
     * }
     */
    public static void SCIPgetVarCoefChg(MemorySegment scip, int varidx, MemorySegment negated, MemorySegment entering, MemorySegment leaving) {
        var mh$ = SCIPgetVarCoefChg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarCoefChg", scip, varidx, negated, entering, leaving);
            }
            mh$.invokeExact(scip, varidx, negated, entering, leaving);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepa(SCIP *scip, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepa$descriptor() {
        return SCIPincludeSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepa(SCIP *scip, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static MethodHandle SCIPincludeSepa$handle() {
        return SCIPincludeSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepa(SCIP *scip, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static MemorySegment SCIPincludeSepa$address() {
        return SCIPincludeSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepa(SCIP *scip, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *), SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static int SCIPincludeSepa(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, int freq, double maxbounddist, int usessubscip, int delay, MemorySegment sepacopy, MemorySegment sepafree, MemorySegment sepainit, MemorySegment sepaexit, MemorySegment sepainitsol, MemorySegment sepaexitsol, MemorySegment sepaexeclp, MemorySegment sepaexecsol, MemorySegment sepadata) {
        var mh$ = SCIPincludeSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepa", scip, name, desc, priority, freq, maxbounddist, usessubscip, delay, sepacopy, sepafree, sepainit, sepaexit, sepainitsol, sepaexitsol, sepaexeclp, sepaexecsol, sepadata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, freq, maxbounddist, usessubscip, delay, sepacopy, sepafree, sepainit, sepaexit, sepainitsol, sepaexitsol, sepaexeclp, sepaexecsol, sepadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeSepaBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeSepaBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaBasic(SCIP *scip, SCIP_SEPA **sepa, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static FunctionDescriptor SCIPincludeSepaBasic$descriptor() {
        return SCIPincludeSepaBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaBasic(SCIP *scip, SCIP_SEPA **sepa, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static MethodHandle SCIPincludeSepaBasic$handle() {
        return SCIPincludeSepaBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaBasic(SCIP *scip, SCIP_SEPA **sepa, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static MemorySegment SCIPincludeSepaBasic$address() {
        return SCIPincludeSepaBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeSepaBasic(SCIP *scip, SCIP_SEPA **sepa, const char *name, const char *desc, int priority, int freq, double maxbounddist, unsigned int usessubscip, unsigned int delay, SCIP_RETCODE (*sepaexeclp)(SCIP *, SCIP_SEPA *, SCIP_RESULT *, unsigned int, int), SCIP_RETCODE (*sepaexecsol)(SCIP *, SCIP_SEPA *, SCIP_SOL *, SCIP_RESULT *, unsigned int, int), SCIP_SEPADATA *sepadata)
     * }
     */
    public static int SCIPincludeSepaBasic(MemorySegment scip, MemorySegment sepa, MemorySegment name, MemorySegment desc, int priority, int freq, double maxbounddist, int usessubscip, int delay, MemorySegment sepaexeclp, MemorySegment sepaexecsol, MemorySegment sepadata) {
        var mh$ = SCIPincludeSepaBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeSepaBasic", scip, sepa, name, desc, priority, freq, maxbounddist, usessubscip, delay, sepaexeclp, sepaexecsol, sepadata);
            }
            return (int)mh$.invokeExact(scip, sepa, name, desc, priority, freq, maxbounddist, usessubscip, delay, sepaexeclp, sepaexecsol, sepadata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaCopy(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaCopy$descriptor() {
        return SCIPsetSepaCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaCopy(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaCopy$handle() {
        return SCIPsetSepaCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaCopy(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaCopy$address() {
        return SCIPsetSepaCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaCopy(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepacopy)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaCopy(MemorySegment scip, MemorySegment sepa, MemorySegment sepacopy) {
        var mh$ = SCIPsetSepaCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaCopy", scip, sepa, sepacopy);
            }
            return (int)mh$.invokeExact(scip, sepa, sepacopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaFree(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaFree$descriptor() {
        return SCIPsetSepaFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaFree(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaFree$handle() {
        return SCIPsetSepaFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaFree(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaFree$address() {
        return SCIPsetSepaFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaFree(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepafree)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaFree(MemorySegment scip, MemorySegment sepa, MemorySegment sepafree) {
        var mh$ = SCIPsetSepaFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaFree", scip, sepa, sepafree);
            }
            return (int)mh$.invokeExact(scip, sepa, sepafree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaInit$descriptor() {
        return SCIPsetSepaInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaInit$handle() {
        return SCIPsetSepaInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaInit$address() {
        return SCIPsetSepaInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaInit(MemorySegment scip, MemorySegment sepa, MemorySegment sepainit) {
        var mh$ = SCIPsetSepaInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaInit", scip, sepa, sepainit);
            }
            return (int)mh$.invokeExact(scip, sepa, sepainit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaExit$descriptor() {
        return SCIPsetSepaExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaExit$handle() {
        return SCIPsetSepaExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaExit$address() {
        return SCIPsetSepaExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExit(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexit)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaExit(MemorySegment scip, MemorySegment sepa, MemorySegment sepaexit) {
        var mh$ = SCIPsetSepaExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaExit", scip, sepa, sepaexit);
            }
            return (int)mh$.invokeExact(scip, sepa, sepaexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaInitsol$descriptor() {
        return SCIPsetSepaInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaInitsol$handle() {
        return SCIPsetSepaInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaInitsol$address() {
        return SCIPsetSepaInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaInitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepainitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaInitsol(MemorySegment scip, MemorySegment sepa, MemorySegment sepainitsol) {
        var mh$ = SCIPsetSepaInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaInitsol", scip, sepa, sepainitsol);
            }
            return (int)mh$.invokeExact(scip, sepa, sepainitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static FunctionDescriptor SCIPsetSepaExitsol$descriptor() {
        return SCIPsetSepaExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MethodHandle SCIPsetSepaExitsol$handle() {
        return SCIPsetSepaExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static MemorySegment SCIPsetSepaExitsol$address() {
        return SCIPsetSepaExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaExitsol(SCIP *scip, SCIP_SEPA *sepa, SCIP_RETCODE (*sepaexitsol)(SCIP *, SCIP_SEPA *))
     * }
     */
    public static int SCIPsetSepaExitsol(MemorySegment scip, MemorySegment sepa, MemorySegment sepaexitsol) {
        var mh$ = SCIPsetSepaExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaExitsol", scip, sepa, sepaexitsol);
            }
            return (int)mh$.invokeExact(scip, sepa, sepaexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindSepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindSepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPfindSepa(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindSepa$descriptor() {
        return SCIPfindSepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPfindSepa(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindSepa$handle() {
        return SCIPfindSepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPfindSepa(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindSepa$address() {
        return SCIPfindSepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SEPA *SCIPfindSepa(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindSepa(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindSepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindSepa", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSepas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSepas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SEPA **SCIPgetSepas(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSepas$descriptor() {
        return SCIPgetSepas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SEPA **SCIPgetSepas(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSepas$handle() {
        return SCIPgetSepas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SEPA **SCIPgetSepas(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSepas$address() {
        return SCIPgetSepas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SEPA **SCIPgetSepas(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSepas(MemorySegment scip) {
        var mh$ = SCIPgetSepas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSepas", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSepas {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSepas");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNSepas(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNSepas$descriptor() {
        return SCIPgetNSepas.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNSepas(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNSepas$handle() {
        return SCIPgetNSepas.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNSepas(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNSepas$address() {
        return SCIPgetNSepas.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNSepas(SCIP *scip)
     * }
     */
    public static int SCIPgetNSepas(MemorySegment scip) {
        var mh$ = SCIPgetNSepas.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSepas", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaPriority(SCIP *scip, SCIP_SEPA *sepa, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetSepaPriority$descriptor() {
        return SCIPsetSepaPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaPriority(SCIP *scip, SCIP_SEPA *sepa, int priority)
     * }
     */
    public static MethodHandle SCIPsetSepaPriority$handle() {
        return SCIPsetSepaPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaPriority(SCIP *scip, SCIP_SEPA *sepa, int priority)
     * }
     */
    public static MemorySegment SCIPsetSepaPriority$address() {
        return SCIPsetSepaPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSepaPriority(SCIP *scip, SCIP_SEPA *sepa, int priority)
     * }
     */
    public static int SCIPsetSepaPriority(MemorySegment scip, MemorySegment sepa, int priority) {
        var mh$ = SCIPsetSepaPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaPriority", scip, sepa, priority);
            }
            return (int)mh$.invokeExact(scip, sepa, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaIsParentsepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaIsParentsepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetSepaIsParentsepa(SCIP *scip, SCIP_SEPA *sepa)
     * }
     */
    public static FunctionDescriptor SCIPsetSepaIsParentsepa$descriptor() {
        return SCIPsetSepaIsParentsepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetSepaIsParentsepa(SCIP *scip, SCIP_SEPA *sepa)
     * }
     */
    public static MethodHandle SCIPsetSepaIsParentsepa$handle() {
        return SCIPsetSepaIsParentsepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetSepaIsParentsepa(SCIP *scip, SCIP_SEPA *sepa)
     * }
     */
    public static MemorySegment SCIPsetSepaIsParentsepa$address() {
        return SCIPsetSepaIsParentsepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetSepaIsParentsepa(SCIP *scip, SCIP_SEPA *sepa)
     * }
     */
    public static void SCIPsetSepaIsParentsepa(MemorySegment scip, MemorySegment sepa) {
        var mh$ = SCIPsetSepaIsParentsepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaIsParentsepa", scip, sepa);
            }
            mh$.invokeExact(scip, sepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSepaParentsepa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSepaParentsepa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetSepaParentsepa(SCIP *scip, SCIP_SEPA *sepa, SCIP_SEPA *parentsepa)
     * }
     */
    public static FunctionDescriptor SCIPsetSepaParentsepa$descriptor() {
        return SCIPsetSepaParentsepa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetSepaParentsepa(SCIP *scip, SCIP_SEPA *sepa, SCIP_SEPA *parentsepa)
     * }
     */
    public static MethodHandle SCIPsetSepaParentsepa$handle() {
        return SCIPsetSepaParentsepa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetSepaParentsepa(SCIP *scip, SCIP_SEPA *sepa, SCIP_SEPA *parentsepa)
     * }
     */
    public static MemorySegment SCIPsetSepaParentsepa$address() {
        return SCIPsetSepaParentsepa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetSepaParentsepa(SCIP *scip, SCIP_SEPA *sepa, SCIP_SEPA *parentsepa)
     * }
     */
    public static void SCIPsetSepaParentsepa(MemorySegment scip, MemorySegment sepa, MemorySegment parentsepa) {
        var mh$ = SCIPsetSepaParentsepa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSepaParentsepa", scip, sepa, parentsepa);
            }
            mh$.invokeExact(scip, sepa, parentsepa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSepaMinEfficacy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSepaMinEfficacy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSepaMinEfficacy(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSepaMinEfficacy$descriptor() {
        return SCIPgetSepaMinEfficacy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSepaMinEfficacy(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSepaMinEfficacy$handle() {
        return SCIPgetSepaMinEfficacy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSepaMinEfficacy(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSepaMinEfficacy$address() {
        return SCIPgetSepaMinEfficacy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSepaMinEfficacy(SCIP *scip)
     * }
     */
    public static double SCIPgetSepaMinEfficacy(MemorySegment scip) {
        var mh$ = SCIPgetSepaMinEfficacy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSepaMinEfficacy", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCutsel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCutsel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutsel(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static FunctionDescriptor SCIPincludeCutsel$descriptor() {
        return SCIPincludeCutsel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutsel(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MethodHandle SCIPincludeCutsel$handle() {
        return SCIPincludeCutsel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutsel(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MemorySegment SCIPincludeCutsel$address() {
        return SCIPincludeCutsel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutsel(SCIP *scip, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *), SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static int SCIPincludeCutsel(MemorySegment scip, MemorySegment name, MemorySegment desc, int priority, MemorySegment cutselcopy, MemorySegment cutselfree, MemorySegment cutselinit, MemorySegment cutselexit, MemorySegment cutselinitsol, MemorySegment cutselexitsol, MemorySegment cutselselect, MemorySegment cutseldata) {
        var mh$ = SCIPincludeCutsel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCutsel", scip, name, desc, priority, cutselcopy, cutselfree, cutselinit, cutselexit, cutselinitsol, cutselexitsol, cutselselect, cutseldata);
            }
            return (int)mh$.invokeExact(scip, name, desc, priority, cutselcopy, cutselfree, cutselinit, cutselexit, cutselinitsol, cutselexitsol, cutselselect, cutseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeCutselBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeCutselBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselBasic(SCIP *scip, SCIP_CUTSEL **cutsel, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static FunctionDescriptor SCIPincludeCutselBasic$descriptor() {
        return SCIPincludeCutselBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselBasic(SCIP *scip, SCIP_CUTSEL **cutsel, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MethodHandle SCIPincludeCutselBasic$handle() {
        return SCIPincludeCutselBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselBasic(SCIP *scip, SCIP_CUTSEL **cutsel, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static MemorySegment SCIPincludeCutselBasic$address() {
        return SCIPincludeCutselBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeCutselBasic(SCIP *scip, SCIP_CUTSEL **cutsel, const char *name, const char *desc, int priority, SCIP_RETCODE (*cutselselect)(SCIP *, SCIP_CUTSEL *, SCIP_ROW **, int, SCIP_ROW **, int, unsigned int, int, int *, SCIP_RESULT *), SCIP_CUTSELDATA *cutseldata)
     * }
     */
    public static int SCIPincludeCutselBasic(MemorySegment scip, MemorySegment cutsel, MemorySegment name, MemorySegment desc, int priority, MemorySegment cutselselect, MemorySegment cutseldata) {
        var mh$ = SCIPincludeCutselBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeCutselBasic", scip, cutsel, name, desc, priority, cutselselect, cutseldata);
            }
            return (int)mh$.invokeExact(scip, cutsel, name, desc, priority, cutselselect, cutseldata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselCopy(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselCopy$descriptor() {
        return SCIPsetCutselCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselCopy(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselCopy$handle() {
        return SCIPsetCutselCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselCopy(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselCopy$address() {
        return SCIPsetCutselCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselCopy(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselcopy)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselCopy(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselcopy) {
        var mh$ = SCIPsetCutselCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselCopy", scip, cutsel, cutselcopy);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselcopy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselFree(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselFree$descriptor() {
        return SCIPsetCutselFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselFree(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselFree$handle() {
        return SCIPsetCutselFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselFree(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselFree$address() {
        return SCIPsetCutselFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselFree(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselfree)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselFree(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselfree) {
        var mh$ = SCIPsetCutselFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselFree", scip, cutsel, cutselfree);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselfree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselInit$descriptor() {
        return SCIPsetCutselInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselInit$handle() {
        return SCIPsetCutselInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselInit$address() {
        return SCIPsetCutselInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselInit(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselinit) {
        var mh$ = SCIPsetCutselInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselInit", scip, cutsel, cutselinit);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselinit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselExit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselExit$descriptor() {
        return SCIPsetCutselExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselExit$handle() {
        return SCIPsetCutselExit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselExit$address() {
        return SCIPsetCutselExit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExit(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexit)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselExit(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselexit) {
        var mh$ = SCIPsetCutselExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselExit", scip, cutsel, cutselexit);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselexit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselInitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselInitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselInitsol$descriptor() {
        return SCIPsetCutselInitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselInitsol$handle() {
        return SCIPsetCutselInitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselInitsol$address() {
        return SCIPsetCutselInitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselInitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselinitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselInitsol(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselinitsol) {
        var mh$ = SCIPsetCutselInitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselInitsol", scip, cutsel, cutselinitsol);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselinitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselExitsol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselExitsol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static FunctionDescriptor SCIPsetCutselExitsol$descriptor() {
        return SCIPsetCutselExitsol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MethodHandle SCIPsetCutselExitsol$handle() {
        return SCIPsetCutselExitsol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static MemorySegment SCIPsetCutselExitsol$address() {
        return SCIPsetCutselExitsol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselExitsol(SCIP *scip, SCIP_CUTSEL *cutsel, SCIP_RETCODE (*cutselexitsol)(SCIP *, SCIP_CUTSEL *))
     * }
     */
    public static int SCIPsetCutselExitsol(MemorySegment scip, MemorySegment cutsel, MemorySegment cutselexitsol) {
        var mh$ = SCIPsetCutselExitsol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselExitsol", scip, cutsel, cutselexitsol);
            }
            return (int)mh$.invokeExact(scip, cutsel, cutselexitsol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindCutsel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindCutsel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUTSEL *SCIPfindCutsel(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindCutsel$descriptor() {
        return SCIPfindCutsel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUTSEL *SCIPfindCutsel(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindCutsel$handle() {
        return SCIPfindCutsel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUTSEL *SCIPfindCutsel(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCutsel$address() {
        return SCIPfindCutsel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUTSEL *SCIPfindCutsel(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindCutsel(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindCutsel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindCutsel", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCutsels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCutsels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_CUTSEL **SCIPgetCutsels(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCutsels$descriptor() {
        return SCIPgetCutsels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_CUTSEL **SCIPgetCutsels(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCutsels$handle() {
        return SCIPgetCutsels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_CUTSEL **SCIPgetCutsels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCutsels$address() {
        return SCIPgetCutsels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_CUTSEL **SCIPgetCutsels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCutsels(MemorySegment scip) {
        var mh$ = SCIPgetCutsels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCutsels", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCutsels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCutsels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCutsels(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCutsels$descriptor() {
        return SCIPgetNCutsels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCutsels(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCutsels$handle() {
        return SCIPgetNCutsels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCutsels(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCutsels$address() {
        return SCIPgetNCutsels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCutsels(SCIP *scip)
     * }
     */
    public static int SCIPgetNCutsels(MemorySegment scip) {
        var mh$ = SCIPgetNCutsels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCutsels", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetCutselPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetCutselPriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselPriority(SCIP *scip, SCIP_CUTSEL *cutsel, int priority)
     * }
     */
    public static FunctionDescriptor SCIPsetCutselPriority$descriptor() {
        return SCIPsetCutselPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselPriority(SCIP *scip, SCIP_CUTSEL *cutsel, int priority)
     * }
     */
    public static MethodHandle SCIPsetCutselPriority$handle() {
        return SCIPsetCutselPriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselPriority(SCIP *scip, SCIP_CUTSEL *cutsel, int priority)
     * }
     */
    public static MemorySegment SCIPsetCutselPriority$address() {
        return SCIPsetCutselPriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetCutselPriority(SCIP *scip, SCIP_CUTSEL *cutsel, int priority)
     * }
     */
    public static int SCIPsetCutselPriority(MemorySegment scip, MemorySegment cutsel, int priority) {
        var mh$ = SCIPsetCutselPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetCutselPriority", scip, cutsel, priority);
            }
            return (int)mh$.invokeExact(scip, cutsel, priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateSol$descriptor() {
        return SCIPcreateSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateSol$handle() {
        return SCIPcreateSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateSol$address() {
        return SCIPcreateSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateLPSol$descriptor() {
        return SCIPcreateLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateLPSol$handle() {
        return SCIPcreateLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateLPSol$address() {
        return SCIPcreateLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateLPSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateLPSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateNLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateNLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateNLPSol$descriptor() {
        return SCIPcreateNLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateNLPSol$handle() {
        return SCIPcreateNLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateNLPSol$address() {
        return SCIPcreateNLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateNLPSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateNLPSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateNLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateNLPSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateRelaxSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateRelaxSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRelaxSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateRelaxSol$descriptor() {
        return SCIPcreateRelaxSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRelaxSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateRelaxSol$handle() {
        return SCIPcreateRelaxSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRelaxSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateRelaxSol$address() {
        return SCIPcreateRelaxSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateRelaxSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateRelaxSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateRelaxSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateRelaxSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreatePseudoSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreatePseudoSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePseudoSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreatePseudoSol$descriptor() {
        return SCIPcreatePseudoSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePseudoSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreatePseudoSol$handle() {
        return SCIPcreatePseudoSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePseudoSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreatePseudoSol$address() {
        return SCIPcreatePseudoSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePseudoSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreatePseudoSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreatePseudoSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreatePseudoSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateCurrentSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateCurrentSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCurrentSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateCurrentSol$descriptor() {
        return SCIPcreateCurrentSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCurrentSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateCurrentSol$handle() {
        return SCIPcreateCurrentSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCurrentSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateCurrentSol$address() {
        return SCIPcreateCurrentSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCurrentSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateCurrentSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateCurrentSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateCurrentSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreatePartialSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreatePartialSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePartialSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreatePartialSol$descriptor() {
        return SCIPcreatePartialSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePartialSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreatePartialSol$handle() {
        return SCIPcreatePartialSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePartialSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreatePartialSol$address() {
        return SCIPcreatePartialSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreatePartialSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreatePartialSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreatePartialSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreatePartialSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateUnknownSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateUnknownSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateUnknownSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateUnknownSol$descriptor() {
        return SCIPcreateUnknownSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateUnknownSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateUnknownSol$handle() {
        return SCIPcreateUnknownSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateUnknownSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateUnknownSol$address() {
        return SCIPcreateUnknownSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateUnknownSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateUnknownSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateUnknownSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateUnknownSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateOrigSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateOrigSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateOrigSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static FunctionDescriptor SCIPcreateOrigSol$descriptor() {
        return SCIPcreateOrigSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateOrigSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MethodHandle SCIPcreateOrigSol$handle() {
        return SCIPcreateOrigSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateOrigSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static MemorySegment SCIPcreateOrigSol$address() {
        return SCIPcreateOrigSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateOrigSol(SCIP *scip, SCIP_SOL **sol, SCIP_HEUR *heur)
     * }
     */
    public static int SCIPcreateOrigSol(MemorySegment scip, MemorySegment sol, MemorySegment heur) {
        var mh$ = SCIPcreateOrigSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateOrigSol", scip, sol, heur);
            }
            return (int)mh$.invokeExact(scip, sol, heur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateSolCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateSolCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static FunctionDescriptor SCIPcreateSolCopy$descriptor() {
        return SCIPcreateSolCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static MethodHandle SCIPcreateSolCopy$handle() {
        return SCIPcreateSolCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static MemorySegment SCIPcreateSolCopy$address() {
        return SCIPcreateSolCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static int SCIPcreateSolCopy(MemorySegment scip, MemorySegment sol, MemorySegment sourcesol) {
        var mh$ = SCIPcreateSolCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateSolCopy", scip, sol, sourcesol);
            }
            return (int)mh$.invokeExact(scip, sol, sourcesol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateSolCopyOrig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateSolCopyOrig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopyOrig(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static FunctionDescriptor SCIPcreateSolCopyOrig$descriptor() {
        return SCIPcreateSolCopyOrig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopyOrig(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static MethodHandle SCIPcreateSolCopyOrig$handle() {
        return SCIPcreateSolCopyOrig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopyOrig(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static MemorySegment SCIPcreateSolCopyOrig$address() {
        return SCIPcreateSolCopyOrig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateSolCopyOrig(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol)
     * }
     */
    public static int SCIPcreateSolCopyOrig(MemorySegment scip, MemorySegment sol, MemorySegment sourcesol) {
        var mh$ = SCIPcreateSolCopyOrig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateSolCopyOrig", scip, sol, sourcesol);
            }
            return (int)mh$.invokeExact(scip, sol, sourcesol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateFiniteSolCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateFiniteSolCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateFiniteSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPcreateFiniteSolCopy$descriptor() {
        return SCIPcreateFiniteSolCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateFiniteSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPcreateFiniteSolCopy$handle() {
        return SCIPcreateFiniteSolCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateFiniteSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPcreateFiniteSolCopy$address() {
        return SCIPcreateFiniteSolCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateFiniteSolCopy(SCIP *scip, SCIP_SOL **sol, SCIP_SOL *sourcesol, unsigned int *success)
     * }
     */
    public static int SCIPcreateFiniteSolCopy(MemorySegment scip, MemorySegment sol, MemorySegment sourcesol, MemorySegment success) {
        var mh$ = SCIPcreateFiniteSolCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateFiniteSolCopy", scip, sol, sourcesol, success);
            }
            return (int)mh$.invokeExact(scip, sol, sourcesol, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSol(SCIP *scip, SCIP_SOL **sol)
     * }
     */
    public static FunctionDescriptor SCIPfreeSol$descriptor() {
        return SCIPfreeSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSol(SCIP *scip, SCIP_SOL **sol)
     * }
     */
    public static MethodHandle SCIPfreeSol$handle() {
        return SCIPfreeSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSol(SCIP *scip, SCIP_SOL **sol)
     * }
     */
    public static MemorySegment SCIPfreeSol$address() {
        return SCIPfreeSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSol(SCIP *scip, SCIP_SOL **sol)
     * }
     */
    public static int SCIPfreeSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPfreeSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinkLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinkLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPlinkLPSol$descriptor() {
        return SCIPlinkLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPlinkLPSol$handle() {
        return SCIPlinkLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPlinkLPSol$address() {
        return SCIPlinkLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPlinkLPSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPlinkLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinkLPSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinkNLPSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinkNLPSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkNLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPlinkNLPSol$descriptor() {
        return SCIPlinkNLPSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkNLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPlinkNLPSol$handle() {
        return SCIPlinkNLPSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkNLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPlinkNLPSol$address() {
        return SCIPlinkNLPSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkNLPSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPlinkNLPSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPlinkNLPSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinkNLPSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinkRelaxSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinkRelaxSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkRelaxSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPlinkRelaxSol$descriptor() {
        return SCIPlinkRelaxSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkRelaxSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPlinkRelaxSol$handle() {
        return SCIPlinkRelaxSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkRelaxSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPlinkRelaxSol$address() {
        return SCIPlinkRelaxSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkRelaxSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPlinkRelaxSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPlinkRelaxSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinkRelaxSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinkPseudoSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinkPseudoSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkPseudoSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPlinkPseudoSol$descriptor() {
        return SCIPlinkPseudoSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkPseudoSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPlinkPseudoSol$handle() {
        return SCIPlinkPseudoSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkPseudoSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPlinkPseudoSol$address() {
        return SCIPlinkPseudoSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkPseudoSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPlinkPseudoSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPlinkPseudoSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinkPseudoSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPlinkCurrentSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPlinkCurrentSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkCurrentSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPlinkCurrentSol$descriptor() {
        return SCIPlinkCurrentSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkCurrentSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPlinkCurrentSol$handle() {
        return SCIPlinkCurrentSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkCurrentSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPlinkCurrentSol$address() {
        return SCIPlinkCurrentSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPlinkCurrentSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPlinkCurrentSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPlinkCurrentSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPlinkCurrentSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPclearSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPclearSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPclearSol$descriptor() {
        return SCIPclearSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPclearSol$handle() {
        return SCIPclearSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPclearSol$address() {
        return SCIPclearSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPclearSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPclearSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPclearSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPclearSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPunlinkSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPunlinkSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlinkSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPunlinkSol$descriptor() {
        return SCIPunlinkSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlinkSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPunlinkSol$handle() {
        return SCIPunlinkSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlinkSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPunlinkSol$address() {
        return SCIPunlinkSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPunlinkSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPunlinkSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPunlinkSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPunlinkSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double val)
     * }
     */
    public static FunctionDescriptor SCIPsetSolVal$descriptor() {
        return SCIPsetSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double val)
     * }
     */
    public static MethodHandle SCIPsetSolVal$handle() {
        return SCIPsetSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double val)
     * }
     */
    public static MemorySegment SCIPsetSolVal$address() {
        return SCIPsetSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double val)
     * }
     */
    public static int SCIPsetSolVal(MemorySegment scip, MemorySegment sol, MemorySegment var_, double val) {
        var mh$ = SCIPsetSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSolVal", scip, sol, var_, val);
            }
            return (int)mh$.invokeExact(scip, sol, var_, val);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetSolVals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetSolVals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPsetSolVals$descriptor() {
        return SCIPsetSolVals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MethodHandle SCIPsetSolVals$handle() {
        return SCIPsetSolVals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MemorySegment SCIPsetSolVals$address() {
        return SCIPsetSolVals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static int SCIPsetSolVals(MemorySegment scip, MemorySegment sol, int nvars, MemorySegment vars, MemorySegment vals) {
        var mh$ = SCIPsetSolVals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetSolVals", scip, sol, nvars, vars, vals);
            }
            return (int)mh$.invokeExact(scip, sol, nvars, vars, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double incval)
     * }
     */
    public static FunctionDescriptor SCIPincSolVal$descriptor() {
        return SCIPincSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double incval)
     * }
     */
    public static MethodHandle SCIPincSolVal$handle() {
        return SCIPincSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double incval)
     * }
     */
    public static MemorySegment SCIPincSolVal$address() {
        return SCIPincSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var, double incval)
     * }
     */
    public static int SCIPincSolVal(MemorySegment scip, MemorySegment sol, MemorySegment var_, double incval) {
        var mh$ = SCIPincSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincSolVal", scip, sol, var_, incval);
            }
            return (int)mh$.invokeExact(scip, sol, var_, incval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetSolVal$descriptor() {
        return SCIPgetSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetSolVal$handle() {
        return SCIPgetSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetSolVal$address() {
        return SCIPgetSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSolVal(SCIP *scip, SCIP_SOL *sol, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetSolVal(MemorySegment scip, MemorySegment sol, MemorySegment var_) {
        var mh$ = SCIPgetSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolVal", scip, sol, var_);
            }
            return (double)mh$.invokeExact(scip, sol, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolVals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolVals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static FunctionDescriptor SCIPgetSolVals$descriptor() {
        return SCIPgetSolVals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MethodHandle SCIPgetSolVals$handle() {
        return SCIPgetSolVals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static MemorySegment SCIPgetSolVals$address() {
        return SCIPgetSolVals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSolVals(SCIP *scip, SCIP_SOL *sol, int nvars, SCIP_VAR **vars, double *vals)
     * }
     */
    public static int SCIPgetSolVals(MemorySegment scip, MemorySegment sol, int nvars, MemorySegment vars, MemorySegment vals) {
        var mh$ = SCIPgetSolVals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolVals", scip, sol, nvars, vars, vals);
            }
            return (int)mh$.invokeExact(scip, sol, nvars, vars, vals);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolOrigObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolOrigObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSolOrigObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolOrigObj$descriptor() {
        return SCIPgetSolOrigObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSolOrigObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolOrigObj$handle() {
        return SCIPgetSolOrigObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSolOrigObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolOrigObj$address() {
        return SCIPgetSolOrigObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSolOrigObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetSolOrigObj(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolOrigObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolOrigObj", scip, sol);
            }
            return (double)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolTransObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolTransObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSolTransObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolTransObj$descriptor() {
        return SCIPgetSolTransObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSolTransObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolTransObj$handle() {
        return SCIPgetSolTransObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSolTransObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolTransObj$address() {
        return SCIPgetSolTransObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSolTransObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetSolTransObj(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolTransObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolTransObj", scip, sol);
            }
            return (double)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrecomputeSolObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrecomputeSolObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecomputeSolObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPrecomputeSolObj$descriptor() {
        return SCIPrecomputeSolObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecomputeSolObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPrecomputeSolObj$handle() {
        return SCIPrecomputeSolObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecomputeSolObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPrecomputeSolObj$address() {
        return SCIPrecomputeSolObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrecomputeSolObj(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPrecomputeSolObj(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPrecomputeSolObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrecomputeSolObj", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPtransformObj(SCIP *scip, double obj)
     * }
     */
    public static FunctionDescriptor SCIPtransformObj$descriptor() {
        return SCIPtransformObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPtransformObj(SCIP *scip, double obj)
     * }
     */
    public static MethodHandle SCIPtransformObj$handle() {
        return SCIPtransformObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPtransformObj(SCIP *scip, double obj)
     * }
     */
    public static MemorySegment SCIPtransformObj$address() {
        return SCIPtransformObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPtransformObj(SCIP *scip, double obj)
     * }
     */
    public static double SCIPtransformObj(MemorySegment scip, double obj) {
        var mh$ = SCIPtransformObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformObj", scip, obj);
            }
            return (double)mh$.invokeExact(scip, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPretransformObj {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPretransformObj");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPretransformObj(SCIP *scip, double obj)
     * }
     */
    public static FunctionDescriptor SCIPretransformObj$descriptor() {
        return SCIPretransformObj.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPretransformObj(SCIP *scip, double obj)
     * }
     */
    public static MethodHandle SCIPretransformObj$handle() {
        return SCIPretransformObj.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPretransformObj(SCIP *scip, double obj)
     * }
     */
    public static MemorySegment SCIPretransformObj$address() {
        return SCIPretransformObj.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPretransformObj(SCIP *scip, double obj)
     * }
     */
    public static double SCIPretransformObj(MemorySegment scip, double obj) {
        var mh$ = SCIPretransformObj.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPretransformObj", scip, obj);
            }
            return (double)mh$.invokeExact(scip, obj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSolTime(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolTime$descriptor() {
        return SCIPgetSolTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSolTime(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolTime$handle() {
        return SCIPgetSolTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSolTime(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolTime$address() {
        return SCIPgetSolTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSolTime(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static double SCIPgetSolTime(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolTime", scip, sol);
            }
            return (double)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolRunnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolRunnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetSolRunnum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolRunnum$descriptor() {
        return SCIPgetSolRunnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetSolRunnum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolRunnum$handle() {
        return SCIPgetSolRunnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetSolRunnum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolRunnum$address() {
        return SCIPgetSolRunnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetSolRunnum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPgetSolRunnum(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolRunnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolRunnum", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolNodenum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolNodenum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetSolNodenum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolNodenum$descriptor() {
        return SCIPgetSolNodenum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetSolNodenum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolNodenum$handle() {
        return SCIPgetSolNodenum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetSolNodenum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolNodenum$address() {
        return SCIPgetSolNodenum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetSolNodenum(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static long SCIPgetSolNodenum(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolNodenum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolNodenum", scip, sol);
            }
            return (long)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolHeur {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolHeur");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPgetSolHeur(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPgetSolHeur$descriptor() {
        return SCIPgetSolHeur.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPgetSolHeur(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPgetSolHeur$handle() {
        return SCIPgetSolHeur.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPgetSolHeur(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolHeur$address() {
        return SCIPgetSolHeur.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_HEUR *SCIPgetSolHeur(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPgetSolHeur(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPgetSolHeur.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolHeur", scip, sol);
            }
            return (MemorySegment)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPareSolsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPareSolsEqual");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPareSolsEqual(SCIP *scip, SCIP_SOL *sol1, SCIP_SOL *sol2)
     * }
     */
    public static FunctionDescriptor SCIPareSolsEqual$descriptor() {
        return SCIPareSolsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPareSolsEqual(SCIP *scip, SCIP_SOL *sol1, SCIP_SOL *sol2)
     * }
     */
    public static MethodHandle SCIPareSolsEqual$handle() {
        return SCIPareSolsEqual.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPareSolsEqual(SCIP *scip, SCIP_SOL *sol1, SCIP_SOL *sol2)
     * }
     */
    public static MemorySegment SCIPareSolsEqual$address() {
        return SCIPareSolsEqual.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPareSolsEqual(SCIP *scip, SCIP_SOL *sol1, SCIP_SOL *sol2)
     * }
     */
    public static int SCIPareSolsEqual(MemorySegment scip, MemorySegment sol1, MemorySegment sol2) {
        var mh$ = SCIPareSolsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPareSolsEqual", scip, sol1, sol2);
            }
            return (int)mh$.invokeExact(scip, sol1, sol2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPadjustImplicitSolVals {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPadjustImplicitSolVals");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPadjustImplicitSolVals(SCIP *scip, SCIP_SOL *sol, unsigned int uselprows)
     * }
     */
    public static FunctionDescriptor SCIPadjustImplicitSolVals$descriptor() {
        return SCIPadjustImplicitSolVals.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPadjustImplicitSolVals(SCIP *scip, SCIP_SOL *sol, unsigned int uselprows)
     * }
     */
    public static MethodHandle SCIPadjustImplicitSolVals$handle() {
        return SCIPadjustImplicitSolVals.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPadjustImplicitSolVals(SCIP *scip, SCIP_SOL *sol, unsigned int uselprows)
     * }
     */
    public static MemorySegment SCIPadjustImplicitSolVals$address() {
        return SCIPadjustImplicitSolVals.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPadjustImplicitSolVals(SCIP *scip, SCIP_SOL *sol, unsigned int uselprows)
     * }
     */
    public static int SCIPadjustImplicitSolVals(MemorySegment scip, MemorySegment sol, int uselprows) {
        var mh$ = SCIPadjustImplicitSolVals.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPadjustImplicitSolVals", scip, sol, uselprows);
            }
            return (int)mh$.invokeExact(scip, sol, uselprows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintSol$descriptor() {
        return SCIPprintSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintSol$handle() {
        return SCIPprintSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintSol$address() {
        return SCIPprintSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintSol(MemorySegment scip, MemorySegment sol, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintSol", scip, sol, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, sol, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintTransSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintTransSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintTransSol$descriptor() {
        return SCIPprintTransSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintTransSol$handle() {
        return SCIPprintTransSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintTransSol$address() {
        return SCIPprintTransSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransSol(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintTransSol(MemorySegment scip, MemorySegment sol, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintTransSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintTransSol", scip, sol, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, sol, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintMIPStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintMIPStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintMIPStart(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintMIPStart$descriptor() {
        return SCIPprintMIPStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintMIPStart(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintMIPStart$handle() {
        return SCIPprintMIPStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintMIPStart(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintMIPStart$address() {
        return SCIPprintMIPStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintMIPStart(SCIP *scip, SCIP_SOL *sol, FILE *file)
     * }
     */
    public static int SCIPprintMIPStart(MemorySegment scip, MemorySegment sol, MemorySegment file) {
        var mh$ = SCIPprintMIPStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintMIPStart", scip, sol, file);
            }
            return (int)mh$.invokeExact(scip, sol, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualSolVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualSolVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDualSolVal(SCIP *scip, SCIP_CONS *cons, double *dualsolval, unsigned int *boundconstraint)
     * }
     */
    public static FunctionDescriptor SCIPgetDualSolVal$descriptor() {
        return SCIPgetDualSolVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDualSolVal(SCIP *scip, SCIP_CONS *cons, double *dualsolval, unsigned int *boundconstraint)
     * }
     */
    public static MethodHandle SCIPgetDualSolVal$handle() {
        return SCIPgetDualSolVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDualSolVal(SCIP *scip, SCIP_CONS *cons, double *dualsolval, unsigned int *boundconstraint)
     * }
     */
    public static MemorySegment SCIPgetDualSolVal$address() {
        return SCIPgetDualSolVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetDualSolVal(SCIP *scip, SCIP_CONS *cons, double *dualsolval, unsigned int *boundconstraint)
     * }
     */
    public static int SCIPgetDualSolVal(MemorySegment scip, MemorySegment cons, MemorySegment dualsolval, MemorySegment boundconstraint) {
        var mh$ = SCIPgetDualSolVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualSolVal", scip, cons, dualsolval, boundconstraint);
            }
            return (int)mh$.invokeExact(scip, cons, dualsolval, boundconstraint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisDualSolAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisDualSolAvailable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualSolAvailable(SCIP *scip, unsigned int printreason)
     * }
     */
    public static FunctionDescriptor SCIPisDualSolAvailable$descriptor() {
        return SCIPisDualSolAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualSolAvailable(SCIP *scip, unsigned int printreason)
     * }
     */
    public static MethodHandle SCIPisDualSolAvailable$handle() {
        return SCIPisDualSolAvailable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisDualSolAvailable(SCIP *scip, unsigned int printreason)
     * }
     */
    public static MemorySegment SCIPisDualSolAvailable$address() {
        return SCIPisDualSolAvailable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisDualSolAvailable(SCIP *scip, unsigned int printreason)
     * }
     */
    public static int SCIPisDualSolAvailable(MemorySegment scip, int printreason) {
        var mh$ = SCIPisDualSolAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisDualSolAvailable", scip, printreason);
            }
            return (int)mh$.invokeExact(scip, printreason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintDualSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintDualSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDualSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintDualSol$descriptor() {
        return SCIPprintDualSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDualSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintDualSol$handle() {
        return SCIPprintDualSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDualSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintDualSol$address() {
        return SCIPprintDualSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDualSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintDualSol(MemorySegment scip, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintDualSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintDualSol", scip, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRay(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintRay$descriptor() {
        return SCIPprintRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRay(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintRay$handle() {
        return SCIPprintRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRay(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintRay$address() {
        return SCIPprintRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintRay(SCIP *scip, SCIP_SOL *sol, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintRay(MemorySegment scip, MemorySegment sol, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintRay", scip, sol, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, sol, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNSols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNSols$descriptor() {
        return SCIPgetNSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNSols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNSols$handle() {
        return SCIPgetNSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNSols$address() {
        return SCIPgetNSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNSols(SCIP *scip)
     * }
     */
    public static int SCIPgetNSols(MemorySegment scip) {
        var mh$ = SCIPgetNSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetSols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSols$descriptor() {
        return SCIPgetSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetSols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSols$handle() {
        return SCIPgetSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSols$address() {
        return SCIPgetSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSols(MemorySegment scip) {
        var mh$ = SCIPgetSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSols", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetBestSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestSol$descriptor() {
        return SCIPgetBestSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetBestSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestSol$handle() {
        return SCIPgetBestSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetBestSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestSol$address() {
        return SCIPgetBestSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetBestSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestSol(MemorySegment scip) {
        var mh$ = SCIPgetBestSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestSol", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBestSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBestSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintBestSol$descriptor() {
        return SCIPprintBestSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintBestSol$handle() {
        return SCIPprintBestSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintBestSol$address() {
        return SCIPprintBestSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintBestSol(MemorySegment scip, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintBestSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBestSol", scip, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBestTransSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBestTransSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestTransSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static FunctionDescriptor SCIPprintBestTransSol$descriptor() {
        return SCIPprintBestTransSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestTransSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MethodHandle SCIPprintBestTransSol$handle() {
        return SCIPprintBestTransSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestTransSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static MemorySegment SCIPprintBestTransSol$address() {
        return SCIPprintBestTransSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBestTransSol(SCIP *scip, FILE *file, unsigned int printzeros)
     * }
     */
    public static int SCIPprintBestTransSol(MemorySegment scip, MemorySegment file, int printzeros) {
        var mh$ = SCIPprintBestTransSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBestTransSol", scip, file, printzeros);
            }
            return (int)mh$.invokeExact(scip, file, printzeros);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIProundSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIProundSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIProundSol(SCIP *scip, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIProundSol$descriptor() {
        return SCIProundSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIProundSol(SCIP *scip, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static MethodHandle SCIProundSol$handle() {
        return SCIProundSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIProundSol(SCIP *scip, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static MemorySegment SCIProundSol$address() {
        return SCIProundSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIProundSol(SCIP *scip, SCIP_SOL *sol, unsigned int *success)
     * }
     */
    public static int SCIProundSol(MemorySegment scip, MemorySegment sol, MemorySegment success) {
        var mh$ = SCIProundSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIProundSol", scip, sol, success);
            }
            return (int)mh$.invokeExact(scip, sol, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPretransformSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPretransformSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPretransformSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static FunctionDescriptor SCIPretransformSol$descriptor() {
        return SCIPretransformSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPretransformSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MethodHandle SCIPretransformSol$handle() {
        return SCIPretransformSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPretransformSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static MemorySegment SCIPretransformSol$address() {
        return SCIPretransformSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPretransformSol(SCIP *scip, SCIP_SOL *sol)
     * }
     */
    public static int SCIPretransformSol(MemorySegment scip, MemorySegment sol) {
        var mh$ = SCIPretransformSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPretransformSol", scip, sol);
            }
            return (int)mh$.invokeExact(scip, sol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSol(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPreadSol$descriptor() {
        return SCIPreadSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSol(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPreadSol$handle() {
        return SCIPreadSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSol(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPreadSol$address() {
        return SCIPreadSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSol(SCIP *scip, const char *filename)
     * }
     */
    public static int SCIPreadSol(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPreadSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadSol", scip, filename);
            }
            return (int)mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreadSolFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreadSolFile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSolFile(SCIP *scip, const char *filename, SCIP_SOL *sol, unsigned int xml, unsigned int *partial, unsigned int *error)
     * }
     */
    public static FunctionDescriptor SCIPreadSolFile$descriptor() {
        return SCIPreadSolFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSolFile(SCIP *scip, const char *filename, SCIP_SOL *sol, unsigned int xml, unsigned int *partial, unsigned int *error)
     * }
     */
    public static MethodHandle SCIPreadSolFile$handle() {
        return SCIPreadSolFile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSolFile(SCIP *scip, const char *filename, SCIP_SOL *sol, unsigned int xml, unsigned int *partial, unsigned int *error)
     * }
     */
    public static MemorySegment SCIPreadSolFile$address() {
        return SCIPreadSolFile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreadSolFile(SCIP *scip, const char *filename, SCIP_SOL *sol, unsigned int xml, unsigned int *partial, unsigned int *error)
     * }
     */
    public static int SCIPreadSolFile(MemorySegment scip, MemorySegment filename, MemorySegment sol, int xml, MemorySegment partial, MemorySegment error) {
        var mh$ = SCIPreadSolFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreadSolFile", scip, filename, sol, xml, partial, error);
            }
            return (int)mh$.invokeExact(scip, filename, sol, xml, partial, error);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSol(SCIP *scip, SCIP_SOL *sol, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPaddSol$descriptor() {
        return SCIPaddSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSol(SCIP *scip, SCIP_SOL *sol, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPaddSol$handle() {
        return SCIPaddSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSol(SCIP *scip, SCIP_SOL *sol, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPaddSol$address() {
        return SCIPaddSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSol(SCIP *scip, SCIP_SOL *sol, unsigned int *stored)
     * }
     */
    public static int SCIPaddSol(MemorySegment scip, MemorySegment sol, MemorySegment stored) {
        var mh$ = SCIPaddSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddSol", scip, sol, stored);
            }
            return (int)mh$.invokeExact(scip, sol, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddSolFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddSolFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSolFree(SCIP *scip, SCIP_SOL **sol, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPaddSolFree$descriptor() {
        return SCIPaddSolFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSolFree(SCIP *scip, SCIP_SOL **sol, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPaddSolFree$handle() {
        return SCIPaddSolFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSolFree(SCIP *scip, SCIP_SOL **sol, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPaddSolFree$address() {
        return SCIPaddSolFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddSolFree(SCIP *scip, SCIP_SOL **sol, unsigned int *stored)
     * }
     */
    public static int SCIPaddSolFree(MemorySegment scip, MemorySegment sol, MemorySegment stored) {
        var mh$ = SCIPaddSolFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddSolFree", scip, sol, stored);
            }
            return (int)mh$.invokeExact(scip, sol, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddCurrentSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddCurrentSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPaddCurrentSol$descriptor() {
        return SCIPaddCurrentSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPaddCurrentSol$handle() {
        return SCIPaddCurrentSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPaddCurrentSol$address() {
        return SCIPaddCurrentSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int *stored)
     * }
     */
    public static int SCIPaddCurrentSol(MemorySegment scip, MemorySegment heur, MemorySegment stored) {
        var mh$ = SCIPaddCurrentSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddCurrentSol", scip, heur, stored);
            }
            return (int)mh$.invokeExact(scip, heur, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtrySol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtrySol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPtrySol$descriptor() {
        return SCIPtrySol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPtrySol$handle() {
        return SCIPtrySol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPtrySol$address() {
        return SCIPtrySol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static int SCIPtrySol(MemorySegment scip, MemorySegment sol, int printreason, int completely, int checkbounds, int checkintegrality, int checklprows, MemorySegment stored) {
        var mh$ = SCIPtrySol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtrySol", scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, stored);
            }
            return (int)mh$.invokeExact(scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtrySolFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtrySolFree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySolFree(SCIP *scip, SCIP_SOL **sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPtrySolFree$descriptor() {
        return SCIPtrySolFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySolFree(SCIP *scip, SCIP_SOL **sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPtrySolFree$handle() {
        return SCIPtrySolFree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySolFree(SCIP *scip, SCIP_SOL **sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPtrySolFree$address() {
        return SCIPtrySolFree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtrySolFree(SCIP *scip, SCIP_SOL **sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static int SCIPtrySolFree(MemorySegment scip, MemorySegment sol, int printreason, int completely, int checkbounds, int checkintegrality, int checklprows, MemorySegment stored) {
        var mh$ = SCIPtrySolFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtrySolFree", scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, stored);
            }
            return (int)mh$.invokeExact(scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtryCurrentSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtryCurrentSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int printreason, unsigned int completely, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static FunctionDescriptor SCIPtryCurrentSol$descriptor() {
        return SCIPtryCurrentSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int printreason, unsigned int completely, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MethodHandle SCIPtryCurrentSol$handle() {
        return SCIPtryCurrentSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int printreason, unsigned int completely, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static MemorySegment SCIPtryCurrentSol$address() {
        return SCIPtryCurrentSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtryCurrentSol(SCIP *scip, SCIP_HEUR *heur, unsigned int printreason, unsigned int completely, unsigned int checkintegrality, unsigned int checklprows, unsigned int *stored)
     * }
     */
    public static int SCIPtryCurrentSol(MemorySegment scip, MemorySegment heur, int printreason, int completely, int checkintegrality, int checklprows, MemorySegment stored) {
        var mh$ = SCIPtryCurrentSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtryCurrentSol", scip, heur, printreason, completely, checkintegrality, checklprows, stored);
            }
            return (int)mh$.invokeExact(scip, heur, printreason, completely, checkintegrality, checklprows, stored);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPartialSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPartialSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetPartialSols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPartialSols$descriptor() {
        return SCIPgetPartialSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetPartialSols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPartialSols$handle() {
        return SCIPgetPartialSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetPartialSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPartialSols$address() {
        return SCIPgetPartialSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL **SCIPgetPartialSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPartialSols(MemorySegment scip) {
        var mh$ = SCIPgetPartialSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPartialSols", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPartialSols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPartialSols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPartialSols(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPartialSols$descriptor() {
        return SCIPgetNPartialSols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPartialSols(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPartialSols$handle() {
        return SCIPgetNPartialSols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPartialSols(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPartialSols$address() {
        return SCIPgetNPartialSols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPartialSols(SCIP *scip)
     * }
     */
    public static int SCIPgetNPartialSols(MemorySegment scip) {
        var mh$ = SCIPgetNPartialSols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPartialSols", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *feasible)
     * }
     */
    public static FunctionDescriptor SCIPcheckSol$descriptor() {
        return SCIPcheckSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *feasible)
     * }
     */
    public static MethodHandle SCIPcheckSol$handle() {
        return SCIPcheckSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *feasible)
     * }
     */
    public static MemorySegment SCIPcheckSol$address() {
        return SCIPcheckSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSol(SCIP *scip, SCIP_SOL *sol, unsigned int printreason, unsigned int completely, unsigned int checkbounds, unsigned int checkintegrality, unsigned int checklprows, unsigned int *feasible)
     * }
     */
    public static int SCIPcheckSol(MemorySegment scip, MemorySegment sol, int printreason, int completely, int checkbounds, int checkintegrality, int checklprows, MemorySegment feasible) {
        var mh$ = SCIPcheckSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckSol", scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, feasible);
            }
            return (int)mh$.invokeExact(scip, sol, printreason, completely, checkbounds, checkintegrality, checklprows, feasible);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckSolOrig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckSolOrig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolOrig(SCIP *scip, SCIP_SOL *sol, unsigned int *feasible, unsigned int printreason, unsigned int completely)
     * }
     */
    public static FunctionDescriptor SCIPcheckSolOrig$descriptor() {
        return SCIPcheckSolOrig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolOrig(SCIP *scip, SCIP_SOL *sol, unsigned int *feasible, unsigned int printreason, unsigned int completely)
     * }
     */
    public static MethodHandle SCIPcheckSolOrig$handle() {
        return SCIPcheckSolOrig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolOrig(SCIP *scip, SCIP_SOL *sol, unsigned int *feasible, unsigned int printreason, unsigned int completely)
     * }
     */
    public static MemorySegment SCIPcheckSolOrig$address() {
        return SCIPcheckSolOrig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckSolOrig(SCIP *scip, SCIP_SOL *sol, unsigned int *feasible, unsigned int printreason, unsigned int completely)
     * }
     */
    public static int SCIPcheckSolOrig(MemorySegment scip, MemorySegment sol, MemorySegment feasible, int printreason, int completely) {
        var mh$ = SCIPcheckSolOrig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckSolOrig", scip, sol, feasible, printreason, completely);
            }
            return (int)mh$.invokeExact(scip, sol, feasible, printreason, completely);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateSolIntegralityViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateSolIntegralityViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateSolIntegralityViolation(SCIP *scip, SCIP_SOL *sol, double absviol)
     * }
     */
    public static FunctionDescriptor SCIPupdateSolIntegralityViolation$descriptor() {
        return SCIPupdateSolIntegralityViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateSolIntegralityViolation(SCIP *scip, SCIP_SOL *sol, double absviol)
     * }
     */
    public static MethodHandle SCIPupdateSolIntegralityViolation$handle() {
        return SCIPupdateSolIntegralityViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateSolIntegralityViolation(SCIP *scip, SCIP_SOL *sol, double absviol)
     * }
     */
    public static MemorySegment SCIPupdateSolIntegralityViolation$address() {
        return SCIPupdateSolIntegralityViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateSolIntegralityViolation(SCIP *scip, SCIP_SOL *sol, double absviol)
     * }
     */
    public static void SCIPupdateSolIntegralityViolation(MemorySegment scip, MemorySegment sol, double absviol) {
        var mh$ = SCIPupdateSolIntegralityViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateSolIntegralityViolation", scip, sol, absviol);
            }
            mh$.invokeExact(scip, sol, absviol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateSolBoundViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateSolBoundViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateSolBoundViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static FunctionDescriptor SCIPupdateSolBoundViolation$descriptor() {
        return SCIPupdateSolBoundViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateSolBoundViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MethodHandle SCIPupdateSolBoundViolation$handle() {
        return SCIPupdateSolBoundViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateSolBoundViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MemorySegment SCIPupdateSolBoundViolation$address() {
        return SCIPupdateSolBoundViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateSolBoundViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static void SCIPupdateSolBoundViolation(MemorySegment scip, MemorySegment sol, double absviol, double relviol) {
        var mh$ = SCIPupdateSolBoundViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateSolBoundViolation", scip, sol, absviol, relviol);
            }
            mh$.invokeExact(scip, sol, absviol, relviol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateSolLPRowViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateSolLPRowViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPRowViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static FunctionDescriptor SCIPupdateSolLPRowViolation$descriptor() {
        return SCIPupdateSolLPRowViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPRowViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MethodHandle SCIPupdateSolLPRowViolation$handle() {
        return SCIPupdateSolLPRowViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPRowViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MemorySegment SCIPupdateSolLPRowViolation$address() {
        return SCIPupdateSolLPRowViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateSolLPRowViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static void SCIPupdateSolLPRowViolation(MemorySegment scip, MemorySegment sol, double absviol, double relviol) {
        var mh$ = SCIPupdateSolLPRowViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateSolLPRowViolation", scip, sol, absviol, relviol);
            }
            mh$.invokeExact(scip, sol, absviol, relviol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateSolConsViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateSolConsViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateSolConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static FunctionDescriptor SCIPupdateSolConsViolation$descriptor() {
        return SCIPupdateSolConsViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateSolConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MethodHandle SCIPupdateSolConsViolation$handle() {
        return SCIPupdateSolConsViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateSolConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MemorySegment SCIPupdateSolConsViolation$address() {
        return SCIPupdateSolConsViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateSolConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static void SCIPupdateSolConsViolation(MemorySegment scip, MemorySegment sol, double absviol, double relviol) {
        var mh$ = SCIPupdateSolConsViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateSolConsViolation", scip, sol, absviol, relviol);
            }
            mh$.invokeExact(scip, sol, absviol, relviol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateSolLPConsViolation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateSolLPConsViolation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static FunctionDescriptor SCIPupdateSolLPConsViolation$descriptor() {
        return SCIPupdateSolLPConsViolation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MethodHandle SCIPupdateSolLPConsViolation$handle() {
        return SCIPupdateSolLPConsViolation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPupdateSolLPConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static MemorySegment SCIPupdateSolLPConsViolation$address() {
        return SCIPupdateSolLPConsViolation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPupdateSolLPConsViolation(SCIP *scip, SCIP_SOL *sol, double absviol, double relviol)
     * }
     */
    public static void SCIPupdateSolLPConsViolation(MemorySegment scip, MemorySegment sol, double absviol, double relviol) {
        var mh$ = SCIPupdateSolLPConsViolation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateSolLPConsViolation", scip, sol, absviol, relviol);
            }
            mh$.invokeExact(scip, sol, absviol, relviol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPactivateSolViolationUpdates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPactivateSolViolationUpdates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPactivateSolViolationUpdates$descriptor() {
        return SCIPactivateSolViolationUpdates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPactivateSolViolationUpdates$handle() {
        return SCIPactivateSolViolationUpdates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPactivateSolViolationUpdates$address() {
        return SCIPactivateSolViolationUpdates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static void SCIPactivateSolViolationUpdates(MemorySegment scip) {
        var mh$ = SCIPactivateSolViolationUpdates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPactivateSolViolationUpdates", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPdeactivateSolViolationUpdates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPdeactivateSolViolationUpdates");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPdeactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPdeactivateSolViolationUpdates$descriptor() {
        return SCIPdeactivateSolViolationUpdates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPdeactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPdeactivateSolViolationUpdates$handle() {
        return SCIPdeactivateSolViolationUpdates.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPdeactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPdeactivateSolViolationUpdates$address() {
        return SCIPdeactivateSolViolationUpdates.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPdeactivateSolViolationUpdates(SCIP *scip)
     * }
     */
    public static void SCIPdeactivateSolViolationUpdates(MemorySegment scip) {
        var mh$ = SCIPdeactivateSolViolationUpdates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPdeactivateSolViolationUpdates", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPhasPrimalRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPhasPrimalRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPrimalRay(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPhasPrimalRay$descriptor() {
        return SCIPhasPrimalRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPrimalRay(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPhasPrimalRay$handle() {
        return SCIPhasPrimalRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPhasPrimalRay(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPhasPrimalRay$address() {
        return SCIPhasPrimalRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPhasPrimalRay(SCIP *scip)
     * }
     */
    public static int SCIPhasPrimalRay(MemorySegment scip) {
        var mh$ = SCIPhasPrimalRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPhasPrimalRay", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPrimalRayVal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPrimalRayVal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPrimalRayVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetPrimalRayVal$descriptor() {
        return SCIPgetPrimalRayVal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPrimalRayVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetPrimalRayVal$handle() {
        return SCIPgetPrimalRayVal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPrimalRayVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetPrimalRayVal$address() {
        return SCIPgetPrimalRayVal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPrimalRayVal(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetPrimalRayVal(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetPrimalRayVal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPrimalRayVal", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdatePrimalRay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdatePrimalRay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdatePrimalRay(SCIP *scip, SCIP_SOL *primalray)
     * }
     */
    public static FunctionDescriptor SCIPupdatePrimalRay$descriptor() {
        return SCIPupdatePrimalRay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdatePrimalRay(SCIP *scip, SCIP_SOL *primalray)
     * }
     */
    public static MethodHandle SCIPupdatePrimalRay$handle() {
        return SCIPupdatePrimalRay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdatePrimalRay(SCIP *scip, SCIP_SOL *primalray)
     * }
     */
    public static MemorySegment SCIPupdatePrimalRay$address() {
        return SCIPupdatePrimalRay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdatePrimalRay(SCIP *scip, SCIP_SOL *primalray)
     * }
     */
    public static int SCIPupdatePrimalRay(MemorySegment scip, MemorySegment primalray) {
        var mh$ = SCIPupdatePrimalRay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdatePrimalRay", scip, primalray);
            }
            return (int)mh$.invokeExact(scip, primalray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformProb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformProb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformProb(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPtransformProb$descriptor() {
        return SCIPtransformProb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformProb(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPtransformProb$handle() {
        return SCIPtransformProb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformProb(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPtransformProb$address() {
        return SCIPtransformProb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformProb(SCIP *scip)
     * }
     */
    public static int SCIPtransformProb(MemorySegment scip) {
        var mh$ = SCIPtransformProb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformProb", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpresolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpresolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPpresolve$descriptor() {
        return SCIPpresolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPpresolve$handle() {
        return SCIPpresolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPpresolve$address() {
        return SCIPpresolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpresolve(SCIP *scip)
     * }
     */
    public static int SCIPpresolve(MemorySegment scip) {
        var mh$ = SCIPpresolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpresolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsolve$descriptor() {
        return SCIPsolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsolve$handle() {
        return SCIPsolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsolve$address() {
        return SCIPsolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolve(SCIP *scip)
     * }
     */
    public static int SCIPsolve(MemorySegment scip) {
        var mh$ = SCIPsolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveParallel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveParallel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveParallel(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsolveParallel$descriptor() {
        return SCIPsolveParallel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveParallel(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsolveParallel$handle() {
        return SCIPsolveParallel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveParallel(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsolveParallel$address() {
        return SCIPsolveParallel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveParallel(SCIP *scip)
     * }
     */
    public static int SCIPsolveParallel(MemorySegment scip) {
        var mh$ = SCIPsolveParallel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveParallel", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsolveConcurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsolveConcurrent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveConcurrent(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPsolveConcurrent$descriptor() {
        return SCIPsolveConcurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveConcurrent(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPsolveConcurrent$handle() {
        return SCIPsolveConcurrent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveConcurrent(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPsolveConcurrent$address() {
        return SCIPsolveConcurrent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsolveConcurrent(SCIP *scip)
     * }
     */
    public static int SCIPsolveConcurrent(MemorySegment scip) {
        var mh$ = SCIPsolveConcurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsolveConcurrent", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSolve(SCIP *scip, unsigned int restart)
     * }
     */
    public static FunctionDescriptor SCIPfreeSolve$descriptor() {
        return SCIPfreeSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSolve(SCIP *scip, unsigned int restart)
     * }
     */
    public static MethodHandle SCIPfreeSolve$handle() {
        return SCIPfreeSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSolve(SCIP *scip, unsigned int restart)
     * }
     */
    public static MemorySegment SCIPfreeSolve$address() {
        return SCIPfreeSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeSolve(SCIP *scip, unsigned int restart)
     * }
     */
    public static int SCIPfreeSolve(MemorySegment scip, int restart) {
        var mh$ = SCIPfreeSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeSolve", scip, restart);
            }
            return (int)mh$.invokeExact(scip, restart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeTransform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeTransform(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPfreeTransform$descriptor() {
        return SCIPfreeTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeTransform(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPfreeTransform$handle() {
        return SCIPfreeTransform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeTransform(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPfreeTransform$address() {
        return SCIPfreeTransform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeTransform(SCIP *scip)
     * }
     */
    public static int SCIPfreeTransform(MemorySegment scip) {
        var mh$ = SCIPfreeTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeTransform", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinterruptSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinterruptSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptSolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPinterruptSolve$descriptor() {
        return SCIPinterruptSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptSolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPinterruptSolve$handle() {
        return SCIPinterruptSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptSolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPinterruptSolve$address() {
        return SCIPinterruptSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPinterruptSolve(SCIP *scip)
     * }
     */
    public static int SCIPinterruptSolve(MemorySegment scip) {
        var mh$ = SCIPinterruptSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinterruptSolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisSolveInterrupted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisSolveInterrupted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisSolveInterrupted(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisSolveInterrupted$descriptor() {
        return SCIPisSolveInterrupted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisSolveInterrupted(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisSolveInterrupted$handle() {
        return SCIPisSolveInterrupted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisSolveInterrupted(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisSolveInterrupted$address() {
        return SCIPisSolveInterrupted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisSolveInterrupted(SCIP *scip)
     * }
     */
    public static int SCIPisSolveInterrupted(MemorySegment scip) {
        var mh$ = SCIPisSolveInterrupted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisSolveInterrupted", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrestartSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrestartSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrestartSolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPrestartSolve$descriptor() {
        return SCIPrestartSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrestartSolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPrestartSolve$handle() {
        return SCIPrestartSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrestartSolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPrestartSolve$address() {
        return SCIPrestartSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrestartSolve(SCIP *scip)
     * }
     */
    public static int SCIPrestartSolve(MemorySegment scip) {
        var mh$ = SCIPrestartSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrestartSolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisInRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisInRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisInRestart(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisInRestart$descriptor() {
        return SCIPisInRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisInRestart(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisInRestart$handle() {
        return SCIPisInRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisInRestart(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisInRestart$address() {
        return SCIPisInRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisInRestart(SCIP *scip)
     * }
     */
    public static int SCIPisInRestart(MemorySegment scip) {
        var mh$ = SCIPisInRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisInRestart", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeReoptSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeReoptSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeReoptSolve(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPfreeReoptSolve$descriptor() {
        return SCIPfreeReoptSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeReoptSolve(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPfreeReoptSolve$handle() {
        return SCIPfreeReoptSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeReoptSolve(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPfreeReoptSolve$address() {
        return SCIPfreeReoptSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeReoptSolve(SCIP *scip)
     * }
     */
    public static int SCIPfreeReoptSolve(MemorySegment scip) {
        var mh$ = SCIPfreeReoptSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeReoptSolve", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableReoptimization {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableReoptimization");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableReoptimization(SCIP *scip, unsigned int enable)
     * }
     */
    public static FunctionDescriptor SCIPenableReoptimization$descriptor() {
        return SCIPenableReoptimization.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableReoptimization(SCIP *scip, unsigned int enable)
     * }
     */
    public static MethodHandle SCIPenableReoptimization$handle() {
        return SCIPenableReoptimization.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableReoptimization(SCIP *scip, unsigned int enable)
     * }
     */
    public static MemorySegment SCIPenableReoptimization$address() {
        return SCIPenableReoptimization.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableReoptimization(SCIP *scip, unsigned int enable)
     * }
     */
    public static int SCIPenableReoptimization(MemorySegment scip, int enable) {
        var mh$ = SCIPenableReoptimization.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableReoptimization", scip, enable);
            }
            return (int)mh$.invokeExact(scip, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisReoptEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisReoptEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisReoptEnabled(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisReoptEnabled$descriptor() {
        return SCIPisReoptEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisReoptEnabled(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisReoptEnabled$handle() {
        return SCIPisReoptEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisReoptEnabled(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisReoptEnabled$address() {
        return SCIPisReoptEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisReoptEnabled(SCIP *scip)
     * }
     */
    public static int SCIPisReoptEnabled(MemorySegment scip) {
        var mh$ = SCIPisReoptEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisReoptEnabled", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptSolsRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptSolsRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptSolsRun(SCIP *scip, int run, SCIP_SOL **sols, int allocmem, int *nsols)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptSolsRun$descriptor() {
        return SCIPgetReoptSolsRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptSolsRun(SCIP *scip, int run, SCIP_SOL **sols, int allocmem, int *nsols)
     * }
     */
    public static MethodHandle SCIPgetReoptSolsRun$handle() {
        return SCIPgetReoptSolsRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptSolsRun(SCIP *scip, int run, SCIP_SOL **sols, int allocmem, int *nsols)
     * }
     */
    public static MemorySegment SCIPgetReoptSolsRun$address() {
        return SCIPgetReoptSolsRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptSolsRun(SCIP *scip, int run, SCIP_SOL **sols, int allocmem, int *nsols)
     * }
     */
    public static int SCIPgetReoptSolsRun(MemorySegment scip, int run, MemorySegment sols, int allocmem, MemorySegment nsols) {
        var mh$ = SCIPgetReoptSolsRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptSolsRun", scip, run, sols, allocmem, nsols);
            }
            return (int)mh$.invokeExact(scip, run, sols, allocmem, nsols);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetReoptSolMarks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetReoptSolMarks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPresetReoptSolMarks(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPresetReoptSolMarks$descriptor() {
        return SCIPresetReoptSolMarks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPresetReoptSolMarks(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPresetReoptSolMarks$handle() {
        return SCIPresetReoptSolMarks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPresetReoptSolMarks(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPresetReoptSolMarks$address() {
        return SCIPresetReoptSolMarks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPresetReoptSolMarks(SCIP *scip)
     * }
     */
    public static void SCIPresetReoptSolMarks(MemorySegment scip) {
        var mh$ = SCIPresetReoptSolMarks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetReoptSolMarks", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcheckReoptRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcheckReoptRestart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckReoptRestart(SCIP *scip, SCIP_NODE *node, unsigned int *restart)
     * }
     */
    public static FunctionDescriptor SCIPcheckReoptRestart$descriptor() {
        return SCIPcheckReoptRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckReoptRestart(SCIP *scip, SCIP_NODE *node, unsigned int *restart)
     * }
     */
    public static MethodHandle SCIPcheckReoptRestart$handle() {
        return SCIPcheckReoptRestart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckReoptRestart(SCIP *scip, SCIP_NODE *node, unsigned int *restart)
     * }
     */
    public static MemorySegment SCIPcheckReoptRestart$address() {
        return SCIPcheckReoptRestart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcheckReoptRestart(SCIP *scip, SCIP_NODE *node, unsigned int *restart)
     * }
     */
    public static int SCIPcheckReoptRestart(MemorySegment scip, MemorySegment node, MemorySegment restart) {
        var mh$ = SCIPcheckReoptRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcheckReoptRestart", scip, node, restart);
            }
            return (int)mh$.invokeExact(scip, node, restart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddReoptDualBndchg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddReoptDualBndchg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptDualBndchg(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound, double oldbound)
     * }
     */
    public static FunctionDescriptor SCIPaddReoptDualBndchg$descriptor() {
        return SCIPaddReoptDualBndchg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptDualBndchg(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound, double oldbound)
     * }
     */
    public static MethodHandle SCIPaddReoptDualBndchg$handle() {
        return SCIPaddReoptDualBndchg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptDualBndchg(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound, double oldbound)
     * }
     */
    public static MemorySegment SCIPaddReoptDualBndchg$address() {
        return SCIPaddReoptDualBndchg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPaddReoptDualBndchg(SCIP *scip, SCIP_NODE *node, SCIP_VAR *var, double newbound, double oldbound)
     * }
     */
    public static int SCIPaddReoptDualBndchg(MemorySegment scip, MemorySegment node, MemorySegment var_, double newbound, double oldbound) {
        var mh$ = SCIPaddReoptDualBndchg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddReoptDualBndchg", scip, node, var_, newbound, oldbound);
            }
            return (int)mh$.invokeExact(scip, node, var_, newbound, oldbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptLastOptSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptLastOptSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetReoptLastOptSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptLastOptSol$descriptor() {
        return SCIPgetReoptLastOptSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetReoptLastOptSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetReoptLastOptSol$handle() {
        return SCIPgetReoptLastOptSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetReoptLastOptSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetReoptLastOptSol$address() {
        return SCIPgetReoptLastOptSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_SOL *SCIPgetReoptLastOptSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetReoptLastOptSol(MemorySegment scip) {
        var mh$ = SCIPgetReoptLastOptSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptLastOptSol", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReoptOldObjCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReoptOldObjCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptOldObjCoef(SCIP *scip, SCIP_VAR *var, int run, double *objcoef)
     * }
     */
    public static FunctionDescriptor SCIPgetReoptOldObjCoef$descriptor() {
        return SCIPgetReoptOldObjCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptOldObjCoef(SCIP *scip, SCIP_VAR *var, int run, double *objcoef)
     * }
     */
    public static MethodHandle SCIPgetReoptOldObjCoef$handle() {
        return SCIPgetReoptOldObjCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptOldObjCoef(SCIP *scip, SCIP_VAR *var, int run, double *objcoef)
     * }
     */
    public static MemorySegment SCIPgetReoptOldObjCoef$address() {
        return SCIPgetReoptOldObjCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetReoptOldObjCoef(SCIP *scip, SCIP_VAR *var, int run, double *objcoef)
     * }
     */
    public static int SCIPgetReoptOldObjCoef(MemorySegment scip, MemorySegment var_, int run, MemorySegment objcoef) {
        var mh$ = SCIPgetReoptOldObjCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReoptOldObjCoef", scip, var_, run, objcoef);
            }
            return (int)mh$.invokeExact(scip, var_, run, objcoef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRuns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRuns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNRuns(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRuns$descriptor() {
        return SCIPgetNRuns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNRuns(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRuns$handle() {
        return SCIPgetNRuns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNRuns(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRuns$address() {
        return SCIPgetNRuns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNRuns(SCIP *scip)
     * }
     */
    public static int SCIPgetNRuns(MemorySegment scip) {
        var mh$ = SCIPgetNRuns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRuns", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNReoptRuns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNReoptRuns");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNReoptRuns(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNReoptRuns$descriptor() {
        return SCIPgetNReoptRuns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNReoptRuns(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNReoptRuns$handle() {
        return SCIPgetNReoptRuns.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNReoptRuns(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNReoptRuns$address() {
        return SCIPgetNReoptRuns.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNReoptRuns(SCIP *scip)
     * }
     */
    public static int SCIPgetNReoptRuns(MemorySegment scip) {
        var mh$ = SCIPgetNReoptRuns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNReoptRuns", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPaddNNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPaddNNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPaddNNodes(SCIP *scip, long long nnodes)
     * }
     */
    public static FunctionDescriptor SCIPaddNNodes$descriptor() {
        return SCIPaddNNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPaddNNodes(SCIP *scip, long long nnodes)
     * }
     */
    public static MethodHandle SCIPaddNNodes$handle() {
        return SCIPaddNNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPaddNNodes(SCIP *scip, long long nnodes)
     * }
     */
    public static MemorySegment SCIPaddNNodes$address() {
        return SCIPaddNNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPaddNNodes(SCIP *scip, long long nnodes)
     * }
     */
    public static void SCIPaddNNodes(MemorySegment scip, long nnodes) {
        var mh$ = SCIPaddNNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPaddNNodes", scip, nnodes);
            }
            mh$.invokeExact(scip, nnodes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodes(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodes$descriptor() {
        return SCIPgetNNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodes(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodes$handle() {
        return SCIPgetNNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodes$address() {
        return SCIPgetNNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodes(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodes(MemorySegment scip) {
        var mh$ = SCIPgetNNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodes", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNTotalNodes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNTotalNodes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNTotalNodes(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNTotalNodes$descriptor() {
        return SCIPgetNTotalNodes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNTotalNodes(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNTotalNodes$handle() {
        return SCIPgetNTotalNodes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNTotalNodes(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNTotalNodes$address() {
        return SCIPgetNTotalNodes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNTotalNodes(SCIP *scip)
     * }
     */
    public static long SCIPgetNTotalNodes(MemorySegment scip) {
        var mh$ = SCIPgetNTotalNodes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNTotalNodes", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNFeasibleLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNFeasibleLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNFeasibleLeaves(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNFeasibleLeaves$descriptor() {
        return SCIPgetNFeasibleLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNFeasibleLeaves(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNFeasibleLeaves$handle() {
        return SCIPgetNFeasibleLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNFeasibleLeaves(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNFeasibleLeaves$address() {
        return SCIPgetNFeasibleLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNFeasibleLeaves(SCIP *scip)
     * }
     */
    public static long SCIPgetNFeasibleLeaves(MemorySegment scip) {
        var mh$ = SCIPgetNFeasibleLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNFeasibleLeaves", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNInfeasibleLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNInfeasibleLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNInfeasibleLeaves(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNInfeasibleLeaves$descriptor() {
        return SCIPgetNInfeasibleLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNInfeasibleLeaves(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNInfeasibleLeaves$handle() {
        return SCIPgetNInfeasibleLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNInfeasibleLeaves(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNInfeasibleLeaves$address() {
        return SCIPgetNInfeasibleLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNInfeasibleLeaves(SCIP *scip)
     * }
     */
    public static long SCIPgetNInfeasibleLeaves(MemorySegment scip) {
        var mh$ = SCIPgetNInfeasibleLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNInfeasibleLeaves", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNObjlimLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNObjlimLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNObjlimLeaves(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNObjlimLeaves$descriptor() {
        return SCIPgetNObjlimLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNObjlimLeaves(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNObjlimLeaves$handle() {
        return SCIPgetNObjlimLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNObjlimLeaves(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNObjlimLeaves$address() {
        return SCIPgetNObjlimLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNObjlimLeaves(SCIP *scip)
     * }
     */
    public static long SCIPgetNObjlimLeaves(MemorySegment scip) {
        var mh$ = SCIPgetNObjlimLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNObjlimLeaves", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootboundChgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootboundChgs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootboundChgs$descriptor() {
        return SCIPgetNRootboundChgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootboundChgs$handle() {
        return SCIPgetNRootboundChgs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootboundChgs$address() {
        return SCIPgetNRootboundChgs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgs(SCIP *scip)
     * }
     */
    public static int SCIPgetNRootboundChgs(MemorySegment scip) {
        var mh$ = SCIPgetNRootboundChgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootboundChgs", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootboundChgsRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootboundChgsRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgsRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootboundChgsRun$descriptor() {
        return SCIPgetNRootboundChgsRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgsRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootboundChgsRun$handle() {
        return SCIPgetNRootboundChgsRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgsRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootboundChgsRun$address() {
        return SCIPgetNRootboundChgsRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNRootboundChgsRun(SCIP *scip)
     * }
     */
    public static int SCIPgetNRootboundChgsRun(MemorySegment scip) {
        var mh$ = SCIPgetNRootboundChgsRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootboundChgsRun", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDelayedCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDelayedCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDelayedCutoffs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDelayedCutoffs$descriptor() {
        return SCIPgetNDelayedCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDelayedCutoffs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDelayedCutoffs$handle() {
        return SCIPgetNDelayedCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDelayedCutoffs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDelayedCutoffs$address() {
        return SCIPgetNDelayedCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDelayedCutoffs(SCIP *scip)
     * }
     */
    public static long SCIPgetNDelayedCutoffs(MemorySegment scip) {
        var mh$ = SCIPgetNDelayedCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDelayedCutoffs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPs$descriptor() {
        return SCIPgetNLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPs$handle() {
        return SCIPgetNLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPs$address() {
        return SCIPgetNLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNLPs(MemorySegment scip) {
        var mh$ = SCIPgetNLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLPIterations$descriptor() {
        return SCIPgetNLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLPIterations$handle() {
        return SCIPgetNLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLPIterations$address() {
        return SCIPgetNLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNZs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNZs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNZs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNZs$descriptor() {
        return SCIPgetNNZs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNZs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNZs$handle() {
        return SCIPgetNNZs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNZs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNZs$address() {
        return SCIPgetNNZs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNZs(SCIP *scip)
     * }
     */
    public static long SCIPgetNNZs(MemorySegment scip) {
        var mh$ = SCIPgetNNZs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNZs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNRootLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootLPIterations$descriptor() {
        return SCIPgetNRootLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNRootLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootLPIterations$handle() {
        return SCIPgetNRootLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNRootLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootLPIterations$address() {
        return SCIPgetNRootLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNRootLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNRootLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNRootLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootFirstLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootFirstLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNRootFirstLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootFirstLPIterations$descriptor() {
        return SCIPgetNRootFirstLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNRootFirstLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootFirstLPIterations$handle() {
        return SCIPgetNRootFirstLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNRootFirstLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootFirstLPIterations$address() {
        return SCIPgetNRootFirstLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNRootFirstLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNRootFirstLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNRootFirstLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootFirstLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrimalLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrimalLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrimalLPs$descriptor() {
        return SCIPgetNPrimalLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrimalLPs$handle() {
        return SCIPgetNPrimalLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrimalLPs$address() {
        return SCIPgetNPrimalLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNPrimalLPs(MemorySegment scip) {
        var mh$ = SCIPgetNPrimalLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrimalLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrimalLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrimalLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrimalLPIterations$descriptor() {
        return SCIPgetNPrimalLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrimalLPIterations$handle() {
        return SCIPgetNPrimalLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrimalLPIterations$address() {
        return SCIPgetNPrimalLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNPrimalLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNPrimalLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNPrimalLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrimalLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDualLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDualLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDualLPs$descriptor() {
        return SCIPgetNDualLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDualLPs$handle() {
        return SCIPgetNDualLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDualLPs$address() {
        return SCIPgetNDualLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDualLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNDualLPs(MemorySegment scip) {
        var mh$ = SCIPgetNDualLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDualLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDualLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDualLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDualLPIterations$descriptor() {
        return SCIPgetNDualLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDualLPIterations$handle() {
        return SCIPgetNDualLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDualLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDualLPIterations$address() {
        return SCIPgetNDualLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDualLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNDualLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNDualLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDualLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBarrierLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBarrierLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBarrierLPs$descriptor() {
        return SCIPgetNBarrierLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBarrierLPs$handle() {
        return SCIPgetNBarrierLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBarrierLPs$address() {
        return SCIPgetNBarrierLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNBarrierLPs(MemorySegment scip) {
        var mh$ = SCIPgetNBarrierLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBarrierLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBarrierLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBarrierLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBarrierLPIterations$descriptor() {
        return SCIPgetNBarrierLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBarrierLPIterations$handle() {
        return SCIPgetNBarrierLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBarrierLPIterations$address() {
        return SCIPgetNBarrierLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNBarrierLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNBarrierLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNBarrierLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBarrierLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNResolveLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNResolveLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNResolveLPs$descriptor() {
        return SCIPgetNResolveLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNResolveLPs$handle() {
        return SCIPgetNResolveLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNResolveLPs$address() {
        return SCIPgetNResolveLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNResolveLPs(MemorySegment scip) {
        var mh$ = SCIPgetNResolveLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNResolveLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNResolveLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNResolveLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNResolveLPIterations$descriptor() {
        return SCIPgetNResolveLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNResolveLPIterations$handle() {
        return SCIPgetNResolveLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNResolveLPIterations$address() {
        return SCIPgetNResolveLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNResolveLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNResolveLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNResolveLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNResolveLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrimalResolveLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrimalResolveLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrimalResolveLPs$descriptor() {
        return SCIPgetNPrimalResolveLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrimalResolveLPs$handle() {
        return SCIPgetNPrimalResolveLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrimalResolveLPs$address() {
        return SCIPgetNPrimalResolveLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNPrimalResolveLPs(MemorySegment scip) {
        var mh$ = SCIPgetNPrimalResolveLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrimalResolveLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPrimalResolveLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPrimalResolveLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPrimalResolveLPIterations$descriptor() {
        return SCIPgetNPrimalResolveLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPrimalResolveLPIterations$handle() {
        return SCIPgetNPrimalResolveLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPrimalResolveLPIterations$address() {
        return SCIPgetNPrimalResolveLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNPrimalResolveLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNPrimalResolveLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNPrimalResolveLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPrimalResolveLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDualResolveLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDualResolveLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDualResolveLPs$descriptor() {
        return SCIPgetNDualResolveLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDualResolveLPs$handle() {
        return SCIPgetNDualResolveLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDualResolveLPs$address() {
        return SCIPgetNDualResolveLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNDualResolveLPs(MemorySegment scip) {
        var mh$ = SCIPgetNDualResolveLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDualResolveLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDualResolveLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDualResolveLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDualResolveLPIterations$descriptor() {
        return SCIPgetNDualResolveLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDualResolveLPIterations$handle() {
        return SCIPgetNDualResolveLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDualResolveLPIterations$address() {
        return SCIPgetNDualResolveLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDualResolveLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNDualResolveLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNDualResolveLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDualResolveLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodeLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodeLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodeLPs$descriptor() {
        return SCIPgetNNodeLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodeLPs$handle() {
        return SCIPgetNNodeLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodeLPs$address() {
        return SCIPgetNNodeLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodeLPs(MemorySegment scip) {
        var mh$ = SCIPgetNNodeLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodeLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodeZeroIterationLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodeZeroIterationLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeZeroIterationLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodeZeroIterationLPs$descriptor() {
        return SCIPgetNNodeZeroIterationLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeZeroIterationLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodeZeroIterationLPs$handle() {
        return SCIPgetNNodeZeroIterationLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeZeroIterationLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodeZeroIterationLPs$address() {
        return SCIPgetNNodeZeroIterationLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodeZeroIterationLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodeZeroIterationLPs(MemorySegment scip) {
        var mh$ = SCIPgetNNodeZeroIterationLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodeZeroIterationLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodeLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodeLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodeLPIterations$descriptor() {
        return SCIPgetNNodeLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodeLPIterations$handle() {
        return SCIPgetNNodeLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodeLPIterations$address() {
        return SCIPgetNNodeLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodeLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodeLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNNodeLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodeLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodeInitLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodeInitLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodeInitLPs$descriptor() {
        return SCIPgetNNodeInitLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodeInitLPs$handle() {
        return SCIPgetNNodeInitLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodeInitLPs$address() {
        return SCIPgetNNodeInitLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodeInitLPs(MemorySegment scip) {
        var mh$ = SCIPgetNNodeInitLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodeInitLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodeInitLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodeInitLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodeInitLPIterations$descriptor() {
        return SCIPgetNNodeInitLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodeInitLPIterations$handle() {
        return SCIPgetNNodeInitLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodeInitLPIterations$address() {
        return SCIPgetNNodeInitLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNNodeInitLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNNodeInitLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNNodeInitLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodeInitLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDivingLPs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDivingLPs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDivingLPs$descriptor() {
        return SCIPgetNDivingLPs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDivingLPs$handle() {
        return SCIPgetNDivingLPs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDivingLPs$address() {
        return SCIPgetNDivingLPs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPs(SCIP *scip)
     * }
     */
    public static long SCIPgetNDivingLPs(MemorySegment scip) {
        var mh$ = SCIPgetNDivingLPs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDivingLPs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNDivingLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNDivingLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNDivingLPIterations$descriptor() {
        return SCIPgetNDivingLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNDivingLPIterations$handle() {
        return SCIPgetNDivingLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNDivingLPIterations$address() {
        return SCIPgetNDivingLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNDivingLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNDivingLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNDivingLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNDivingLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNStrongbranchs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNStrongbranchs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNStrongbranchs$descriptor() {
        return SCIPgetNStrongbranchs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNStrongbranchs$handle() {
        return SCIPgetNStrongbranchs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNStrongbranchs$address() {
        return SCIPgetNStrongbranchs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchs(SCIP *scip)
     * }
     */
    public static long SCIPgetNStrongbranchs(MemorySegment scip) {
        var mh$ = SCIPgetNStrongbranchs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNStrongbranchs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNStrongbranchLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNStrongbranchLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNStrongbranchLPIterations$descriptor() {
        return SCIPgetNStrongbranchLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNStrongbranchLPIterations$handle() {
        return SCIPgetNStrongbranchLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNStrongbranchLPIterations$address() {
        return SCIPgetNStrongbranchLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNStrongbranchLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNStrongbranchLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNStrongbranchLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootStrongbranchs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootStrongbranchs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchs(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootStrongbranchs$descriptor() {
        return SCIPgetNRootStrongbranchs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchs(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootStrongbranchs$handle() {
        return SCIPgetNRootStrongbranchs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchs(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootStrongbranchs$address() {
        return SCIPgetNRootStrongbranchs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchs(SCIP *scip)
     * }
     */
    public static long SCIPgetNRootStrongbranchs(MemorySegment scip) {
        var mh$ = SCIPgetNRootStrongbranchs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootStrongbranchs", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNRootStrongbranchLPIterations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNRootStrongbranchLPIterations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNRootStrongbranchLPIterations$descriptor() {
        return SCIPgetNRootStrongbranchLPIterations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNRootStrongbranchLPIterations$handle() {
        return SCIPgetNRootStrongbranchLPIterations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNRootStrongbranchLPIterations$address() {
        return SCIPgetNRootStrongbranchLPIterations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNRootStrongbranchLPIterations(SCIP *scip)
     * }
     */
    public static long SCIPgetNRootStrongbranchLPIterations(MemorySegment scip) {
        var mh$ = SCIPgetNRootStrongbranchLPIterations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNRootStrongbranchLPIterations", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPriceRounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPriceRounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPriceRounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPriceRounds$descriptor() {
        return SCIPgetNPriceRounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPriceRounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPriceRounds$handle() {
        return SCIPgetNPriceRounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPriceRounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPriceRounds$address() {
        return SCIPgetNPriceRounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPriceRounds(SCIP *scip)
     * }
     */
    public static int SCIPgetNPriceRounds(MemorySegment scip) {
        var mh$ = SCIPgetNPriceRounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPriceRounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPricevars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPricevars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPricevars(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPricevars$descriptor() {
        return SCIPgetNPricevars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPricevars(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPricevars$handle() {
        return SCIPgetNPricevars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPricevars(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPricevars$address() {
        return SCIPgetNPricevars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPricevars(SCIP *scip)
     * }
     */
    public static int SCIPgetNPricevars(MemorySegment scip) {
        var mh$ = SCIPgetNPricevars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPricevars", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPricevarsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPricevarsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPricevarsFound$descriptor() {
        return SCIPgetNPricevarsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPricevarsFound$handle() {
        return SCIPgetNPricevarsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPricevarsFound$address() {
        return SCIPgetNPricevarsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPricevarsFound(SCIP *scip)
     * }
     */
    public static int SCIPgetNPricevarsFound(MemorySegment scip) {
        var mh$ = SCIPgetNPricevarsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPricevarsFound", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNPricevarsApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNPricevarsApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsApplied(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNPricevarsApplied$descriptor() {
        return SCIPgetNPricevarsApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsApplied(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNPricevarsApplied$handle() {
        return SCIPgetNPricevarsApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNPricevarsApplied(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNPricevarsApplied$address() {
        return SCIPgetNPricevarsApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNPricevarsApplied(SCIP *scip)
     * }
     */
    public static int SCIPgetNPricevarsApplied(MemorySegment scip) {
        var mh$ = SCIPgetNPricevarsApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNPricevarsApplied", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSepaRounds {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSepaRounds");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNSepaRounds(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNSepaRounds$descriptor() {
        return SCIPgetNSepaRounds.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNSepaRounds(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNSepaRounds$handle() {
        return SCIPgetNSepaRounds.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNSepaRounds(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNSepaRounds$address() {
        return SCIPgetNSepaRounds.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNSepaRounds(SCIP *scip)
     * }
     */
    public static int SCIPgetNSepaRounds(MemorySegment scip) {
        var mh$ = SCIPgetNSepaRounds.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSepaRounds", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCutsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCutsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCutsFound$descriptor() {
        return SCIPgetNCutsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCutsFound$handle() {
        return SCIPgetNCutsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCutsFound$address() {
        return SCIPgetNCutsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCutsFound(SCIP *scip)
     * }
     */
    public static int SCIPgetNCutsFound(MemorySegment scip) {
        var mh$ = SCIPgetNCutsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCutsFound", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCutsFoundRound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCutsFoundRound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFoundRound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCutsFoundRound$descriptor() {
        return SCIPgetNCutsFoundRound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFoundRound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCutsFoundRound$handle() {
        return SCIPgetNCutsFoundRound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCutsFoundRound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCutsFoundRound$address() {
        return SCIPgetNCutsFoundRound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCutsFoundRound(SCIP *scip)
     * }
     */
    public static int SCIPgetNCutsFoundRound(MemorySegment scip) {
        var mh$ = SCIPgetNCutsFoundRound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCutsFoundRound", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNCutsApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNCutsApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNCutsApplied(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNCutsApplied$descriptor() {
        return SCIPgetNCutsApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNCutsApplied(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNCutsApplied$handle() {
        return SCIPgetNCutsApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNCutsApplied(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNCutsApplied$address() {
        return SCIPgetNCutsApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNCutsApplied(SCIP *scip)
     * }
     */
    public static int SCIPgetNCutsApplied(MemorySegment scip) {
        var mh$ = SCIPgetNCutsApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNCutsApplied", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConflictConssFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConflictConssFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConflictConssFound$descriptor() {
        return SCIPgetNConflictConssFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConflictConssFound$handle() {
        return SCIPgetNConflictConssFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConflictConssFound$address() {
        return SCIPgetNConflictConssFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssFound(SCIP *scip)
     * }
     */
    public static long SCIPgetNConflictConssFound(MemorySegment scip) {
        var mh$ = SCIPgetNConflictConssFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConflictConssFound", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConflictConssFoundNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConflictConssFoundNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNConflictConssFoundNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConflictConssFoundNode$descriptor() {
        return SCIPgetNConflictConssFoundNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNConflictConssFoundNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConflictConssFoundNode$handle() {
        return SCIPgetNConflictConssFoundNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNConflictConssFoundNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConflictConssFoundNode$address() {
        return SCIPgetNConflictConssFoundNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNConflictConssFoundNode(SCIP *scip)
     * }
     */
    public static int SCIPgetNConflictConssFoundNode(MemorySegment scip) {
        var mh$ = SCIPgetNConflictConssFoundNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConflictConssFoundNode", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConflictConssApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConflictConssApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssApplied(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConflictConssApplied$descriptor() {
        return SCIPgetNConflictConssApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssApplied(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConflictConssApplied$handle() {
        return SCIPgetNConflictConssApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssApplied(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConflictConssApplied$address() {
        return SCIPgetNConflictConssApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNConflictConssApplied(SCIP *scip)
     * }
     */
    public static long SCIPgetNConflictConssApplied(MemorySegment scip) {
        var mh$ = SCIPgetNConflictConssApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConflictConssApplied", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNConflictDualproofsApplied {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNConflictDualproofsApplied");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictDualproofsApplied(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNConflictDualproofsApplied$descriptor() {
        return SCIPgetNConflictDualproofsApplied.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictDualproofsApplied(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNConflictDualproofsApplied$handle() {
        return SCIPgetNConflictDualproofsApplied.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNConflictDualproofsApplied(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNConflictDualproofsApplied$address() {
        return SCIPgetNConflictDualproofsApplied.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNConflictDualproofsApplied(SCIP *scip)
     * }
     */
    public static long SCIPgetNConflictDualproofsApplied(MemorySegment scip) {
        var mh$ = SCIPgetNConflictDualproofsApplied.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNConflictDualproofsApplied", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMaxDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMaxDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetMaxDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMaxDepth$descriptor() {
        return SCIPgetMaxDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetMaxDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMaxDepth$handle() {
        return SCIPgetMaxDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetMaxDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMaxDepth$address() {
        return SCIPgetMaxDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetMaxDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetMaxDepth(MemorySegment scip) {
        var mh$ = SCIPgetMaxDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMaxDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetMaxTotalDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetMaxTotalDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetMaxTotalDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetMaxTotalDepth$descriptor() {
        return SCIPgetMaxTotalDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetMaxTotalDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetMaxTotalDepth$handle() {
        return SCIPgetMaxTotalDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetMaxTotalDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetMaxTotalDepth$address() {
        return SCIPgetMaxTotalDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetMaxTotalDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetMaxTotalDepth(MemorySegment scip) {
        var mh$ = SCIPgetMaxTotalDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetMaxTotalDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBacktracks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBacktracks");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNBacktracks(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBacktracks$descriptor() {
        return SCIPgetNBacktracks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNBacktracks(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBacktracks$handle() {
        return SCIPgetNBacktracks.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNBacktracks(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBacktracks$address() {
        return SCIPgetNBacktracks.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNBacktracks(SCIP *scip)
     * }
     */
    public static long SCIPgetNBacktracks(MemorySegment scip) {
        var mh$ = SCIPgetNBacktracks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBacktracks", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNActiveConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNActiveConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNActiveConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNActiveConss$descriptor() {
        return SCIPgetNActiveConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNActiveConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNActiveConss$handle() {
        return SCIPgetNActiveConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNActiveConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNActiveConss$address() {
        return SCIPgetNActiveConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNActiveConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNActiveConss(MemorySegment scip) {
        var mh$ = SCIPgetNActiveConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNActiveConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNEnabledConss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNEnabledConss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNEnabledConss(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNEnabledConss$descriptor() {
        return SCIPgetNEnabledConss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNEnabledConss(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNEnabledConss$handle() {
        return SCIPgetNEnabledConss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNEnabledConss(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNEnabledConss$address() {
        return SCIPgetNEnabledConss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNEnabledConss(SCIP *scip)
     * }
     */
    public static int SCIPgetNEnabledConss(MemorySegment scip) {
        var mh$ = SCIPgetNEnabledConss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNEnabledConss", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgDualbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgDualbound$descriptor() {
        return SCIPgetAvgDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgDualbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgDualbound$handle() {
        return SCIPgetAvgDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgDualbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgDualbound$address() {
        return SCIPgetAvgDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgDualbound(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgDualbound(MemorySegment scip) {
        var mh$ = SCIPgetAvgDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgDualbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgLowerbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgLowerbound$descriptor() {
        return SCIPgetAvgLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgLowerbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgLowerbound$handle() {
        return SCIPgetAvgLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgLowerbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgLowerbound$address() {
        return SCIPgetAvgLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgLowerbound(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgLowerbound(MemorySegment scip) {
        var mh$ = SCIPgetAvgLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgLowerbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDualbound$descriptor() {
        return SCIPgetDualbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDualbound$handle() {
        return SCIPgetDualbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDualbound$address() {
        return SCIPgetDualbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualbound(SCIP *scip)
     * }
     */
    public static double SCIPgetDualbound(MemorySegment scip) {
        var mh$ = SCIPgetDualbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLowerbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLowerbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLowerbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLowerbound$descriptor() {
        return SCIPgetLowerbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLowerbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLowerbound$handle() {
        return SCIPgetLowerbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLowerbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLowerbound$address() {
        return SCIPgetLowerbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLowerbound(SCIP *scip)
     * }
     */
    public static double SCIPgetLowerbound(MemorySegment scip) {
        var mh$ = SCIPgetLowerbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLowerbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDualboundRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDualboundRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDualboundRoot(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDualboundRoot$descriptor() {
        return SCIPgetDualboundRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDualboundRoot(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDualboundRoot$handle() {
        return SCIPgetDualboundRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDualboundRoot(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDualboundRoot$address() {
        return SCIPgetDualboundRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDualboundRoot(SCIP *scip)
     * }
     */
    public static double SCIPgetDualboundRoot(MemorySegment scip) {
        var mh$ = SCIPgetDualboundRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDualboundRoot", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLowerboundRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLowerboundRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetLowerboundRoot(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetLowerboundRoot$descriptor() {
        return SCIPgetLowerboundRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetLowerboundRoot(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetLowerboundRoot$handle() {
        return SCIPgetLowerboundRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetLowerboundRoot(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetLowerboundRoot$address() {
        return SCIPgetLowerboundRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetLowerboundRoot(SCIP *scip)
     * }
     */
    public static double SCIPgetLowerboundRoot(MemorySegment scip) {
        var mh$ = SCIPgetLowerboundRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLowerboundRoot", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFirstLPDualboundRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFirstLPDualboundRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPDualboundRoot(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFirstLPDualboundRoot$descriptor() {
        return SCIPgetFirstLPDualboundRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPDualboundRoot(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFirstLPDualboundRoot$handle() {
        return SCIPgetFirstLPDualboundRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPDualboundRoot(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFirstLPDualboundRoot$address() {
        return SCIPgetFirstLPDualboundRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetFirstLPDualboundRoot(SCIP *scip)
     * }
     */
    public static double SCIPgetFirstLPDualboundRoot(MemorySegment scip) {
        var mh$ = SCIPgetFirstLPDualboundRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFirstLPDualboundRoot", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFirstLPLowerboundRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFirstLPLowerboundRoot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPLowerboundRoot(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFirstLPLowerboundRoot$descriptor() {
        return SCIPgetFirstLPLowerboundRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPLowerboundRoot(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFirstLPLowerboundRoot$handle() {
        return SCIPgetFirstLPLowerboundRoot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPLowerboundRoot(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFirstLPLowerboundRoot$address() {
        return SCIPgetFirstLPLowerboundRoot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetFirstLPLowerboundRoot(SCIP *scip)
     * }
     */
    public static double SCIPgetFirstLPLowerboundRoot(MemorySegment scip) {
        var mh$ = SCIPgetFirstLPLowerboundRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFirstLPLowerboundRoot", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFirstPrimalBound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFirstPrimalBound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetFirstPrimalBound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFirstPrimalBound$descriptor() {
        return SCIPgetFirstPrimalBound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetFirstPrimalBound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFirstPrimalBound$handle() {
        return SCIPgetFirstPrimalBound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetFirstPrimalBound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFirstPrimalBound$address() {
        return SCIPgetFirstPrimalBound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetFirstPrimalBound(SCIP *scip)
     * }
     */
    public static double SCIPgetFirstPrimalBound(MemorySegment scip) {
        var mh$ = SCIPgetFirstPrimalBound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFirstPrimalBound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPrimalbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPrimalbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPrimalbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPrimalbound$descriptor() {
        return SCIPgetPrimalbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPrimalbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPrimalbound$handle() {
        return SCIPgetPrimalbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPrimalbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrimalbound$address() {
        return SCIPgetPrimalbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPrimalbound(SCIP *scip)
     * }
     */
    public static double SCIPgetPrimalbound(MemorySegment scip) {
        var mh$ = SCIPgetPrimalbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPrimalbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetUpperbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetUpperbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetUpperbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetUpperbound$descriptor() {
        return SCIPgetUpperbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetUpperbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetUpperbound$handle() {
        return SCIPgetUpperbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetUpperbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetUpperbound$address() {
        return SCIPgetUpperbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetUpperbound(SCIP *scip)
     * }
     */
    public static double SCIPgetUpperbound(MemorySegment scip) {
        var mh$ = SCIPgetUpperbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetUpperbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCutoffbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCutoffbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetCutoffbound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCutoffbound$descriptor() {
        return SCIPgetCutoffbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetCutoffbound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCutoffbound$handle() {
        return SCIPgetCutoffbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetCutoffbound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCutoffbound$address() {
        return SCIPgetCutoffbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetCutoffbound(SCIP *scip)
     * }
     */
    public static double SCIPgetCutoffbound(MemorySegment scip) {
        var mh$ = SCIPgetCutoffbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCutoffbound", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPupdateCutoffbound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPupdateCutoffbound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateCutoffbound(SCIP *scip, double cutoffbound)
     * }
     */
    public static FunctionDescriptor SCIPupdateCutoffbound$descriptor() {
        return SCIPupdateCutoffbound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateCutoffbound(SCIP *scip, double cutoffbound)
     * }
     */
    public static MethodHandle SCIPupdateCutoffbound$handle() {
        return SCIPupdateCutoffbound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateCutoffbound(SCIP *scip, double cutoffbound)
     * }
     */
    public static MemorySegment SCIPupdateCutoffbound$address() {
        return SCIPupdateCutoffbound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPupdateCutoffbound(SCIP *scip, double cutoffbound)
     * }
     */
    public static int SCIPupdateCutoffbound(MemorySegment scip, double cutoffbound) {
        var mh$ = SCIPupdateCutoffbound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPupdateCutoffbound", scip, cutoffbound);
            }
            return (int)mh$.invokeExact(scip, cutoffbound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPisPrimalboundSol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPisPrimalboundSol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPisPrimalboundSol(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPisPrimalboundSol$descriptor() {
        return SCIPisPrimalboundSol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPisPrimalboundSol(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPisPrimalboundSol$handle() {
        return SCIPisPrimalboundSol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPisPrimalboundSol(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPisPrimalboundSol$address() {
        return SCIPisPrimalboundSol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPisPrimalboundSol(SCIP *scip)
     * }
     */
    public static int SCIPisPrimalboundSol(MemorySegment scip) {
        var mh$ = SCIPisPrimalboundSol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPisPrimalboundSol", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetGap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetGap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetGap(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetGap$descriptor() {
        return SCIPgetGap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetGap(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetGap$handle() {
        return SCIPgetGap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetGap(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetGap$address() {
        return SCIPgetGap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetGap(SCIP *scip)
     * }
     */
    public static double SCIPgetGap(MemorySegment scip) {
        var mh$ = SCIPgetGap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetGap", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransGap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransGap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTransGap(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTransGap$descriptor() {
        return SCIPgetTransGap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTransGap(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTransGap$handle() {
        return SCIPgetTransGap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTransGap(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTransGap$address() {
        return SCIPgetTransGap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTransGap(SCIP *scip)
     * }
     */
    public static double SCIPgetTransGap(MemorySegment scip) {
        var mh$ = SCIPgetTransGap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransGap", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSolsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSolsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNSolsFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNSolsFound$descriptor() {
        return SCIPgetNSolsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNSolsFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNSolsFound$handle() {
        return SCIPgetNSolsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNSolsFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNSolsFound$address() {
        return SCIPgetNSolsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNSolsFound(SCIP *scip)
     * }
     */
    public static long SCIPgetNSolsFound(MemorySegment scip) {
        var mh$ = SCIPgetNSolsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSolsFound", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLimSolsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLimSolsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNLimSolsFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLimSolsFound$descriptor() {
        return SCIPgetNLimSolsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNLimSolsFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLimSolsFound$handle() {
        return SCIPgetNLimSolsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNLimSolsFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLimSolsFound$address() {
        return SCIPgetNLimSolsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNLimSolsFound(SCIP *scip)
     * }
     */
    public static long SCIPgetNLimSolsFound(MemorySegment scip) {
        var mh$ = SCIPgetNLimSolsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLimSolsFound", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNBestSolsFound {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_LONG_LONG,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNBestSolsFound");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long SCIPgetNBestSolsFound(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNBestSolsFound$descriptor() {
        return SCIPgetNBestSolsFound.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long SCIPgetNBestSolsFound(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNBestSolsFound$handle() {
        return SCIPgetNBestSolsFound.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long SCIPgetNBestSolsFound(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNBestSolsFound$address() {
        return SCIPgetNBestSolsFound.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long SCIPgetNBestSolsFound(SCIP *scip)
     * }
     */
    public static long SCIPgetNBestSolsFound(MemorySegment scip) {
        var mh$ = SCIPgetNBestSolsFound.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNBestSolsFound", scip);
            }
            return (long)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocost(SCIP *scip, double solvaldelta)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocost$descriptor() {
        return SCIPgetAvgPseudocost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocost(SCIP *scip, double solvaldelta)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocost$handle() {
        return SCIPgetAvgPseudocost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocost(SCIP *scip, double solvaldelta)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocost$address() {
        return SCIPgetAvgPseudocost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocost(SCIP *scip, double solvaldelta)
     * }
     */
    public static double SCIPgetAvgPseudocost(MemorySegment scip, double solvaldelta) {
        var mh$ = SCIPgetAvgPseudocost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocost", scip, solvaldelta);
            }
            return (double)mh$.invokeExact(scip, solvaldelta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocostCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocostCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCurrentRun(SCIP *scip, double solvaldelta)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocostCurrentRun$descriptor() {
        return SCIPgetAvgPseudocostCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCurrentRun(SCIP *scip, double solvaldelta)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocostCurrentRun$handle() {
        return SCIPgetAvgPseudocostCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCurrentRun(SCIP *scip, double solvaldelta)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocostCurrentRun$address() {
        return SCIPgetAvgPseudocostCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCurrentRun(SCIP *scip, double solvaldelta)
     * }
     */
    public static double SCIPgetAvgPseudocostCurrentRun(MemorySegment scip, double solvaldelta) {
        var mh$ = SCIPgetAvgPseudocostCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocostCurrentRun", scip, solvaldelta);
            }
            return (double)mh$.invokeExact(scip, solvaldelta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocostCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocostCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocostCount$descriptor() {
        return SCIPgetAvgPseudocostCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocostCount$handle() {
        return SCIPgetAvgPseudocostCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocostCount$address() {
        return SCIPgetAvgPseudocostCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgPseudocostCount(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgPseudocostCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocostCount", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocostCountCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocostCountCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCountCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocostCountCurrentRun$descriptor() {
        return SCIPgetAvgPseudocostCountCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCountCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocostCountCurrentRun$handle() {
        return SCIPgetAvgPseudocostCountCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCountCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocostCountCurrentRun$address() {
        return SCIPgetAvgPseudocostCountCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostCountCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgPseudocostCountCurrentRun(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgPseudocostCountCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocostCountCurrentRun", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPseudocostCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPseudocostCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static FunctionDescriptor SCIPgetPseudocostCount$descriptor() {
        return SCIPgetPseudocostCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static MethodHandle SCIPgetPseudocostCount$handle() {
        return SCIPgetPseudocostCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static MemorySegment SCIPgetPseudocostCount$address() {
        return SCIPgetPseudocostCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPseudocostCount(SCIP *scip, SCIP_BRANCHDIR dir, unsigned int onlycurrentrun)
     * }
     */
    public static double SCIPgetPseudocostCount(MemorySegment scip, int dir, int onlycurrentrun) {
        var mh$ = SCIPgetPseudocostCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPseudocostCount", scip, dir, onlycurrentrun);
            }
            return (double)mh$.invokeExact(scip, dir, onlycurrentrun);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocostScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocostScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocostScore$descriptor() {
        return SCIPgetAvgPseudocostScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocostScore$handle() {
        return SCIPgetAvgPseudocostScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocostScore$address() {
        return SCIPgetAvgPseudocostScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScore(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgPseudocostScore(MemorySegment scip) {
        var mh$ = SCIPgetAvgPseudocostScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocostScore", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPseudocostVariance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPseudocostVariance");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostVariance(SCIP *scip, SCIP_BRANCHDIR branchdir, unsigned int onlycurrentrun)
     * }
     */
    public static FunctionDescriptor SCIPgetPseudocostVariance$descriptor() {
        return SCIPgetPseudocostVariance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostVariance(SCIP *scip, SCIP_BRANCHDIR branchdir, unsigned int onlycurrentrun)
     * }
     */
    public static MethodHandle SCIPgetPseudocostVariance$handle() {
        return SCIPgetPseudocostVariance.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPseudocostVariance(SCIP *scip, SCIP_BRANCHDIR branchdir, unsigned int onlycurrentrun)
     * }
     */
    public static MemorySegment SCIPgetPseudocostVariance$address() {
        return SCIPgetPseudocostVariance.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPseudocostVariance(SCIP *scip, SCIP_BRANCHDIR branchdir, unsigned int onlycurrentrun)
     * }
     */
    public static double SCIPgetPseudocostVariance(MemorySegment scip, int branchdir, int onlycurrentrun) {
        var mh$ = SCIPgetPseudocostVariance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPseudocostVariance", scip, branchdir, onlycurrentrun);
            }
            return (double)mh$.invokeExact(scip, branchdir, onlycurrentrun);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgPseudocostScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgPseudocostScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScoreCurrentRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgPseudocostScoreCurrentRun$descriptor() {
        return SCIPgetAvgPseudocostScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgPseudocostScoreCurrentRun$handle() {
        return SCIPgetAvgPseudocostScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgPseudocostScoreCurrentRun$address() {
        return SCIPgetAvgPseudocostScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgPseudocostScoreCurrentRun(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgPseudocostScoreCurrentRun(MemorySegment scip) {
        var mh$ = SCIPgetAvgPseudocostScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgPseudocostScoreCurrentRun", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgConflictScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgConflictScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgConflictScore$descriptor() {
        return SCIPgetAvgConflictScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgConflictScore$handle() {
        return SCIPgetAvgConflictScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgConflictScore$address() {
        return SCIPgetAvgConflictScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScore(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgConflictScore(MemorySegment scip) {
        var mh$ = SCIPgetAvgConflictScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgConflictScore", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgConflictScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgConflictScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScoreCurrentRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgConflictScoreCurrentRun$descriptor() {
        return SCIPgetAvgConflictScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgConflictScoreCurrentRun$handle() {
        return SCIPgetAvgConflictScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgConflictScoreCurrentRun$address() {
        return SCIPgetAvgConflictScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgConflictScoreCurrentRun(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgConflictScoreCurrentRun(MemorySegment scip) {
        var mh$ = SCIPgetAvgConflictScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgConflictScoreCurrentRun", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgConflictlengthScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgConflictlengthScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgConflictlengthScore$descriptor() {
        return SCIPgetAvgConflictlengthScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgConflictlengthScore$handle() {
        return SCIPgetAvgConflictlengthScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgConflictlengthScore$address() {
        return SCIPgetAvgConflictlengthScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScore(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgConflictlengthScore(MemorySegment scip) {
        var mh$ = SCIPgetAvgConflictlengthScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgConflictlengthScore", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgConflictlengthScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgConflictlengthScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScoreCurrentRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgConflictlengthScoreCurrentRun$descriptor() {
        return SCIPgetAvgConflictlengthScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgConflictlengthScoreCurrentRun$handle() {
        return SCIPgetAvgConflictlengthScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgConflictlengthScoreCurrentRun$address() {
        return SCIPgetAvgConflictlengthScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgConflictlengthScoreCurrentRun(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgConflictlengthScoreCurrentRun(MemorySegment scip) {
        var mh$ = SCIPgetAvgConflictlengthScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgConflictlengthScoreCurrentRun", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgInferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgInferences");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferences(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgInferences$descriptor() {
        return SCIPgetAvgInferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferences(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgInferences$handle() {
        return SCIPgetAvgInferences.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferences(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgInferences$address() {
        return SCIPgetAvgInferences.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgInferences(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgInferences(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgInferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgInferences", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgInferencesCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgInferencesCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferencesCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgInferencesCurrentRun$descriptor() {
        return SCIPgetAvgInferencesCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferencesCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgInferencesCurrentRun$handle() {
        return SCIPgetAvgInferencesCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferencesCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgInferencesCurrentRun$address() {
        return SCIPgetAvgInferencesCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgInferencesCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgInferencesCurrentRun(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgInferencesCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgInferencesCurrentRun", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgInferenceScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgInferenceScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgInferenceScore$descriptor() {
        return SCIPgetAvgInferenceScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgInferenceScore$handle() {
        return SCIPgetAvgInferenceScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgInferenceScore$address() {
        return SCIPgetAvgInferenceScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScore(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgInferenceScore(MemorySegment scip) {
        var mh$ = SCIPgetAvgInferenceScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgInferenceScore", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgInferenceScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgInferenceScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScoreCurrentRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgInferenceScoreCurrentRun$descriptor() {
        return SCIPgetAvgInferenceScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgInferenceScoreCurrentRun$handle() {
        return SCIPgetAvgInferenceScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgInferenceScoreCurrentRun$address() {
        return SCIPgetAvgInferenceScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgInferenceScoreCurrentRun(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgInferenceScoreCurrentRun(MemorySegment scip) {
        var mh$ = SCIPgetAvgInferenceScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgInferenceScoreCurrentRun", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgCutoffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgCutoffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffs(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgCutoffs$descriptor() {
        return SCIPgetAvgCutoffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffs(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgCutoffs$handle() {
        return SCIPgetAvgCutoffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffs(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgCutoffs$address() {
        return SCIPgetAvgCutoffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffs(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgCutoffs(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgCutoffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgCutoffs", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgCutoffsCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgCutoffsCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffsCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgCutoffsCurrentRun$descriptor() {
        return SCIPgetAvgCutoffsCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffsCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MethodHandle SCIPgetAvgCutoffsCurrentRun$handle() {
        return SCIPgetAvgCutoffsCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffsCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static MemorySegment SCIPgetAvgCutoffsCurrentRun$address() {
        return SCIPgetAvgCutoffsCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffsCurrentRun(SCIP *scip, SCIP_BRANCHDIR dir)
     * }
     */
    public static double SCIPgetAvgCutoffsCurrentRun(MemorySegment scip, int dir) {
        var mh$ = SCIPgetAvgCutoffsCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgCutoffsCurrentRun", scip, dir);
            }
            return (double)mh$.invokeExact(scip, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgCutoffScore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgCutoffScore");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScore(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgCutoffScore$descriptor() {
        return SCIPgetAvgCutoffScore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScore(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgCutoffScore$handle() {
        return SCIPgetAvgCutoffScore.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScore(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgCutoffScore$address() {
        return SCIPgetAvgCutoffScore.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScore(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgCutoffScore(MemorySegment scip) {
        var mh$ = SCIPgetAvgCutoffScore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgCutoffScore", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgCutoffScoreCurrentRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgCutoffScoreCurrentRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScoreCurrentRun(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgCutoffScoreCurrentRun$descriptor() {
        return SCIPgetAvgCutoffScoreCurrentRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgCutoffScoreCurrentRun$handle() {
        return SCIPgetAvgCutoffScoreCurrentRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScoreCurrentRun(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgCutoffScoreCurrentRun$address() {
        return SCIPgetAvgCutoffScoreCurrentRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgCutoffScoreCurrentRun(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgCutoffScoreCurrentRun(MemorySegment scip) {
        var mh$ = SCIPgetAvgCutoffScoreCurrentRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgCutoffScoreCurrentRun", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetAvgGMIeff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetAvgGMIeff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetAvgGMIeff(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetAvgGMIeff$descriptor() {
        return SCIPgetAvgGMIeff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetAvgGMIeff(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetAvgGMIeff$handle() {
        return SCIPgetAvgGMIeff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetAvgGMIeff(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetAvgGMIeff$address() {
        return SCIPgetAvgGMIeff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetAvgGMIeff(SCIP *scip)
     * }
     */
    public static double SCIPgetAvgGMIeff(MemorySegment scip) {
        var mh$ = SCIPgetAvgGMIeff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetAvgGMIeff", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincAvgGMIeff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincAvgGMIeff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPincAvgGMIeff(SCIP *scip, double gmieff)
     * }
     */
    public static FunctionDescriptor SCIPincAvgGMIeff$descriptor() {
        return SCIPincAvgGMIeff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPincAvgGMIeff(SCIP *scip, double gmieff)
     * }
     */
    public static MethodHandle SCIPincAvgGMIeff$handle() {
        return SCIPincAvgGMIeff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPincAvgGMIeff(SCIP *scip, double gmieff)
     * }
     */
    public static MemorySegment SCIPincAvgGMIeff$address() {
        return SCIPincAvgGMIeff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPincAvgGMIeff(SCIP *scip, double gmieff)
     * }
     */
    public static void SCIPincAvgGMIeff(MemorySegment scip, double gmieff) {
        var mh$ = SCIPincAvgGMIeff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincAvgGMIeff", scip, gmieff);
            }
            mh$.invokeExact(scip, gmieff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDeterministicTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDeterministicTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetDeterministicTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDeterministicTime$descriptor() {
        return SCIPgetDeterministicTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetDeterministicTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDeterministicTime$handle() {
        return SCIPgetDeterministicTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetDeterministicTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDeterministicTime$address() {
        return SCIPgetDeterministicTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetDeterministicTime(SCIP *scip)
     * }
     */
    public static double SCIPgetDeterministicTime(MemorySegment scip) {
        var mh$ = SCIPgetDeterministicTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDeterministicTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintOrigProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintOrigProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintOrigProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static FunctionDescriptor SCIPprintOrigProblem$descriptor() {
        return SCIPprintOrigProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintOrigProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static MethodHandle SCIPprintOrigProblem$handle() {
        return SCIPprintOrigProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintOrigProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static MemorySegment SCIPprintOrigProblem$address() {
        return SCIPprintOrigProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintOrigProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static int SCIPprintOrigProblem(MemorySegment scip, MemorySegment file, MemorySegment extension, int genericnames) {
        var mh$ = SCIPprintOrigProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintOrigProblem", scip, file, extension, genericnames);
            }
            return (int)mh$.invokeExact(scip, file, extension, genericnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintTransProblem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintTransProblem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static FunctionDescriptor SCIPprintTransProblem$descriptor() {
        return SCIPprintTransProblem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static MethodHandle SCIPprintTransProblem$handle() {
        return SCIPprintTransProblem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static MemorySegment SCIPprintTransProblem$address() {
        return SCIPprintTransProblem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintTransProblem(SCIP *scip, FILE *file, const char *extension, unsigned int genericnames)
     * }
     */
    public static int SCIPprintTransProblem(MemorySegment scip, MemorySegment file, MemorySegment extension, int genericnames) {
        var mh$ = SCIPprintTransProblem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintTransProblem", scip, file, extension, genericnames);
            }
            return (int)mh$.invokeExact(scip, file, extension, genericnames);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintStatusStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintStatusStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintStatusStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintStatusStatistics$descriptor() {
        return SCIPprintStatusStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintStatusStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintStatusStatistics$handle() {
        return SCIPprintStatusStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintStatusStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintStatusStatistics$address() {
        return SCIPprintStatusStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintStatusStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintStatusStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintStatusStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintStatusStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintTimingStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintTimingStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintTimingStatistics$descriptor() {
        return SCIPprintTimingStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintTimingStatistics$handle() {
        return SCIPprintTimingStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintTimingStatistics$address() {
        return SCIPprintTimingStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintTimingStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintTimingStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintTimingStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintOrigProblemStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintOrigProblemStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintOrigProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintOrigProblemStatistics$descriptor() {
        return SCIPprintOrigProblemStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintOrigProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintOrigProblemStatistics$handle() {
        return SCIPprintOrigProblemStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintOrigProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintOrigProblemStatistics$address() {
        return SCIPprintOrigProblemStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintOrigProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintOrigProblemStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintOrigProblemStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintOrigProblemStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintTransProblemStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintTransProblemStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintTransProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintTransProblemStatistics$descriptor() {
        return SCIPprintTransProblemStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintTransProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintTransProblemStatistics$handle() {
        return SCIPprintTransProblemStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintTransProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintTransProblemStatistics$address() {
        return SCIPprintTransProblemStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintTransProblemStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintTransProblemStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintTransProblemStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintTransProblemStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintPresolverStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintPresolverStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintPresolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintPresolverStatistics$descriptor() {
        return SCIPprintPresolverStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintPresolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintPresolverStatistics$handle() {
        return SCIPprintPresolverStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintPresolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintPresolverStatistics$address() {
        return SCIPprintPresolverStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintPresolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintPresolverStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintPresolverStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintPresolverStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintConstraintStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintConstraintStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintConstraintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintConstraintStatistics$descriptor() {
        return SCIPprintConstraintStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintConstraintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintConstraintStatistics$handle() {
        return SCIPprintConstraintStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintConstraintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintConstraintStatistics$address() {
        return SCIPprintConstraintStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintConstraintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintConstraintStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintConstraintStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintConstraintStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintConstraintTimingStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintConstraintTimingStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintConstraintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintConstraintTimingStatistics$descriptor() {
        return SCIPprintConstraintTimingStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintConstraintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintConstraintTimingStatistics$handle() {
        return SCIPprintConstraintTimingStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintConstraintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintConstraintTimingStatistics$address() {
        return SCIPprintConstraintTimingStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintConstraintTimingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintConstraintTimingStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintConstraintTimingStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintConstraintTimingStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintPropagatorStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintPropagatorStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintPropagatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintPropagatorStatistics$descriptor() {
        return SCIPprintPropagatorStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintPropagatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintPropagatorStatistics$handle() {
        return SCIPprintPropagatorStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintPropagatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintPropagatorStatistics$address() {
        return SCIPprintPropagatorStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintPropagatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintPropagatorStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintPropagatorStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintPropagatorStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintConflictStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintConflictStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintConflictStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintConflictStatistics$descriptor() {
        return SCIPprintConflictStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintConflictStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintConflictStatistics$handle() {
        return SCIPprintConflictStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintConflictStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintConflictStatistics$address() {
        return SCIPprintConflictStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintConflictStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintConflictStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintConflictStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintConflictStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintSeparatorStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintSeparatorStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintSeparatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintSeparatorStatistics$descriptor() {
        return SCIPprintSeparatorStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintSeparatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintSeparatorStatistics$handle() {
        return SCIPprintSeparatorStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintSeparatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintSeparatorStatistics$address() {
        return SCIPprintSeparatorStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintSeparatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintSeparatorStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintSeparatorStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintSeparatorStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintCutselectorStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintCutselectorStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintCutselectorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintCutselectorStatistics$descriptor() {
        return SCIPprintCutselectorStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintCutselectorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintCutselectorStatistics$handle() {
        return SCIPprintCutselectorStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintCutselectorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintCutselectorStatistics$address() {
        return SCIPprintCutselectorStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintCutselectorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintCutselectorStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintCutselectorStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintCutselectorStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintPricerStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintPricerStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintPricerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintPricerStatistics$descriptor() {
        return SCIPprintPricerStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintPricerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintPricerStatistics$handle() {
        return SCIPprintPricerStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintPricerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintPricerStatistics$address() {
        return SCIPprintPricerStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintPricerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintPricerStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintPricerStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintPricerStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBranchruleStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBranchruleStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintBranchruleStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintBranchruleStatistics$descriptor() {
        return SCIPprintBranchruleStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintBranchruleStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintBranchruleStatistics$handle() {
        return SCIPprintBranchruleStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintBranchruleStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintBranchruleStatistics$address() {
        return SCIPprintBranchruleStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintBranchruleStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintBranchruleStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintBranchruleStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBranchruleStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintHeuristicStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintHeuristicStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintHeuristicStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintHeuristicStatistics$descriptor() {
        return SCIPprintHeuristicStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintHeuristicStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintHeuristicStatistics$handle() {
        return SCIPprintHeuristicStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintHeuristicStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintHeuristicStatistics$address() {
        return SCIPprintHeuristicStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintHeuristicStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintHeuristicStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintHeuristicStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintHeuristicStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintCompressionStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintCompressionStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintCompressionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintCompressionStatistics$descriptor() {
        return SCIPprintCompressionStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintCompressionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintCompressionStatistics$handle() {
        return SCIPprintCompressionStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintCompressionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintCompressionStatistics$address() {
        return SCIPprintCompressionStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintCompressionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintCompressionStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintCompressionStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintCompressionStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintLPStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintLPStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintLPStatistics$descriptor() {
        return SCIPprintLPStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintLPStatistics$handle() {
        return SCIPprintLPStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintLPStatistics$address() {
        return SCIPprintLPStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintLPStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintLPStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintLPStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintNLPStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintNLPStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintNLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintNLPStatistics$descriptor() {
        return SCIPprintNLPStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintNLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintNLPStatistics$handle() {
        return SCIPprintNLPStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintNLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintNLPStatistics$address() {
        return SCIPprintNLPStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintNLPStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintNLPStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintNLPStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintNLPStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintRelaxatorStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintRelaxatorStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintRelaxatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintRelaxatorStatistics$descriptor() {
        return SCIPprintRelaxatorStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintRelaxatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintRelaxatorStatistics$handle() {
        return SCIPprintRelaxatorStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintRelaxatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintRelaxatorStatistics$address() {
        return SCIPprintRelaxatorStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintRelaxatorStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintRelaxatorStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintRelaxatorStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintRelaxatorStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintTreeStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintTreeStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintTreeStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintTreeStatistics$descriptor() {
        return SCIPprintTreeStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintTreeStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintTreeStatistics$handle() {
        return SCIPprintTreeStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintTreeStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintTreeStatistics$address() {
        return SCIPprintTreeStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintTreeStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintTreeStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintTreeStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintTreeStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintRootStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintRootStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintRootStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintRootStatistics$descriptor() {
        return SCIPprintRootStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintRootStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintRootStatistics$handle() {
        return SCIPprintRootStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintRootStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintRootStatistics$address() {
        return SCIPprintRootStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintRootStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintRootStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintRootStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintRootStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintSolutionStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintSolutionStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintSolutionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintSolutionStatistics$descriptor() {
        return SCIPprintSolutionStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintSolutionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintSolutionStatistics$handle() {
        return SCIPprintSolutionStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintSolutionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintSolutionStatistics$address() {
        return SCIPprintSolutionStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintSolutionStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintSolutionStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintSolutionStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintSolutionStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintConcsolverStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintConcsolverStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintConcsolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintConcsolverStatistics$descriptor() {
        return SCIPprintConcsolverStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintConcsolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintConcsolverStatistics$handle() {
        return SCIPprintConcsolverStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintConcsolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintConcsolverStatistics$address() {
        return SCIPprintConcsolverStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintConcsolverStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintConcsolverStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintConcsolverStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintConcsolverStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBendersStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBendersStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintBendersStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintBendersStatistics$descriptor() {
        return SCIPprintBendersStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintBendersStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintBendersStatistics$handle() {
        return SCIPprintBendersStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintBendersStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintBendersStatistics$address() {
        return SCIPprintBendersStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintBendersStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintBendersStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintBendersStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBendersStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintExpressionHandlerStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintExpressionHandlerStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintExpressionHandlerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintExpressionHandlerStatistics$descriptor() {
        return SCIPprintExpressionHandlerStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintExpressionHandlerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintExpressionHandlerStatistics$handle() {
        return SCIPprintExpressionHandlerStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintExpressionHandlerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintExpressionHandlerStatistics$address() {
        return SCIPprintExpressionHandlerStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintExpressionHandlerStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintExpressionHandlerStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintExpressionHandlerStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintExpressionHandlerStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintNLPIStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintNLPIStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPprintNLPIStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintNLPIStatistics$descriptor() {
        return SCIPprintNLPIStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPprintNLPIStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintNLPIStatistics$handle() {
        return SCIPprintNLPIStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPprintNLPIStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintNLPIStatistics$address() {
        return SCIPprintNLPIStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPprintNLPIStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static void SCIPprintNLPIStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintNLPIStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintNLPIStatistics", scip, file);
            }
            mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintStatistics$descriptor() {
        return SCIPprintStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintStatistics$handle() {
        return SCIPprintStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintStatistics$address() {
        return SCIPprintStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintStatistics", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintReoptStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintReoptStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintReoptStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintReoptStatistics$descriptor() {
        return SCIPprintReoptStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintReoptStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintReoptStatistics$handle() {
        return SCIPprintReoptStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintReoptStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintReoptStatistics$address() {
        return SCIPprintReoptStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintReoptStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintReoptStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintReoptStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintReoptStatistics", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintBranchingStatistics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintBranchingStatistics");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBranchingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintBranchingStatistics$descriptor() {
        return SCIPprintBranchingStatistics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBranchingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintBranchingStatistics$handle() {
        return SCIPprintBranchingStatistics.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBranchingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintBranchingStatistics$address() {
        return SCIPprintBranchingStatistics.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintBranchingStatistics(SCIP *scip, FILE *file)
     * }
     */
    public static int SCIPprintBranchingStatistics(MemorySegment scip, MemorySegment file) {
        var mh$ = SCIPprintBranchingStatistics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintBranchingStatistics", scip, file);
            }
            return (int)mh$.invokeExact(scip, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintDisplayLine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintDisplayLine");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDisplayLine(SCIP *scip, FILE *file, SCIP_VERBLEVEL verblevel, unsigned int endline)
     * }
     */
    public static FunctionDescriptor SCIPprintDisplayLine$descriptor() {
        return SCIPprintDisplayLine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDisplayLine(SCIP *scip, FILE *file, SCIP_VERBLEVEL verblevel, unsigned int endline)
     * }
     */
    public static MethodHandle SCIPprintDisplayLine$handle() {
        return SCIPprintDisplayLine.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDisplayLine(SCIP *scip, FILE *file, SCIP_VERBLEVEL verblevel, unsigned int endline)
     * }
     */
    public static MemorySegment SCIPprintDisplayLine$address() {
        return SCIPprintDisplayLine.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintDisplayLine(SCIP *scip, FILE *file, SCIP_VERBLEVEL verblevel, unsigned int endline)
     * }
     */
    public static int SCIPprintDisplayLine(MemorySegment scip, MemorySegment file, int verblevel, int endline) {
        var mh$ = SCIPprintDisplayLine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintDisplayLine", scip, file, verblevel, endline);
            }
            return (int)mh$.invokeExact(scip, file, verblevel, endline);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNImplications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNImplications");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNImplications(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNImplications$descriptor() {
        return SCIPgetNImplications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNImplications(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNImplications$handle() {
        return SCIPgetNImplications.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNImplications(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNImplications$address() {
        return SCIPgetNImplications.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNImplications(SCIP *scip)
     * }
     */
    public static int SCIPgetNImplications(MemorySegment scip) {
        var mh$ = SCIPgetNImplications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNImplications", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteImplicationConflictGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteImplicationConflictGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteImplicationConflictGraph(SCIP *scip, const char *filename)
     * }
     */
    public static FunctionDescriptor SCIPwriteImplicationConflictGraph$descriptor() {
        return SCIPwriteImplicationConflictGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteImplicationConflictGraph(SCIP *scip, const char *filename)
     * }
     */
    public static MethodHandle SCIPwriteImplicationConflictGraph$handle() {
        return SCIPwriteImplicationConflictGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteImplicationConflictGraph(SCIP *scip, const char *filename)
     * }
     */
    public static MemorySegment SCIPwriteImplicationConflictGraph$address() {
        return SCIPwriteImplicationConflictGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteImplicationConflictGraph(SCIP *scip, const char *filename)
     * }
     */
    public static int SCIPwriteImplicationConflictGraph(MemorySegment scip, MemorySegment filename) {
        var mh$ = SCIPwriteImplicationConflictGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteImplicationConflictGraph", scip, filename);
            }
            return (int)mh$.invokeExact(scip, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstoreSolutionGap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstoreSolutionGap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPstoreSolutionGap(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstoreSolutionGap$descriptor() {
        return SCIPstoreSolutionGap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPstoreSolutionGap(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstoreSolutionGap$handle() {
        return SCIPstoreSolutionGap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPstoreSolutionGap(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstoreSolutionGap$address() {
        return SCIPstoreSolutionGap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPstoreSolutionGap(SCIP *scip)
     * }
     */
    public static void SCIPstoreSolutionGap(MemorySegment scip) {
        var mh$ = SCIPstoreSolutionGap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstoreSolutionGap", scip);
            }
            mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPrimalDualIntegral {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPrimalDualIntegral");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPrimalDualIntegral(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPrimalDualIntegral$descriptor() {
        return SCIPgetPrimalDualIntegral.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPrimalDualIntegral(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPrimalDualIntegral$handle() {
        return SCIPgetPrimalDualIntegral.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPrimalDualIntegral(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrimalDualIntegral$address() {
        return SCIPgetPrimalDualIntegral.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPrimalDualIntegral(SCIP *scip)
     * }
     */
    public static double SCIPgetPrimalDualIntegral(MemorySegment scip) {
        var mh$ = SCIPgetPrimalDualIntegral.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPrimalDualIntegral", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPincludeTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPincludeTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTable(SCIP *scip, const char *name, const char *desc, unsigned int active, SCIP_RETCODE (*tablecopy)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tablefree)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableoutput)(SCIP *, SCIP_TABLE *, FILE *), SCIP_TABLEDATA *tabledata, int position, SCIP_STAGE earlieststage)
     * }
     */
    public static FunctionDescriptor SCIPincludeTable$descriptor() {
        return SCIPincludeTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTable(SCIP *scip, const char *name, const char *desc, unsigned int active, SCIP_RETCODE (*tablecopy)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tablefree)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableoutput)(SCIP *, SCIP_TABLE *, FILE *), SCIP_TABLEDATA *tabledata, int position, SCIP_STAGE earlieststage)
     * }
     */
    public static MethodHandle SCIPincludeTable$handle() {
        return SCIPincludeTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTable(SCIP *scip, const char *name, const char *desc, unsigned int active, SCIP_RETCODE (*tablecopy)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tablefree)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableoutput)(SCIP *, SCIP_TABLE *, FILE *), SCIP_TABLEDATA *tabledata, int position, SCIP_STAGE earlieststage)
     * }
     */
    public static MemorySegment SCIPincludeTable$address() {
        return SCIPincludeTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPincludeTable(SCIP *scip, const char *name, const char *desc, unsigned int active, SCIP_RETCODE (*tablecopy)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tablefree)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexit)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableinitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableexitsol)(SCIP *, SCIP_TABLE *), SCIP_RETCODE (*tableoutput)(SCIP *, SCIP_TABLE *, FILE *), SCIP_TABLEDATA *tabledata, int position, SCIP_STAGE earlieststage)
     * }
     */
    public static int SCIPincludeTable(MemorySegment scip, MemorySegment name, MemorySegment desc, int active, MemorySegment tablecopy, MemorySegment tablefree, MemorySegment tableinit, MemorySegment tableexit, MemorySegment tableinitsol, MemorySegment tableexitsol, MemorySegment tableoutput, MemorySegment tabledata, int position, int earlieststage) {
        var mh$ = SCIPincludeTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPincludeTable", scip, name, desc, active, tablecopy, tablefree, tableinit, tableexit, tableinitsol, tableexitsol, tableoutput, tabledata, position, earlieststage);
            }
            return (int)mh$.invokeExact(scip, name, desc, active, tablecopy, tablefree, tableinit, tableexit, tableinitsol, tableexitsol, tableoutput, tabledata, position, earlieststage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfindTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfindTable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_TABLE *SCIPfindTable(SCIP *scip, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPfindTable$descriptor() {
        return SCIPfindTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_TABLE *SCIPfindTable(SCIP *scip, const char *name)
     * }
     */
    public static MethodHandle SCIPfindTable$handle() {
        return SCIPfindTable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_TABLE *SCIPfindTable(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindTable$address() {
        return SCIPfindTable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_TABLE *SCIPfindTable(SCIP *scip, const char *name)
     * }
     */
    public static MemorySegment SCIPfindTable(MemorySegment scip, MemorySegment name) {
        var mh$ = SCIPfindTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfindTable", scip, name);
            }
            return (MemorySegment)mh$.invokeExact(scip, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_TABLE **SCIPgetTables(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTables$descriptor() {
        return SCIPgetTables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_TABLE **SCIPgetTables(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTables$handle() {
        return SCIPgetTables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_TABLE **SCIPgetTables(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTables$address() {
        return SCIPgetTables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_TABLE **SCIPgetTables(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTables(MemorySegment scip) {
        var mh$ = SCIPgetTables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTables", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNTables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNTables");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNTables(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNTables$descriptor() {
        return SCIPgetNTables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNTables(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNTables$handle() {
        return SCIPgetNTables.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNTables(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNTables$address() {
        return SCIPgetNTables.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNTables(SCIP *scip)
     * }
     */
    public static int SCIPgetNTables(MemorySegment scip) {
        var mh$ = SCIPgetNTables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNTables", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTimeOfDay {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTimeOfDay");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTimeOfDay(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTimeOfDay$descriptor() {
        return SCIPgetTimeOfDay.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTimeOfDay(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTimeOfDay$handle() {
        return SCIPgetTimeOfDay.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTimeOfDay(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTimeOfDay$address() {
        return SCIPgetTimeOfDay.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTimeOfDay(SCIP *scip)
     * }
     */
    public static double SCIPgetTimeOfDay(MemorySegment scip) {
        var mh$ = SCIPgetTimeOfDay.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTimeOfDay", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static FunctionDescriptor SCIPcreateClock$descriptor() {
        return SCIPcreateClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MethodHandle SCIPcreateClock$handle() {
        return SCIPcreateClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MemorySegment SCIPcreateClock$address() {
        return SCIPcreateClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static int SCIPcreateClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPcreateClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateCPUClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateCPUClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCPUClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static FunctionDescriptor SCIPcreateCPUClock$descriptor() {
        return SCIPcreateCPUClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCPUClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MethodHandle SCIPcreateCPUClock$handle() {
        return SCIPcreateCPUClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCPUClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MemorySegment SCIPcreateCPUClock$address() {
        return SCIPcreateCPUClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateCPUClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static int SCIPcreateCPUClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPcreateCPUClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateCPUClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateWallClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateWallClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWallClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static FunctionDescriptor SCIPcreateWallClock$descriptor() {
        return SCIPcreateWallClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWallClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MethodHandle SCIPcreateWallClock$handle() {
        return SCIPcreateWallClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWallClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MemorySegment SCIPcreateWallClock$address() {
        return SCIPcreateWallClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateWallClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static int SCIPcreateWallClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPcreateWallClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateWallClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static FunctionDescriptor SCIPfreeClock$descriptor() {
        return SCIPfreeClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MethodHandle SCIPfreeClock$handle() {
        return SCIPfreeClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static MemorySegment SCIPfreeClock$address() {
        return SCIPfreeClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPfreeClock(SCIP *scip, SCIP_CLOCK **clck)
     * }
     */
    public static int SCIPfreeClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPfreeClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPresetClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPresetClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static FunctionDescriptor SCIPresetClock$descriptor() {
        return SCIPresetClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MethodHandle SCIPresetClock$handle() {
        return SCIPresetClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MemorySegment SCIPresetClock$address() {
        return SCIPresetClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPresetClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static int SCIPresetClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPresetClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPresetClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static FunctionDescriptor SCIPstartClock$descriptor() {
        return SCIPstartClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MethodHandle SCIPstartClock$handle() {
        return SCIPstartClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MemorySegment SCIPstartClock$address() {
        return SCIPstartClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static int SCIPstartClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPstartClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstopClock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstopClock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static FunctionDescriptor SCIPstopClock$descriptor() {
        return SCIPstopClock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MethodHandle SCIPstopClock$handle() {
        return SCIPstopClock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MemorySegment SCIPstopClock$address() {
        return SCIPstopClock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopClock(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static int SCIPstopClock(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPstopClock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstopClock", scip, clck);
            }
            return (int)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetClockEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetClockEnabled");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetClockEnabled(SCIP_CLOCK *clck, unsigned int enable)
     * }
     */
    public static FunctionDescriptor SCIPsetClockEnabled$descriptor() {
        return SCIPsetClockEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetClockEnabled(SCIP_CLOCK *clck, unsigned int enable)
     * }
     */
    public static MethodHandle SCIPsetClockEnabled$handle() {
        return SCIPsetClockEnabled.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetClockEnabled(SCIP_CLOCK *clck, unsigned int enable)
     * }
     */
    public static MemorySegment SCIPsetClockEnabled$address() {
        return SCIPsetClockEnabled.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetClockEnabled(SCIP_CLOCK *clck, unsigned int enable)
     * }
     */
    public static void SCIPsetClockEnabled(MemorySegment clck, int enable) {
        var mh$ = SCIPsetClockEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetClockEnabled", clck, enable);
            }
            mh$.invokeExact(clck, enable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPenableOrDisableStatisticTiming {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPenableOrDisableStatisticTiming");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableOrDisableStatisticTiming(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPenableOrDisableStatisticTiming$descriptor() {
        return SCIPenableOrDisableStatisticTiming.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableOrDisableStatisticTiming(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPenableOrDisableStatisticTiming$handle() {
        return SCIPenableOrDisableStatisticTiming.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableOrDisableStatisticTiming(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPenableOrDisableStatisticTiming$address() {
        return SCIPenableOrDisableStatisticTiming.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPenableOrDisableStatisticTiming(SCIP *scip)
     * }
     */
    public static int SCIPenableOrDisableStatisticTiming(MemorySegment scip) {
        var mh$ = SCIPenableOrDisableStatisticTiming.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPenableOrDisableStatisticTiming", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstartSolvingTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstartSolvingTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartSolvingTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstartSolvingTime$descriptor() {
        return SCIPstartSolvingTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartSolvingTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstartSolvingTime$handle() {
        return SCIPstartSolvingTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartSolvingTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstartSolvingTime$address() {
        return SCIPstartSolvingTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstartSolvingTime(SCIP *scip)
     * }
     */
    public static int SCIPstartSolvingTime(MemorySegment scip) {
        var mh$ = SCIPstartSolvingTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstartSolvingTime", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPstopSolvingTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPstopSolvingTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopSolvingTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPstopSolvingTime$descriptor() {
        return SCIPstopSolvingTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopSolvingTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPstopSolvingTime$handle() {
        return SCIPstopSolvingTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopSolvingTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPstopSolvingTime$address() {
        return SCIPstopSolvingTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPstopSolvingTime(SCIP *scip)
     * }
     */
    public static int SCIPstopSolvingTime(MemorySegment scip) {
        var mh$ = SCIPstopSolvingTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPstopSolvingTime", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetClockTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetClockTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetClockTime(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static FunctionDescriptor SCIPgetClockTime$descriptor() {
        return SCIPgetClockTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetClockTime(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MethodHandle SCIPgetClockTime$handle() {
        return SCIPgetClockTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetClockTime(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static MemorySegment SCIPgetClockTime$address() {
        return SCIPgetClockTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetClockTime(SCIP *scip, SCIP_CLOCK *clck)
     * }
     */
    public static double SCIPgetClockTime(MemorySegment scip, MemorySegment clck) {
        var mh$ = SCIPgetClockTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetClockTime", scip, clck);
            }
            return (double)mh$.invokeExact(scip, clck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetClockTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetClockTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetClockTime(SCIP *scip, SCIP_CLOCK *clck, double sec)
     * }
     */
    public static FunctionDescriptor SCIPsetClockTime$descriptor() {
        return SCIPsetClockTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetClockTime(SCIP *scip, SCIP_CLOCK *clck, double sec)
     * }
     */
    public static MethodHandle SCIPsetClockTime$handle() {
        return SCIPsetClockTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetClockTime(SCIP *scip, SCIP_CLOCK *clck, double sec)
     * }
     */
    public static MemorySegment SCIPsetClockTime$address() {
        return SCIPsetClockTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPsetClockTime(SCIP *scip, SCIP_CLOCK *clck, double sec)
     * }
     */
    public static int SCIPsetClockTime(MemorySegment scip, MemorySegment clck, double sec) {
        var mh$ = SCIPsetClockTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetClockTime", scip, clck, sec);
            }
            return (int)mh$.invokeExact(scip, clck, sec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTotalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTotalTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetTotalTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetTotalTime$descriptor() {
        return SCIPgetTotalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetTotalTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetTotalTime$handle() {
        return SCIPgetTotalTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetTotalTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetTotalTime$address() {
        return SCIPgetTotalTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetTotalTime(SCIP *scip)
     * }
     */
    public static double SCIPgetTotalTime(MemorySegment scip) {
        var mh$ = SCIPgetTotalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTotalTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSolvingTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSolvingTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetSolvingTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetSolvingTime$descriptor() {
        return SCIPgetSolvingTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetSolvingTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetSolvingTime$handle() {
        return SCIPgetSolvingTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetSolvingTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetSolvingTime$address() {
        return SCIPgetSolvingTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetSolvingTime(SCIP *scip)
     * }
     */
    public static double SCIPgetSolvingTime(MemorySegment scip) {
        var mh$ = SCIPgetSolvingTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSolvingTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetReadingTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetReadingTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetReadingTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetReadingTime$descriptor() {
        return SCIPgetReadingTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetReadingTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetReadingTime$handle() {
        return SCIPgetReadingTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetReadingTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetReadingTime$address() {
        return SCIPgetReadingTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetReadingTime(SCIP *scip)
     * }
     */
    public static double SCIPgetReadingTime(MemorySegment scip) {
        var mh$ = SCIPgetReadingTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetReadingTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPresolvingTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPresolvingTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetPresolvingTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPresolvingTime$descriptor() {
        return SCIPgetPresolvingTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetPresolvingTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPresolvingTime$handle() {
        return SCIPgetPresolvingTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetPresolvingTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPresolvingTime$address() {
        return SCIPgetPresolvingTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetPresolvingTime(SCIP *scip)
     * }
     */
    public static double SCIPgetPresolvingTime(MemorySegment scip) {
        var mh$ = SCIPgetPresolvingTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPresolvingTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFirstLPTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFirstLPTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPTime(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFirstLPTime$descriptor() {
        return SCIPgetFirstLPTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPTime(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFirstLPTime$handle() {
        return SCIPgetFirstLPTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetFirstLPTime(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFirstLPTime$address() {
        return SCIPgetFirstLPTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetFirstLPTime(SCIP *scip)
     * }
     */
    public static double SCIPgetFirstLPTime(MemorySegment scip) {
        var mh$ = SCIPgetFirstLPTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFirstLPTime", scip);
            }
            return (double)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFocusNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFocusNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetFocusNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFocusNode$descriptor() {
        return SCIPgetFocusNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetFocusNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFocusNode$handle() {
        return SCIPgetFocusNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetFocusNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFocusNode$address() {
        return SCIPgetFocusNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetFocusNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFocusNode(MemorySegment scip) {
        var mh$ = SCIPgetFocusNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFocusNode", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCurrentNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCurrentNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetCurrentNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCurrentNode$descriptor() {
        return SCIPgetCurrentNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetCurrentNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCurrentNode$handle() {
        return SCIPgetCurrentNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetCurrentNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCurrentNode$address() {
        return SCIPgetCurrentNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetCurrentNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCurrentNode(MemorySegment scip) {
        var mh$ = SCIPgetCurrentNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCurrentNode", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetDepth$descriptor() {
        return SCIPgetDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetDepth$handle() {
        return SCIPgetDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetDepth$address() {
        return SCIPgetDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetDepth(MemorySegment scip) {
        var mh$ = SCIPgetDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetFocusDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetFocusDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetFocusDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetFocusDepth$descriptor() {
        return SCIPgetFocusDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetFocusDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetFocusDepth$handle() {
        return SCIPgetFocusDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetFocusDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetFocusDepth$address() {
        return SCIPgetFocusDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetFocusDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetFocusDepth(MemorySegment scip) {
        var mh$ = SCIPgetFocusDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetFocusDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPlungeDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPlungeDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetPlungeDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPlungeDepth$descriptor() {
        return SCIPgetPlungeDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetPlungeDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPlungeDepth$handle() {
        return SCIPgetPlungeDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetPlungeDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPlungeDepth$address() {
        return SCIPgetPlungeDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetPlungeDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetPlungeDepth(MemorySegment scip) {
        var mh$ = SCIPgetPlungeDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPlungeDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRootNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRootNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetRootNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetRootNode$descriptor() {
        return SCIPgetRootNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetRootNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetRootNode$handle() {
        return SCIPgetRootNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetRootNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRootNode$address() {
        return SCIPgetRootNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetRootNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRootNode(MemorySegment scip) {
        var mh$ = SCIPgetRootNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRootNode", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetEffectiveRootDepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetEffectiveRootDepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetEffectiveRootDepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetEffectiveRootDepth$descriptor() {
        return SCIPgetEffectiveRootDepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetEffectiveRootDepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetEffectiveRootDepth$handle() {
        return SCIPgetEffectiveRootDepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetEffectiveRootDepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetEffectiveRootDepth$address() {
        return SCIPgetEffectiveRootDepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetEffectiveRootDepth(SCIP *scip)
     * }
     */
    public static int SCIPgetEffectiveRootDepth(MemorySegment scip) {
        var mh$ = SCIPgetEffectiveRootDepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetEffectiveRootDepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPinRepropagation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPinRepropagation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPinRepropagation(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPinRepropagation$descriptor() {
        return SCIPinRepropagation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPinRepropagation(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPinRepropagation$handle() {
        return SCIPinRepropagation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPinRepropagation(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPinRepropagation$address() {
        return SCIPinRepropagation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPinRepropagation(SCIP *scip)
     * }
     */
    public static int SCIPinRepropagation(MemorySegment scip) {
        var mh$ = SCIPinRepropagation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPinRepropagation", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetChildren(SCIP *scip, SCIP_NODE ***children, int *nchildren)
     * }
     */
    public static FunctionDescriptor SCIPgetChildren$descriptor() {
        return SCIPgetChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetChildren(SCIP *scip, SCIP_NODE ***children, int *nchildren)
     * }
     */
    public static MethodHandle SCIPgetChildren$handle() {
        return SCIPgetChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetChildren(SCIP *scip, SCIP_NODE ***children, int *nchildren)
     * }
     */
    public static MemorySegment SCIPgetChildren$address() {
        return SCIPgetChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetChildren(SCIP *scip, SCIP_NODE ***children, int *nchildren)
     * }
     */
    public static int SCIPgetChildren(MemorySegment scip, MemorySegment children, MemorySegment nchildren) {
        var mh$ = SCIPgetChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetChildren", scip, children, nchildren);
            }
            return (int)mh$.invokeExact(scip, children, nchildren);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNChildren {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNChildren");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNChildren(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNChildren$descriptor() {
        return SCIPgetNChildren.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNChildren(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNChildren$handle() {
        return SCIPgetNChildren.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNChildren(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNChildren$address() {
        return SCIPgetNChildren.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNChildren(SCIP *scip)
     * }
     */
    public static int SCIPgetNChildren(MemorySegment scip) {
        var mh$ = SCIPgetNChildren.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNChildren", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetSiblings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetSiblings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSiblings(SCIP *scip, SCIP_NODE ***siblings, int *nsiblings)
     * }
     */
    public static FunctionDescriptor SCIPgetSiblings$descriptor() {
        return SCIPgetSiblings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSiblings(SCIP *scip, SCIP_NODE ***siblings, int *nsiblings)
     * }
     */
    public static MethodHandle SCIPgetSiblings$handle() {
        return SCIPgetSiblings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSiblings(SCIP *scip, SCIP_NODE ***siblings, int *nsiblings)
     * }
     */
    public static MemorySegment SCIPgetSiblings$address() {
        return SCIPgetSiblings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetSiblings(SCIP *scip, SCIP_NODE ***siblings, int *nsiblings)
     * }
     */
    public static int SCIPgetSiblings(MemorySegment scip, MemorySegment siblings, MemorySegment nsiblings) {
        var mh$ = SCIPgetSiblings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetSiblings", scip, siblings, nsiblings);
            }
            return (int)mh$.invokeExact(scip, siblings, nsiblings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNSiblings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNSiblings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNSiblings(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNSiblings$descriptor() {
        return SCIPgetNSiblings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNSiblings(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNSiblings$handle() {
        return SCIPgetNSiblings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNSiblings(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNSiblings$address() {
        return SCIPgetNSiblings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNSiblings(SCIP *scip)
     * }
     */
    public static int SCIPgetNSiblings(MemorySegment scip) {
        var mh$ = SCIPgetNSiblings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNSiblings", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLeaves(SCIP *scip, SCIP_NODE ***leaves, int *nleaves)
     * }
     */
    public static FunctionDescriptor SCIPgetLeaves$descriptor() {
        return SCIPgetLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLeaves(SCIP *scip, SCIP_NODE ***leaves, int *nleaves)
     * }
     */
    public static MethodHandle SCIPgetLeaves$handle() {
        return SCIPgetLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLeaves(SCIP *scip, SCIP_NODE ***leaves, int *nleaves)
     * }
     */
    public static MemorySegment SCIPgetLeaves$address() {
        return SCIPgetLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetLeaves(SCIP *scip, SCIP_NODE ***leaves, int *nleaves)
     * }
     */
    public static int SCIPgetLeaves(MemorySegment scip, MemorySegment leaves, MemorySegment nleaves) {
        var mh$ = SCIPgetLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetLeaves", scip, leaves, nleaves);
            }
            return (int)mh$.invokeExact(scip, leaves, nleaves);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNLeaves {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNLeaves");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNLeaves(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNLeaves$descriptor() {
        return SCIPgetNLeaves.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNLeaves(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNLeaves$handle() {
        return SCIPgetNLeaves.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNLeaves(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNLeaves$address() {
        return SCIPgetNLeaves.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNLeaves(SCIP *scip)
     * }
     */
    public static int SCIPgetNLeaves(MemorySegment scip) {
        var mh$ = SCIPgetNLeaves.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNLeaves", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNNodesLeft {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNNodesLeft");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetNNodesLeft(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetNNodesLeft$descriptor() {
        return SCIPgetNNodesLeft.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetNNodesLeft(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetNNodesLeft$handle() {
        return SCIPgetNNodesLeft.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetNNodesLeft(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetNNodesLeft$address() {
        return SCIPgetNNodesLeft.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetNNodesLeft(SCIP *scip)
     * }
     */
    public static int SCIPgetNNodesLeft(MemorySegment scip) {
        var mh$ = SCIPgetNNodesLeft.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNNodesLeft", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPrioChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPrioChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioChild(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPrioChild$descriptor() {
        return SCIPgetPrioChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioChild(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPrioChild$handle() {
        return SCIPgetPrioChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioChild(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrioChild$address() {
        return SCIPgetPrioChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioChild(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrioChild(MemorySegment scip) {
        var mh$ = SCIPgetPrioChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPrioChild", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetPrioSibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetPrioSibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioSibling(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetPrioSibling$descriptor() {
        return SCIPgetPrioSibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioSibling(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetPrioSibling$handle() {
        return SCIPgetPrioSibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioSibling(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrioSibling$address() {
        return SCIPgetPrioSibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetPrioSibling(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetPrioSibling(MemorySegment scip) {
        var mh$ = SCIPgetPrioSibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetPrioSibling", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestChild");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestChild(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestChild$descriptor() {
        return SCIPgetBestChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestChild(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestChild$handle() {
        return SCIPgetBestChild.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestChild(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestChild$address() {
        return SCIPgetBestChild.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestChild(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestChild(MemorySegment scip) {
        var mh$ = SCIPgetBestChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestChild", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestSibling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestSibling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestSibling(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestSibling$descriptor() {
        return SCIPgetBestSibling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestSibling(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestSibling$handle() {
        return SCIPgetBestSibling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestSibling(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestSibling$address() {
        return SCIPgetBestSibling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestSibling(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestSibling(MemorySegment scip) {
        var mh$ = SCIPgetBestSibling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestSibling", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestLeaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestLeaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestLeaf(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestLeaf$descriptor() {
        return SCIPgetBestLeaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestLeaf(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestLeaf$handle() {
        return SCIPgetBestLeaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestLeaf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestLeaf$address() {
        return SCIPgetBestLeaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestLeaf(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestLeaf(MemorySegment scip) {
        var mh$ = SCIPgetBestLeaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestLeaf", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestNode$descriptor() {
        return SCIPgetBestNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestNode$handle() {
        return SCIPgetBestNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestNode$address() {
        return SCIPgetBestNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestNode(MemorySegment scip) {
        var mh$ = SCIPgetBestNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestNode", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBestboundNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBestboundNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestboundNode(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetBestboundNode$descriptor() {
        return SCIPgetBestboundNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestboundNode(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetBestboundNode$handle() {
        return SCIPgetBestboundNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestboundNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestboundNode$address() {
        return SCIPgetBestboundNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_NODE *SCIPgetBestboundNode(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetBestboundNode(MemorySegment scip) {
        var mh$ = SCIPgetBestboundNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBestboundNode", scip);
            }
            return (MemorySegment)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetOpenNodesData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetOpenNodesData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOpenNodesData(SCIP *scip, SCIP_NODE ***leaves, SCIP_NODE ***children, SCIP_NODE ***siblings, int *nleaves, int *nchildren, int *nsiblings)
     * }
     */
    public static FunctionDescriptor SCIPgetOpenNodesData$descriptor() {
        return SCIPgetOpenNodesData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOpenNodesData(SCIP *scip, SCIP_NODE ***leaves, SCIP_NODE ***children, SCIP_NODE ***siblings, int *nleaves, int *nchildren, int *nsiblings)
     * }
     */
    public static MethodHandle SCIPgetOpenNodesData$handle() {
        return SCIPgetOpenNodesData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOpenNodesData(SCIP *scip, SCIP_NODE ***leaves, SCIP_NODE ***children, SCIP_NODE ***siblings, int *nleaves, int *nchildren, int *nsiblings)
     * }
     */
    public static MemorySegment SCIPgetOpenNodesData$address() {
        return SCIPgetOpenNodesData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetOpenNodesData(SCIP *scip, SCIP_NODE ***leaves, SCIP_NODE ***children, SCIP_NODE ***siblings, int *nleaves, int *nchildren, int *nsiblings)
     * }
     */
    public static int SCIPgetOpenNodesData(MemorySegment scip, MemorySegment leaves, MemorySegment children, MemorySegment siblings, MemorySegment nleaves, MemorySegment nchildren, MemorySegment nsiblings) {
        var mh$ = SCIPgetOpenNodesData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetOpenNodesData", scip, leaves, children, siblings, nleaves, nchildren, nsiblings);
            }
            return (int)mh$.invokeExact(scip, leaves, children, siblings, nleaves, nchildren, nsiblings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcutoffNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcutoffNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutoffNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPcutoffNode$descriptor() {
        return SCIPcutoffNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutoffNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPcutoffNode$handle() {
        return SCIPcutoffNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutoffNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPcutoffNode$address() {
        return SCIPcutoffNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcutoffNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPcutoffNode(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPcutoffNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcutoffNode", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPpruneTree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPpruneTree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpruneTree(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPpruneTree$descriptor() {
        return SCIPpruneTree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpruneTree(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPpruneTree$handle() {
        return SCIPpruneTree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpruneTree(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPpruneTree$address() {
        return SCIPpruneTree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPpruneTree(SCIP *scip)
     * }
     */
    public static int SCIPpruneTree(MemorySegment scip) {
        var mh$ = SCIPpruneTree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPpruneTree", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPrepropagateNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPrepropagateNode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrepropagateNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPrepropagateNode$descriptor() {
        return SCIPrepropagateNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrepropagateNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPrepropagateNode$handle() {
        return SCIPrepropagateNode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrepropagateNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPrepropagateNode$address() {
        return SCIPrepropagateNode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPrepropagateNode(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPrepropagateNode(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPrepropagateNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPrepropagateNode", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetCutoffdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetCutoffdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetCutoffdepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetCutoffdepth$descriptor() {
        return SCIPgetCutoffdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetCutoffdepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetCutoffdepth$handle() {
        return SCIPgetCutoffdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetCutoffdepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetCutoffdepth$address() {
        return SCIPgetCutoffdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetCutoffdepth(SCIP *scip)
     * }
     */
    public static int SCIPgetCutoffdepth(MemorySegment scip) {
        var mh$ = SCIPgetCutoffdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetCutoffdepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetRepropdepth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetRepropdepth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SCIPgetRepropdepth(SCIP *scip)
     * }
     */
    public static FunctionDescriptor SCIPgetRepropdepth$descriptor() {
        return SCIPgetRepropdepth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SCIPgetRepropdepth(SCIP *scip)
     * }
     */
    public static MethodHandle SCIPgetRepropdepth$handle() {
        return SCIPgetRepropdepth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SCIPgetRepropdepth(SCIP *scip)
     * }
     */
    public static MemorySegment SCIPgetRepropdepth$address() {
        return SCIPgetRepropdepth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SCIPgetRepropdepth(SCIP *scip)
     * }
     */
    public static int SCIPgetRepropdepth(MemorySegment scip) {
        var mh$ = SCIPgetRepropdepth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetRepropdepth", scip);
            }
            return (int)mh$.invokeExact(scip);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPprintNodeRootPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPprintNodeRootPath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNodeRootPath(SCIP *scip, SCIP_NODE *node, FILE *file)
     * }
     */
    public static FunctionDescriptor SCIPprintNodeRootPath$descriptor() {
        return SCIPprintNodeRootPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNodeRootPath(SCIP *scip, SCIP_NODE *node, FILE *file)
     * }
     */
    public static MethodHandle SCIPprintNodeRootPath$handle() {
        return SCIPprintNodeRootPath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNodeRootPath(SCIP *scip, SCIP_NODE *node, FILE *file)
     * }
     */
    public static MemorySegment SCIPprintNodeRootPath$address() {
        return SCIPprintNodeRootPath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPprintNodeRootPath(SCIP *scip, SCIP_NODE *node, FILE *file)
     * }
     */
    public static int SCIPprintNodeRootPath(MemorySegment scip, MemorySegment node, MemorySegment file) {
        var mh$ = SCIPprintNodeRootPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPprintNodeRootPath", scip, node, file);
            }
            return (int)mh$.invokeExact(scip, node, file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPsetFocusnodeLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPsetFocusnodeLP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPsetFocusnodeLP(SCIP *scip, unsigned int solvelp)
     * }
     */
    public static FunctionDescriptor SCIPsetFocusnodeLP$descriptor() {
        return SCIPsetFocusnodeLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPsetFocusnodeLP(SCIP *scip, unsigned int solvelp)
     * }
     */
    public static MethodHandle SCIPsetFocusnodeLP$handle() {
        return SCIPsetFocusnodeLP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPsetFocusnodeLP(SCIP *scip, unsigned int solvelp)
     * }
     */
    public static MemorySegment SCIPsetFocusnodeLP$address() {
        return SCIPsetFocusnodeLP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPsetFocusnodeLP(SCIP *scip, unsigned int solvelp)
     * }
     */
    public static void SCIPsetFocusnodeLP(MemorySegment scip, int solvelp) {
        var mh$ = SCIPsetFocusnodeLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPsetFocusnodeLP", scip, solvelp);
            }
            mh$.invokeExact(scip, solvelp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwasNodeLastBranchParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwasNodeLastBranchParent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPwasNodeLastBranchParent(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static FunctionDescriptor SCIPwasNodeLastBranchParent$descriptor() {
        return SCIPwasNodeLastBranchParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPwasNodeLastBranchParent(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MethodHandle SCIPwasNodeLastBranchParent$handle() {
        return SCIPwasNodeLastBranchParent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPwasNodeLastBranchParent(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static MemorySegment SCIPwasNodeLastBranchParent$address() {
        return SCIPwasNodeLastBranchParent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPwasNodeLastBranchParent(SCIP *scip, SCIP_NODE *node)
     * }
     */
    public static int SCIPwasNodeLastBranchParent(MemorySegment scip, MemorySegment node) {
        var mh$ = SCIPwasNodeLastBranchParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwasNodeLastBranchParent", scip, node);
            }
            return (int)mh$.invokeExact(scip, node);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPvalidateSolve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPvalidateSolve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvalidateSolve(SCIP *scip, double primalreference, double dualreference, double reftol, unsigned int quiet, unsigned int *feasible, unsigned int *primalboundcheck, unsigned int *dualboundcheck)
     * }
     */
    public static FunctionDescriptor SCIPvalidateSolve$descriptor() {
        return SCIPvalidateSolve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvalidateSolve(SCIP *scip, double primalreference, double dualreference, double reftol, unsigned int quiet, unsigned int *feasible, unsigned int *primalboundcheck, unsigned int *dualboundcheck)
     * }
     */
    public static MethodHandle SCIPvalidateSolve$handle() {
        return SCIPvalidateSolve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvalidateSolve(SCIP *scip, double primalreference, double dualreference, double reftol, unsigned int quiet, unsigned int *feasible, unsigned int *primalboundcheck, unsigned int *dualboundcheck)
     * }
     */
    public static MemorySegment SCIPvalidateSolve$address() {
        return SCIPvalidateSolve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPvalidateSolve(SCIP *scip, double primalreference, double dualreference, double reftol, unsigned int quiet, unsigned int *feasible, unsigned int *primalboundcheck, unsigned int *dualboundcheck)
     * }
     */
    public static int SCIPvalidateSolve(MemorySegment scip, double primalreference, double dualreference, double reftol, int quiet, MemorySegment feasible, MemorySegment primalboundcheck, MemorySegment dualboundcheck) {
        var mh$ = SCIPvalidateSolve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPvalidateSolve", scip, primalreference, dualreference, reftol, quiet, feasible, primalboundcheck, dualboundcheck);
            }
            return (int)mh$.invokeExact(scip, primalreference, dualreference, reftol, quiet, feasible, primalboundcheck, dualboundcheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVar(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype, unsigned int initial, unsigned int removable, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_VARDATA *vardata)
     * }
     */
    public static FunctionDescriptor SCIPcreateVar$descriptor() {
        return SCIPcreateVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVar(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype, unsigned int initial, unsigned int removable, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_VARDATA *vardata)
     * }
     */
    public static MethodHandle SCIPcreateVar$handle() {
        return SCIPcreateVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVar(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype, unsigned int initial, unsigned int removable, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_VARDATA *vardata)
     * }
     */
    public static MemorySegment SCIPcreateVar$address() {
        return SCIPcreateVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVar(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype, unsigned int initial, unsigned int removable, SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_VARDATA *vardata)
     * }
     */
    public static int SCIPcreateVar(MemorySegment scip, MemorySegment var_, MemorySegment name, double lb, double ub, double obj, int vartype, int initial, int removable, MemorySegment vardelorig, MemorySegment vartrans, MemorySegment vardeltrans, MemorySegment varcopy, MemorySegment vardata) {
        var mh$ = SCIPcreateVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateVar", scip, var_, name, lb, ub, obj, vartype, initial, removable, vardelorig, vartrans, vardeltrans, varcopy, vardata);
            }
            return (int)mh$.invokeExact(scip, var_, name, lb, ub, obj, vartype, initial, removable, vardelorig, vartrans, vardeltrans, varcopy, vardata);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcreateVarBasic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_DOUBLE,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcreateVarBasic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVarBasic(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype)
     * }
     */
    public static FunctionDescriptor SCIPcreateVarBasic$descriptor() {
        return SCIPcreateVarBasic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVarBasic(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype)
     * }
     */
    public static MethodHandle SCIPcreateVarBasic$handle() {
        return SCIPcreateVarBasic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVarBasic(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype)
     * }
     */
    public static MemorySegment SCIPcreateVarBasic$address() {
        return SCIPcreateVarBasic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcreateVarBasic(SCIP *scip, SCIP_VAR **var, const char *name, double lb, double ub, double obj, SCIP_VARTYPE vartype)
     * }
     */
    public static int SCIPcreateVarBasic(MemorySegment scip, MemorySegment var_, MemorySegment name, double lb, double ub, double obj, int vartype) {
        var mh$ = SCIPcreateVarBasic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcreateVarBasic", scip, var_, name, lb, ub, obj, vartype);
            }
            return (int)mh$.invokeExact(scip, var_, name, lb, ub, obj, vartype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteVarName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteVarName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarName(SCIP *scip, FILE *file, SCIP_VAR *var, unsigned int type)
     * }
     */
    public static FunctionDescriptor SCIPwriteVarName$descriptor() {
        return SCIPwriteVarName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarName(SCIP *scip, FILE *file, SCIP_VAR *var, unsigned int type)
     * }
     */
    public static MethodHandle SCIPwriteVarName$handle() {
        return SCIPwriteVarName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarName(SCIP *scip, FILE *file, SCIP_VAR *var, unsigned int type)
     * }
     */
    public static MemorySegment SCIPwriteVarName$address() {
        return SCIPwriteVarName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarName(SCIP *scip, FILE *file, SCIP_VAR *var, unsigned int type)
     * }
     */
    public static int SCIPwriteVarName(MemorySegment scip, MemorySegment file, MemorySegment var_, int type) {
        var mh$ = SCIPwriteVarName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteVarName", scip, file, var_, type);
            }
            return (int)mh$.invokeExact(scip, file, var_, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteVarsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_CHAR
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteVarsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsList(SCIP *scip, FILE *file, SCIP_VAR **vars, int nvars, unsigned int type, char delimiter)
     * }
     */
    public static FunctionDescriptor SCIPwriteVarsList$descriptor() {
        return SCIPwriteVarsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsList(SCIP *scip, FILE *file, SCIP_VAR **vars, int nvars, unsigned int type, char delimiter)
     * }
     */
    public static MethodHandle SCIPwriteVarsList$handle() {
        return SCIPwriteVarsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsList(SCIP *scip, FILE *file, SCIP_VAR **vars, int nvars, unsigned int type, char delimiter)
     * }
     */
    public static MemorySegment SCIPwriteVarsList$address() {
        return SCIPwriteVarsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsList(SCIP *scip, FILE *file, SCIP_VAR **vars, int nvars, unsigned int type, char delimiter)
     * }
     */
    public static int SCIPwriteVarsList(MemorySegment scip, MemorySegment file, MemorySegment vars, int nvars, int type, byte delimiter) {
        var mh$ = SCIPwriteVarsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteVarsList", scip, file, vars, nvars, type, delimiter);
            }
            return (int)mh$.invokeExact(scip, file, vars, nvars, type, delimiter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteVarsLinearsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteVarsLinearsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsLinearsum(SCIP *scip, FILE *file, SCIP_VAR **vars, double *vals, int nvars, unsigned int type)
     * }
     */
    public static FunctionDescriptor SCIPwriteVarsLinearsum$descriptor() {
        return SCIPwriteVarsLinearsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsLinearsum(SCIP *scip, FILE *file, SCIP_VAR **vars, double *vals, int nvars, unsigned int type)
     * }
     */
    public static MethodHandle SCIPwriteVarsLinearsum$handle() {
        return SCIPwriteVarsLinearsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsLinearsum(SCIP *scip, FILE *file, SCIP_VAR **vars, double *vals, int nvars, unsigned int type)
     * }
     */
    public static MemorySegment SCIPwriteVarsLinearsum$address() {
        return SCIPwriteVarsLinearsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsLinearsum(SCIP *scip, FILE *file, SCIP_VAR **vars, double *vals, int nvars, unsigned int type)
     * }
     */
    public static int SCIPwriteVarsLinearsum(MemorySegment scip, MemorySegment file, MemorySegment vars, MemorySegment vals, int nvars, int type) {
        var mh$ = SCIPwriteVarsLinearsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteVarsLinearsum", scip, file, vars, vals, nvars, type);
            }
            return (int)mh$.invokeExact(scip, file, vars, vals, nvars, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPwriteVarsPolynomial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPwriteVarsPolynomial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsPolynomial(SCIP *scip, FILE *file, SCIP_VAR ***monomialvars, double **monomialexps, double *monomialcoefs, int *monomialnvars, int nmonomials, unsigned int type)
     * }
     */
    public static FunctionDescriptor SCIPwriteVarsPolynomial$descriptor() {
        return SCIPwriteVarsPolynomial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsPolynomial(SCIP *scip, FILE *file, SCIP_VAR ***monomialvars, double **monomialexps, double *monomialcoefs, int *monomialnvars, int nmonomials, unsigned int type)
     * }
     */
    public static MethodHandle SCIPwriteVarsPolynomial$handle() {
        return SCIPwriteVarsPolynomial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsPolynomial(SCIP *scip, FILE *file, SCIP_VAR ***monomialvars, double **monomialexps, double *monomialcoefs, int *monomialnvars, int nmonomials, unsigned int type)
     * }
     */
    public static MemorySegment SCIPwriteVarsPolynomial$address() {
        return SCIPwriteVarsPolynomial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPwriteVarsPolynomial(SCIP *scip, FILE *file, SCIP_VAR ***monomialvars, double **monomialexps, double *monomialcoefs, int *monomialnvars, int nmonomials, unsigned int type)
     * }
     */
    public static int SCIPwriteVarsPolynomial(MemorySegment scip, MemorySegment file, MemorySegment monomialvars, MemorySegment monomialexps, MemorySegment monomialcoefs, MemorySegment monomialnvars, int nmonomials, int type) {
        var mh$ = SCIPwriteVarsPolynomial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPwriteVarsPolynomial", scip, file, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials, type);
            }
            return (int)mh$.invokeExact(scip, file, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVar(SCIP *scip, SCIP_VAR **var, const char *str, unsigned int initial, unsigned int removable, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_VARDATA *vardata, char **endptr, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPparseVar$descriptor() {
        return SCIPparseVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVar(SCIP *scip, SCIP_VAR **var, const char *str, unsigned int initial, unsigned int removable, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_VARDATA *vardata, char **endptr, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPparseVar$handle() {
        return SCIPparseVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVar(SCIP *scip, SCIP_VAR **var, const char *str, unsigned int initial, unsigned int removable, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_VARDATA *vardata, char **endptr, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPparseVar$address() {
        return SCIPparseVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVar(SCIP *scip, SCIP_VAR **var, const char *str, unsigned int initial, unsigned int removable, SCIP_RETCODE (*varcopy)(SCIP *, SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_HASHMAP *, SCIP_HASHMAP *, SCIP_VAR *, SCIP_VARDATA **, SCIP_RESULT *), SCIP_RETCODE (*vardelorig)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vartrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA *, SCIP_VAR *, SCIP_VARDATA **), SCIP_RETCODE (*vardeltrans)(SCIP *, SCIP_VAR *, SCIP_VARDATA **), SCIP_VARDATA *vardata, char **endptr, unsigned int *success)
     * }
     */
    public static int SCIPparseVar(MemorySegment scip, MemorySegment var_, MemorySegment str, int initial, int removable, MemorySegment varcopy, MemorySegment vardelorig, MemorySegment vartrans, MemorySegment vardeltrans, MemorySegment vardata, MemorySegment endptr, MemorySegment success) {
        var mh$ = SCIPparseVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseVar", scip, var_, str, initial, removable, varcopy, vardelorig, vartrans, vardeltrans, vardata, endptr, success);
            }
            return (int)mh$.invokeExact(scip, var_, str, initial, removable, varcopy, vardelorig, vartrans, vardeltrans, vardata, endptr, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseVarName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseVarName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarName(SCIP *scip, const char *str, SCIP_VAR **var, char **endptr)
     * }
     */
    public static FunctionDescriptor SCIPparseVarName$descriptor() {
        return SCIPparseVarName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarName(SCIP *scip, const char *str, SCIP_VAR **var, char **endptr)
     * }
     */
    public static MethodHandle SCIPparseVarName$handle() {
        return SCIPparseVarName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarName(SCIP *scip, const char *str, SCIP_VAR **var, char **endptr)
     * }
     */
    public static MemorySegment SCIPparseVarName$address() {
        return SCIPparseVarName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarName(SCIP *scip, const char *str, SCIP_VAR **var, char **endptr)
     * }
     */
    public static int SCIPparseVarName(MemorySegment scip, MemorySegment str, MemorySegment var_, MemorySegment endptr) {
        var mh$ = SCIPparseVarName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseVarName", scip, str, var_, endptr);
            }
            return (int)mh$.invokeExact(scip, str, var_, endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseVarsList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_CHAR,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseVarsList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsList(SCIP *scip, const char *str, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize, char **endptr, char delimiter, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPparseVarsList$descriptor() {
        return SCIPparseVarsList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsList(SCIP *scip, const char *str, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize, char **endptr, char delimiter, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPparseVarsList$handle() {
        return SCIPparseVarsList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsList(SCIP *scip, const char *str, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize, char **endptr, char delimiter, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPparseVarsList$address() {
        return SCIPparseVarsList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsList(SCIP *scip, const char *str, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize, char **endptr, char delimiter, unsigned int *success)
     * }
     */
    public static int SCIPparseVarsList(MemorySegment scip, MemorySegment str, MemorySegment vars, MemorySegment nvars, int varssize, MemorySegment requiredsize, MemorySegment endptr, byte delimiter, MemorySegment success) {
        var mh$ = SCIPparseVarsList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseVarsList", scip, str, vars, nvars, varssize, requiredsize, endptr, delimiter, success);
            }
            return (int)mh$.invokeExact(scip, str, vars, nvars, varssize, requiredsize, endptr, delimiter, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseVarsLinearsum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseVarsLinearsum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsLinearsum(SCIP *scip, const char *str, SCIP_VAR **vars, double *vals, int *nvars, int varssize, int *requiredsize, char **endptr, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPparseVarsLinearsum$descriptor() {
        return SCIPparseVarsLinearsum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsLinearsum(SCIP *scip, const char *str, SCIP_VAR **vars, double *vals, int *nvars, int varssize, int *requiredsize, char **endptr, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPparseVarsLinearsum$handle() {
        return SCIPparseVarsLinearsum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsLinearsum(SCIP *scip, const char *str, SCIP_VAR **vars, double *vals, int *nvars, int varssize, int *requiredsize, char **endptr, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPparseVarsLinearsum$address() {
        return SCIPparseVarsLinearsum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsLinearsum(SCIP *scip, const char *str, SCIP_VAR **vars, double *vals, int *nvars, int varssize, int *requiredsize, char **endptr, unsigned int *success)
     * }
     */
    public static int SCIPparseVarsLinearsum(MemorySegment scip, MemorySegment str, MemorySegment vars, MemorySegment vals, MemorySegment nvars, int varssize, MemorySegment requiredsize, MemorySegment endptr, MemorySegment success) {
        var mh$ = SCIPparseVarsLinearsum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseVarsLinearsum", scip, str, vars, vals, nvars, varssize, requiredsize, endptr, success);
            }
            return (int)mh$.invokeExact(scip, str, vars, vals, nvars, varssize, requiredsize, endptr, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPparseVarsPolynomial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPparseVarsPolynomial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsPolynomial(SCIP *scip, const char *str, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int *nmonomials, char **endptr, unsigned int *success)
     * }
     */
    public static FunctionDescriptor SCIPparseVarsPolynomial$descriptor() {
        return SCIPparseVarsPolynomial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsPolynomial(SCIP *scip, const char *str, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int *nmonomials, char **endptr, unsigned int *success)
     * }
     */
    public static MethodHandle SCIPparseVarsPolynomial$handle() {
        return SCIPparseVarsPolynomial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsPolynomial(SCIP *scip, const char *str, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int *nmonomials, char **endptr, unsigned int *success)
     * }
     */
    public static MemorySegment SCIPparseVarsPolynomial$address() {
        return SCIPparseVarsPolynomial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPparseVarsPolynomial(SCIP *scip, const char *str, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int *nmonomials, char **endptr, unsigned int *success)
     * }
     */
    public static int SCIPparseVarsPolynomial(MemorySegment scip, MemorySegment str, MemorySegment monomialvars, MemorySegment monomialexps, MemorySegment monomialcoefs, MemorySegment monomialnvars, MemorySegment nmonomials, MemorySegment endptr, MemorySegment success) {
        var mh$ = SCIPparseVarsPolynomial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPparseVarsPolynomial", scip, str, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials, endptr, success);
            }
            return (int)mh$.invokeExact(scip, str, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials, endptr, success);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPfreeParseVarsPolynomialData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPfreeParseVarsPolynomialData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SCIPfreeParseVarsPolynomialData(SCIP *scip, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int nmonomials)
     * }
     */
    public static FunctionDescriptor SCIPfreeParseVarsPolynomialData$descriptor() {
        return SCIPfreeParseVarsPolynomialData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SCIPfreeParseVarsPolynomialData(SCIP *scip, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int nmonomials)
     * }
     */
    public static MethodHandle SCIPfreeParseVarsPolynomialData$handle() {
        return SCIPfreeParseVarsPolynomialData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SCIPfreeParseVarsPolynomialData(SCIP *scip, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int nmonomials)
     * }
     */
    public static MemorySegment SCIPfreeParseVarsPolynomialData$address() {
        return SCIPfreeParseVarsPolynomialData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SCIPfreeParseVarsPolynomialData(SCIP *scip, SCIP_VAR ****monomialvars, double ***monomialexps, double **monomialcoefs, int **monomialnvars, int nmonomials)
     * }
     */
    public static void SCIPfreeParseVarsPolynomialData(MemorySegment scip, MemorySegment monomialvars, MemorySegment monomialexps, MemorySegment monomialcoefs, MemorySegment monomialnvars, int nmonomials) {
        var mh$ = SCIPfreeParseVarsPolynomialData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPfreeParseVarsPolynomialData", scip, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials);
            }
            mh$.invokeExact(scip, monomialvars, monomialexps, monomialcoefs, monomialnvars, nmonomials);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPcaptureVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPcaptureVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPcaptureVar$descriptor() {
        return SCIPcaptureVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPcaptureVar$handle() {
        return SCIPcaptureVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPcaptureVar$address() {
        return SCIPcaptureVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPcaptureVar(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPcaptureVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPcaptureVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPcaptureVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPreleaseVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPreleaseVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseVar(SCIP *scip, SCIP_VAR **var)
     * }
     */
    public static FunctionDescriptor SCIPreleaseVar$descriptor() {
        return SCIPreleaseVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseVar(SCIP *scip, SCIP_VAR **var)
     * }
     */
    public static MethodHandle SCIPreleaseVar$handle() {
        return SCIPreleaseVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseVar(SCIP *scip, SCIP_VAR **var)
     * }
     */
    public static MemorySegment SCIPreleaseVar$address() {
        return SCIPreleaseVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPreleaseVar(SCIP *scip, SCIP_VAR **var)
     * }
     */
    public static int SCIPreleaseVar(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPreleaseVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPreleaseVar", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPchgVarName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPchgVarName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarName(SCIP *scip, SCIP_VAR *var, const char *name)
     * }
     */
    public static FunctionDescriptor SCIPchgVarName$descriptor() {
        return SCIPchgVarName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarName(SCIP *scip, SCIP_VAR *var, const char *name)
     * }
     */
    public static MethodHandle SCIPchgVarName$handle() {
        return SCIPchgVarName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarName(SCIP *scip, SCIP_VAR *var, const char *name)
     * }
     */
    public static MemorySegment SCIPchgVarName$address() {
        return SCIPchgVarName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPchgVarName(SCIP *scip, SCIP_VAR *var, const char *name)
     * }
     */
    public static int SCIPchgVarName(MemorySegment scip, MemorySegment var_, MemorySegment name) {
        var mh$ = SCIPchgVarName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPchgVarName", scip, var_, name);
            }
            return (int)mh$.invokeExact(scip, var_, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static FunctionDescriptor SCIPtransformVar$descriptor() {
        return SCIPtransformVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static MethodHandle SCIPtransformVar$handle() {
        return SCIPtransformVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static MemorySegment SCIPtransformVar$address() {
        return SCIPtransformVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static int SCIPtransformVar(MemorySegment scip, MemorySegment var_, MemorySegment transvar) {
        var mh$ = SCIPtransformVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformVar", scip, var_, transvar);
            }
            return (int)mh$.invokeExact(scip, var_, transvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPtransformVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPtransformVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static FunctionDescriptor SCIPtransformVars$descriptor() {
        return SCIPtransformVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static MethodHandle SCIPtransformVars$handle() {
        return SCIPtransformVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static MemorySegment SCIPtransformVars$address() {
        return SCIPtransformVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPtransformVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static int SCIPtransformVars(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment transvars) {
        var mh$ = SCIPtransformVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPtransformVars", scip, nvars, vars, transvars);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, transvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransformedVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransformedVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static FunctionDescriptor SCIPgetTransformedVar$descriptor() {
        return SCIPgetTransformedVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static MethodHandle SCIPgetTransformedVar$handle() {
        return SCIPgetTransformedVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static MemorySegment SCIPgetTransformedVar$address() {
        return SCIPgetTransformedVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **transvar)
     * }
     */
    public static int SCIPgetTransformedVar(MemorySegment scip, MemorySegment var_, MemorySegment transvar) {
        var mh$ = SCIPgetTransformedVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransformedVar", scip, var_, transvar);
            }
            return (int)mh$.invokeExact(scip, var_, transvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetTransformedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetTransformedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static FunctionDescriptor SCIPgetTransformedVars$descriptor() {
        return SCIPgetTransformedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static MethodHandle SCIPgetTransformedVars$handle() {
        return SCIPgetTransformedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static MemorySegment SCIPgetTransformedVars$address() {
        return SCIPgetTransformedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetTransformedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **transvars)
     * }
     */
    public static int SCIPgetTransformedVars(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment transvars) {
        var mh$ = SCIPgetTransformedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetTransformedVars", scip, nvars, vars, transvars);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, transvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNegatedVar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNegatedVar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **negvar)
     * }
     */
    public static FunctionDescriptor SCIPgetNegatedVar$descriptor() {
        return SCIPgetNegatedVar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **negvar)
     * }
     */
    public static MethodHandle SCIPgetNegatedVar$handle() {
        return SCIPgetNegatedVar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **negvar)
     * }
     */
    public static MemorySegment SCIPgetNegatedVar$address() {
        return SCIPgetNegatedVar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVar(SCIP *scip, SCIP_VAR *var, SCIP_VAR **negvar)
     * }
     */
    public static int SCIPgetNegatedVar(MemorySegment scip, MemorySegment var_, MemorySegment negvar) {
        var mh$ = SCIPgetNegatedVar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNegatedVar", scip, var_, negvar);
            }
            return (int)mh$.invokeExact(scip, var_, negvar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetNegatedVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetNegatedVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **negvars)
     * }
     */
    public static FunctionDescriptor SCIPgetNegatedVars$descriptor() {
        return SCIPgetNegatedVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **negvars)
     * }
     */
    public static MethodHandle SCIPgetNegatedVars$handle() {
        return SCIPgetNegatedVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **negvars)
     * }
     */
    public static MemorySegment SCIPgetNegatedVars$address() {
        return SCIPgetNegatedVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetNegatedVars(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **negvars)
     * }
     */
    public static int SCIPgetNegatedVars(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment negvars) {
        var mh$ = SCIPgetNegatedVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetNegatedVars", scip, nvars, vars, negvars);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, negvars);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinvarRepresentative {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinvarRepresentative");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentative(SCIP *scip, SCIP_VAR *var, SCIP_VAR **repvar, unsigned int *negated)
     * }
     */
    public static FunctionDescriptor SCIPgetBinvarRepresentative$descriptor() {
        return SCIPgetBinvarRepresentative.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentative(SCIP *scip, SCIP_VAR *var, SCIP_VAR **repvar, unsigned int *negated)
     * }
     */
    public static MethodHandle SCIPgetBinvarRepresentative$handle() {
        return SCIPgetBinvarRepresentative.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentative(SCIP *scip, SCIP_VAR *var, SCIP_VAR **repvar, unsigned int *negated)
     * }
     */
    public static MemorySegment SCIPgetBinvarRepresentative$address() {
        return SCIPgetBinvarRepresentative.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentative(SCIP *scip, SCIP_VAR *var, SCIP_VAR **repvar, unsigned int *negated)
     * }
     */
    public static int SCIPgetBinvarRepresentative(MemorySegment scip, MemorySegment var_, MemorySegment repvar, MemorySegment negated) {
        var mh$ = SCIPgetBinvarRepresentative.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinvarRepresentative", scip, var_, repvar, negated);
            }
            return (int)mh$.invokeExact(scip, var_, repvar, negated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetBinvarRepresentatives {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetBinvarRepresentatives");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentatives(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **repvars, unsigned int *negated)
     * }
     */
    public static FunctionDescriptor SCIPgetBinvarRepresentatives$descriptor() {
        return SCIPgetBinvarRepresentatives.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentatives(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **repvars, unsigned int *negated)
     * }
     */
    public static MethodHandle SCIPgetBinvarRepresentatives$handle() {
        return SCIPgetBinvarRepresentatives.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentatives(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **repvars, unsigned int *negated)
     * }
     */
    public static MemorySegment SCIPgetBinvarRepresentatives$address() {
        return SCIPgetBinvarRepresentatives.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetBinvarRepresentatives(SCIP *scip, int nvars, SCIP_VAR **vars, SCIP_VAR **repvars, unsigned int *negated)
     * }
     */
    public static int SCIPgetBinvarRepresentatives(MemorySegment scip, int nvars, MemorySegment vars, MemorySegment repvars, MemorySegment negated) {
        var mh$ = SCIPgetBinvarRepresentatives.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetBinvarRepresentatives", scip, nvars, vars, repvars, negated);
            }
            return (int)mh$.invokeExact(scip, nvars, vars, repvars, negated);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPflattenVarAggregationGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPflattenVarAggregationGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflattenVarAggregationGraph(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPflattenVarAggregationGraph$descriptor() {
        return SCIPflattenVarAggregationGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflattenVarAggregationGraph(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPflattenVarAggregationGraph$handle() {
        return SCIPflattenVarAggregationGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflattenVarAggregationGraph(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPflattenVarAggregationGraph$address() {
        return SCIPflattenVarAggregationGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPflattenVarAggregationGraph(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static int SCIPflattenVarAggregationGraph(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPflattenVarAggregationGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPflattenVarAggregationGraph", scip, var_);
            }
            return (int)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbvarLinearSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbvarLinearSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarLinearSum(SCIP *scip, SCIP_VAR **vars, double *scalars, int *nvars, int varssize, double *constant, int *requiredsize, unsigned int mergemultiples)
     * }
     */
    public static FunctionDescriptor SCIPgetProbvarLinearSum$descriptor() {
        return SCIPgetProbvarLinearSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarLinearSum(SCIP *scip, SCIP_VAR **vars, double *scalars, int *nvars, int varssize, double *constant, int *requiredsize, unsigned int mergemultiples)
     * }
     */
    public static MethodHandle SCIPgetProbvarLinearSum$handle() {
        return SCIPgetProbvarLinearSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarLinearSum(SCIP *scip, SCIP_VAR **vars, double *scalars, int *nvars, int varssize, double *constant, int *requiredsize, unsigned int mergemultiples)
     * }
     */
    public static MemorySegment SCIPgetProbvarLinearSum$address() {
        return SCIPgetProbvarLinearSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarLinearSum(SCIP *scip, SCIP_VAR **vars, double *scalars, int *nvars, int varssize, double *constant, int *requiredsize, unsigned int mergemultiples)
     * }
     */
    public static int SCIPgetProbvarLinearSum(MemorySegment scip, MemorySegment vars, MemorySegment scalars, MemorySegment nvars, int varssize, MemorySegment constant, MemorySegment requiredsize, int mergemultiples) {
        var mh$ = SCIPgetProbvarLinearSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbvarLinearSum", scip, vars, scalars, nvars, varssize, constant, requiredsize, mergemultiples);
            }
            return (int)mh$.invokeExact(scip, vars, scalars, nvars, varssize, constant, requiredsize, mergemultiples);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetProbvarSum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetProbvarSum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarSum(SCIP *scip, SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static FunctionDescriptor SCIPgetProbvarSum$descriptor() {
        return SCIPgetProbvarSum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarSum(SCIP *scip, SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static MethodHandle SCIPgetProbvarSum$handle() {
        return SCIPgetProbvarSum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarSum(SCIP *scip, SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static MemorySegment SCIPgetProbvarSum$address() {
        return SCIPgetProbvarSum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetProbvarSum(SCIP *scip, SCIP_VAR **var, double *scalar, double *constant)
     * }
     */
    public static int SCIPgetProbvarSum(MemorySegment scip, MemorySegment var_, MemorySegment scalar, MemorySegment constant) {
        var mh$ = SCIPgetProbvarSum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetProbvarSum", scip, var_, scalar, constant);
            }
            return (int)mh$.invokeExact(scip, var_, scalar, constant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetActiveVars {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetActiveVars");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetActiveVars(SCIP *scip, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize)
     * }
     */
    public static FunctionDescriptor SCIPgetActiveVars$descriptor() {
        return SCIPgetActiveVars.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetActiveVars(SCIP *scip, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize)
     * }
     */
    public static MethodHandle SCIPgetActiveVars$handle() {
        return SCIPgetActiveVars.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetActiveVars(SCIP *scip, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize)
     * }
     */
    public static MemorySegment SCIPgetActiveVars$address() {
        return SCIPgetActiveVars.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SCIP_RETCODE SCIPgetActiveVars(SCIP *scip, SCIP_VAR **vars, int *nvars, int varssize, int *requiredsize)
     * }
     */
    public static int SCIPgetActiveVars(MemorySegment scip, MemorySegment vars, MemorySegment nvars, int varssize, MemorySegment requiredsize) {
        var mh$ = SCIPgetActiveVars.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetActiveVars", scip, vars, nvars, varssize, requiredsize);
            }
            return (int)mh$.invokeExact(scip, vars, nvars, varssize, requiredsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarRedcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarRedcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarRedcost(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarRedcost$descriptor() {
        return SCIPgetVarRedcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarRedcost(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarRedcost$handle() {
        return SCIPgetVarRedcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarRedcost(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarRedcost$address() {
        return SCIPgetVarRedcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarRedcost(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarRedcost(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarRedcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarRedcost", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarImplRedcost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarImplRedcost");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarImplRedcost(SCIP *scip, SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static FunctionDescriptor SCIPgetVarImplRedcost$descriptor() {
        return SCIPgetVarImplRedcost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarImplRedcost(SCIP *scip, SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MethodHandle SCIPgetVarImplRedcost$handle() {
        return SCIPgetVarImplRedcost.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarImplRedcost(SCIP *scip, SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static MemorySegment SCIPgetVarImplRedcost$address() {
        return SCIPgetVarImplRedcost.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarImplRedcost(SCIP *scip, SCIP_VAR *var, unsigned int varfixing)
     * }
     */
    public static double SCIPgetVarImplRedcost(MemorySegment scip, MemorySegment var_, int varfixing) {
        var mh$ = SCIPgetVarImplRedcost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarImplRedcost", scip, var_, varfixing);
            }
            return (double)mh$.invokeExact(scip, var_, varfixing);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarFarkasCoef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarFarkasCoef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarFarkasCoef(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static FunctionDescriptor SCIPgetVarFarkasCoef$descriptor() {
        return SCIPgetVarFarkasCoef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarFarkasCoef(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MethodHandle SCIPgetVarFarkasCoef$handle() {
        return SCIPgetVarFarkasCoef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarFarkasCoef(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static MemorySegment SCIPgetVarFarkasCoef$address() {
        return SCIPgetVarFarkasCoef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarFarkasCoef(SCIP *scip, SCIP_VAR *var)
     * }
     */
    public static double SCIPgetVarFarkasCoef(MemorySegment scip, MemorySegment var_) {
        var mh$ = SCIPgetVarFarkasCoef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarFarkasCoef", scip, var_);
            }
            return (double)mh$.invokeExact(scip, var_);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarLbAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarLbAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarLbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPgetVarLbAtIndex$descriptor() {
        return SCIPgetVarLbAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarLbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPgetVarLbAtIndex$handle() {
        return SCIPgetVarLbAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarLbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPgetVarLbAtIndex$address() {
        return SCIPgetVarLbAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarLbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPgetVarLbAtIndex(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPgetVarLbAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarLbAtIndex", scip, var_, bdchgidx, after);
            }
            return (double)mh$.invokeExact(scip, var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarUbAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarUbAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarUbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPgetVarUbAtIndex$descriptor() {
        return SCIPgetVarUbAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarUbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPgetVarUbAtIndex$handle() {
        return SCIPgetVarUbAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarUbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPgetVarUbAtIndex$address() {
        return SCIPgetVarUbAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarUbAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPgetVarUbAtIndex(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPgetVarUbAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarUbAtIndex", scip, var_, bdchgidx, after);
            }
            return (double)mh$.invokeExact(scip, var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarBdAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_DOUBLE,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarBdAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double SCIPgetVarBdAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPgetVarBdAtIndex$descriptor() {
        return SCIPgetVarBdAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double SCIPgetVarBdAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPgetVarBdAtIndex$handle() {
        return SCIPgetVarBdAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double SCIPgetVarBdAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPgetVarBdAtIndex$address() {
        return SCIPgetVarBdAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double SCIPgetVarBdAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BOUNDTYPE boundtype, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static double SCIPgetVarBdAtIndex(MemorySegment scip, MemorySegment var_, int boundtype, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPgetVarBdAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarBdAtIndex", scip, var_, boundtype, bdchgidx, after);
            }
            return (double)mh$.invokeExact(scip, var_, boundtype, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SCIPgetVarWasFixedAtIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            scip_h.C_INT,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_POINTER,
            scip_h.C_INT
        );

        public static final MemorySegment ADDR = scip_h.findOrThrow("SCIPgetVarWasFixedAtIndex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int SCIPgetVarWasFixedAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static FunctionDescriptor SCIPgetVarWasFixedAtIndex$descriptor() {
        return SCIPgetVarWasFixedAtIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int SCIPgetVarWasFixedAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MethodHandle SCIPgetVarWasFixedAtIndex$handle() {
        return SCIPgetVarWasFixedAtIndex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int SCIPgetVarWasFixedAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static MemorySegment SCIPgetVarWasFixedAtIndex$address() {
        return SCIPgetVarWasFixedAtIndex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int SCIPgetVarWasFixedAtIndex(SCIP *scip, SCIP_VAR *var, SCIP_BDCHGIDX *bdchgidx, unsigned int after)
     * }
     */
    public static int SCIPgetVarWasFixedAtIndex(MemorySegment scip, MemorySegment var_, MemorySegment bdchgidx, int after) {
        var mh$ = SCIPgetVarWasFixedAtIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SCIPgetVarWasFixedAtIndex", scip, var_, bdchgidx, after);
            }
            return (int)mh$.invokeExact(scip, var_, bdchgidx, after);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

